///////////////////////////////////////////////////////////////////////////////
// Служебные процедуры и функции глобального контекста:
// - для инициализации подключения к базе Mobile Smarts;
// - для чтения и записи данных в базе Mobile Smarts;
// - для чтения и записи данных в базе 1С;
// - для обработки событий сервера Mobile Smarts;
// - прочее.
///////////////////////////////////////////////////////////////////////////////

Перем КэшАдресаПеременных; // Только для онлайн-обмена
Перем СоотвСимволов;
Перем КэшПроверенныхСсылок;

// Формирует сведения о внешней обработке для подключения в справочник "Дополнительные отчеты и обработки" 
//
//Возвращаемое значение:
//	Структура - содержит:
//		* БезопасныйРежим 		  - Булево 			 - Признак подключения внешней обработки в безопасном режиме.
//		* Вид 					  - Строка 			 - Вид внешней обработки.
//		* Наименование 			  - Строка 			 - Представление для администратора (наименование элемента справочника).
//		* Версия 				  - Строка 			 - Версия внешней обработки.
//		* ВерсияСтруктурыНастроек - Строка 			 - Версия структуры настроек внешней обработки.
//		* Информация 			  - Строка 			 - Краткая информация о внешней обработке.
//		* Назначение 			  - Массив из Строка - Полные имена объектов конфигурации, для которых предназначена внешняя обработка.
//		* Команды 				  - ТаблицаЗначений  - Настройки команд, поставляемых внешней обработкой:
//			** Идентификатор - Строка - Внутреннее имя команды.
//			** Представление - Строка - Пользовательское представление команды.
//			** Модификатор - Строка - Дополнительная классификация команды.
//			** ПоказыватьОповещение - Булево - если Истина, то при запуске команды выводится оповещение "Команда выполняется...".
//			** Использование - Строка - Тип команды ("ВызовКлиентскогоМетода", "ВызовСерверногоМетода", "ЗаполнениеФормы", "ОткрытиеФормы" или "СценарийВБезопасномРежиме").
Функция СведенияОВнешнейОбработке() Экспорт
	 
	МассивНазначений = Новый Массив;
	МассивНазначений.Добавить("Документ.*");
	
	МассивПоддерживаемыхВерсийAPI = Новый Массив;
	МассивПоддерживаемыхВерсийAPI.Добавить(2);
	МассивПоддерживаемыхВерсийAPI.Добавить(3);
	МассивПоддерживаемыхВерсийAPI.Добавить(4); // При вызове из ИО ПолучитьМакетСКД() вторым параметром передается структура параметров. Раньше было булево РаботаБезАлкоголя
	
	РегистрационныеДанные = Новый Структура;	
	#Область НесовместимыйКодFresh
	РегистрационныеДанные.Вставить("БезопасныйРежим", Ложь);
	#КонецОбласти //НесовместимыйКодFresh
	#Область СовместимыйКодFresh
	//РегистрационныеДанные.Вставить("БезопасныйРежим", Истина);
	#КонецОбласти //СовместимыйКодFresh
	//РегистрационныеДанные.Вставить("Вид","ЗаполнениеОбъекта"); // если ставить другой вид обработки, то не появляется встроенная кнопка на формах		
	РегистрационныеДанные.Вставить("Вид","ДополнительнаяОбработка"); // чтоб в списке доп.обработок была кнопка "запустить"
	РегистрационныеДанные.Вставить("Наименование", "КлеверенсТСД_ОсновнаяОбработка");
	РегистрационныеДанные.Вставить("Версия", ПолучитьВерсиюОсновнойОбработки());
	РегистрационныеДанные.Вставить("ВерсияСтруктурыНастроек", "1.3.14.1"); // нужно для запуска процесса реструктуризации настроек
	РегистрационныеДанные.Вставить("ПоддерживаемыеВерсииAPI", МассивПоддерживаемыхВерсийAPI);
	РегистрационныеДанные.Вставить("Информация", "Данная обработка осуществляет обмен с мобильными устройствами на плафторме Mobile SMARTS и отвечает за функционал и интерфейс");
	РегистрационныеДанные.Вставить("Назначение", МассивНазначений);
	
	ТЗКоманд = Новый ТаблицаЗначений;
	ТЗКоманд.Колонки.Добавить("Идентификатор");
	ТЗКоманд.Колонки.Добавить("Представление"); 
	ТЗКоманд.Колонки.Добавить("Модификатор");
	ТЗКоманд.Колонки.Добавить("ПоказыватьОповещение");
	ТЗКоманд.Колонки.Добавить("Использование");
	
	СтрокаКоманды = ТЗКоманд.Добавить();
	СтрокаКоманды.Идентификатор        		= РегистрационныеДанные.Наименование;
	СтрокаКоманды.Представление        		= "1. Открыть обработку обмена";
	СтрокаКоманды.ПоказыватьОповещение 	= Истина;
	СтрокаКоманды.Использование        		= "ОткрытиеФормы";
					
	СтрокаКоманды = ТЗКоманд.Добавить();
	СтрокаКоманды.Идентификатор			= "Выгрузить все справочники в Mobile SMARTS";
	СтрокаКоманды.Представление			= "2. Выгрузить все справочники в Mobile SMARTS";
	СтрокаКоманды.ПоказыватьОповещение 	= Истина;
	СтрокаКоманды.Использование			= "ВызовКлиентскогоМетода";
	СтрокаКоманды.Модификатор 			= ""; 	
	
	СтрокаКоманды = ТЗКоманд.Добавить();
	СтрокаКоманды.Идентификатор			= "Регламентная выгрузка справочников в Mobile SMARTS";
	СтрокаКоманды.Представление			= "3. Регламентная выгрузка справочников в Mobile SMARTS";
	СтрокаКоманды.ПоказыватьОповещение 	= Истина;
	СтрокаКоманды.Использование			= "ВызовСерверногоМетода";
	СтрокаКоманды.Модификатор 			= "";
	
	//// +++ Для тестирования встраиваемых комманд расскомментировать
	//СтрокаКоманды = ТЗКоманд.Добавить();
	//СтрокаКоманды.Идентификатор			= "Выгрузить документ в Mobile SMARTS";
	//СтрокаКоманды.Представление			= "Выгрузить документ в Mobile SMARTS";
	//СтрокаКоманды.ПоказыватьОповещение 	= Истина;
	//СтрокаКоманды.Использование			= ДополнительныеОтчетыИОбработкиКлиентСервер.ТипКомандыВызовКлиентскогоМетода();
	////СтрокаКоманды.Использование			= ДополнительныеОтчетыИОбработкиКлиентСервер.ТипКомандыОткрытиеФормы();
	//СтрокаКоманды.Модификатор 			= "ВыгрузитьДокумент1С";
	//
	//СтрокаКоманды = ТЗКоманд.Добавить();
	//СтрокаКоманды.Идентификатор			= "Загрузить документ из Mobile SMARTS";
	//СтрокаКоманды.Представление			= "Загрузить документ из Mobile SMARTS";
	//СтрокаКоманды.ПоказыватьОповещение 	= Истина;
	//СтрокаКоманды.Использование			= ДополнительныеОтчетыИОбработкиКлиентСервер.ТипКомандыВызовКлиентскогоМетода();
	////СтрокаКоманды.Использование			= ДополнительныеОтчетыИОбработкиКлиентСервер.ТипКомандыЗагрузкаДанныхИзФайла();
	//СтрокаКоманды.Модификатор 			= "";

	// ---
	РегистрационныеДанные.Вставить("Команды", ТЗКоманд);  	

	#Область СовместимыйКодFresh	
	//Разрешения = Новый Массив;
	//
	//Разрешение = ОбщегоНазначения.ОбщийМодуль("РаботаВБезопасномРежиме").РазрешениеНаИспользованиеПривилегированногоРежима("Для сохранения данных проверки и подбора требуется.."); 
	//Разрешения.Добавить(Разрешение);

	//Описание = "Обмен данными с Mobile SMARTS";
	//
	//МассивОписанийИнтернетРесурсов = Новый Массив;
	//МассивОписанийИнтернетРесурсов.Добавить(Новый Структура("Протокол, Адрес, Порт", "HTTP", 	"1cfresh.cleverence.ru", 	80));
	//МассивОписанийИнтернетРесурсов.Добавить(Новый Структура("Протокол, Адрес, Порт", "HTTPS", 	"1cfresh.cleverence.ru", 	443));
	//МассивОписанийИнтернетРесурсов.Добавить(Новый Структура("Протокол, Адрес, Порт", "HTTP", 	"1cfresh2.cleverence.ru", 	10771));
	//МассивОписанийИнтернетРесурсов.Добавить(Новый Структура("Протокол, Адрес, Порт", "HTTPS", 	"1cfresh2.cleverence.ru", 	10772));
	//МассивОписанийИнтернетРесурсов.Добавить(Новый Структура("Протокол, Адрес, Порт", "HTTP", 	"cloud.cleverence.ru", 		80));
	//МассивОписанийИнтернетРесурсов.Добавить(Новый Структура("Протокол, Адрес, Порт", "HTTPS", 	"cloud.cleverence.ru", 		443));
	//МассивОписанийИнтернетРесурсов.Добавить(Новый Структура("Протокол, Адрес, Порт", "HTTP", 	"cloud.cleverence.ru", 		10771));
	//МассивОписанийИнтернетРесурсов.Добавить(Новый Структура("Протокол, Адрес, Порт", "HTTPS", 	"cloud.cleverence.ru", 		10772));
	//
	//Для Каждого ОписаниеИнтернетРесурса Из МассивОписанийИнтернетРесурсов Цикл
	//	Разрешение = ОбщегоНазначения.ОбщийМодуль("РаботаВБезопасномРежиме").РазрешениеНаИспользованиеИнтернетРесурса(
	//		ОписаниеИнтернетРесурса.Протокол, ОписаниеИнтернетРесурса.Адрес, ОписаниеИнтернетРесурса.Порт, Описание);
	//	
	//	Разрешения.Добавить(Разрешение);
	//КонецЦикла;

	//РегистрационныеДанные.Вставить("Разрешения", Разрешения);
	//
	//РегистрационныеДанные.Вставить("ВерсияБСП", ОбщегоНазначения.ОбщийМодуль("СтандартныеПодсистемыСервер").ВерсияБиблиотеки());
	#КонецОбласти //СовместимыйКодFresh
	
	Возврат РегистрационныеДанные;
	
КонецФункции 

// Получает версию основной обработки
//
// Возвращаемое значение:
//   Строка   - актуальная версия основной обработки
//
Функция ПолучитьВерсиюОсновнойОбработки() Экспорт
	
	// Последние изменения в релизах:
	// 1.3.7 	- Печать этикеток из формы выгрузки справочников
	// 1.3.8 	- Универсальный проксирующий произвольного вызова в функцию в ИО 
	// 1.3.9 	- Функционал управления, настройки групп и пользователей Mobile SMARTS: создание, 
	//			  редактирование, генерация на основании пользователей базы 1С
	// 1.3.10 	- Переработка ОО под совместимость со скриптом собирающего во фреш расширения
	// 1.3.11 	- Возможность добавления своей таблицы из Mobile SMARTS и настройки её заполнения 
	//			  в окне обмена справочниками
	// 1.3.12	- Дополнительный функционал для режима работы через Интернет ("легкое облако"): восстановление документов,
	//			  управление вариантами и назначениями выгрузки документов (пин-код, устройство, пользователь)
	// 1.3.13	- Сжатие и распаковка GZIP
	// 1.3.14	- Разделение глобальных параметров на ГлобальныеПараметры_ПоУмолчанию и ГлобальныеПараметры_Пользовательские
	// 1.3.15	- Оптимизация инициализации. Удаление лишних вызовов при открытии ОО. Объединение части механизмов
	// 1.3.16	- Кэширование бизнес-процессов, произвольных кодов, отборов, глобальных параметров, метаданных 1с и MS
	// 1.3.17	- Механизм инициализации в фоновом задании
	// 1.3.18	- Поддержка новых ИО с подменяемыми текстами запросов
	// 1.3.19	- Поддержка новой авторизации для облака с tempuid
	//...	
	ВерсияОсновнойОбработки = "1.3.19.66 Core, 10.10.2022";
	
	Возврат ВерсияОсновнойОбработки;
	
КонецФункции

/////////////////////////////////////////////////////////////////
//// ЯДРО.
/////////////////////////////////////////////////////////////////

#Область ЯдроКонфигураций

Функция Конф_ПолучитьПрефиксКонфигурации(АдресаПеременных)
	
	ПрефиксКонфигурации = "";
	
	СтруктураИО = КомЯдро_ПолучитьЗначениеПеременной("ИнтеграционнаяОбработка",АдресаПеременных);
		
	Если (СтруктураИО = Неопределено
		ИЛИ НЕ ТипЗнч(СтруктураИО) = Тип("Структура")
		ИЛИ НЕ СтруктураИО.Свойство("ИнтеграционнаяОбработка")
		ИЛИ СтруктураИО.ИнтеграционнаяОбработка = Неопределено)
		И НЕ ГлЯдро_ПересоздатьИнтеграционнуюОбработку(АдресаПеременных) Тогда
		Возврат Неопределено;
	КонецЕсли;
	СтруктураИО = КомЯдро_ПолучитьЗначениеПеременной("ИнтеграционнаяОбработка",АдресаПеременных);
	ИнтеграционнаяОбработка = СтруктураИО.ИнтеграционнаяОбработка;
	
	Если ИнтеграционнаяОбработка <> Неопределено Тогда
		ПрефиксКонфигурации =  ИнтеграционнаяОбработка.Конф_ПрефиксКонфигурации();	
	КонецЕсли;
	
	Возврат ПрефиксКонфигурации;
	
КонецФункции

Функция Конф_ПолучитьПустуюСсылкуСправочника(ТипСправочника,АдресаПеременных)
	
	СтруктураИО = КомЯдро_ПолучитьЗначениеПеременной("ИнтеграционнаяОбработка",АдресаПеременных);
		
	Если (СтруктураИО = Неопределено
		ИЛИ НЕ ТипЗнч(СтруктураИО) = Тип("Структура")
		ИЛИ НЕ СтруктураИО.Свойство("ИнтеграционнаяОбработка")
		ИЛИ СтруктураИО.ИнтеграционнаяОбработка = Неопределено)
		И НЕ ГлЯдро_ПересоздатьИнтеграционнуюОбработку(АдресаПеременных) Тогда
		Возврат Неопределено;
	КонецЕсли;
	СтруктураИО = КомЯдро_ПолучитьЗначениеПеременной("ИнтеграционнаяОбработка",АдресаПеременных);
	ИнтеграционнаяОбработка = СтруктураИО.ИнтеграционнаяОбработка;
	
	ПустаяСсылка = Неопределено;
	Если ИнтеграционнаяОбработка <> Неопределено Тогда
		ПустаяСсылка = ИнтеграционнаяОбработка.Конф_ПолучитьПустуюСсылкуСправочника(ТипСправочника);
	КонецЕсли;
	
	Возврат ПустаяСсылка;	
КонецФункции

Функция Конф_ИспользоватьХарактеристикиНоменклатуры(АдресаПеременных)
	
	СтруктураИО = КомЯдро_ПолучитьЗначениеПеременной("ИнтеграционнаяОбработка",АдресаПеременных);
		
	Если (СтруктураИО = Неопределено
		ИЛИ НЕ ТипЗнч(СтруктураИО) = Тип("Структура")
		ИЛИ НЕ СтруктураИО.Свойство("ИнтеграционнаяОбработка")
		ИЛИ СтруктураИО.ИнтеграционнаяОбработка = Неопределено)
		И НЕ ГлЯдро_ПересоздатьИнтеграционнуюОбработку(АдресаПеременных) Тогда
		Возврат Неопределено;
	КонецЕсли;
	СтруктураИО = КомЯдро_ПолучитьЗначениеПеременной("ИнтеграционнаяОбработка",АдресаПеременных);
	ИнтеграционнаяОбработка = СтруктураИО.ИнтеграционнаяОбработка;
	
	Результат = Ложь;
	Если ИнтеграционнаяОбработка <> Неопределено Тогда
		Результат = ИнтеграционнаяОбработка.Конф_ИспользоватьХарактеристикиНоменклатуры();
	КонецЕсли;
	
	Возврат Результат;
	
 КонецФункции

Функция Конф_ПолучитьМетаданныеНСИ(АдресаПеременных)
	
	СтруктураИО = КомЯдро_ПолучитьЗначениеПеременной("ИнтеграционнаяОбработка",АдресаПеременных);
		
	Если (СтруктураИО = Неопределено
		ИЛИ НЕ ТипЗнч(СтруктураИО) = Тип("Структура")
		ИЛИ НЕ СтруктураИО.Свойство("ИнтеграционнаяОбработка")
		ИЛИ СтруктураИО.ИнтеграционнаяОбработка = Неопределено)
		И НЕ ГлЯдро_ПересоздатьИнтеграционнуюОбработку(АдресаПеременных) Тогда
		Возврат Неопределено;
	КонецЕсли;
	СтруктураИО = КомЯдро_ПолучитьЗначениеПеременной("ИнтеграционнаяОбработка",АдресаПеременных);
	ИнтеграционнаяОбработка = СтруктураИО.ИнтеграционнаяОбработка;
	
	Если ИнтеграционнаяОбработка <> Неопределено Тогда
		МетаданныеНСИ = ИнтеграционнаяОбработка.Конф_ПолучитьМетаданныеНСИ();	
	Иначе
		МетаданныеНСИ = Неопределено;
	КонецЕсли;

	Возврат МетаданныеНСИ;

КонецФункции

#КонецОбласти

#Область ЯдроСистемы

#Область ГлобальныйКонтекст

#Область ГлобальныйКонтекст_Настройки

#Область ГлобальныйКонтекст_Настройки_Инициализация

Процедура ГлЯдро_Инициализация(ИмяСобытия = "ГлЯдро_Инициализация", ПолнаяИнициализация = ложь,mXmlDoc = Неопределено, АдресаПеременных=Неопределено)
	
	НачалоСобытия = ТекущаяУниверсальнаяДатаВМиллисекундах();
	ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Начало инициализации",НачалоСобытия,АдресаПеременных);
	
	Если АдресаПеременных = Неопределено Тогда	
		АдресаПеременных = КомЯдро_СоздатьСтруктуруАдресаПеременных();
	КонецЕсли;
	
	ПараметрыПодключенияMS   = ГлЯдро_ПолучитьДанныеИзХранилища1С("Cleverence_ПараметрыПодключенияMS");
	ТипИнтерфейса            = ГлЯдро_ПолучитьДанныеИзХранилища1С("Cleverence_ТипИнтерфейса");
	КомЯдро_СохранитьЗначениеПеременной("ТипИнтерфейса",ТипИнтерфейса,АдресаПеременных); 
	
	Если ПолнаяИнициализация Тогда
		ПараметрыПодключенияMS = ГлЯдро_АктуализацияСтруктурыПараметровПодключенияSMARTS(ПараметрыПодключенияMS);		
	КонецЕсли;
	
	Если ТипИнтерфейса = "REST_API" Тогда 
		КлючПеременной = "REST_API_СтруктураПодключенияБазыMS";
	 	КомЯдро_СохранитьЗначениеПеременной(КлючПеременной,ПараметрыПодключенияMS,АдресаПеременных);
	КонецЕсли;
	
	ЭтоВнешнееСоединение = Ложь;
	#Если ВнешнееСоединение Тогда
		ЭтоВнешнееСоединение = Истина;	
	#КонецЕсли
	
	ИспJSON_mXmlDoc = Истина;
		
	Если ТипЗнч(mXmlDoc)=Тип("Строка") И Лев(mXmlDoc,5)="<?xml" ИЛИ ТипИнтерфейса <> "REST_API" Тогда
		ИспJSON_mXmlDoc = Ложь;
	КонецЕсли;
		
	Ошибка_mXmlDoc = Ложь;
	Если mXmlDoc <> Неопределено И mXmlDoc <> "AutoSerialization" Тогда
		Попытка
			ГлЯдро_ЗагрузитьИзJSON(mXmlDoc);
		Исключение
			ИспJSON_mXmlDoc = Ложь;
			Если ТипИнтерфейса = "REST_API" Тогда
				ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Не удалось распознать JSON во входящем параметре mXmlDoc. Возможно в настройках базы Mobile SMARTS установлен режим XML",НачалоСобытия,АдресаПеременных);
				
				Если ЭтоВнешнееСоединение ИЛИ ЭтоWebСервис Тогда
					Ошибка_mXmlDoc = Истина;
					ОписаниеОшибкиONLEX = Новый Структура;
					ОписаниеОшибкиONLEX.Вставить("КодОшибкиONLEX", "ONLEX004");
					ГлЯдро_СохранитьДанныеВХранилище1С("Cleverence_ОписаниеОшибкиONLEX", ОписаниеОшибкиONLEX);
				КонецЕсли;	
			КонецЕсли;
		КонецПопытки;
	КонецЕсли;
	
	КомЯдро_СохранитьЗначениеПеременной("ИспJSON_mXmlDoc",ИспJSON_mXmlDoc,АдресаПеременных);
	КомЯдро_СохранитьЗначениеПеременной("ПараметрыПодключенияMS",ПараметрыПодключенияMS,АдресаПеременных);
	
	Если ПолнаяИнициализация Тогда
		КомЯдро_УдалитьПеременныеCOM(АдресаПеременных);	
	КонецЕсли;
	
	Если НЕ ГлЯдро_ПроверитьСоединениеССерверомSMARTS(,,,,,,АдресаПеременных) = Истина Тогда
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Не удалось подключиться к Базе Mobile SMARTS",НачалоСобытия,АдресаПеременных);
		Возврат;	
	КонецЕсли;
	
	ИспользоватьКэш = ЭтоWebСервис или ЭтоВнешнееСоединение;
	Если ИспользоватьКэш Тогда
		//ДатаАктуальностиКэшаВБазе = ГлЯдро_ПолучитьДанныеИзХранилища1С("Cleverence_ДатаАктуальностиКэша");
		Если ПолнаяИнициализация
			//ИЛИ НЕ ТипЗнч(ДатаАктуальностиКэшаВБазе) = Тип("Дата") 
			//ИЛИ ТекущаяДата() - ДатаАктуальностиКэшаВБазе > 3600*12 Тогда //Если настройки устарели и нужно переполучить,12ч. // 25.01.22 Решено убрать бессмысленное обновление настроек
			Тогда
			ГлЯдро_СохранитьДанныеВХранилище1С("Cleverence_ДатаАктуальностиКэша", ТекущаяДата());
			ГлЯдро_ПолучитьДанныеДляИнициализации(,АдресаПеременных);
			ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Полная инициализация и сохранение настроек в кеш для онлайна",НачалоСобытия,АдресаПеременных);
		Иначе
			ГлЯдро_ПолучитьДанныеДляИнициализацииИзКэша(ИмяСобытия, АдресаПеременных);
			ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Получаем данные из кеша для онлайна",НачалоСобытия,АдресаПеременных);
			Если НЕ ГлЯдро_ПроверитьТекущиеНастройки(АдресаПеременных) Тогда
				ГлЯдро_ПолучитьДанныеДляИнициализации(,АдресаПеременных);		
			КонецЕсли;
		КонецЕсли;
	Иначе
		ГлЯдро_ПолучитьДанныеДляИнициализации(,АдресаПеременных);
	КонецЕсли;
	Если Ошибка_mXmlDoc Тогда
		КомЯдро_СохранитьЗначениеПеременной("НастройкиИнициализированы", Ложь, АдресаПеременных);
	КонецЕсли;
	
	ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Подключаем интеграционную обработку. Начало.",НачалоСобытия,АдресаПеременных);
	ИнтеграционнаяОбработка = КомЯдро_ПолучитьЗначениеПеременной("ИнтеграционнаяОбработка",АдресаПеременных);
		
	Если ИнтеграционнаяОбработка = Неопределено Тогда
		РезультатПодключенияВО = ГлЯдро_ПодключитьИнтеграционнуюОбработку(,,,,АдресаПеременных);
		Если НЕ (ЭтоАдресВременногоХранилища(РезультатПодключенияВО) 
			ИЛИ РезультатПодключенияВО = "Интеграционная обработка не соответствует конфигурации или версии 1С") Тогда		
				КомЯдро_СохранитьЗначениеПеременной("НастройкиИнициализированы",Ложь,АдресаПеременных);
				Если ТипЗнч(РезультатПодключенияВО) = Тип("Строка") И НЕ ПустаяСтрока(РезультатПодключенияВО) Тогда
					ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", РезультатПодключенияВО, НачалоСобытия, АдресаПеременных);
					
					Если ЭтоВнешнееСоединение ИЛИ ЭтоWebСервис Тогда
						ОписаниеОшибкиONLEX = Новый Структура;
						ОписаниеОшибкиONLEX.Вставить("КодОшибкиONLEX", "ONLEX002");
						ОписаниеОшибкиONLEX.Вставить("СтруктураПараметровONLEX", Новый Структура("ОшибкаПодключенияИО", РезультатПодключенияВО));
							
						ГлЯдро_СохранитьДанныеВХранилище1С("Cleverence_ОписаниеОшибкиONLEX", ОписаниеОшибкиONLEX);
					КонецЕсли;
				КонецЕсли;
				ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Ошибка инициализации, не удалось подключить интеграционную обработку",НачалоСобытия,АдресаПеременных);
				Возврат;
		КонецЕсли;
		КомЯдро_СохранитьЗначениеПеременной("ИнтеграционнаяОбработкаПодключена",Истина,АдресаПеременных);
	Иначе
		Если ТипЗнч(АдресаПеременных) = Тип("Структура")
			И АдресаПеременных.Свойство("ИнтеграционнаяОбработка") Тогда
			РезультатПодключенияВО = АдресаПеременных.ИнтеграционнаяОбработка;
		КонецЕсли;
		// Для актуализации значений в кэше сессии
		КомЯдро_СохранитьЗначениеПеременной("ИнтеграционнаяОбработка", 			 ИнтеграционнаяОбработка, АдресаПеременных);
		КомЯдро_СохранитьЗначениеПеременной("ИнтеграционнаяОбработкаПодключена", Истина, 				  АдресаПеременных);
	КонецЕсли;
	ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Интеграционная обработка: "+Строка(ИнтеграционнаяОбработка)+"РезультатПодключенияВО: "+Строка(РезультатПодключенияВО),НачалоСобытия,АдресаПеременных);
	ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Конец инициализации",НачалоСобытия,АдресаПеременных);
	
КонецПроцедуры

// Возвращает структуру настроек подключаемой базы Mobile Smarts
//
// Параметры:
//	ЗаполнятьДанные - Булево
//	АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
//
// Возвращаемое значение:
//	Структура - содержит:	
//		* ДанныеТекущегоУзла - Структура - содержит:
//			** ID_Узла - Строка
//			** Наименование - Строка
//          ** ЧастнаяБазаMS - Строка
//      * КатегорииНастроекMS - Структура - см. ГлЯдро_ПолучитьКатегорииНастроекMS
//	    * ТекущиеНастройкиMS - Структура - см. ГлЯдро_ПолучитьПустуюСтруктуруНастроекSMARTS
//      * СтруктураМетаданных - Структура - содержит:
//      	** Документы1С - Структура - см. ГлЯдро_ПолучитьМетаданныеДокументов1С 
//          ** НастройкиMS - Структура - см. ГлЯдро_СформироватьМетаданныеНастроекMS
//          ** ДокументыMS - Структура - см. КомЯдро_ПолучитьМетаданныеДокументовMS или REST_API_ПолучитьМетаданныеДокументовMS (в зависимости от типа интерфейса)
// 		   	** ПользователиMS - см. КомЯдро_ПолучитьМетаданныеДокументовMS или REST_API_ПолучитьМетаданныеДокументовMS (в зависимости от типа интерфейса)
//          ** УстройстваMS - см. КомЯдро_ПолучитьМетаданныеДокументовMS или REST_API_ПолучитьМетаданныеДокументовMS (в зависимости от типа интерфейса)
//          ** Tables - см. КомЯдро_ПолучитьМетаданныеДокументовMS или REST_API_ПолучитьМетаданныеДокументовMS (в зависимости от типа интерфейса)
//          ** UniПолейНоменклатуры - см. КомЯдро_ПолучитьМетаданныеДокументовMS или REST_API_ПолучитьМетаданныеДокументовMS (в зависимости от типа интерфейса)
//      * ПраваПользователя - Структура - содержит:
//			** РольПользователя - Строка
Функция ГлЯдро_ПолучитьДанныеДляИнициализации(ЗаполнятьДанные = Истина, АдресаПеременных) Экспорт
		
	НачалоСобытия = ТекущаяУниверсальнаяДатаВМиллисекундах();
		
	ДанныеДляИнициализации = Новый Структура;

	КатегорииНастроек = ГлЯдро_ПолучитьКатегорииНастроекMS();
	СтруктураНастроек = ГлЯдро_ПолучитьПустуюСтруктуруНастроекSMARTS(КатегорииНастроек.СериализуемыеНастройки);
	
	Если ЗаполнятьДанные Тогда
		КомЯдро_СохранитьЗначениеПеременной("КатегорииНастроекMS", КатегорииНастроек, АдресаПеременных);
	КонецЕсли;
	
	СтруктураМетаданных = Новый Структура;
	СтруктураМетаданных.Вставить("Документы1С", ГлЯдро_ОбновитьМетаданныеДокументов1С(, АдресаПеременных));
	СтруктураМетаданных.Вставить("НастройкиMS", ГлЯдро_СформироватьМетаданныеНастроекMS());
	ЭтоВнешнееСоединение = Ложь;
	#Если ВнешнееСоединение Тогда
		ЭтоВнешнееСоединение = Истина;	
	#КонецЕсли
	ИспользоватьКэш = ЭтоWebСервис или ЭтоВнешнееСоединение;
	Если ИспользоватьКэш Тогда
		ГлЯдро_СохранитьДанныеВХранилище1С("Cleverence_СтруктураМетаданныхДокументы1С", СтруктураМетаданных.Документы1С);	
	КонецЕсли;
	
	ПараметрыПодключенияMS = ГлЯдро_ПолучитьДанныеИзХранилища1С("Cleverence_ПараметрыПодключенияMS");
	ТипИнтерфейса = ГлЯдро_ПолучитьДанныеИзХранилища1С("Cleverence_ТипИнтерфейса");
	
	Если ЗаполнятьДанные Тогда		
		ГлЯдро_ПроверитьАктуальностьКэшируемыхНастроекПриИнициализации(, АдресаПеременных);
		
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации("ГлЯдро_ПолучитьНастройкиНаСервереSMARTS", "Информация", "Начало", НачалоСобытия, АдресаПеременных);
		СтруктураНастроек = ГлЯдро_ПолучитьНастройкиНаСервереSMARTS(СтруктураНастроек, КатегорииНастроек.УзловыеНастройки,, АдресаПеременных);
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации("ГлЯдро_ПолучитьНастройкиНаСервереSMARTS", "Информация", "Конец", НачалоСобытия, АдресаПеременных);
		
		//Если ИспользоватьКэш Тогда
		//	ГлЯдро_СохранитьДанныеВХранилище1С("Cleverence_СтруктураНастроек", СтруктураНастроек);
		//КонецЕсли;
		
		ДанныеТекущегоУзла = Новый Структура;
		ДанныеТекущегоУзла.Вставить("ID_Узла", 		"");
		ДанныеТекущегоУзла.Вставить("Наименование", "");
		ДанныеТекущегоУзла.Вставить("ЧастнаяБазаMS","");		
		
		// Текущий узел			
		ID_ТекущегоУзла = ГлЯдро_ПолучитьДанныеИзХранилища1С("Cleverence_ID_ТекущегоУзла_"+ПараметрыПодключенияMS.Ид);
		Если Не ЗначениеЗаполнено(ID_ТекущегоУзла) Тогда
			ID_ТекущегоУзла = "";	
		КонецЕсли;
		
		// Структуру настроек получаем для всех узлов
		Если ИспользоватьКэш Тогда
			КомЯдро_СохранитьЗначениеПеременной("ТекущиеНастройкиMS_ГлавныйУзел", ГлЯдро_СобратьСтруктуруНастроекИзКэша("", АдресаПеременных), АдресаПеременных);
			
			Если ТипЗнч(СтруктураНастроек.Узлы) = Тип("Массив") Тогда
				Для Каждого пУзел Из СтруктураНастроек.Узлы Цикл
					Если пУзел.Свойство("ID_Узла") Тогда
						//Для Каждого ИмяНастройки Из КатегорииНастроек.УзловыеНастройки Цикл
						//	СтруктураНастроек.Вставить(ИмяНастройки, Ложь);
						//КонецЦикла;
						//
						//ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации("ГлЯдро_ПолучитьНастройкиНаСервереSMARTS", "Информация", "Начало, ID_Узла = " + СокрЛП(пУзел.ID_Узла), НачалоСобытия, АдресаПеременных);
						//СтруктураУзловыхНастроек = ГлЯдро_ПолучитьНастройкиНаСервереSMARTS(СтруктураНастроек, КатегорииНастроек.УзловыеНастройки, пУзел.ID_Узла, АдресаПеременных);
						//ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации("ГлЯдро_ПолучитьНастройкиНаСервереSMARTS", "Информация", "Конец, ID_Узла = " + СокрЛП(пУзел.ID_Узла), НачалоСобытия, АдресаПеременных);
						// ГлЯдро_СохранитьДанныеВХранилище1С("Cleverence_СтруктураНастроек_" + пУзел.ID_Узла, СтруктураНастроек);
						
						КомЯдро_СохранитьЗначениеПеременной("ТекущиеНастройкиMS_" + пУзел.ID_Узла, ГлЯдро_СобратьСтруктуруНастроекИзКэша(пУзел.ID_Узла, АдресаПеременных), АдресаПеременных);
					КонецЕсли;
				КонецЦикла;
			КонецЕсли;
		КонецЕсли;
		
		ДанныеУзла = Неопределено;
		Если ID_ТекущегоУзла <> "" И (ТипЗнч(СтруктураНастроек.Узлы) = Тип("Массив")) Тогда
			Для Каждого пУзел Из СтруктураНастроек.Узлы Цикл
				Если пУзел.Свойство("ID_Узла") И пУзел.ID_Узла = ID_ТекущегоУзла Тогда
					ДанныеУзла = пУзел;
				КонецЕсли;
			КонецЦикла;
			Если ДанныеУзла <> Неопределено Тогда
				ДанныеТекущегоУзла.Вставить("ID_Узла", 		ID_ТекущегоУзла);
				ДанныеТекущегоУзла.Вставить("Наименование", ДанныеУзла.Наименование);
				Если ДанныеУзла.ИспользоватьЧастнуюБазу Тогда
					ДанныеТекущегоУзла.Вставить("ЧастнаяБазаMS", ДанныеУзла.ЧастнаяБазаMS);
				КонецЕсли;
				
				Если ИспользоватьКэш Тогда
					// СтруктураНастроек = ГлЯдро_ПолучитьДанныеИзХранилища1С("Cleverence_СтруктураНастроек_" + ID_ТекущегоУзла);
					СтруктураНастроек = КомЯдро_ПолучитьЗначениеПеременной("ТекущиеНастройкиMS_" + ID_ТекущегоУзла, АдресаПеременных);
				Иначе
					ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации("ГлЯдро_ПолучитьНастройкиНаСервереSMARTS", "Информация", "Начало", НачалоСобытия, АдресаПеременных);
					СтруктураНастроек = ГлЯдро_ПолучитьНастройкиНаСервереSMARTS(СтруктураНастроек, КатегорииНастроек.УзловыеНастройки, ID_ТекущегоУзла, АдресаПеременных);
					ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации("ГлЯдро_ПолучитьНастройкиНаСервереSMARTS", "Информация", "Конец", НачалоСобытия, АдресаПеременных);
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		
		ДанныеДляИнициализации.Вставить("ДанныеТекущегоУзла", ДанныеТекущегоУзла);
		
		пСтруктураМетаданных = ГлЯдро_ОбновитьМетаданныеДокументовMS(, АдресаПеременных);

		СтруктураМетаданных.Вставить("ДокументыMS",		?(пСтруктураМетаданных = Неопределено, Новый Структура(), пСтруктураМетаданных.ДокументыMS));
		СтруктураМетаданных.Вставить("ПользователиMS",	?(пСтруктураМетаданных = Неопределено, "", пСтруктураМетаданных.ПользователиMS));
		СтруктураМетаданных.Вставить("УстройстваMS",	?(пСтруктураМетаданных = Неопределено, "", пСтруктураМетаданных.УстройстваMS));
		СтруктураМетаданных.Вставить("Tables",			?(пСтруктураМетаданных = Неопределено, Новый СписокЗначений(), пСтруктураМетаданных.Tables));
		СтруктураМетаданных.Вставить("UniПолейНоменклатуры", ?(пСтруктураМетаданных = Неопределено, Новый Соответствие(), пСтруктураМетаданных.UniПолейНоменклатуры));
		СтруктураМетаданных.Вставить("ВыгружаемыеПоляНоменклатурыMS", ?(пСтруктураМетаданных=Неопределено, Новый Структура, пСтруктураМетаданных.ВыгружаемыеПоляНоменклатурыMS));
		
		Если ИспользоватьКэш Тогда
			ГлЯдро_СохранитьДанныеВХранилище1С("Cleverence_СтруктураМетаданныхДокументыMS", СтруктураМетаданных.ДокументыMS);	
			ГлЯдро_СохранитьДанныеВХранилище1С("Cleverence_ПользователиMS", СтруктураМетаданных.ПользователиMS);
			ГлЯдро_СохранитьДанныеВХранилище1С("Cleverence_УстройстваMS", СтруктураМетаданных.УстройстваMS);
			ГлЯдро_СохранитьДанныеВХранилище1С("Cleverence_ТаблицыMS", СтруктураМетаданных.Tables);
		КонецЕсли;
		
		ДанныеДляИнициализации.Вставить("КатегорииНастроекMS", 	КатегорииНастроек);
		ДанныеДляИнициализации.Вставить("ТекущиеНастройкиMS",	СтруктураНастроек);
	КонецЕсли;
	
	ДанныеДляИнициализации.Вставить("СтруктураМетаданных", СтруктураМетаданных);
	
	//Заготовка для своей системы разграничения прав
	РольПользователя ="Пользователь";
	Попытка
		Если Метаданные.Роли.Найти("АдминистраторСистемы") = Неопределено
			ИЛИ РольДоступна("АдминистраторСистемы") Тогда
			РольПользователя = "Администратор";	
		КонецЕсли;
	Исключение
		//Если нет роли АдминистраторСистемы тогда все админы
		РольПользователя = "Администратор";
	КонецПопытки;
	ДанныеДляИнициализации.Вставить("ПраваПользователя",Новый Структура("РольПользователя", РольПользователя));
			
	Если ЗаполнятьДанные Тогда	
		КомЯдро_СохранитьЗначениеПеременной("КатегорииНастроекMS",	ДанныеДляИнициализации.КатегорииНастроекMS,	АдресаПеременных);
		КомЯдро_СохранитьЗначениеПеременной("ТекущиеНастройкиMS",	ДанныеДляИнициализации.ТекущиеНастройкиMS,	АдресаПеременных);
		КомЯдро_СохранитьЗначениеПеременной("СтруктураМетаданных", 	ДанныеДляИнициализации.СтруктураМетаданных, АдресаПеременных);
		КомЯдро_СохранитьЗначениеПеременной("ДанныеТекущегоУзла",	ДанныеДляИнициализации.ДанныеТекущегоУзла,	АдресаПеременных);
		
		КомЯдро_СохранитьЗначениеПеременной("НастройкиИнициализированы",Истина,АдресаПеременных);	
		
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации("ГлЯдро_ПроверитьИспользованиеНовойСтруктурыНастроекБизнесПроцессов", "Информация", "Начало", НачалоСобытия, АдресаПеременных);
		// Проверяем текущие настройки по-умолчанию (нового формата они, или нет) и сохраняем результат в переменную 
		КомЯдро_СохранитьЗначениеПеременной(
			"НовыеНастройкиБизнесПроцессов", 
			ГлЯдро_ПроверитьИспользованиеНовойСтруктурыНастроекБизнесПроцессов(АдресаПеременных),
			АдресаПеременных);
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации("ГлЯдро_ПроверитьИспользованиеНовойСтруктурыНастроекБизнесПроцессов", "Информация", "Конец", НачалоСобытия, АдресаПеременных);
		
		//Реструктуризация настроек
		ВерсияНастроек_ПоУмолчанию 				= Ложь;
		НастройкиБизнесПроцессов_ПоУмолчанию 	= Ложь;
		Если ТипЗнч(СтруктураНастроек.НастройкиБизнесПроцессов_ПоУмолчанию) = Тип("Структура") Тогда
			Если СтруктураНастроек.НастройкиБизнесПроцессов_ПоУмолчанию.Свойство("ВерсияНастроек") Тогда
				ВерсияНастроек_ПоУмолчанию = СтруктураНастроек.НастройкиБизнесПроцессов_ПоУмолчанию.ВерсияНастроек;
			КонецЕсли;
			Если СтруктураНастроек.НастройкиБизнесПроцессов_ПоУмолчанию.Свойство("НастройкиБизнесПроцессов") Тогда
				НастройкиБизнесПроцессов_ПоУмолчанию = СтруктураНастроек.НастройкиБизнесПроцессов_ПоУмолчанию.НастройкиБизнесПроцессов;
			КонецЕсли;
		КонецЕсли;
		
		пСтруктураНастроек = Новый Структура;
		пСтруктураНастроек.Вставить("ВерсияОбработкиНастроек", 		СтруктураНастроек.ВерсияОбработкиНастроек);
		пСтруктураНастроек.Вставить("ВерсияОбработкиКлеверенсТСД", 	СтруктураНастроек.ВерсияОбработкиКлеверенсТСД);
		пСтруктураНастроек.Вставить("ВерсияНастроек_ПоУмолчанию", 	ВерсияНастроек_ПоУмолчанию);
		пСтруктураНастроек.Вставить("НастройкиБизнесПроцессов",		НастройкиБизнесПроцессов_ПоУмолчанию);
		пСтруктураНастроек.Вставить("ВерсияГлобальныеПараметры",	СтруктураНастроек.ВерсияГлобальныеПараметры);
		
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации("ГлЯдро_ВыполнитьОбновлениеСтруктурыНастроек", "Информация", "Начало", НачалоСобытия, АдресаПеременных);
		СтруктураИзменений = ГлЯдро_ВыполнитьОбновлениеСтруктурыНастроек(пСтруктураНастроек,,,АдресаПеременных);
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации("ГлЯдро_ВыполнитьОбновлениеСтруктурыНастроек", "Информация", "Конец", НачалоСобытия, АдресаПеременных);
		
		Если ГлЯдро_ПроверитьСохраненнуюСтрокуПодключения1С(АдресаПеременных) = Ложь Тогда
			#Область СовместимыйКодFresh
			//Если ПараметрыПодключенияMS.Свойство("База1ССтрокаСоединенияКлиент") Тогда
			//	СтруктураИзменений.ИзменениеВНастройках.Вставить("ServiceHTTPAddress",ПараметрыПодключенияMS.База1ССтрокаСоединенияКлиент);
			//КонецЕсли;
			#КонецОбласти //СовместимыйКодFresh
			СтруктураИзменений.ИзменениеВНастройках.Вставить("База1СПодключенаДата",ТекущаяДата());
		КонецЕсли;
		
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации("ГлЯдро_СохранитьНастройкиВБазеSMARTS", "Информация", "Начало", НачалоСобытия, АдресаПеременных);
		ГлЯдро_СохранитьНастройкиВБазеSMARTS(СтруктураИзменений.ИзменениеВНастройках,ID_ТекущегоУзла,АдресаПеременных);
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации("ГлЯдро_СохранитьНастройкиВБазеSMARTS", "Информация", "Конец", НачалоСобытия, АдресаПеременных);
		
		ГлЯдро_ЗаписатьВКэшНастройкиSMARTS(СтруктураИзменений.ИзменениеВНастройках,АдресаПеременных);
		ГлЯдро_ЗаписатьВКэшНастройкиSMARTS(СтруктураИзменений.ИзмененияВКэше,АдресаПеременных);
		
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации("ГлЯдро_УстановитьДанныеТекущегоУзла", "Информация", "Начало", НачалоСобытия, АдресаПеременных);
		ГлЯдро_УстановитьДанныеТекущегоУзла(ID_ТекущегоУзла,Ложь,,ТипИнтерфейса,АдресаПеременных);
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации("ГлЯдро_УстановитьДанныеТекущегоУзла", "Информация", "Конец", НачалоСобытия, АдресаПеременных);
		
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации("ГлЯдро_ОбъединитьПроизвольныеКоды", "Информация", "Начало", НачалоСобытия, АдресаПеременных);
		ГлЯдро_ОбъединитьПроизвольныеКоды(АдресаПеременных); //Временная заплатка на случай если произвольные коды лежат в 4-х ключах		
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации("ГлЯдро_ОбъединитьПроизвольныеКоды", "Информация", "Конец", НачалоСобытия, АдресаПеременных);
		
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации("ГлЯдро_ПроверитьОбновлениеТиповыхБизнесПроцессов", "Информация", "Начало", НачалоСобытия, АдресаПеременных);
		ГлЯдро_ПроверитьОбновлениеТиповыхБизнесПроцессов(СтруктураНастроек, АдресаПеременных);
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации("ГлЯдро_ПроверитьОбновлениеТиповыхБизнесПроцессов", "Информация", "Конец", НачалоСобытия, АдресаПеременных);
		
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации("ГлЯдро_СобратьОбщуюСтруктуруБизнесПроцессов", "Информация", "Начало", НачалоСобытия, АдресаПеременных);
		ГлЯдро_СобратьОбщуюСтруктуруБизнесПроцессов(АдресаПеременных);
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации("ГлЯдро_СобратьОбщуюСтруктуруБизнесПроцессов", "Информация", "Конец", НачалоСобытия, АдресаПеременных);
		
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации("ГлЯдро_СобратьОбщуюСтруктуруПроизвольныхКодов", "Информация", "Начало", НачалоСобытия, АдресаПеременных);
		ГлЯдро_СобратьОбщуюСтруктуруПроизвольныхКодов(АдресаПеременных);
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации("ГлЯдро_СобратьОбщуюСтруктуруПроизвольныхКодов", "Информация", "Конец", НачалоСобытия, АдресаПеременных);
		
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации("ГлЯдро_СобратьОбщуюСтруктуруГлобальныхПараметров", "Информация", "Начало", НачалоСобытия, АдресаПеременных);
		ГлЯдро_СобратьОбщуюСтруктуруГлобальныхПараметров(АдресаПеременных);
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации("ГлЯдро_СобратьОбщуюСтруктуруГлобальныхПараметров", "Информация", "Конец", НачалоСобытия, АдресаПеременных);
		
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации("ГлЯдро_ОбновитьНастройкиТаймаутов", "Информация", "Начало", НачалоСобытия, АдресаПеременных);
		ГлЯдро_ОбновитьНастройкиТаймаутов(АдресаПеременных);
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации("ГлЯдро_ОбновитьНастройкиТаймаутов", "Информация", "Конец", НачалоСобытия, АдресаПеременных);
	КонецЕсли;
	
	Возврат ДанныеДляИнициализации;
		
КонецФункции

// Возвращает полученную из кэша структуру настроек подключаемой базы Mobile Smarts
//
// Параметры:
//	АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
//
// Возвращаемое значение:
//  Структура - содержит:	
//		* ДанныеТекущегоУзла - Структура - содержит:
//			** ID_Узла - Строка
//			** Наименование - Строка
//          ** ID_БазыMS - Строка
//      * КатегорииНастроекMS - Структура - см. ГлЯдро_ПолучитьКатегорииНастроекMS
//	    * ТекущиеНастройкиMS - Структура - см. ГлЯдро_ПолучитьПустуюСтруктуруНастроекSMARTS
//      * СтруктураМетаданных - Структура - содержит:
//      	** Документы1С - Структура - см. ГлЯдро_ПолучитьМетаданныеДокументов1С 
//          ** НастройкиMS - Структура - см. ГлЯдро_СформироватьМетаданныеНастроекMS
//          ** ДокументыMS - Структура - см. КомЯдро_ПолучитьМетаданныеДокументовMS или REST_API_ПолучитьМетаданныеДокументовMS (в зависимости от типа интерфейса)
// 		   	** ПользователиMS - см. КомЯдро_ПолучитьМетаданныеДокументовMS или REST_API_ПолучитьМетаданныеДокументовMS (в зависимости от типа интерфейса)
//          ** УстройстваMS - см. КомЯдро_ПолучитьМетаданныеДокументовMS или REST_API_ПолучитьМетаданныеДокументовMS (в зависимости от типа интерфейса)
//          ** Tables - см. КомЯдро_ПолучитьМетаданныеДокументовMS или REST_API_ПолучитьМетаданныеДокументовMS (в зависимости от типа интерфейса)
Функция ГлЯдро_ПолучитьДанныеДляИнициализацииИзКэша(ИмяСобытия = "ГлЯдро_Инициализация", АдресаПеременных) Экспорт
		
	НачалоСобытия = ТекущаяУниверсальнаяДатаВМиллисекундах();
	
	ДанныеДляИнициализации = Новый Структура;

	КатегорииНастроек = ГлЯдро_ПолучитьКатегорииНастроекMS();
	КомЯдро_СохранитьЗначениеПеременной("КатегорииНастроекMS", КатегорииНастроек, АдресаПеременных);
	
	Если ИмяСобытия = "ИнициализацияПодключенияСМАРТС"
		И НЕ ГлЯдро_ПроверитьАктуальностьКэшируемыхНастроекПриИнициализации(, АдресаПеременных) Тогда
		КомЯдро_СохранитьЗначениеПеременной("СтруктураМетаданных", Ложь, АдресаПеременных);
		Возврат ДанныеДляИнициализации;
	КонецЕсли;
	
	СтруктураМетаданных = Новый Структура;
    СтруктураМетаданных.Вставить("Документы1С", ГлЯдро_ПолучитьДанныеИзХранилища1С("Cleverence_СтруктураМетаданныхДокументы1С"));
	СтруктураМетаданных.Вставить("НастройкиMS", ГлЯдро_СформироватьМетаданныеНастроекMS());

	ПараметрыПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("ПараметрыПодключенияMS", АдресаПеременных);
	Если ПараметрыПодключенияMS = Неопределено Тогда
		ПараметрыПодключенияMS = ГлЯдро_ПолучитьДанныеИзХранилища1С("Cleverence_ПараметрыПодключенияMS");
	КонецЕсли;
	
	// Текущий узел	
	ID_ТекущегоУзла = ГлЯдро_ПолучитьДанныеИзХранилища1С("Cleverence_ID_ТекущегоУзла_" + ПараметрыПодключенияMS.Ид);
	Если Не ЗначениеЗаполнено(ID_ТекущегоУзла) Тогда
		ID_ТекущегоУзла = "";	
	КонецЕсли;
	
	СтруктураНастроек = ГлЯдро_СобратьСтруктуруНастроекИзКэша(ID_ТекущегоУзла, АдресаПеременных);
	
	ДанныеТекущегоУзла = Новый Структура;
	ДанныеТекущегоУзла.Вставить("ID_Узла", "");
	ДанныеТекущегоУзла.Вставить("Наименование", "");
	ДанныеТекущегоУзла.Вставить("ID_БазыMS", "");

	ДанныеУзла = Неопределено;
	Если ID_ТекущегоУзла <> ""
			И (СтруктураНастроек.Свойство("Узлы") И ТипЗнч(СтруктураНастроек.Узлы) = Тип("Массив")) Тогда
		Для Каждого пУзел Из СтруктураНастроек.Узлы Цикл
			Если пУзел.Свойство("ID_Узла") И пУзел.ID_Узла = ID_ТекущегоУзла Тогда
				ДанныеУзла = пУзел;
			КонецЕсли;
		КонецЦикла;
		Если ДанныеУзла <> Неопределено Тогда
			ДанныеТекущегоУзла.Вставить("ID_Узла", ID_ТекущегоУзла);
			ДанныеТекущегоУзла.Вставить("Наименование", ДанныеУзла.Наименование);
			Если ДанныеУзла.ИспользоватьЧастнуюБазу Тогда
				ДанныеТекущегоУзла.Вставить("ID_БазыMS", ДанныеУзла.ЧастнаяБазаMS);
			Иначе
				ДанныеТекущегоУзла.Вставить("ID_БазыMS", ПараметрыПодключенияMS.Ид);
			КонецЕсли;
			//СтруктураНастроек = ГлЯдро_ПолучитьДанныеИзХранилища1С("Cleverence_СтруктураНастроек_"
			//	+ ID_ТекущегоУзла);
		КонецЕсли;
	КонецЕсли;

	ДанныеДляИнициализации.Вставить("ДанныеТекущегоУзла", ДанныеТекущегоУзла);
	
	СтруктураМетаданных.Вставить("ДокументыMS", 	ГлЯдро_ПолучитьДанныеИзХранилища1С("Cleverence_СтруктураМетаданныхДокументыMS"));
	СтруктураМетаданных.Вставить("ПользователиMS", 	ГлЯдро_ПолучитьДанныеИзХранилища1С("Cleverence_ПользователиMS"));
	СтруктураМетаданных.Вставить("УстройстваMS",   	ГлЯдро_ПолучитьДанныеИзХранилища1С("Cleverence_УстройстваMS"));
	СтруктураМетаданных.Вставить("Tables", 			ГлЯдро_ПолучитьДанныеИзХранилища1С("Cleverence_ТаблицыMS"));
	
	ДанныеДляИнициализации.Вставить("КатегорииНастроекMS", 	КатегорииНастроек);
	ДанныеДляИнициализации.Вставить("ТекущиеНастройкиMS", 	СтруктураНастроек);
	ДанныеДляИнициализации.Вставить("СтруктураМетаданных", 	СтруктураМетаданных);
	
	КомЯдро_СохранитьЗначениеПеременной("ТекущиеНастройкиMS",	ДанныеДляИнициализации.ТекущиеНастройкиMS,	АдресаПеременных);
	КомЯдро_СохранитьЗначениеПеременной("СтруктураМетаданных",	ДанныеДляИнициализации.СтруктураМетаданных,	АдресаПеременных);
	КомЯдро_СохранитьЗначениеПеременной("ДанныеТекущегоУзла",	ДанныеДляИнициализации.ДанныеТекущегоУзла,	АдресаПеременных);
	
	КомЯдро_СохранитьЗначениеПеременной("НастройкиИнициализированы",Истина,АдресаПеременных);

	//ГлЯдро_СобратьОбщуюСтруктуруБизнесПроцессов(АдресаПеременных);
	//ГлЯдро_СобратьОбщуюСтруктуруПроизвольныхКодов(АдресаПеременных);
    //ГлЯдро_СобратьОбщуюСтруктуруГлобальныхПараметров(АдресаПеременных);
	
	Если НЕ СтруктураНастроек.Свойство("НастройкиБизнесПроцессов") ИЛИ СтруктураНастроек.НастройкиБизнесПроцессов = Ложь Тогда
		ГлЯдро_СобратьОбщуюСтруктуруБизнесПроцессов(АдресаПеременных);
		СтруктураНастроек.Вставить("НастройкиБизнесПроцессов", ГлЯдро_ПолучитьИзКэшаНастройкуSMARTS("НастройкиБизнесПроцессов",, АдресаПеременных));
	КонецЕсли;
	Если НЕ СтруктураНастроек.Свойство("ПроизвольныеКоды") ИЛИ СтруктураНастроек.ПроизвольныеКоды = Ложь Тогда
		ГлЯдро_СобратьОбщуюСтруктуруПроизвольныхКодов(АдресаПеременных);
		СтруктураНастроек.Вставить("ПроизвольныеКоды", ГлЯдро_ПолучитьИзКэшаНастройкуSMARTS("ПроизвольныеКоды",, АдресаПеременных));
	КонецЕсли;
	Если НЕ СтруктураНастроек.Свойство("ГлобальныеПараметры") ИЛИ СтруктураНастроек.ГлобальныеПараметры = Ложь Тогда
		ГлЯдро_СобратьОбщуюСтруктуруГлобальныхПараметров(АдресаПеременных);
		СтруктураНастроек.Вставить("ГлобальныеПараметры", ГлЯдро_ПолучитьИзКэшаНастройкуSMARTS("ГлобальныеПараметры",, АдресаПеременных));
	КонецЕсли;
	
	Возврат ДанныеДляИнициализации;
		
КонецФункции

Функция ГлЯдро_СобратьСтруктуруНастроекИзКэша(ID_Узла, АдресаПеременных)
	
	ПараметрыПодключенияMS = ГлЯдро_ПолучитьДанныеИзХранилища1С("Cleverence_ПараметрыПодключенияMS");
	
	ИдентификаторБазыMS = "";
	Если ТипЗнч(ПараметрыПодключенияMS) = Тип("Структура")
		И ПараметрыПодключенияMS.Свойство("Ид") Тогда
		ИдентификаторБазыMS = СтрЗаменить(ПараметрыПодключенияMS.Ид, "-", "_");
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(ИдентификаторБазыMS) Тогда
		Возврат ГлЯдро_ПолучитьТекущиеНастройкиНаСервереSMARTS(, ID_Узла, АдресаПеременных);
	КонецЕсли;
	
	ПолученыНастройкиИзНастроекПользователя = Истина;
	
	СтруктураНастроек = ГлЯдро_ПолучитьДанныеИзХранилища1С("Cleverence_КэшируемыеНастройки_" + ИдентификаторБазыMS + "_СтруктураНастроекSMARTS");
	Если НЕ ТипЗнч(СтруктураНастроек) = Тип("Структура") Тогда
		ПолученыНастройкиИзНастроекПользователя = Ложь;
	КонецЕсли;
	
	Если ПолученыНастройкиИзНастроекПользователя И ЗначениеЗаполнено(ID_Узла) Тогда
		СтруктураУзловыхНастроек = ГлЯдро_ПолучитьДанныеИзХранилища1С("Cleverence_КэшируемыеНастройки_" + ИдентификаторБазыMS + "_СтруктураНастроекSMARTS_" + ID_Узла);
		Если НЕ ТипЗнч(СтруктураУзловыхНастроек) = Тип("Структура") Тогда
			ПолученыНастройкиИзНастроекПользователя = Ложь;
		Иначе
			Для каждого УзловаяНастройка ИЗ СтруктураУзловыхНастроек Цикл
				СтруктураНастроек.Вставить(УзловаяНастройка.Ключ, УзловаяНастройка.Значение);
			КонецЦикла;	
		КонецЕсли;
	КонецЕсли;
	
	Если НЕ ПолученыНастройкиИзНастроекПользователя Тогда
		Возврат ГлЯдро_ПолучитьТекущиеНастройкиНаСервереSMARTS(, ID_Узла, АдресаПеременных);
	КонецЕсли;
	
	КэшируемыеНастройки = ГлЯдро_ПолучитьСтруктуруКэшируемыхНастроек();
	
	КатегорииНастроекMS = КомЯдро_ПолучитьЗначениеПеременной("КатегорииНастроекMS", АдресаПеременных);
	Если КатегорииНастроекMS = Неопределено Тогда
		КатегорииНастроекMS = ГлЯдро_ПолучитьКатегорииНастроекMS();		
	КонецЕсли;
	
	УзловыеНастройки = КатегорииНастроекMS.УзловыеНастройки;
	УзловыеНастройки.Добавить("НастройкиБизнесПроцессов");
	
	ПолученныеНастройки = Новый Массив;
	НастройкиССервера   = Новый Структура;
	Для каждого КэшируемаяНастройка ИЗ КэшируемыеНастройки Цикл
		ИмяНастройкиКлюч 	 = КэшируемаяНастройка.Ключ;
		ИмяНастройкиЗначение = КэшируемаяНастройка.Значение;
		
		КлючНастройки = "Cleverence_КэшируемыеНастройки_" + ИдентификаторБазыMS + "_" + ИмяНастройкиКлюч + ?(ЗначениеЗаполнено(ID_Узла) И УзловыеНастройки.Найти(ИмяНастройкиЗначение) <> Неопределено, "_" + ID_Узла, "");
		ЗначениеНастройки = ГлЯдро_ПолучитьДанныеИзХранилища1С(КлючНастройки);
		Если ЗначениеЗаполнено(ЗначениеНастройки) Тогда
			СтруктураНастроек.Вставить(ИмяНастройкиКлюч, ЗначениеНастройки);
			ПолученныеНастройки.Добавить(ИмяНастройкиКлюч);
		Иначе
			НастройкиССервера.Вставить(ИмяНастройкиКлюч, Ложь);
		КонецЕсли;
		
		Если ПолученныеНастройки.Найти(ИмяНастройкиЗначение) = Неопределено Тогда		
			КлючНастройки = "Cleverence_КэшируемыеНастройки_" + ИдентификаторБазыMS + "_" + ИмяНастройкиЗначение + ?(ЗначениеЗаполнено(ID_Узла) И УзловыеНастройки.Найти(ИмяНастройкиЗначение) <> Неопределено, "_" + ID_Узла, "");
			ЗначениеНастройки = ГлЯдро_ПолучитьДанныеИзХранилища1С(КлючНастройки);
			Если ЗначениеЗаполнено(ЗначениеНастройки) Тогда
				СтруктураНастроек.Вставить(ИмяНастройкиЗначение, ЗначениеНастройки);
				ПолученныеНастройки.Добавить(ИмяНастройкиЗначение);
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	ПустаяСтруктураНастроек = ГлЯдро_ПолучитьПустуюСтруктуруНастроекSMARTS(КатегорииНастроекMS.СериализуемыеНастройки);
	Для каждого Настройка ИЗ ПустаяСтруктураНастроек Цикл
		Если НЕ СтруктураНастроек.Свойство(Настройка.Ключ) И НЕ НастройкиССервера.Свойство(Настройка.Ключ) Тогда
			НастройкиССервера.Вставить(Настройка.Ключ, Ложь);
		КонецЕсли;
	КонецЦикла;
	
	Если НастройкиССервера.Количество() Тогда
		НастройкиССервера = ГлЯдро_ПолучитьТекущиеНастройкиНаСервереSMARTS(НастройкиССервера, ID_Узла, АдресаПеременных);
		Для каждого Настройка ИЗ НастройкиССервера Цикл
			СтруктураНастроек.Вставить(Настройка.Ключ, Настройка.Значение);
		КонецЦикла;
	КонецЕсли;
	
	Возврат СтруктураНастроек;
	
КонецФункции

Функция ГлЯдро_ПолучитьТекущиеНастройкиНаСервереSMARTS(СтруктураНастроек = Неопределено, ID_Узла, АдресаПеременных)
	
	ИмяСобытия 	  = "ГлЯдро_ПолучитьТекущиеНастройкиНаСервереSMARTS";
	НачалоСобытия = ТекущаяУниверсальнаяДатаВМиллисекундах();
	
	ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Начало",, АдресаПеременных);
	
	КатегорииНастроекMS = КомЯдро_ПолучитьЗначениеПеременной("КатегорииНастроекMS", АдресаПеременных);
	Если КатегорииНастроекMS = Неопределено Тогда
		КатегорииНастроекMS = ГлЯдро_ПолучитьКатегорииНастроекMS();
	КонецЕсли;
	
	Если СтруктураНастроек = Неопределено Тогда
		СтруктураНастроек = ГлЯдро_ПолучитьПустуюСтруктуруНастроекSMARTS(КатегорииНастроекMS.СериализуемыеНастройки);
	КонецЕсли;
	
	СтруктураНастроек = ГлЯдро_ПолучитьНастройкиНаСервереSMARTS(СтруктураНастроек, КатегорииНастроекMS.УзловыеНастройки, ID_Узла, АдресаПеременных);
	
	ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Конец", НачалоСобытия, АдресаПеременных);
	
	Возврат СтруктураНастроек;
	
КонецФункции

// Возвращает структуру, ключами которой являются категории настроек Mobile Smarts,
// а значениями - массивы имен настроек.
//
// Возвращаемое значение:
//	Структура - содержит:	
//		* СериализуемыеНастройки - Массив из Строка
//      * УзловыеНастройки - Массив из Строка
//      * НастройкиПодключения - Массив из Строка
//      * НастройкиСправочников - Массив из Строка
//      * НастройкиНоменклатуры - Массив из Строка
Функция ГлЯдро_ПолучитьКатегорииНастроекMS() Экспорт
	
	СериализуемыеНастройки = Новый Массив;
	СериализуемыеНастройки.Добавить("НастройкиБизнесПроцессов_ПоУмолчанию");
	СериализуемыеНастройки.Добавить("НастройкиБизнесПроцессов_Пользовательские");
	СериализуемыеНастройки.Добавить("НастройкиБизнесПроцессов_ПользовательскиеНастройки");
	СериализуемыеНастройки.Добавить("НастройкиОбменаСправочников");
	СериализуемыеНастройки.Добавить("НастройкиОтборовУзлов_Онлайн");
	СериализуемыеНастройки.Добавить("НастройкиОтборовУзлов_Интерактивный");
	СериализуемыеНастройки.Добавить("НастройкиОтборовУзлов_Автообмен");	
	СериализуемыеНастройки.Добавить("Пользователи");
	СериализуемыеНастройки.Добавить("ПользователиТСД");
	СериализуемыеНастройки.Добавить("ГлобальныеПараметры");
	СериализуемыеНастройки.Добавить("ГлобальныеПараметры_ПоУмолчанию");
	СериализуемыеНастройки.Добавить("ГлобальныеПараметры_Пользовательские");
	СериализуемыеНастройки.Добавить("Узлы");
	СериализуемыеНастройки.Добавить("ЗначенияПараметровУзлов");
	СериализуемыеНастройки.Добавить("ГлобальныеПараметры_Значения");
	СериализуемыеНастройки.Добавить("ПроизвольныеКоды_ПоУмолчанию");
	СериализуемыеНастройки.Добавить("ПроизвольныеКоды_Пользовательские");
	СериализуемыеНастройки.Добавить("ПроизвольныеОтборыДокументов");
	СериализуемыеНастройки.Добавить("ФормаОбменаВыбранныеКолонки");
	СериализуемыеНастройки.Добавить("ФормаОбменаВыбранныеКолонкиSMARTS");
	СериализуемыеНастройки.Добавить("НастройкиТаймаутов");
	СериализуемыеНастройки.Добавить("НастройкиРазмеровПорцийДанных");
	СериализуемыеНастройки.Добавить("НастройкиПечатиЭтикеток");
	
	УзловыеНастройки = Новый Массив;
	УзловыеНастройки.Добавить("НастройкиОбменаСправочников");
	УзловыеНастройки.Добавить("НастройкиОтборовУзлов_Онлайн");
	УзловыеНастройки.Добавить("НастройкиОтборовУзлов_Интерактивный");
	УзловыеНастройки.Добавить("НастройкиОтборовУзлов_Автообмен");
	УзловыеНастройки.Добавить("Пользователи");
	УзловыеНастройки.Добавить("ПользователиТСД");
	УзловыеНастройки.Добавить("ЗначенияПараметровУзлов");
	УзловыеНастройки.Добавить("ГлобальныеПараметры_Значения");
	УзловыеНастройки.Добавить("НастройкиБизнесПроцессов_ПользовательскиеНастройки");
	УзловыеНастройки.Добавить("ФормаОбменаВыбранныеКолонки");
	УзловыеНастройки.Добавить("ФормаОбменаВыбранныеКолонкиSMARTS");
	
	// Пользовательские настройки бизнес-процессов, доступные для редактирования только из главного узла
	ПользовательскиеНастройкиГлавногоУзла = Новый Массив;
	ПользовательскиеНастройкиГлавногоУзла.Добавить("НастройкаПредставленийРеквизитовДокумента");
	ПользовательскиеНастройкиГлавногоУзла.Добавить("ЗаменитьПредставлениеДокументаПриВыгрузке");
	
	НастройкиПодключения = Новый Массив;
	НастройкиПодключения.Добавить("Ид");
	НастройкиПодключения.Добавить("Имя");
	НастройкиПодключения.Добавить("ИдПриложения");
	НастройкиПодключения.Добавить("ИдОсновногоПриложения");
	НастройкиПодключения.Добавить("ИмяПриложения");
	НастройкиПодключения.Добавить("УровеньПриложения");
	НастройкиПодключения.Добавить("СтрокаПодключения");
	НастройкиПодключения.Добавить("РабочийКаталог"); 
	НастройкиПодключения.Добавить("ИмяИнтеграционнойОбработки");
	НастройкиПодключения.Добавить("ПутьИнтеграционнойОбработки");
	НастройкиПодключения.Добавить("ПодключеннаяБазаИмяКонфигурации1С");
	НастройкиПодключения.Добавить("ПодключеннаяБазаСинонимКонфигурации1С");
	НастройкиПодключения.Добавить("ПодключеннаяБазаСтрокаСоединения");
	НастройкиПодключения.Добавить("ПодключеннаяБазаВерсияПлатформы1С");
	НастройкиПодключения.Добавить("ПодключеннаяБазаВерсияКонфигурации1С");	
	НастройкиПодключения.Добавить("База1СПодключенаДата");
	
	НастройкиСправочников = Новый Массив;
	НастройкиСправочников.Добавить("ВыгружатьНоменклатуруСразу");
	НастройкиСправочников.Добавить("ВыгружатьКонтрагентовСразу");
	НастройкиСправочников.Добавить("ВыгружатьОстаткиСразу");
	НастройкиСправочников.Добавить("ВыгружатьСерииСразу");
	НастройкиСправочников.Добавить("ВыгружатьСкладыСразу");
	НастройкиСправочников.Добавить("ВыгружатьФормыАСразу");
	НастройкиСправочников.Добавить("ВыгружатьХарактеристикиСразу");
	НастройкиСправочников.Добавить("ВыгружатьЦеныСразу");
	НастройкиСправочников.Добавить("ВыгружатьАкцизныеМаркиСразу");
	НастройкиСправочников.Добавить("ВыгружатьКоробкиСразу");
	НастройкиСправочников.Добавить("ВыгружатьЯчейкиСразу");
	НастройкиСправочников.Добавить("ВыгружатьОстаткиПоЯчейкамСразу");
	НастройкиСправочников.Добавить("ВыгружатьДополнительнуюИнформациюСразу");
	НастройкиСправочников.Добавить("ВыгружатьКИЗСразу");
	НастройкиСправочников.Добавить("ВыгружатьТранспортныеУпаковкиСразу");
	
	НастройкиНоменклатуры = Новый Массив;
	НастройкиНоменклатуры.Добавить("ИспользоватьШаблоныВесовогоТовара");
	НастройкиНоменклатуры.Добавить("ПрефиксКодаВесовогоТовара");
	НастройкиНоменклатуры.Добавить("ДлинаКодаВесовогоТовара");
	НастройкиНоменклатуры.Добавить("ЧислоЗнаковПослеЗапятойВесТовара");
	НастройкиНоменклатуры.Добавить("ПрефиксВключенВКодВесовогоТовара");
	НастройкиНоменклатуры.Добавить("РазмерПорцииНоменклатуры");	
	НастройкиНоменклатуры.Добавить("МобильнаяПечать");
	НастройкиНоменклатуры.Добавить("ПереписыватьНоменклатуруПриВыгрузке");
	НастройкиНоменклатуры.Добавить("УстановитьПоискПоНаименованиюИАртикулу");
	
	// Категории настроек
	МетаНастройки = Новый Структура;
	МетаНастройки.Вставить("СериализуемыеНастройки", СериализуемыеНастройки);
	МетаНастройки.Вставить("УзловыеНастройки",       УзловыеНастройки);
	МетаНастройки.Вставить("НастройкиПодключения",   НастройкиПодключения);
	МетаНастройки.Вставить("НастройкиСправочников",  НастройкиСправочников);
	МетаНастройки.Вставить("НастройкиНоменклатуры",  НастройкиНоменклатуры);
	МетаНастройки.Вставить("ПользовательскиеНастройкиГлавногоУзла", ПользовательскиеНастройкиГлавногоУзла);
	
	Возврат МетаНастройки;
	
КонецФункции

// Вовращает пустую структуру настроек Mobile Smarts
//
// Параметры:
//	СериализуемыеНастройки - Неопределено, Массив из Строка - см. ГлЯдро_ПолучитьКатегорииНастроекMS
//
// Возвращаемое значение:
//	Структура - содержит:	
//		* ИспользоватьШаблоныВесовогоТовара - Булево
//      * ПрефиксКодаВесовогоТовара - Булево
//		* ДлинаКодаВесовогоТовара - Булево
//		* ЧислоЗнаковПослеЗапятойВесТовара - Булево
//		* ПрефиксВключенВКодВесовогоТовара - Булево
//		* РазмерПорцииНоменклатуры - Булево
//		* ВыгружатьНоменклатуруДокументаПередВыгрузкойДокумента - Булево
//      * УстановитьПоискПоНаименованиюИАртикулу - Булево
//      * ВыгружатьНоменклатуруСразу - Булево
//      * ВыгружатьКонтрагентовСразу - Булево
//      * ВыгружатьОстаткиСразу - Булево
//      * ВыгружатьСерииСразу - Булево
//      * ВыгружатьСкладыСразу - Булево
//      * ВыгружатьФормыАСразу - Булево
//      * ВыгружатьХарактеристикиСразу - Булево
//      * ВыгружатьЦеныСразу - Булево
//      * ВыгружатьАкцизныеМаркиСразу - Булево
//      * ВыгружатьКоробкиСразу - Булево
//      * ВыгружатьОстаткиПоЯчейкамСразу - Булево
//      * ВыгружатьЯчейкиСразу - Булево
//      * МобильнаяПечать - Булево
//      * ПереписыватьНоменклатуруПриВыгрузке - Булево
//      * ПодключеннаяБазаИмяКонфигурации1С - Булево
//      * ПодключеннаяБазаСинонимКонфигурации1С - Булево
//      * ПодключеннаяБазаСтрокаСоединения - Булево
//      * ПодключеннаяБазаВерсияПлатформы1С - Булево
//      * ПодключеннаяБазаВерсияКонфигурации1С - Булево
//      * Ид - Булево
//      * ИдПриложения - Булево
//      * ИдОсновногоПриложения - Булево
//      * ИмяПриложения - Булево
//      * УровеньПриложения - Булево
//      * ID_ТекущегоУзла - Булево
//      * РежимОтладки - Булево
//      * РаботаБезАлкоголя - Булево
//      * УровеньПриложенияСтрокой - Булево
//      * ТипУстановленногоПродукта - Булево
//      * АвторизацияВключена - Булево
//      * АвторизацияЛогин - Булево
//      * АвторизацияТокен - Булево
//		* АвторизацияРефрешТокен - Булево
//      * СериализуемыеНастройки - Массив из Строка
Функция ГлЯдро_ПолучитьПустуюСтруктуруНастроекSMARTS(СериализуемыеНастройки = Неопределено) Экспорт
	
	СтруктураНастроекSMARTS = Новый Структура;
	
	СтруктураНастроекSMARTS.Вставить("ИспользоватьШаблоныВесовогоТовара", Ложь);
	СтруктураНастроекSMARTS.Вставить("ПрефиксКодаВесовогоТовара",         Ложь);
	СтруктураНастроекSMARTS.Вставить("ДлинаКодаВесовогоТовара",           Ложь);
	СтруктураНастроекSMARTS.Вставить("ЧислоЗнаковПослеЗапятойВесТовара",  Ложь);
	СтруктураНастроекSMARTS.Вставить("ПрефиксВключенВКодВесовогоТовара",  Ложь);
	СтруктураНастроекSMARTS.Вставить("РазмерПорцииНоменклатуры",  		  Ложь);
	СтруктураНастроекSMARTS.Вставить("ВыгружатьНоменклатуруДокументаПередВыгрузкойДокумента",Ложь);
	СтруктураНастроекSMARTS.Вставить("УстановитьПоискПоНаименованиюИАртикулу",Ложь);
	
	СтруктураНастроекSMARTS.Вставить("ВыгружатьНоменклатуруСразу",   	Ложь);
	СтруктураНастроекSMARTS.Вставить("ВыгружатьКонтрагентовСразу",   	Ложь);
	СтруктураНастроекSMARTS.Вставить("ВыгружатьОстаткиСразу",        	Ложь);
	СтруктураНастроекSMARTS.Вставить("ВыгружатьСерииСразу",          	Ложь);
	СтруктураНастроекSMARTS.Вставить("ВыгружатьСкладыСразу",         	Ложь);
	СтруктураНастроекSMARTS.Вставить("ВыгружатьФормыАСразу",         	Ложь);
	СтруктураНастроекSMARTS.Вставить("ВыгружатьХарактеристикиСразу", 	Ложь);
	СтруктураНастроекSMARTS.Вставить("ВыгружатьЦеныСразу",           	Ложь);
	СтруктураНастроекSMARTS.Вставить("ВыгружатьАкцизныеМаркиСразу",  	Ложь);
	СтруктураНастроекSMARTS.Вставить("ВыгружатьКоробкиСразу",        	Ложь);	
	СтруктураНастроекSMARTS.Вставить("ВыгружатьОстаткиПоЯчейкамСразу",	Ложь);
	СтруктураНастроекSMARTS.Вставить("ВыгружатьЯчейкиСразу",			Ложь);
	СтруктураНастроекSMARTS.Вставить("ВыгружатьДополнительнуюИнформациюСразу",Ложь);
	СтруктураНастроекSMARTS.Вставить("ВыгружатьКИЗСразу",				Ложь);
	СтруктураНастроекSMARTS.Вставить("ВыгружатьТранспортныеУпаковкиСразу",Ложь);
		
	СтруктураНастроекSMARTS.Вставить("МобильнаяПечать",                     Ложь);
	СтруктураНастроекSMARTS.Вставить("ПереписыватьНоменклатуруПриВыгрузке", Ложь);
	
	СтруктураНастроекSMARTS.Вставить("ПодключеннаяБазаИмяКонфигурации1С",     Ложь);
	СтруктураНастроекSMARTS.Вставить("ПодключеннаяБазаСинонимКонфигурации1С", Ложь);
	СтруктураНастроекSMARTS.Вставить("ПодключеннаяБазаСтрокаСоединения",      Ложь);
	СтруктураНастроекSMARTS.Вставить("ПодключеннаяБазаВерсияПлатформы1С",     Ложь);
	СтруктураНастроекSMARTS.Вставить("ПодключеннаяБазаВерсияКонфигурации1С",  Ложь);
	СтруктураНастроекSMARTS.Вставить("Ид",                                    Ложь);
	СтруктураНастроекSMARTS.Вставить("ИдПриложения",                          Ложь);
	СтруктураНастроекSMARTS.Вставить("ИдОсновногоПриложения",                 Ложь);
	СтруктураНастроекSMARTS.Вставить("ИмяПриложения",                         Ложь);
	СтруктураНастроекSMARTS.Вставить("УровеньПриложения",                     Ложь);
	СтруктураНастроекSMARTS.Вставить("РежимОтладки", 						  Ложь);
	СтруктураНастроекSMARTS.Вставить("РаботаБезАлкоголя", 					  Ложь);
	СтруктураНастроекSMARTS.Вставить("УровеньПриложенияСтрокой",			  Ложь);
	СтруктураНастроекSMARTS.Вставить("ТипУстановленногоПродукта",			  Ложь);
	СтруктураНастроекSMARTS.Вставить("АвторизацияВключена", 				  Ложь);
	СтруктураНастроекSMARTS.Вставить("АвторизацияЛогин",	 				  Ложь);
	СтруктураНастроекSMARTS.Вставить("АвторизацияТокен", 					  Ложь);
	СтруктураНастроекSMARTS.Вставить("АвторизацияРефрешТокен",				  Ложь);
	СтруктураНастроекSMARTS.Вставить("База1СПодключенаДата",				  Ложь);
	СтруктураНастроекSMARTS.Вставить("OneCProcessingFileName", 				  Ложь);
	СтруктураНастроекSMARTS.Вставить("ОтключитьРаботуВФоне", 				  Ложь);
	
	СтруктураНастроекSMARTS.Вставить("InternetGateOption", 					  Ложь);
	
	СтруктураИменРасширений = ГлЯдро_ПолучитьСтруктуруИменРасширений();
	Для каждого ЭлементСтруктуры Из СтруктураИменРасширений Цикл
		ИмяНастройки 			= "ВерсияРасширения_" + ЭлементСтруктуры.Значение;
		ИмяНастройкиПоУмолчанию = "ВерсияРасширения_" + ЭлементСтруктуры.Значение + "_ПоУмолчанию";
		СтруктураНастроекSMARTS.Вставить(ИмяНастройки, 				"0.0.0.0");
		СтруктураНастроекSMARTS.Вставить(ИмяНастройкиПоУмолчанию, 	"0.0.0.0");		
	КонецЦикла;
	
	СтруктураНастроекSMARTS.Вставить("ВерсияОбработки_ОсновнаяОбработка",					"0.0.0.0");
	СтруктураНастроекSMARTS.Вставить("ВерсияОбработки_ОсновнаяОбработка_ПоУмолчанию", 		"0.0.0.0");
	СтруктураНастроекSMARTS.Вставить("ВерсияОбработки_ИнтеграционнаяОбработка",				"0.0.0.0");
	СтруктураНастроекSMARTS.Вставить("ВерсияОбработки_ИнтеграционнаяОбработка_ПоУмолчанию", "0.0.0.0");

	СтруктураНастроекSMARTS.Вставить("ВерсияПриложения", 							Ложь);
	СтруктураНастроекSMARTS.Вставить("ВерсияПриложения_ОсновнаяОбработка", 			Ложь);
	СтруктураНастроекSMARTS.Вставить("ВерсияПриложения_ИнтеграционнаяОбработка", 	Ложь);
	
	СтруктураНастроекSMARTS.Вставить("ВерсияОбработкиНастроек", 					Ложь);
	СтруктураНастроекSMARTS.Вставить("ВерсияОбработкиКлеверенсТСД", 				Ложь);
	СтруктураНастроекSMARTS.Вставить("ВерсияГлобальныеПараметры",					Ложь);
	
	Если СериализуемыеНастройки = Неопределено Тогда
		МетаНастройки = ГлЯдро_ПолучитьКатегорииНастроекMS();
		СериализуемыеНастройки = МетаНастройки.СериализуемыеНастройки;
	КонецЕсли;
	
	Для Каждого ИмяНастройки Из СериализуемыеНастройки Цикл
		СтруктураНастроекSMARTS.Вставить(ИмяНастройки, Ложь);
	КонецЦикла;
	
	Возврат  СтруктураНастроекSMARTS;
	
КонецФункции

Функция ГлЯдро_ПолучитьМетаданныеДокументов1С()
	
	ИменаКонтрагентов = Новый Массив;
	ИменаКонтрагентов.Добавить("Контрагент");
	
	ИменаСкладов = Новый Массив;
	ИменаСкладов.Добавить("Помещение");
	ИменаСкладов.Добавить("СтруктурнаяЕдиница");
	ИменаСкладов.Добавить("Склад");
	ИменаСкладов.Добавить("СкладОрдер");
	ИменаСкладов.Добавить("СкладОтправитель");
	ИменаСкладов.Добавить("СтруктурнаяЕдиницаПродажи");
	
	ИменаСкладовКуда = Новый Массив;
	ИменаСкладовКуда.Добавить("СтруктурнаяЕдиницаПолучатель");
	ИменаСкладовКуда.Добавить("СкладПолучатель");	
		
	СтруктураМетаданных1С = Новый Структура;
	
	КэшСоставаОбщихРеквизитов = Новый Массив;
	Для Каждого МетаРеквизит Из Метаданные.ОбщиеРеквизиты Цикл
		Если Лев(МетаРеквизит.Имя, 7) <> "Удалить" Тогда 
			КэшСоставаОбщихРеквизитов.Добавить(Новый Структура("Реквизит, Состав",МетаРеквизит, МетаРеквизит.Состав));
		КонецЕсли;
	КонецЦикла;
	
	Для Каждого МетаДокумент Из Метаданные.Документы Цикл
		
		СтруктураДокумента = Новый Структура("Синоним,Реквизиты,ТабличныеЧасти",,, Новый Структура("Синоним,Реквизиты",, Новый СписокЗначений));
		СтруктураДокумента.Вставить("Имя", МетаДокумент.Имя);
		СтруктураДокумента.Вставить("Синоним", МетаДокумент.Синоним);
		
		СписокРеквизитов = Новый СписокЗначений;
		
		Для Каждого МетаРеквизит Из МетаДокумент.Реквизиты Цикл
			Если Лев(МетаРеквизит.Имя, 7) <> "Удалить" Тогда
				СписокРеквизитов.Добавить(МетаРеквизит.Имя, МетаРеквизит.Синоним, ГлЯдро_СложныеТипыОтсутствуют(МетаРеквизит.Тип));
			КонецЕсли;
		КонецЦикла;
				
		Для Каждого Структура Из КэшСоставаОбщихРеквизитов Цикл
			Если Структура.Состав.Содержит(МетаДокумент) Тогда
				МетаРеквизит = Структура.Реквизит;
				СписокРеквизитов.Добавить(МетаРеквизит.Имя, МетаРеквизит.Синоним, ГлЯдро_СложныеТипыОтсутствуют(МетаРеквизит.Тип));		
			КонецЕсли;
		КонецЦикла;
		
		СписокРеквизитов.СортироватьПоПредставлению();
		
		Если МетаДокумент.ДлинаНомера <> 0 Тогда
			СписокРеквизитов.Вставить(0, "Номер", "Номер", Истина);							
		КонецЕсли;		
				
		СписокРеквизитов.Вставить(0, "Дата", "Дата", Истина);
		СписокРеквизитов.Вставить(0, "Ссылка", "Ссылка", Ложь);
		СтруктураДокумента.Вставить("Реквизиты", СписокРеквизитов);
		СтруктураДокумента.Вставить("ТабличныеЧасти", Новый Структура);
		
		Для Каждого МетаТЧ Из МетаДокумент.ТабличныеЧасти Цикл
			СписокРеквизитов = Новый СписокЗначений;
			СписокРеквизитов.Добавить("НомерСтроки", "Номер строки", Истина);
			Для Каждого МетаРеквизит Из МетаТЧ.Реквизиты Цикл
				Если Лев(МетаРеквизит.Имя, 7) <> "Удалить" Тогда
					СписокРеквизитов.Добавить(МетаРеквизит.Имя, МетаРеквизит.Синоним, ГлЯдро_СложныеТипыОтсутствуют(МетаРеквизит.Тип));
				КонецЕсли;
			КонецЦикла;
			СписокРеквизитов.СортироватьПоПредставлению();
			СтруктураДокумента.ТабличныеЧасти.Вставить(МетаТЧ.Имя, Новый Структура("Имя,Синоним,Реквизиты", МетаТЧ.Имя, МетаТЧ.Синоним, СписокРеквизитов));
		КонецЦикла;
		
		ИменаРеквизитовШапки = Новый Структура;
		
		Для каждого ИмяКонтрагента Из ИменаКонтрагентов Цикл
			Если МетаДокумент.Реквизиты.Найти(ИмяКонтрагента) <> Неопределено Тогда			
				ИменаРеквизитовШапки.Вставить("ИмяКонтрагента", ИмяКонтрагента);							
				Прервать;
			КонецЕсли; 					
		КонецЦикла; 
		
		Для каждого ИмяСклада Из ИменаСкладов Цикл
			Если МетаДокумент.Реквизиты.Найти(ИмяСклада) <> Неопределено Тогда			
				ИменаРеквизитовШапки.Вставить("ИмяСклада", ИмяСклада);							
				Прервать;
			КонецЕсли; 					
		КонецЦикла; 		
		
		Для каждого ИмяСкладаКуда Из ИменаСкладовКуда Цикл
			Если МетаДокумент.Реквизиты.Найти(ИмяСкладаКуда) <> Неопределено Тогда			
				ИменаРеквизитовШапки.Вставить("ИмяСкладаКуда", ИмяСкладаКуда);							
				Прервать;
			КонецЕсли; 					
		КонецЦикла; 			
		
		СтруктураДокумента.Вставить("ИменаРеквизитовШапки", ИменаРеквизитовШапки);
		
		СтруктураМетаданных1С.Вставить(МетаДокумент.Имя, СтруктураДокумента);
		
	КонецЦикла;
	
	Возврат СтруктураМетаданных1С;
	
КонецФункции

Функция ГлЯдро_СформироватьМетаданныеНастроекMS()

	СтруктураМетаданныхНастроекMS = Новый Структура;
	
	// Обмен справочниками
	ШаблонНастроек = Новый Структура;
	ШаблонНастроек.Вставить("ИмяТаблицы",                   Новый ОписаниеТипов("Строка",,,, Новый КвалификаторыСтроки(50)));
	ШаблонНастроек.Вставить("НастройкаКомпоновщикаСтрокой", Новый ОписаниеТипов("Строка",,,, Новый КвалификаторыСтроки(0)));
	СтруктураМетаданныхНастроекMS.Вставить("НастройкиОбменаСправочников", ШаблонНастроек);
	
	// Обмен документами
	ШаблонНастроек = Новый Структура;
	ШаблонНастроек.Вставить("ID_БизнесПроцесса",               	Новый ОписаниеТипов("Строка",,,, Новый КвалификаторыСтроки(40)));
	ШаблонНастроек.Вставить("Название",                        	Новый ОписаниеТипов("Строка",,,, Новый КвалификаторыСтроки(100)));
	ШаблонНастроек.Вставить("ТипИсходногоДокумента1С",         	Новый ОписаниеТипов("Строка",,,, Новый КвалификаторыСтроки(200)));
	ШаблонНастроек.Вставить("ТипИсходногоДокумента1С_Синоним", 	Новый ОписаниеТипов("Строка",,,, Новый КвалификаторыСтроки(200)));
	ШаблонНастроек.Вставить("НастройкаКомпоновщикаСтрокой",    	Новый ОписаниеТипов("Строка",,,, Новый КвалификаторыСтроки(0)));
	ШаблонНастроек.Вставить("Используется", 					Новый ОписаниеТипов("Булево"));	
	ШаблонНастроек.Вставить("ВариантОтбора",    				Новый ОписаниеТипов("Строка",,,, Новый КвалификаторыСтроки(0)));
	ШаблонНастроек.Вставить("ID_ПроизвольногоОтбора",   	 	Новый ОписаниеТипов("Строка",,,, Новый КвалификаторыСтроки(0)));	
	СтруктураМетаданныхНастроекMS.Вставить("НастройкиОтборовУзлов_Онлайн",        ШаблонНастроек);
	СтруктураМетаданныхНастроекMS.Вставить("НастройкиОтборовУзлов_Интерактивный", ШаблонНастроек);
	СтруктураМетаданныхНастроекMS.Вставить("НастройкиОтборовУзлов_Автообмен",     ШаблонНастроек);
	
	// Бизнес-процессы
	ШаблонНастроек = Новый Структура;
	ШаблонНастроек.Вставить("ID_БизнесПроцесса",                    	Новый ОписаниеТипов("Строка",,,, Новый КвалификаторыСтроки(40)));
	ШаблонНастроек.Вставить("Используется",                         	Новый ОписаниеТипов("Булево"));
	ШаблонНастроек.Вставить("ЭтоТиповойБизнесПроцесс",              	Новый ОписаниеТипов("Булево"));
	ШаблонНастроек.Вставить("Название",                             	Новый ОписаниеТипов("Строка",,,, Новый КвалификаторыСтроки(255)));
	ШаблонНастроек.Вставить("ТипИсходногоДокумента1С",              	Новый ОписаниеТипов("Строка",,,, Новый КвалификаторыСтроки(255)));
	ШаблонНастроек.Вставить("ТипРезультирующегоДокумента1С",        	Новый ОписаниеТипов("Строка",,,, Новый КвалификаторыСтроки(255)));
	ШаблонНастроек.Вставить("ТипДокументаMS",                       	Новый ОписаниеТипов("Строка",,,, Новый КвалификаторыСтроки(100)));
	ШаблонНастроек.Вставить("ЗагружатьВТотЖе",                      	Новый ОписаниеТипов("Булево"));
	ШаблонНастроек.Вставить("КонтрольКоличества",                   	Новый ОписаниеТипов("Булево"));
	ШаблонНастроек.Вставить("КоллективнаяРабота",                   	Новый ОписаниеТипов("Булево"));
	ШаблонНастроек.Вставить("СоздаватьНовыйДокументПриЗагрузке",    	Новый ОписаниеТипов("Булево"));
	ШаблонНастроек.Вставить("ПроводитьДокументПослеЗагрузки",       	Новый ОписаниеТипов("Булево"));	
	ШаблонНастроек.Вставить("ИмяТЧ1СИсходного",                     	Новый ОписаниеТипов("Строка",,,, Новый КвалификаторыСтроки(100)));
	ШаблонНастроек.Вставить("Комментарий",                          	Новый ОписаниеТипов("Строка",,,, Новый КвалификаторыСтроки(0)));
	ШаблонНастроек.Вставить("НазначитьПользователю",                	Новый ОписаниеТипов("Строка",,,, Новый КвалификаторыСтроки(0)));
	ШаблонНастроек.Вставить("ТекстЗапросаВыгрузкиНаТСД",            	Новый ОписаниеТипов("Строка",,,, Новый КвалификаторыСтроки(0)));
	ШаблонНастроек.Вставить("Обработчик_ПередЗаполнениемДокумента", 	Новый ОписаниеТипов("Строка",,,, Новый КвалификаторыСтроки(200)));
	ШаблонНастроек.Вставить("Обработчик_ПослеЗаполненияДокумента",  	Новый ОписаниеТипов("Строка",,,, Новый КвалификаторыСтроки(200)));
	ШаблонНастроек.Вставить("Обработчик_ПослеОткрытияФормыДокумента",  	Новый ОписаниеТипов("Строка",,,, Новый КвалификаторыСтроки(200)));
	ШаблонНастроек.Вставить("НастройкаВыгрузкиПолейМассивСтруктур", 	Новый Массив);
	ШаблонНастроек.Вставить("НастройкаВыгрузкиТЧМассивСтруктур",		Новый Массив);
	ШаблонНастроек.Вставить("НастройкаЗагрузкиПолейМассивСтруктур", 	Новый Массив);
	ШаблонНастроек.Вставить("НастройкаЗагрузкиТЧМассивСтруктур",    	Новый Массив);
	ШаблонНастроек.Вставить("КопияДокументаДляКаждогоПользователя",		Новый ОписаниеТипов("Булево"));
	ШаблонНастроек.Вставить("ВыполнитьТолькоПроизвольныйКод",			Новый ОписаниеТипов("Булево"));
	ШаблонНастроек.Вставить("ID_ПроизвольногоКода_Выгрузка_Документ",   Новый ОписаниеТипов("Строка",,,, Новый КвалификаторыСтроки(40)));
	ШаблонНастроек.Вставить("ID_ПроизвольногоКода_Загрузка_Документ",   Новый ОписаниеТипов("Строка",,,, Новый КвалификаторыСтроки(40)));
	ШаблонНастроек.Вставить("ТипОбработчикаВыгрузки",   				Новый ОписаниеТипов("Число"));
	ШаблонНастроек.Вставить("ТипОбработчикаЗагрузки",   				Новый ОписаниеТипов("Число"));
	ШаблонНастроек.Вставить("НастройкаПоследовательностиБПМассивСтруктур",		Новый Массив);
	ШаблонНастроек.Вставить("ПрерыватьПоследовательностьПриКритическойОшибке",  Новый ОписаниеТипов("Булево"));
	СтруктураМетаданныхНастроекMS.Вставить("НастройкиБизнесПроцессов", 	ШаблонНастроек);
	
	// Узлы
	ШаблонНастроек = Новый Структура;
	ШаблонНастроек.Вставить("ID_Узла",                 Новый ОписаниеТипов("Строка",,,, Новый КвалификаторыСтроки(40)));
	ШаблонНастроек.Вставить("Наименование",            Новый ОписаниеТипов("Строка",,,, Новый КвалификаторыСтроки(100)));
	ШаблонНастроек.Вставить("ИспользоватьЧастнуюБазу", Новый ОписаниеТипов("Булево"));
	ШаблонНастроек.Вставить("ЧастнаяБазаMS",           Новый ОписаниеТипов("Строка",,,, Новый КвалификаторыСтроки(40)));
	ШаблонНастроек.Вставить("Комментарий",             Новый ОписаниеТипов("Строка",,,, Новый КвалификаторыСтроки(0)));
	СтруктураМетаданныхНастроекMS.Вставить("Узлы", ШаблонНастроек);
	
	// ПроизвольныеКоды
	ШаблонНастроек = Новый Структура;
	ШаблонНастроек.Вставить("ID_ПроизвольногоКода",   Новый ОписаниеТипов("Строка",,,, Новый КвалификаторыСтроки(40)));
	ШаблонНастроек.Вставить("Наименование",           Новый ОписаниеТипов("Строка",,,, Новый КвалификаторыСтроки(100)));
	ШаблонНастроек.Вставить("Описание",               Новый ОписаниеТипов("Строка",,,, Новый КвалификаторыСтроки(0)));
	ШаблонНастроек.Вставить("ТекстПроизвольногоКода", Новый ОписаниеТипов("Строка",,,, Новый КвалификаторыСтроки(0)));
	ШаблонНастроек.Вставить("Направление",            Новый ОписаниеТипов("Строка",,,, Новый КвалификаторыСтроки(0)));
	ШаблонНастроек.Вставить("ТипОбъекта",			  Новый ОписаниеТипов("Строка",,,, Новый КвалификаторыСтроки(0)));	

	СтруктураМетаданныхНастроекMS.Вставить("ПроизвольныеКоды_ПоУмолчанию",ШаблонНастроек);
	СтруктураМетаданныхНастроекMS.Вставить("ПроизвольныеКоды_Пользовательские",ШаблонНастроек);
	
	// ПроизвольныеОтборыДокументов
	ШаблонНастроек = Новый Структура;
	ШаблонНастроек.Вставить("ID_ПроизвольногоОтбора", 	Новый ОписаниеТипов("Строка",,,, Новый КвалификаторыСтроки(40)));
	ШаблонНастроек.Вставить("Наименование",           	Новый ОписаниеТипов("Строка",,,, Новый КвалификаторыСтроки(100)));
	ШаблонНастроек.Вставить("Описание",               	Новый ОписаниеТипов("Строка",,,, Новый КвалификаторыСтроки(0)));
	ШаблонНастроек.Вставить("ТекстПроизвольногоОтбора", Новый ОписаниеТипов("Строка",,,, Новый КвалификаторыСтроки(0)));	
	СтруктураМетаданныхНастроекMS.Вставить("ПроизвольныеОтборыДокументов", ШаблонНастроек);
	
	// Настройки печати этикеток
	ШаблонНастроек = Новый Структура;
	ШаблонНастроек.Вставить("ИмяТаблицы",              					Новый ОписаниеТипов("Строка",,,, Новый КвалификаторыСтроки(50)));
	ШаблонНастроек.Вставить("ШаблонЭтикетки",                         	Новый ОписаниеТипов("Строка",,,, Новый КвалификаторыСтроки(100)));
	ШаблонНастроек.Вставить("ВстроенныйМакет",                         	Новый ОписаниеТипов("Булево"));
	ШаблонНастроек.Вставить("НастройкаПечатиМассивСтруктур", 			Новый Массив);
	СтруктураМетаданныхНастроекMS.Вставить("НастройкиПечатиЭтикеток", 	ШаблонНастроек);
	
	Возврат СтруктураМетаданныхНастроекMS;
	
КонецФункции

// Выполняет подключение интеграционной обработки и помещает ее структуру во временное хранилище
//
// Параметры:
//	ПолныйПутьКИнтеграционнойОбработке - Неопределено, Строка - адрес временного хранилища
//  ПутьКФайлу - Строка - путь к файлу интеграционной обработки
//  ПараметрыПодключенияMS - Неопределено, Структура - структура, ключами которой являются имена настроек подключения
//										 			   Mobile Smarts, значениями - значения соответствующих настроек
//  ТипОбработки - Неопределено, Строка - тип подключаемой интеграционной обработки ("ФайлНаДиске", "СправочникСсылка", "Встроенная")
//  АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
//
// Возвращаемое значение:
//	Строка - адрес структуры подключенной интеграционной обработки во временном хранилище
//         - описание ошибки, если подключить интеграционную обработку не удалось
Функция ГлЯдро_ПодключитьИнтеграционнуюОбработку(ПолныйПутьКИнтеграционнойОбработке = Неопределено,ПутьКФайлу = "",ПараметрыПодключенияMS=Неопределено,ТипОбработки = Неопределено,АдресаПеременных) Экспорт 
		
	ФайлИнтеграционнойОбработкиСуществует = Ложь;
	ИнтеграционнаяОбработка = Неопределено;
	ИмяИнтеграционнойОбработки = "";
	ИмяСобытия = "ПодключитьИнтеграционнуюОбработку";
	Если ПараметрыПодключенияMS = Неопределено Тогда
		ПараметрыПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("ПараметрыПодключенияMS",АдресаПеременных);
	КонецЕсли;
	
	Если ПараметрыПодключенияMS = Неопределено Тогда
		ПараметрыПодключенияMS   = ГлЯдро_ПолучитьДанныеИзХранилища1С("Cleverence_ПараметрыПодключенияMS");	
	КонецЕсли;
	
	Если ТипОбработки = Неопределено Тогда
		ТипОбработки= ?(НЕ ПараметрыПодключенияMS.Свойство("ТипОбработки") ИЛИ НЕ ЗначениеЗаполнено(ПараметрыПодключенияMS.ТипОбработки),"ФайлНаДиске",ПараметрыПодключенияMS.ТипОбработки);
	КонецЕсли;
	
	ДоступноВыполнениеВФоне = КомЯдро_ПолучитьЗначениеПеременной("ДоступноВыполнениеВФоне", АдресаПеременных);
	ДвоичныеДанныеДляФЗ 	= Неопределено;
	
	Если ЭтоАдресВременногоХранилища(ПолныйПутьКИнтеграционнойОбработке) Тогда
		#Область НесовместимыйКодFresh
		ФайлИнтеграционнойОбработкиСуществует = Истина;
		#Если ТолстыйКлиентОбычноеПриложение Тогда
			пДвоичныеДанные = ПолучитьИзВременногоХранилища(ПолныйПутьКИнтеграционнойОбработке);
			пИмяОбработки = ПолучитьИмяВременногоФайла();
			пДвоичныеДанные.Записать(пИмяОбработки);
		#Иначе	
			пИмяОбработки = ВнешниеОбработки.Подключить(ПолныйПутьКИнтеграционнойОбработке,,ложь);
			Если ДоступноВыполнениеВФоне = Истина Тогда
				// Получить ИО в виде двоичных данных
				ДвоичныеДанныеДляФЗ = ПолучитьИзВременногоХранилища(ПолныйПутьКИнтеграционнойОбработке);
			КонецЕсли;
		#КонецЕсли
		Попытка
			ИнтеграционнаяОбработка = ВнешниеОбработки.Создать(пИмяОбработки,ложь);
		Исключение
			пАдресСтруктуры = Неопределено;
			ТекстОшибки = "Ошибка подключения интеграционной обработки: " + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
			ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", ТекстОшибки, ,АдресаПеременных);
			Возврат ТекстОшибки;
		КонецПопытки;
	ИначеЕсли ТипОбработки = "ФайлНаДиске" Тогда
		Если (Не ПараметрыПодключенияMS.Свойство("РабочийКаталог")) // в старых версиях не сохранялись эти параметры 
			ИЛИ (Не ПараметрыПодключенияMS.Свойство("ИмяИнтеграционнойОбработки"))
			ИЛИ (Не ПараметрыПодключенияMS.Свойство("ПутьИнтеграционнойОбработки")) Тогда 
			ГлЯдро_ПересохранитьНастройкиПодключения(АдресаПеременных);
		КонецЕсли;
		РабочийКаталог = ПараметрыПодключенияMS.РабочийКаталог;
		ПутьОсновнойОбработки = ЭтотОбъект.ИспользуемоеИмяФайла;
		пИмяОбработки = "";
		Если ЗначениеЗаполнено(РабочийКаталог)
			ИЛИ ЗначениеЗаполнено(ПутьОсновнойОбработки) Тогда
			пИмяФайла = ПараметрыПодключенияMS.ИмяИнтеграционнойОбработки;
			ПутьИнтеграционнойОбработки = ПараметрыПодключенияMS.ПутьИнтеграционнойОбработки;
			
			// Сначала пробуем подцепить обработку по адресу Путь+Имя, если там её нет, берем РабочийКаталог+Путь+Имя
			ПолныйПутьКИнтеграционнойОбработке = Строка(ПутьИнтеграционнойОбработки)+Строка(пИмяФайла);
			
			ФайлИнтеграционнойОбработки = Новый Файл(ПолныйПутьКИнтеграционнойОбработке);
			Если НЕ ФайлИнтеграционнойОбработки.Существует() Тогда
				Если ЗначениеЗаполнено(РабочийКаталог) Тогда
					ПолныйПутьКИнтеграционнойОбработке = Строка(РабочийКаталог)
						+ Строка(ПутьИнтеграционнойОбработки)
						+ Строка(пИмяФайла);
					ФайлИнтеграционнойОбработки = Новый Файл(ПолныйПутьКИнтеграционнойОбработке);
				КонецЕсли;
			КонецЕсли;
			
			// Если файл интеграционной обработки не найден, пробуем подключить
			// её по относительному пути из каталога основной обработки
			Если ЗначениеЗаполнено(ПутьОсновнойОбработки) Тогда
				Если НЕ ЗначениеЗаполнено(РабочийКаталог)
					ИЛИ НЕ ФайлИнтеграционнойОбработки.Существует() Тогда
					ПутьИнтеграционнойОбработки = ГлЯдро_ПолучитьПутьИнтеграционнойОбработки(ПутьОсновнойОбработки);
					Если НЕ ПустаяСтрока(ПутьИнтеграционнойОбработки) Тогда
						ПолныйПутьКИнтеграционнойОбработке = ПутьИнтеграционнойОбработки
							+ Строка(ИмяИнтеграционнойОбработки);
						ФайлИнтеграционнойОбработки = Новый Файл(ПолныйПутьКИнтеграционнойОбработке);
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
			
			ФайлИнтеграционнойОбработкиСуществует = ФайлИнтеграционнойОбработки.Существует();
			Если ФайлИнтеграционнойОбработкиСуществует Тогда
				Попытка
					ИнтеграционнаяОбработка = ВнешниеОбработки.Создать(ПолныйПутьКИнтеграционнойОбработке,ложь);
					пИмяОбработки = ИнтеграционнаяОбработка.Метаданные().Имя;
					Если ДоступноВыполнениеВФоне = Истина Тогда
						// Получить ИО в виде двоичных данных
						ДвоичныеДанныеДляФЗ = ПолучитьИзВременногоХранилища(ПолныйПутьКИнтеграционнойОбработке);
					КонецЕсли;
				Исключение
					пАдресСтруктуры = Неопределено;
					ТекстОшибки = "Ошибка подключения интеграционной обработки: " + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
					ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", ТекстОшибки, ,АдресаПеременных);					
					Возврат ТекстОшибки;
				КонецПопытки;
			Иначе	
				ТекстОшибки = "Файл интеграционной обработки по пути """ + Строка(ПутьИнтеграционнойОбработки) + Строка(пИмяФайла) + """ не найден.";
				ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", ТекстОшибки, , АдресаПеременных);
				
				Возврат ТекстОшибки;	
			КонецЕсли;
			ПутьКФайлу = ПолныйПутьКИнтеграционнойОбработке;
		
		Иначе
			ТекстОшибки = "Файл интеграционной обработки по пути """+Строка(ПутьИнтеграционнойОбработки)+Строка(пИмяФайла)+""" не найден.";
			ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", ТекстОшибки, ,АдресаПеременных);
			
			Возврат ТекстОшибки;
		КонецЕсли;
	ИначеЕсли ТипОбработки = "СправочникСсылка" Тогда
		СсылкаНаЭлемент = ПараметрыПодключенияMS.ПутьИнтеграционнойОбработки;
		Если НЕ ЗначениеЗаполнено(СсылкаНаЭлемент)
			ИЛИ ТипЗнч(СсылкаНаЭлемент) = Тип("Строка") Тогда
			
			ТекстОшибки = "Ошибка подключения интеграционной обработки: Не выбран элемент справочника";
			ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", ТекстОшибки, ,АдресаПеременных);

			Возврат ТекстОшибки;
		КонецЕсли;
		
		Если НЕ ГлЯдро_СсылкаСуществует(СсылкаНаЭлемент) Тогда
			
			ТекстОшибки = "Ошибка подключения интеграционной обработки: Ссылка на элемент справочника """ + Строка(СсылкаНаЭлемент) + """ больше не доступна";
			ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", ТекстОшибки, ,АдресаПеременных);
			
			Возврат ТекстОшибки;
		КонецЕсли;
		
		ИнтеграционнаяОбработкаПодключена = Ложь;
		
		МетаданныеСправочника = СсылкаНаЭлемент.Метаданные();
		Для каждого Реквизит из МетаданныеСправочника.Реквизиты Цикл
			Если Реквизит.Тип.СодержитТип(Тип("ХранилищеЗначения")) Тогда
				ХранимоеЗначение = СсылкаНаЭлемент[Реквизит.Имя].Получить();
				Если ХранимоеЗначение = Неопределено
						ИЛИ ТипЗнч(ХранимоеЗначение) <> Тип("ДвоичныеДанные") Тогда
						//В хранилище пустое значение или в хранилище не хранится двоичный файл!
					Продолжить;
				КонецЕсли;
				#Если ТолстыйКлиентОбычноеПриложение Тогда
					пИмяОбработки = ПолучитьИмяВременногоФайла();
					ХранимоеЗначение.Записать(пИмяОбработки);
				#Иначе
					АдресДвоичныхДанных = ПоместитьВоВременноеХранилище(ХранимоеЗначение);
					Если ДоступноВыполнениеВФоне = Истина Тогда
						// Получить ИО в виде двоичных данных
						ДвоичныеДанныеДляФЗ = ХранимоеЗначение;
					КонецЕсли;
				#КонецЕсли
				Попытка
					#Если НЕ ТолстыйКлиентОбычноеПриложение Тогда
						пИмяОбработки = ВнешниеОбработки.Подключить(АдресДвоичныхДанных,,ложь);
					#КонецЕсли
					ИнтеграционнаяОбработка = ВнешниеОбработки.Создать(пИмяОбработки,ложь);
					ПутьКФайлу = "Справочник: """ + МетаданныеСправочника.Синоним
						+ """, Обработка: """ + Строка(СсылкаНаЭлемент) + """";
					ИнтеграционнаяОбработкаПодключена = Истина;	
					Прервать;
				Исключение
				КонецПопытки;
			КонецЕсли;
		КонецЦикла;
		
		Если НЕ ИнтеграционнаяОбработкаПодключена Тогда
			ТекстОшибки = "Ошибка подключения интеграционной обработки: Не удалось подключить интеграционную обработку """ + Строка(СсылкаНаЭлемент) + """ из справочника """ + МетаданныеСправочника.Синоним + """";
			ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", ТекстОшибки, ,АдресаПеременных);
			
			Возврат ТекстОшибки;
		КонецЕсли;
		#КонецОбласти //НесовместимыйКодFresh		
	ИначеЕсли ТипОбработки = "Встроенная" Тогда
		ИмяОбработки = ПараметрыПодключенияMS.ПутьИнтеграционнойОбработки;
		Если НЕ ЗначениеЗаполнено(ИмяОбработки) Тогда
			Возврат "Ошибка подключения интеграционной обработки: Не выбрана встроенная обработка";
		КонецЕсли; 
		Если Метаданные.Обработки.Найти(ИмяОбработки) = Неопределено Тогда
			Возврат "Ошибка подключения интеграционной обработки: Обработка """+ИмяОбработки+""" не найдена в конфигурации";	
		КонецЕсли;	
			
		Попытка
			пИмяОбработки = ИмяОбработки;
			ИнтеграционнаяОбработка = Обработки[ИмяОбработки].Создать();
			ПутьКФайлу = "Встроенная обработка: """ + Строка(пИмяОбработки) + """";
		Исключение
			ТекстОшибки = "Ошибка подключения интеграционной обработки: Не удалось подключить встроенную в конфигурацию интеграционную обработку """ + Строка(пИмяОбработки) + """: " + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
			ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", ТекстОшибки, ,АдресаПеременных);
			
			Возврат ТекстОшибки;	
		КонецПопытки;
	КонецЕсли;

	Если НЕ ИнтеграционнаяОбработка = Неопределено Тогда
		
		Попытка
			Если Не ИнтеграционнаяОбработка.Конф_ПроверкаСоответствияИспользуемойКонфигурации() Тогда
				//Сообщить( "Интеграционная обработка не соответствует конфигурации или версии 1С");
			КонецЕсли;
			СтруктураОбработки = Новый Структура();
			СтруктураОбработки.Вставить("ИнтеграционнаяОбработка",ИнтеграционнаяОбработка);
			СтруктураОбработки.Вставить("Подключена",Истина);
			СтруктураОбработки.Вставить("ПутьКФайлу",ПутьКФайлу);
			СтруктураОбработки.Вставить("ИмяОбработки",ИнтеграционнаяОбработка.Метаданные().Имя);
			Если ДоступноВыполнениеВФоне = Истина Тогда
				СтруктураОбработки.Вставить("ИнтеграционнаяОбработкаДвоичныеДанные", 
					?(ЗначениеЗаполнено(ДвоичныеДанныеДляФЗ), ДвоичныеДанныеДляФЗ, Неопределено));
			КонецЕсли;
			#Если ТолстыйКлиентОбычноеПриложение Тогда
				СтруктураОбработки.Вставить("Форма",ИнтеграционнаяОбработка.ПолучитьФорму());
			#КонецЕсли
			КомЯдро_СохранитьЗначениеПеременной("ИнтеграционнаяОбработка",СтруктураОбработки,АдресаПеременных);
			ГлЯдро_СохранитьДанныеВХранилище1С("Cleverence_ИмяИнтеграционнойОбработки", пИмяОбработки);
			пАдресСтруктуры = АдресаПеременных.ИнтеграционнаяОбработка;
		Исключение
			пАдресСтруктуры = Неопределено;
			//Удалим некорректную настройку
			ПараметрыПодключенияMS = ГлЯдро_ПолучитьДанныеИзХранилища1С("Cleverence_ПараметрыПодключенияMS");
			Если ЗначениеЗаполнено(ПараметрыПодключенияMS.Свойство("ИмяИнтеграционнойОбработки"))
				ИЛИ ЗначениеЗаполнено(ПараметрыПодключенияMS.Свойство("ПутьИнтеграционнойОбработки")) Тогда
				ПараметрыПодключенияMS.Вставить("ИмяИнтеграционнойОбработки","");
				ПараметрыПодключенияMS.Вставить("ПутьИнтеграционнойОбработки","");
				ГлЯдро_СохранитьДанныеВХранилище1С("Cleverence_ПараметрыПодключенияMS", ПараметрыПодключенияMS);
			КонецЕсли;
			
			ТекстОшибки = "Ошибка подключения интеграционной обработки: " + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
			ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", ТекстОшибки, ,АдресаПеременных);
			
			Возврат ТекстОшибки;
		КонецПопытки;
	КонецЕсли;
	
	Возврат пАдресСтруктуры;	
	
КонецФункции

Функция ГлЯдро_ПолучитьРабочийКаталогОсновнойОбработки(ПутьОсновнойОбработки)

	КаталогОсновнойОбработки = "";
	
	РазделительПути = ПолучитьРазделительПути();
	
	ПозицияРазделителя = ГлЯдро_СтрНайти(ПутьОсновнойОбработки, РазделительПути, "СКонца");
	Если ПозицияРазделителя Тогда
		КаталогОсновнойОбработки = Лев(ПутьОсновнойОбработки, ПозицияРазделителя - 1);
	КонецЕсли;	
	
	Возврат КаталогОсновнойОбработки;
	
КонецФункции

Функция ГлЯдро_ПолучитьПутьИнтеграционнойОбработки(ПутьОсновнойОбработки)

	РазделительПути = ПолучитьРазделительПути();
	
	ПутьИнтеграционнойОбработки = ГлЯдро_ПолучитьРабочийКаталогОсновнойОбработки(ПутьОсновнойОбработки)
		 + РазделительПути
		 + "Обработки интеграции"
		 + РазделительПути;
	
	Возврат ПутьИнтеграционнойОбработки;
	
КонецФункции

// Выполняет пересоздание интеграционной обработки по данным временного хранилища
//
// Параметры:
//	АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных	
//
// Возвращаемое значение:
//	Булево - признак успешности выполнения операции
Функция ГлЯдро_ПересоздатьИнтеграционнуюОбработку(АдресаПеременных) Экспорт 
	
	ИмяИнтеграционнойОбработки = ГлЯдро_ПолучитьДанныеИзХранилища1С("Cleverence_ИмяИнтеграционнойОбработки");
	
	ИмяСобытия = "ГлЯдро_ПересоздатьИнтеграционнуюОбработку";
		
	Если ИмяИнтеграционнойОбработки = "" Тогда
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Не удалось пересоздать интеграционную обработку", , АдресаПеременных);
		Возврат ложь;
	КонецЕсли;
	
	ПараметрыПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("ПараметрыПодключенияMS",АдресаПеременных);
	
	ФайлИнтеграционнойОбработкиСуществует = Ложь;
	ИнтеграционнаяОбработка = Неопределено;
	Если ПараметрыПодключенияMS = Неопределено Тогда
		ПараметрыПодключенияMS   = ГлЯдро_ПолучитьДанныеИзХранилища1С("Cleverence_ПараметрыПодключенияMS");	
	КонецЕсли;
	ТипОбработки= ?(НЕ ПараметрыПодключенияMS.Свойство("ТипОбработки") ИЛИ НЕ ЗначениеЗаполнено(ПараметрыПодключенияMS.ТипОбработки),"ФайлНаДиске",ПараметрыПодключенияMS.ТипОбработки);
	
	Если ТипОбработки = "Встроенная" Тогда
		ИмяОбработки = ПараметрыПодключенияMS.ПутьИнтеграционнойОбработки;
		Если НЕ ЗначениеЗаполнено(ИмяОбработки)
			ИЛИ Метаданные.Обработки.Найти(ИмяОбработки) = Неопределено Тогда
			ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Не удалось пересоздать интеграционную обработку", , АдресаПеременных);
			Возврат Ложь;
		КонецЕсли; 			
		Попытка
			пИмяОбработки = ИмяОбработки;
			ИнтеграционнаяОбработка = Обработки[ИмяОбработки].Создать();
			ПутьКФайлу = "Встроенная обработка: """ + Строка(пИмяОбработки) + """";
		Исключение
			ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Не удалось пересоздать интеграционную обработку: " + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()), , АдресаПеременных);
		КонецПопытки;
	Иначе
		#Область НесовместимыйКодFresh
		Попытка
			ИмяВременногоФайла = "";
			Если АдресаПеременных.Свойство("ЭтоФоновоеЗадание") И
				АдресаПеременных.ЭтоФоновоеЗадание Тогда
				
				Если АдресаПеременных.ИнтеграционнаяОбработка.Свойство("ИнтеграционнаяОбработкаДвоичныеДанные") = Ложь 
					Или Не ЗначениеЗаполнено(АдресаПеременных.ИнтеграционнаяОбработка.ИнтеграционнаяОбработкаДвоичныеДанные) Тогда					
					ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Ошибка подключения интеграционной обработки. Для выполнения фонового задания отсутствует значение ИнтеграционнаяОбработкаДвоичныеДанные", , АдресаПеременных);
					Возврат Ложь;
				КонецЕсли;
					
				ДвоичныеДанные = АдресаПеременных.ИнтеграционнаяОбработка.ИнтеграционнаяОбработкаДвоичныеДанные;
				ИмяВременногоФайла = ПолучитьИмяВременногоФайла();
				ДвоичныеДанные.Записать(ИмяВременногоФайла);
				ИмяИнтеграционнойОбработки = ИмяВременногоФайла;
				
			КонецЕсли;

			ИнтеграционнаяОбработка = ВнешниеОбработки.Создать(ИмяИнтеграционнойОбработки,ложь);
			
			Если ЗначениеЗаполнено(ИмяВременногоФайла) Тогда
				УдалитьФайлы(ИмяВременногоФайла);
			КонецЕсли;
		Исключение
			ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Не удалось пересоздать интеграционную обработку: " + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()), , АдресаПеременных);
			Возврат Ложь;
		КонецПопытки;
		#КонецОбласти //НесовместимыйКодFresh
	КонецЕсли;
	
	Если НЕ ИнтеграционнаяОбработка = Неопределено Тогда
		
		Попытка
			Если Не ИнтеграционнаяОбработка.Конф_ПроверкаСоответствияИспользуемойКонфигурации() Тогда
				//Возврат Ложь;
			КонецЕсли;
		Исключение
			ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Не удалось пересоздать интеграционную обработку: " + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()), , АдресаПеременных);
			Возврат Ложь;
		КонецПопытки;
		КомЯдро_СохранитьЗначениеПеременной("ИнтеграционнаяОбработка",Новый Структура("ИнтеграционнаяОбработка,ПутьКФайлу,Подключена,ИмяОбработки",ИнтеграционнаяОбработка,?(ПараметрыПодключенияMS.Свойство("ПутьКФайлу"),ПараметрыПодключенияMS.ПутьКФайлу,""),Истина,ИмяИнтеграционнойОбработки),АдресаПеременных);
		Возврат Истина;
	КонецЕсли;
	
	Возврат Ложь;	
	
КонецФункции

Функция ГлЯдро_ПроверитьСуществованиеИнтеграционнаяОбработкаДвоичныеДанные(АдресаПеременных) Экспорт
	
	Результат = Ложь;
	
	Если Не АдресаПеременных.Свойство("ИнтеграционнаяОбработка") Тогда
		Возврат Результат;
	КонецЕсли;
	
	СтруктураИО = КомЯдро_ПолучитьЗначениеПеременной("ИнтеграционнаяОбработка",АдресаПеременных);
	Если СтруктураИО.Свойство("ИнтеграционнаяОбработкаДвоичныеДанные") 
		И ЗначениеЗаполнено(СтруктураИО.ИнтеграционнаяОбработкаДвоичныеДанные) Тогда
		Результат = Истина;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

Процедура ГлЯдро_ПересохранитьНастройкиПодключения(АдресаПеременных)
	
	ПараметрыПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("ПараметрыПодключенияMS",АдресаПеременных);
	
	ИдБазы = ПараметрыПодключенияMS.Ид;
	
	СписокБазНаСервереSMARTS = КомЯдро_ПолучитьСписокБазНаСервереSMARTS(Истина,АдресаПеременных);
	СтрокаПараметров = ГлЯдро_НайтиСтруктуруВМассивеПоЭлементу(СписокБазНаСервереSMARTS,"Ид",ИдБазы);
	
	Если СтрокаПараметров <> Неопределено Тогда
		
		ПараметрыПодключенияMS = Новый Структура;
		ПараметрыПодключенияMS.Вставить("Ид", 							СтрокаПараметров.Ид);
		ПараметрыПодключенияMS.Вставить("Имя", 							СтрокаПараметров.Имя);
		ПараметрыПодключенияMS.Вставить("ИдПриложения", 				СтрокаПараметров.ИдПриложения);
		ПараметрыПодключенияMS.Вставить("ИдОсновногоПриложения", 		СтрокаПараметров.ИдОсновногоПриложения);
		ПараметрыПодключенияMS.Вставить("ИмяПриложения", 				СтрокаПараметров.ИмяПриложения);
		ПараметрыПодключенияMS.Вставить("УровеньПриложения", 			СтрокаПараметров.УровеньПриложения);
		ПараметрыПодключенияMS.Вставить("СтрокаПодключения", 			СтрокаПараметров.СтрокаПодключения);
		ПараметрыПодключенияMS.Вставить("РабочийКаталог", 				СтрокаПараметров.РабочийКаталог);
		ПараметрыПодключенияMS.Вставить("ИмяИнтеграционнойОбработки",	СтрокаПараметров.ИмяИнтеграционнойОбработки);
		ПараметрыПодключенияMS.Вставить("ПутьИнтеграционнойОбработки",	СтрокаПараметров.ПутьИнтеграционнойОбработки);
		ПараметрыПодключенияMS.Вставить("УровеньПриложенияСтрокой",		СтрокаПараметров.УровеньПриложенияСтрокой);
		ПараметрыПодключенияMS.Вставить("ТипУстановленногоПродукта",	СтрокаПараметров.ТипУстановленногоПродукта);
		ПараметрыПодключенияMS.Вставить("АвторизацияВключена", 			Ложь);
		ПараметрыПодключенияMS.Вставить("АвторизацияЛогин",		 		"");
		ПараметрыПодключенияMS.Вставить("АвторизацияТокен", 			"");
		ПараметрыПодключенияMS.Вставить("АвторизацияРефрешТокен",		"");
		
		ГлЯдро_СохранитьДанныеВХранилище1С("Cleverence_ПараметрыПодключенияMS", ПараметрыПодключенияMS);
	КонецЕсли;
	
КонецПроцедуры

Функция ГлЯдро_ПроверитьОбновлениеТиповыхБизнесПроцессов(пСтруктураНастроек, АдресаПеременных)
	
	СтруктураНастроек = Новый Структура("ВерсияНастроек,ВерсияНастроек_ПоУмолчанию", Неопределено, Неопределено);
	СтруктураНастроек_Пользовательские 	= Новый Структура;
	СтруктураНастроек_ПоУмолчанию 		= Новый Структура;
	
	ВерсияНастроек_ПоУмолчанию 				= Ложь;
	НастройкиБизнесПроцессов_ПоУмолчанию 	= Ложь;
	Если ТипЗнч(пСтруктураНастроек.НастройкиБизнесПроцессов_ПоУмолчанию) = Тип("Структура") Тогда
		Если пСтруктураНастроек.НастройкиБизнесПроцессов_ПоУмолчанию.Свойство("ВерсияНастроек") Тогда
			ВерсияНастроек_ПоУмолчанию = пСтруктураНастроек.НастройкиБизнесПроцессов_ПоУмолчанию.ВерсияНастроек;
		КонецЕсли;
		Если пСтруктураНастроек.НастройкиБизнесПроцессов_ПоУмолчанию.Свойство("НастройкиБизнесПроцессов") Тогда
			НастройкиБизнесПроцессов_ПоУмолчанию = пСтруктураНастроек.НастройкиБизнесПроцессов_ПоУмолчанию.НастройкиБизнесПроцессов;
		КонецЕсли;
	КонецЕсли;
	
	ВерсияНастроек_Пользовательские 			= Ложь;
	НастройкиБизнесПроцессов_Пользовательские 	= Ложь;
	Если ТипЗнч(пСтруктураНастроек.НастройкиБизнесПроцессов_Пользовательские) = Тип("Структура") Тогда
		Если пСтруктураНастроек.НастройкиБизнесПроцессов_Пользовательские.Свойство("ВерсияНастроек") Тогда
			ВерсияНастроек_Пользовательские = пСтруктураНастроек.НастройкиБизнесПроцессов_Пользовательские.ВерсияНастроек;
		КонецЕсли;
		Если пСтруктураНастроек.НастройкиБизнесПроцессов_Пользовательские.Свойство("НастройкиБизнесПроцессов") Тогда
			НастройкиБизнесПроцессов_Пользовательские = пСтруктураНастроек.НастройкиБизнесПроцессов_Пользовательские.НастройкиБизнесПроцессов;
		КонецЕсли;
	КонецЕсли;
	
	// Получаем версии пользовательских настроек из настроек БП (если настройки сохранены в новом формате), либо по старому ключу, все это реализовано в соответствующих методах
	СтруктураНастроек_ПоУмолчанию.Вставить("НастройкиБизнесПроцессов", 		НастройкиБизнесПроцессов_ПоУмолчанию);
	СтруктураНастроек_Пользовательские.Вставить("НастройкиБизнесПроцессов", НастройкиБизнесПроцессов_Пользовательские);

	СтруктураНастроек.ВерсияНастроек			 = ВерсияНастроек_Пользовательские;
	СтруктураНастроек.ВерсияНастроек_ПоУмолчанию = ВерсияНастроек_ПоУмолчанию;		

	НужноОбновить = Ложь;
	Если Не ЗначениеЗаполнено(СтруктураНастроек.ВерсияНастроек) ИЛИ СтруктураНастроек.ВерсияНастроек = Ложь Тогда
		НужноОбновить = Истина;
	ИначеЕсли ТипЗнч(СтруктураНастроек.ВерсияНастроек) = Тип("Строка") И ТипЗнч(СтруктураНастроек.ВерсияНастроек_ПоУмолчанию) = Тип("Строка") Тогда		
		ВерсияНастроекСтр = СтруктураНастроек.ВерсияНастроек;
		ВерсияНастроек_ПоУмолчаниюСтр = СтруктураНастроек.ВерсияНастроек_ПоУмолчанию;
		Пока Истина Цикл
			Если СтрДлина(ВерсияНастроек_ПоУмолчаниюСтр) = 0 Тогда
				Прервать;
			КонецЕсли;
			Если СтрДлина(ВерсияНастроекСтр) = 0 Тогда
				НужноОбновить = Истина;
				Прервать;
			КонецЕсли;
			
			Инд = Найти(ВерсияНастроек_ПоУмолчаниюСтр,".");
			Если Инд = 0 Тогда				
				ВерсияПоУмолчанию = ВерсияНастроек_ПоУмолчаниюСтр;
				ВерсияНастроек_ПоУмолчаниюСтр = "";
			Иначе
				ВерсияПоУмолчанию = Лев(ВерсияНастроек_ПоУмолчаниюСтр,Инд-1);
				ВерсияНастроек_ПоУмолчаниюСтр = Прав(ВерсияНастроек_ПоУмолчаниюСтр,СтрДлина(ВерсияНастроек_ПоУмолчаниюСтр)-Инд);
			КонецЕсли;
			
			Попытка
				ВерсияПоУмолчанию = Число(ВерсияПоУмолчанию);	
			Исключение
				Прервать;
			КонецПопытки;
			
			Инд = Найти(ВерсияНастроекСтр,".");
			Если Инд = 0 Тогда				
				ТекВерсия = ВерсияНастроекСтр;
				ВерсияНастроекСтр = "";
			Иначе
				ТекВерсия = Лев(ВерсияНастроекСтр,Инд-1);
				ВерсияНастроекСтр = Прав(ВерсияНастроекСтр,СтрДлина(ВерсияНастроекСтр)-Инд);
			КонецЕсли;
			
			Попытка
				ТекВерсия = Число(ТекВерсия);	
			Исключение
				НужноОбновить = Истина;
				Прервать;
			КонецПопытки;
			
			Если ВерсияПоУмолчанию > ТекВерсия Тогда
				НужноОбновить = Истина;
				Прервать;	
			КонецЕсли;
			
		КонецЦикла;
	КонецЕсли;
	
	Если НЕ НужноОбновить Тогда
		Возврат Ложь;	
	КонецЕсли;
		
	НастройкиБизнесПроцессовПоУмолчанию = СтруктураНастроек_ПоУмолчанию.НастройкиБизнесПроцессов;
	Если НастройкиБизнесПроцессовПоУмолчанию <> Неопределено И НастройкиБизнесПроцессовПоУмолчанию <> Ложь Тогда
		Если ТипЗнч(НастройкиБизнесПроцессовПоУмолчанию) = Тип("Строка") Тогда
			НастройкиБизнесПроцессовПоУмолчанию = ГлЯдро_ЗначениеИзСтрокиXML(НастройкиБизнесПроцессовПоУмолчанию);
		КонецЕсли;
		Если ТипЗнч(НастройкиБизнесПроцессовПоУмолчанию) = Тип("ТаблицаЗначений") Тогда
			НастройкиБизнесПроцессовПоУмолчанию = ГлЯдро_ТаблицуЗначенийВМассивСтруктур(НастройкиБизнесПроцессовПоУмолчанию);
		КонецЕсли;
		
		СтруктураНастроекБизнесПроцессов_ПоУмолчанию = ГлЯдро_СкомпоноватьСтруктуруНастроекДляСохранения(
				НастройкиБизнесПроцессовПоУмолчанию, 
				ГлЯдро_ПолучитьВерсиюСтруктурыНастроекОбработки(),
				АдресаПеременных); 		                                                                		
		ГлЯдро_ЗаписатьВКэшНастройкуSMARTS("НастройкиБизнесПроцессов_ПоУмолчанию", СтруктураНастроекБизнесПроцессов_ПоУмолчанию, АдресаПеременных);
		
	КонецЕсли; 	
	
	Если СтруктураНастроек_Пользовательские.НастройкиБизнесПроцессов = Ложь Тогда	
		НастройкиБизнесПроцессовСтарые = ГлЯдро_ПолучитьНастройкуНаСервереSMARTS("НастройкиБизнесПроцессов",,АдресаПеременных);	
		Если НастройкиБизнесПроцессовСтарые <> Неопределено и НастройкиБизнесПроцессовСтарые <> Ложь Тогда
			НастройкиБизнесПроцессов_Пользовательские = НастройкиБизнесПроцессовСтарые;
			СтруктураНастроек_Пользовательские = ГлЯдро_СкомпоноватьСтруктуруНастроекДляСохранения(
				НастройкиБизнесПроцессов_Пользовательские, 
				ГлЯдро_ПолучитьВерсиюСтруктурыНастроекОбработки(),
				АдресаПеременных); 		
			ГлЯдро_СохранитьНастройкуВБазеSMARTS("НастройкиБизнесПроцессов_Пользовательские", 	 СтруктураНастроек_Пользовательские,, АдресаПеременных);
			ГлЯдро_ЗаписатьВКэшНастройкуSMARTS("НастройкиБизнесПроцессов_Пользовательские", 	 СтруктураНастроек_Пользовательские,  АдресаПеременных);	
			ГлЯдро_УдалитьНастройкиВБазеSMARTS(Новый Структура("НастройкиБизнесПроцессов",Ложь), Неопределено,					   ,  АдресаПеременных);
		КонецЕсли;
	КонецЕсли;
	                      	
	НужноСохранить = Ложь;
	
	НастройкиБизнесПроцессов_Пользовательские = СтруктураНастроек_Пользовательские.НастройкиБизнесПроцессов;
	Если НастройкиБизнесПроцессов_Пользовательские <> Неопределено И НастройкиБизнесПроцессов_Пользовательские <> Ложь Тогда		
		Если ТипЗнч(НастройкиБизнесПроцессов_Пользовательские) = Тип("Строка") Тогда
			НастройкиБизнесПроцессов_Пользовательские = ГлЯдро_ЗначениеИзСтрокиXML(НастройкиБизнесПроцессов_Пользовательские);
		КонецЕсли;
		Если ТипЗнч(НастройкиБизнесПроцессов_Пользовательские) = Тип("ТаблицаЗначений") Тогда
			НастройкиБизнесПроцессов_Пользовательские = ГлЯдро_ТаблицуЗначенийВМассивСтруктур(НастройкиБизнесПроцессов_Пользовательские);
		КонецЕсли;
		Икс = НастройкиБизнесПроцессов_Пользовательские.Количество();
		Пока Икс > 0 Цикл
			Икс = Икс - 1;
			НастройкаБП = НастройкиБизнесПроцессов_Пользовательские[Икс];
			Если НастройкаБП.Свойство("ID_БизнесПроцесса") Тогда
				ID = НастройкаБП.ID_БизнесПроцесса;
			ИначеЕсли НастройкаБП.Свойство("IDБизнесПроцесса") Тогда
				ID = НастройкаБП.IDБизнесПроцесса;
			Иначе
				ID = Неопределено;
			КонецЕсли;
			Если ID <> Неопределено Тогда
				Индекс = ГлЯдро_НайтиСтруктуруВМассивеПоЭлементу(НастройкиБизнесПроцессовПоУмолчанию,"ID_БизнесПроцесса",ID,Истина);
				Если Индекс <> Неопределено Тогда
					НастройкиБизнесПроцессов_Пользовательские.Удалить(Икс);
					НужноСохранить=Истина;
				КонецЕсли;
			КонецЕсли;	
		КонецЦикла;
		НастройкиБизнесПроцессов_Пользовательские = ГлЯдро_ОбновитьСтруктуруНастроекБизнесПроцессов(НастройкиБизнесПроцессов_Пользовательские, НужноСохранить,,АдресаПеременных);
	КонецЕсли;
	
	Если НужноСохранить Тогда		
		СтруктураНастроекБизнесПроцессов_Пользовательские = ГлЯдро_СкомпоноватьСтруктуруНастроекДляСохранения(
			НастройкиБизнесПроцессов_Пользовательские, 
			ГлЯдро_ПолучитьВерсиюСтруктурыНастроекОбработки(),
			АдресаПеременных); 		
		ГлЯдро_СохранитьНастройкуВБазеSMARTS("НастройкиБизнесПроцессов_Пользовательские", 	СтруктураНастроекБизнесПроцессов_Пользовательские,,	АдресаПеременных);
		ГлЯдро_ЗаписатьВКэшНастройкуSMARTS("НастройкиБизнесПроцессов_Пользовательские", 	СтруктураНастроекБизнесПроцессов_Пользовательские,	АдресаПеременных);	
	КонецЕсли;
		
	ПроизвольныеКоды_ПоУмолчанию = ГлЯдро_ПолучитьНастройкуПоУмолчаниюНаСервереSMARTS("ПроизвольныеКоды_ПоУмолчанию",,АдресаПеременных);
	Если ПроизвольныеКоды_ПоУмолчанию <> Неопределено и ПроизвольныеКоды_ПоУмолчанию <> Ложь Тогда
		Если ТипЗнч(ПроизвольныеКоды_ПоУмолчанию) = Тип("Строка") Тогда
			ПроизвольныеКоды_ПоУмолчанию = ГлЯдро_ЗначениеИзСтрокиXML(ПроизвольныеКоды_ПоУмолчанию);
		КонецЕсли;
		Если ТипЗнч(ПроизвольныеКоды_ПоУмолчанию) = Тип("ТаблицаЗначений") Тогда
			ПроизвольныеКоды_ПоУмолчанию = ГлЯдро_ТаблицуЗначенийВМассивСтруктур(ПроизвольныеКоды_ПоУмолчанию);
		КонецЕсли;
		
		ГлЯдро_ЗаписатьВКэшНастройкуSMARTS("ПроизвольныеКоды_ПоУмолчанию", ПроизвольныеКоды_ПоУмолчанию,АдресаПеременных);
	КонецЕсли;
	
	ПроизвольныеКоды_Пользовательские = ГлЯдро_ПолучитьИзКэшаНастройкуSMARTS("ПроизвольныеКоды_Пользовательские",,АдресаПеременных);	
	Если ПроизвольныеКоды_Пользовательские <> Неопределено и ПроизвольныеКоды_Пользовательские <> Ложь Тогда
		НужноСохранить=Ложь;
		Если ТипЗнч(ПроизвольныеКоды_Пользовательские) = Тип("Строка") Тогда
			ПроизвольныеКоды_Пользовательские = ГлЯдро_ЗначениеИзСтрокиXML(ПроизвольныеКоды_Пользовательские);
		КонецЕсли;
		Если ТипЗнч(ПроизвольныеКоды_Пользовательские) = Тип("ТаблицаЗначений") Тогда
			ПроизвольныеКоды_Пользовательские = ГлЯдро_ТаблицуЗначенийВМассивСтруктур(ПроизвольныеКоды_Пользовательские);
		КонецЕсли;
		Икс = ПроизвольныеКоды_Пользовательские.Количество();
		Пока Икс > 0 Цикл
			Икс = Икс - 1;
			СтрокаПК = ПроизвольныеКоды_Пользовательские[Икс];
			Если СтрокаПК.Свойство("ID_ПроизвольногоКода") Тогда
				Индекс = ГлЯдро_НайтиСтруктуруВМассивеПоЭлементу(ПроизвольныеКоды_ПоУмолчанию,"ID_ПроизвольногоКода",СтрокаПК.ID_ПроизвольногоКода,Истина);
				Если Индекс <> Неопределено Тогда
					ПроизвольныеКоды_Пользовательские.Удалить(Икс);
					НужноСохранить=Истина;
				КонецЕсли;
			КонецЕсли;	
		КонецЦикла;	
		
		НоваяНастройка = Новый Массив;
		НоваяНастройка.Добавить(Новый Структура("КолонкиТаблицыЗначений,ЭтоТаблицаЗначений","Наименование,Описание,ТекстПроизвольногоКода,ID_ПроизвольногоКода,Направление,ТипОбъекта",Истина));
		
		Для Каждого ПроизвольныйКод из ПроизвольныеКоды_Пользовательские Цикл
			Если ПроизвольныйКод.Свойство("ЭтоТаблицаЗначений") Тогда
				Продолжить;
			КонецЕсли;
			Если ПроизвольныйКод.Свойство("ID_Кода") Тогда
				НовыйПроизвольныйКод = Новый Структура();
				НовыйПроизвольныйКод.Вставить("Наименование",			ПроизвольныйКод.Наименование);
				НовыйПроизвольныйКод.Вставить("Описание",				"");
				НовыйПроизвольныйКод.Вставить("ТекстПроизвольногоКода",	ПроизвольныйКод.ТекстКода);
				НовыйПроизвольныйКод.Вставить("ID_ПроизвольногоКода",	ПроизвольныйКод.ID_Кода);
				НовыйПроизвольныйКод.Вставить("Направление",			ПроизвольныйКод.Направление);
				НовыйПроизвольныйКод.Вставить("ТипОбъекта",				ПроизвольныйКод.ТипОбъекта);
				НоваяНастройка.Добавить(НовыйПроизвольныйКод);
				НужноСохранить = Истина;
			ИначеЕсли ПроизвольныйКод.Свойство("ID_ПроизвольногоКода") Тогда
				НоваяНастройка.Добавить(ПроизвольныйКод);
			КонецЕсли;
		КонецЦикла;	
				
		Если НужноСохранить Тогда
			ГлЯдро_СохранитьНастройкуВБазеSMARTS("ПроизвольныеКоды_Пользовательские", 	НоваяНастройка,,АдресаПеременных);
			ГлЯдро_ЗаписатьВКэшНастройкуSMARTS("ПроизвольныеКоды_Пользовательские", 	НоваяНастройка,АдресаПеременных);	
		КонецЕсли;
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

Процедура ГлЯдро_ОбъединитьПроизвольныеКоды(АдресаПеременных)
	
	ПроизвольныеКоды_ПоУмолчанию = ГлЯдро_ПолучитьИзКэшаНастройкуSMARTS("ПроизвольныеКоды_ПоУмолчанию",,АдресаПеременных);
	ПроизвольныеКоды_Пользовательские = ГлЯдро_ПолучитьИзКэшаНастройкуSMARTS("ПроизвольныеКоды_Пользовательские",,АдресаПеременных);
	
	Если (НЕ ПроизвольныеКоды_ПоУмолчанию = Ложь И ЗначениеЗаполнено(ПроизвольныеКоды_ПоУмолчанию))
		ИЛИ (НЕ ПроизвольныеКоды_Пользовательские = Ложь И ЗначениеЗаполнено(ПроизвольныеКоды_Пользовательские)) Тогда
		Возврат;
	КонецЕсли;
	
	СтруктураНастроек = Новый Структура("ПроизвольныеКоды_Выгрузка_ШапкаДокумента,ПроизвольныеКоды_Выгрузка_ТабличнаяЧастьДокумента,ПроизвольныеКоды_Загрузка_ШапкаДокумента,ПроизвольныеКоды_Загрузка_ТабличнаяЧастьДокумента",Неопределено,Неопределено);
	СтруктураНастроек = ГлЯдро_ПолучитьНастройкиНаСервереSMARTS(СтруктураНастроек,,,АдресаПеременных);		
		
	ПроизвольныеКоды_Пользовательские = Новый Массив;
	ПроизвольныеКоды_Пользовательские.Добавить(Новый Структура("ЭтоТаблицаЗначений,КолонкиТаблицыЗначений",Истина,"Наименование,Описание,ТекстПроизвольногоКода,ID_ПроизвольногоКода,Направление,ТипОбъекта"));
	
	Если ЗначениеЗаполнено(СтруктураНастроек.ПроизвольныеКоды_Выгрузка_ШапкаДокумента)
		И НЕ СтруктураНастроек.ПроизвольныеКоды_Выгрузка_ШапкаДокумента = Ложь Тогда
		Если ТипЗнч(СтруктураНастроек.ПроизвольныеКоды_Выгрузка_ШапкаДокумента) = Тип("Строка") Тогда
			СтруктураНастроек.ПроизвольныеКоды_Выгрузка_ШапкаДокумента = ГлЯдро_ЗначениеИзСтрокиXML(СтруктураНастроек.ПроизвольныеКоды_Выгрузка_ШапкаДокумента);
		КонецЕсли;
		Если ТипЗнч(СтруктураНастроек.ПроизвольныеКоды_Выгрузка_ШапкаДокумента) = Тип("ТаблицаЗначений") Тогда
			СтруктураНастроек.ПроизвольныеКоды_Выгрузка_ШапкаДокумента = ГлЯдро_ТаблицуЗначенийВМассивСтруктур(СтруктураНастроек.ПроизвольныеКоды_Выгрузка_ШапкаДокумента);
		КонецЕсли;
		Для каждого ПК Из СтруктураНастроек.ПроизвольныеКоды_Выгрузка_ШапкаДокумента Цикл
			Если НЕ ПК.Свойство("ЭтоТаблицаЗначений") Тогда
				ПК.Вставить("Направление","Выгрузка");
				ПК.Вставить("ТипОбъекта","Шапка");
				ПроизвольныеКоды_Пользовательские.Добавить(ПК);
			КонецЕсли;
		КонецЦикла;
		
	КонецЕсли;
	
	Если ЗначениеЗаполнено(СтруктураНастроек.ПроизвольныеКоды_Выгрузка_ТабличнаяЧастьДокумента)
		И НЕ СтруктураНастроек.ПроизвольныеКоды_Выгрузка_ТабличнаяЧастьДокумента = Ложь Тогда
		Если ТипЗнч(СтруктураНастроек.ПроизвольныеКоды_Выгрузка_ТабличнаяЧастьДокумента) = Тип("Строка") Тогда
			СтруктураНастроек.ПроизвольныеКоды_Выгрузка_ТабличнаяЧастьДокумента = ГлЯдро_ЗначениеИзСтрокиXML(СтруктураНастроек.ПроизвольныеКоды_Выгрузка_ТабличнаяЧастьДокумента);		
		КонецЕсли;
		Если ТипЗнч(СтруктураНастроек.ПроизвольныеКоды_Выгрузка_ТабличнаяЧастьДокумента) = Тип("ТаблицаЗначений") Тогда
			СтруктураНастроек.ПроизвольныеКоды_Выгрузка_ТабличнаяЧастьДокумента = ГлЯдро_ТаблицуЗначенийВМассивСтруктур(СтруктураНастроек.ПроизвольныеКоды_Выгрузка_ТабличнаяЧастьДокумента);
		КонецЕсли;
		Для каждого ПК Из СтруктураНастроек.ПроизвольныеКоды_Выгрузка_ТабличнаяЧастьДокумента Цикл
			Если НЕ ПК.Свойство("ЭтоТаблицаЗначений") Тогда
				ПК.Вставить("Направление","Выгрузка");
				ПК.Вставить("ТипОбъекта","ТабличнаяЧасть");
				ПроизвольныеКоды_Пользовательские.Добавить(ПК);
			КонецЕсли;
		КонецЦикла;
		
	КонецЕсли;
	
	Если ЗначениеЗаполнено(СтруктураНастроек.ПроизвольныеКоды_Загрузка_ШапкаДокумента)
		И НЕ СтруктураНастроек.ПроизвольныеКоды_Загрузка_ШапкаДокумента = Ложь Тогда
		Если ТипЗнч(СтруктураНастроек.ПроизвольныеКоды_Загрузка_ШапкаДокумента) = Тип("Строка") Тогда
			СтруктураНастроек.ПроизвольныеКоды_Загрузка_ШапкаДокумента = ГлЯдро_ЗначениеИзСтрокиXML(СтруктураНастроек.ПроизвольныеКоды_Загрузка_ШапкаДокумента);		
		КонецЕсли;
		Если ТипЗнч(СтруктураНастроек.ПроизвольныеКоды_Загрузка_ШапкаДокумента) = Тип("ТаблицаЗначений") Тогда
			СтруктураНастроек.ПроизвольныеКоды_Загрузка_ШапкаДокумента = ГлЯдро_ТаблицуЗначенийВМассивСтруктур(СтруктураНастроек.ПроизвольныеКоды_Загрузка_ШапкаДокумента);
		КонецЕсли;
		Для каждого ПК Из СтруктураНастроек.ПроизвольныеКоды_Загрузка_ШапкаДокумента Цикл
			Если НЕ ПК.Свойство("ЭтоТаблицаЗначений") Тогда
				ПК.Вставить("Направление","Загрузка");
				ПК.Вставить("ТипОбъекта","Шапка");
				ПроизвольныеКоды_Пользовательские.Добавить(ПК);
			КонецЕсли;
		КонецЦикла;
		
	КонецЕсли;
	
	Если ЗначениеЗаполнено(СтруктураНастроек.ПроизвольныеКоды_Загрузка_ТабличнаяЧастьДокумента)
		И НЕ СтруктураНастроек.ПроизвольныеКоды_Загрузка_ТабличнаяЧастьДокумента = Ложь Тогда
		Если ТипЗнч(СтруктураНастроек.ПроизвольныеКоды_Загрузка_ТабличнаяЧастьДокумента) = Тип("Строка") Тогда
			СтруктураНастроек.ПроизвольныеКоды_Загрузка_ТабличнаяЧастьДокумента = ГлЯдро_ЗначениеИзСтрокиXML(СтруктураНастроек.ПроизвольныеКоды_Загрузка_ТабличнаяЧастьДокумента);		
		КонецЕсли;		
		Если ТипЗнч(СтруктураНастроек.ПроизвольныеКоды_Загрузка_ТабличнаяЧастьДокумента) = Тип("ТаблицаЗначений") Тогда
			СтруктураНастроек.ПроизвольныеКоды_Загрузка_ТабличнаяЧастьДокумента = ГлЯдро_ТаблицуЗначенийВМассивСтруктур(СтруктураНастроек.ПроизвольныеКоды_Загрузка_ТабличнаяЧастьДокумента);
		КонецЕсли;

		Для каждого ПК Из СтруктураНастроек.ПроизвольныеКоды_Загрузка_ТабличнаяЧастьДокумента Цикл
			Если НЕ ПК.Свойство("ЭтоТаблицаЗначений") Тогда
				ПК.Вставить("Направление","Загрузка");
				ПК.Вставить("ТипОбъекта","ТабличнаяЧасть");
				ПроизвольныеКоды_Пользовательские.Добавить(ПК);
			КонецЕсли;
		КонецЦикла;
		
	КонецЕсли;
	
	Если ПроизвольныеКоды_Пользовательские.Количество() > 0 Тогда
		ГлЯдро_СохранитьНастройкуВБазеSMARTS("ПроизвольныеКоды_Пользовательские", ПроизвольныеКоды_Пользовательские,,АдресаПеременных);
		ГлЯдро_ЗаписатьВКэшНастройкуSMARTS("ПроизвольныеКоды_Пользовательские", ПроизвольныеКоды_Пользовательские,АдресаПеременных);
	КонецЕсли;
	
КонецПроцедуры

Процедура ГлЯдро_СобратьОбщуюСтруктуруБизнесПроцессов(АдресаПеременных)
	
	ID_Узла = "";
	ДанныеТекущегоУзла = КомЯдро_ПолучитьЗначениеПеременной("ДанныеТекущегоУзла", АдресаПеременных);
	Если ТипЗнч(ДанныеТекущегоУзла) = Тип("Структура") И ДанныеТекущегоУзла.Свойство("ID_Узла") Тогда
		ID_Узла = ДанныеТекущегоУзла.ID_Узла;		
	КонецЕсли;
	
	НастройкиБизнесПроцессов = ГлЯдро_ПолучитьЗначениеКэшируемойНастройки("НастройкиБизнесПроцессов", ID_Узла, АдресаПеременных);
	Если ЗначениеЗаполнено(НастройкиБизнесПроцессов) И НЕ НастройкиБизнесПроцессов = Ложь Тогда
		ГлЯдро_ЗаписатьВКэшНастройкуSMARTS("НастройкиБизнесПроцессов", НастройкиБизнесПроцессов, АдресаПеременных);	
		Возврат;
	КонецЕсли;
	
	НастройкиБизнесПроцессов = Новый Массив();
	
	СтруктураНастроек_Пользовательские 			= ГлЯдро_ПолучитьИзКэшаСтруктуруПользовательскихНастроекБизнесПроцессов(АдресаПеременных);
	СтруктураНастроек_ПользовательскиеНастройки = ГлЯдро_ПолучитьИзКэшаСтруктуруИзмененныхТиповыхНастроекБизнесПроцессов(АдресаПеременных);
	СтруктураНастроек_ПоУмолчанию 				= ГлЯдро_ПолучитьИзКэшаСтруктуруНастроекПоУмолчаниюБизнесПроцессов(АдресаПеременных);
		
	НастройкиБизнесПроцессов_ПоУмолчанию 				= СтруктураНастроек_ПоУмолчанию.НастройкиБизнесПроцессов;
	НастройкиБизнесПроцессов_Пользовательские 			= СтруктураНастроек_Пользовательские.НастройкиБизнесПроцессов;
	НастройкиБизнесПроцессов_ПользовательскиеНастройки 	= СтруктураНастроек_ПользовательскиеНастройки.НастройкиБизнесПроцессов;
	
	ИдТиповыхБП = Новый Массив();
	
	Если ЗначениеЗаполнено(НастройкиБизнесПроцессов_ПоУмолчанию) И НЕ НастройкиБизнесПроцессов_ПоУмолчанию = Ложь Тогда
		Если ТипЗнч(НастройкиБизнесПроцессов_ПоУмолчанию) = Тип("Строка") Тогда
			НастройкиБизнесПроцессов_ПоУмолчанию = ГлЯдро_ЗначениеИзСтрокиXML(НастройкиБизнесПроцессов_ПоУмолчанию);		
		КонецЕсли;		
		Если ТипЗнч(НастройкиБизнесПроцессов_ПоУмолчанию) = Тип("ТаблицаЗначений") Тогда
			НастройкиБизнесПроцессов_ПоУмолчанию = ГлЯдро_ТаблицуЗначенийВМассивСтруктур(НастройкиБизнесПроцессов_ПоУмолчанию);
		КонецЕсли;
		Для Каждого СтрокаБП Из НастройкиБизнесПроцессов_ПоУмолчанию Цикл
			Если НЕ СтрокаБП.Свойство("ЭтоТаблицаЗначений") Тогда
				СтрокаБП.Вставить("ЭтоТиповойБизнесПроцесс",Истина);
				НастройкиБизнесПроцессов.Добавить(ГлЯдро_СкопироватьСтруктуру(СтрокаБП));
				ИдТиповыхБП.Добавить(СтрокаБП.ID_БизнесПроцесса);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(НастройкиБизнесПроцессов_Пользовательские) И НЕ НастройкиБизнесПроцессов_Пользовательские = Ложь Тогда
		Если ТипЗнч(НастройкиБизнесПроцессов_Пользовательские) = Тип("Строка") Тогда
			НастройкиБизнесПроцессов_Пользовательские = ГлЯдро_ЗначениеИзСтрокиXML(НастройкиБизнесПроцессов_Пользовательские);		
		КонецЕсли;		
		Если ТипЗнч(НастройкиБизнесПроцессов_Пользовательские) = Тип("ТаблицаЗначений") Тогда
			НастройкиБизнесПроцессов_Пользовательские = ГлЯдро_ТаблицуЗначенийВМассивСтруктур(НастройкиБизнесПроцессов_Пользовательские);
		КонецЕсли;
		Для Каждого СтрокаБП Из НастройкиБизнесПроцессов_Пользовательские Цикл
			Если ТипЗнч(СтрокаБП) <> Тип("Структура") Тогда
				Продолжить;
			КонецЕсли;
			Если НЕ СтрокаБП.Свойство("ЭтоТаблицаЗначений") Тогда
				СтрокаБП.Вставить("ЭтоТиповойБизнесПроцесс",Ложь);
				Если ИдТиповыхБП.Найти(СтрокаБП.ID_БизнесПроцесса) = Неопределено Тогда
					НастройкиБизнесПроцессов.Добавить(ГлЯдро_СкопироватьСтруктуру(СтрокаБП));
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	ЭтоГлавныйУзел = НЕ ЗначениеЗаполнено(ID_Узла);
	
	КатегорииНастроекMS = КомЯдро_ПолучитьЗначениеПеременной("КатегорииНастроекMS", АдресаПеременных);
	Если КатегорииНастроекMS = Неопределено Тогда
		КатегорииНастроекMS = ГлЯдро_ПолучитьКатегорииНастроекMS();
	КонецЕсли;
	
	ПользовательскиеНастройкиГлавногоУзла = КатегорииНастроекMS.ПользовательскиеНастройкиГлавногоУзла; 
	
	Если ЗначениеЗаполнено(НастройкиБизнесПроцессов_ПользовательскиеНастройки) И НЕ (НастройкиБизнесПроцессов_ПользовательскиеНастройки) = Ложь Тогда
		Если ТипЗнч(НастройкиБизнесПроцессов_ПользовательскиеНастройки) = Тип("Строка") Тогда
			НастройкиБизнесПроцессов_ПользовательскиеНастройки = ГлЯдро_ЗначениеИзСтрокиXML(НастройкиБизнесПроцессов_ПользовательскиеНастройки);		
		КонецЕсли;		
		Если ТипЗнч(НастройкиБизнесПроцессов_ПользовательскиеНастройки) = Тип("ТаблицаЗначений") Тогда
			НастройкиБизнесПроцессов_ПользовательскиеНастройки = ГлЯдро_ТаблицуЗначенийВМассивСтруктур(НастройкиБизнесПроцессов_ПользовательскиеНастройки);
		КонецЕсли;
		
		Для Каждого СтрокаБП Из НастройкиБизнесПроцессов_ПользовательскиеНастройки Цикл
			Если СтрокаБП.Свойство("ЭтоТаблицаЗначений") Тогда
				Продолжить;
			КонецЕсли;
			Если ЭтоГлавныйУзел И ИдТиповыхБП.Найти(СтрокаБП.ID_БизнесПроцесса) = Неопределено Тогда
				Продолжить;
			КонецЕсли;
			
			Индекс = неопределено;
			Икс = 0;
			Для каждого СтрокаНастройкиБП Из НастройкиБизнесПроцессов Цикл
				Если СтрокаНастройкиБП.Свойство("ID_БизнесПроцесса") И СтрокаНастройкиБП.ID_БизнесПроцесса = СтрокаБП.ID_БизнесПроцесса Тогда
					Индекс = Икс;
					Прервать;
				КонецЕсли;
				Икс=Икс+1;
			КонецЦикла;
			
			Если Индекс <> Неопределено Тогда
				НастройкиБизнесПроцессов[Индекс].Вставить("ПользовательскаяНастройка", Истина);
				Для Каждого КлючИЗначение Из СтрокаБП Цикл
					Если НЕ ЭтоГлавныйУзел И ПользовательскиеНастройкиГлавногоУзла.Найти(КлючИЗначение.Ключ) <> Неопределено Тогда
						Продолжить;
					КонецЕсли;
					
					НастройкиБизнесПроцессов[Индекс].Вставить(КлючИЗначение.Ключ, КлючИЗначение.Значение);
				КонецЦикла;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	НастройкиБизнесПроцессов_ПользовательскиеНастройки_ГлавныйУзел = Неопределено;
	Если НЕ ЭтоГлавныйУзел Тогда
		СтруктураНастроекБизнесПроцессов_ПользовательскиеНастройки_ГлавныйУзел = ГлЯдро_ПолучитьСтруктуруИзмененныхТиповыхНастроекБизнесПроцессовНаСервереSMARTS("", АдресаПеременных);
		НастройкиБизнесПроцессов_ПользовательскиеНастройки_ГлавныйУзел = СтруктураНастроекБизнесПроцессов_ПользовательскиеНастройки_ГлавныйУзел.НастройкиБизнесПроцессов; 
	КонецЕсли;
		
	Если ЗначениеЗаполнено(НастройкиБизнесПроцессов_ПользовательскиеНастройки_ГлавныйУзел) И НЕ (НастройкиБизнесПроцессов_ПользовательскиеНастройки_ГлавныйУзел) = Ложь Тогда
		Если ТипЗнч(НастройкиБизнесПроцессов_ПользовательскиеНастройки_ГлавныйУзел) = Тип("Строка") Тогда
			НастройкиБизнесПроцессов_ПользовательскиеНастройки_ГлавныйУзел = ГлЯдро_ЗначениеИзСтрокиXML(НастройкиБизнесПроцессов_ПользовательскиеНастройки_ГлавныйУзел);		
		КонецЕсли;		
		Если ТипЗнч(НастройкиБизнесПроцессов_ПользовательскиеНастройки_ГлавныйУзел) = Тип("ТаблицаЗначений") Тогда
			НастройкиБизнесПроцессов_ПользовательскиеНастройки = ГлЯдро_ТаблицуЗначенийВМассивСтруктур(НастройкиБизнесПроцессов_ПользовательскиеНастройки_ГлавныйУзел);
		КонецЕсли;
		
		Для Каждого СтрокаБП Из НастройкиБизнесПроцессов_ПользовательскиеНастройки_ГлавныйУзел Цикл
			Если СтрокаБП.Свойство("ЭтоТаблицаЗначений") Тогда
				Продолжить;
			КонецЕсли;
			
			Индекс = неопределено;
			Икс = 0;
			Для каждого СтрокаНастройкиБП Из НастройкиБизнесПроцессов Цикл
				Если СтрокаНастройкиБП.Свойство("ID_БизнесПроцесса") И СтрокаНастройкиБП.ID_БизнесПроцесса = СтрокаБП.ID_БизнесПроцесса Тогда
					Индекс = Икс;
					Прервать;
				КонецЕсли;
				Икс = Икс+1;
			КонецЦикла;
			
			Если Индекс <> Неопределено Тогда
				НастройкиБизнесПроцессов[Индекс].Вставить("ПользовательскаяНастройка", Истина);
				Для Каждого КлючИЗначение Из СтрокаБП Цикл
					Если ПользовательскиеНастройкиГлавногоУзла.Найти(КлючИЗначение.Ключ) = Неопределено Тогда
						Продолжить;
					КонецЕсли;
					
					НастройкиБизнесПроцессов[Индекс].Вставить(КлючИЗначение.Ключ, КлючИЗначение.Значение);
				КонецЦикла;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	ГлЯдро_ЗаписатьВКэшНастройкуSMARTS("НастройкиБизнесПроцессов", НастройкиБизнесПроцессов, АдресаПеременных);
	
	// Обновляем значения кэшируемых настроек
	ГлЯдро_СохранитьЗначениеКэшируемойНастройки("НастройкиБизнесПроцессов", НастройкиБизнесПроцессов, ID_Узла, АдресаПеременных);
	
	// Настройки кэшируются при получении из базы SMARTS и обновляются в кэше при сохранении в базу SMARTS
	//ГлЯдро_СохранитьЗначениеКэшируемойНастройки("НастройкиБизнесПроцессов_ПоУмолчанию", 					НастройкиБизнесПроцессов_ПоУмолчанию, 				ID_Узла, АдресаПеременных);
	//ГлЯдро_СохранитьЗначениеКэшируемойНастройки("НастройкиБизнесПроцессов_Пользовательские", 				НастройкиБизнесПроцессов_Пользовательские, 			ID_Узла, АдресаПеременных);
	//ГлЯдро_СохранитьЗначениеКэшируемойНастройки("НастройкиБизнесПроцессов_ПользовательскиеНастройки", 	НастройкиБизнесПроцессов_ПользовательскиеНастройки, ID_Узла, АдресаПеременных);
	
КонецПроцедуры

Процедура ГлЯдро_СобратьОбщуюСтруктуруПроизвольныхКодов(АдресаПеременных)
	
	ПроизвольныеКоды = ГлЯдро_ПолучитьЗначениеКэшируемойНастройки("ПроизвольныеКоды", "", АдресаПеременных);
	Если ЗначениеЗаполнено(ПроизвольныеКоды) И НЕ ПроизвольныеКоды = Ложь Тогда
		ГлЯдро_ЗаписатьВКэшНастройкуSMARTS("ПроизвольныеКоды", ПроизвольныеКоды, АдресаПеременных);	
		Возврат;
	КонецЕсли;
	
	ПроизвольныеКоды = Новый Массив();
	ПроизвольныеКоды_ПоУмолчанию = ГлЯдро_ПолучитьИзКэшаНастройкуSMARTS("ПроизвольныеКоды_ПоУмолчанию",,АдресаПеременных);
	ПроизвольныеКоды_Пользовательские = ГлЯдро_ПолучитьИзКэшаНастройкуSMARTS("ПроизвольныеКоды_Пользовательские",,АдресаПеременных);
	
	Если ЗначениеЗаполнено(ПроизвольныеКоды_ПоУмолчанию) И НЕ ПроизвольныеКоды_ПоУмолчанию = Ложь Тогда
		Если ТипЗнч(ПроизвольныеКоды_ПоУмолчанию) = Тип("Строка") Тогда
			ПроизвольныеКоды_ПоУмолчанию = ГлЯдро_ЗначениеИзСтрокиXML(ПроизвольныеКоды_ПоУмолчанию);
		КонецЕсли;
		Если ТипЗнч(ПроизвольныеКоды_ПоУмолчанию) = Тип("ТаблицаЗначений") Тогда
			ПроизвольныеКоды_ПоУмолчанию = ГлЯдро_ТаблицуЗначенийВМассивСтруктур(ПроизвольныеКоды_ПоУмолчанию);
		КонецЕсли;
		Для Каждого СтрокаПК Из ПроизвольныеКоды_ПоУмолчанию Цикл
			Если НЕ СтрокаПК.Свойство("ЭтоТаблицаЗначений") Тогда
				СтрокаПК.Вставить("ЭтоТиповой",Истина);
				ПроизвольныеКоды.Добавить(ГлЯдро_СкопироватьСтруктуру(СтрокаПК));
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ПроизвольныеКоды_Пользовательские) И НЕ ПроизвольныеКоды_Пользовательские = Ложь Тогда
		Если ТипЗнч(ПроизвольныеКоды_Пользовательские) = Тип("Строка") Тогда
			ПроизвольныеКоды_Пользовательские = ГлЯдро_ЗначениеИзСтрокиXML(ПроизвольныеКоды_Пользовательские);
		КонецЕсли;
		Если ТипЗнч(ПроизвольныеКоды_Пользовательские) = Тип("ТаблицаЗначений") Тогда
			ПроизвольныеКоды_Пользовательские = ГлЯдро_ТаблицуЗначенийВМассивСтруктур(ПроизвольныеКоды_Пользовательские);
		КонецЕсли;
		Для Каждого СтрокаПК Из ПроизвольныеКоды_Пользовательские Цикл
			Если НЕ СтрокаПК.Свойство("ЭтоТаблицаЗначений") Тогда
				СтрокаПК.Вставить("ЭтоТиповой",Ложь);
				ПроизвольныеКоды.Добавить(ГлЯдро_СкопироватьСтруктуру(СтрокаПК));
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	ГлЯдро_ЗаписатьВКэшНастройкуSMARTS("ПроизвольныеКоды", ПроизвольныеКоды,АдресаПеременных);

	// Обновляем значения кэшируемых настроек
	ГлЯдро_СохранитьЗначениеКэшируемойНастройки("ПроизвольныеКоды", 					ПроизвольныеКоды, 					"", АдресаПеременных);
	ГлЯдро_СохранитьЗначениеКэшируемойНастройки("ПроизвольныеКоды_ПоУмолчанию", 		ПроизвольныеКоды_ПоУмолчанию, 		"", АдресаПеременных);
	ГлЯдро_СохранитьЗначениеКэшируемойНастройки("ПроизвольныеКоды_Пользовательские", 	ПроизвольныеКоды_Пользовательские, 	"", АдресаПеременных);

КонецПроцедуры

Процедура ГлЯдро_СобратьОбщуюСтруктуруГлобальныхПараметров(АдресаПеременных)
	
	ГлобальныеПараметры = ГлЯдро_ПолучитьЗначениеКэшируемойНастройки("ГлобальныеПараметры", "", АдресаПеременных);
	Если ЗначениеЗаполнено(ГлобальныеПараметры) И НЕ ГлобальныеПараметры = Ложь Тогда
		ГлЯдро_ЗаписатьВКэшНастройкуSMARTS("ГлобальныеПараметры", ГлобальныеПараметры, АдресаПеременных);	
		Возврат;
	КонецЕсли;
	
	ГлобальныеПараметры = Новый Массив();
	ГлобальныеПараметры_ПоУмолчанию 	 = ГлЯдро_ПолучитьИзКэшаНастройкуSMARTS("ГлобальныеПараметры_ПоУмолчанию",, АдресаПеременных);
	ГлобальныеПараметры_Пользовательские = ГлЯдро_ПолучитьИзКэшаНастройкуSMARTS("ГлобальныеПараметры_Пользовательские",, АдресаПеременных);
	
	Если НЕ ЗначениеЗаполнено(ГлобальныеПараметры_ПоУмолчанию) ИЛИ ГлобальныеПараметры_ПоУмолчанию = Ложь Тогда
		ГлобальныеПараметры_ПоУмолчанию = ГлЯдро_ПолучитьНастройкуНаСервереSMARTS("ГлобальныеПараметры",, АдресаПеременных);
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ГлобальныеПараметры_ПоУмолчанию) И НЕ ГлобальныеПараметры_ПоУмолчанию = Ложь Тогда
		Если ТипЗнч(ГлобальныеПараметры_ПоУмолчанию) = Тип("Строка") Тогда
			ГлобальныеПараметры_ПоУмолчанию = ГлЯдро_ЗначениеИзСтрокиXML(ГлобальныеПараметры_ПоУмолчанию);
		КонецЕсли;
		Если ТипЗнч(ГлобальныеПараметры_ПоУмолчанию) = Тип("ТаблицаЗначений") Тогда
			ГлобальныеПараметры_ПоУмолчанию = ГлЯдро_ТаблицуЗначенийВМассивСтруктур(ГлобальныеПараметры_ПоУмолчанию);
		КонецЕсли;
		Для каждого СтрокаГП ИЗ ГлобальныеПараметры_ПоУмолчанию Цикл
			Если НЕ СтрокаГП.Свойство("ЭтоТаблицаЗначений") Тогда
				СтрокаГП.Вставить("Типовой", Истина);
				ГлобальныеПараметры.Добавить(ГлЯдро_СкопироватьСтруктуру(СтрокаГП));
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ГлобальныеПараметры_Пользовательские) И НЕ ГлобальныеПараметры_Пользовательские = Ложь Тогда
		Если ТипЗнч(ГлобальныеПараметры_Пользовательские) = Тип("Строка") Тогда
			ГлобальныеПараметры_Пользовательские = ГлЯдро_ЗначениеИзСтрокиXML(ГлобальныеПараметры_Пользовательские);
		КонецЕсли;
		Если ТипЗнч(ГлобальныеПараметры_Пользовательские) = Тип("ТаблицаЗначений") Тогда
			ГлобальныеПараметры_Пользовательские = ГлЯдро_ТаблицуЗначенийВМассивСтруктур(ГлобальныеПараметры_Пользовательские);
		КонецЕсли;
		Для каждого СтрокаГП ИЗ ГлобальныеПараметры_Пользовательские Цикл
			Если НЕ СтрокаГП.Свойство("ЭтоТаблицаЗначений") Тогда
				НайденныйПараметр = ГлЯдро_НайтиСтруктуруВМассивеПоЭлементу(ГлобальныеПараметры_ПоУмолчанию, "ID_Параметра", СтрокаГП.ID_Параметра);
				Если НайденныйПараметр <> Неопределено Тогда
					Продолжить;
				КонецЕсли;
				
				СтрокаГП.Вставить("Типовой", Ложь);
				ГлобальныеПараметры.Добавить(ГлЯдро_СкопироватьСтруктуру(СтрокаГП));
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	ГлЯдро_ЗаписатьВКэшНастройкуSMARTS("ГлобальныеПараметры", ГлобальныеПараметры, АдресаПеременных);
	
	// Обновляем значения кэшируемых настроек
	ГлЯдро_СохранитьЗначениеКэшируемойНастройки("ГлобальныеПараметры", ГлобальныеПараметры, "", АдресаПеременных);
	
	// Настройки кэшируются при получении из базы SMARTS и обновляются в кэше при сохранении в базу SMARTS
	//ГлЯдро_СохранитьЗначениеКэшируемойНастройки("ГлобальныеПараметры_ПоУмолчанию", 		ГлобальныеПараметры_ПоУмолчанию, 		"", АдресаПеременных);
	//ГлЯдро_СохранитьЗначениеКэшируемойНастройки("ГлобальныеПараметры_Пользовательские", ГлобальныеПараметры_Пользовательские, 	"", АдресаПеременных);
	
КонецПроцедуры

// Выполняет автоматическое подключение расширений
//
// Параметры:
//  МассивФайловРасширений  - Массив - массив, содержащий элементы ОписаниеПереданногоФайла либо структуры, 
//										в которых обязательно должны быть ключи: Хранение - адрес файла в хранилище, Имя - имя файла
//
// Возвращаемое значение:
//   Массив   - см. описание ГлЯдро_ПодключитьРасширения 
//
Функция ГлЯдро_ПодключитьРасширенияАвтоматическиЗавершение(МассивФайловРасширений = Неопределено, АдресаПеременных) Экспорт
	
	#Область НесовместимыйКодFresh
	Если МассивФайловРасширений = Неопределено Тогда
		//Здесь можно получить файлы, доступные на сервере
	КонецЕсли;
	
	РезультатыПодключений = ГлЯдро_ПодключитьРасширения(МассивФайловРасширений,, АдресаПеременных);
	
	Возврат РезультатыПодключений;
	#КонецОбласти //НесовместимыйКодFresh
	
КонецФункции

// Выполняет подключение расширений
//
// Параметры:
//  МассивФайловРасширений  - Массив - массив, содержащий элементы ОписаниеПереданногоФайла либо структуры, 
//										в которых обязательно должны быть ключи: Хранение - адрес файла в хранилище, Имя - имя файла
//  РасширениеФайла  - Строка - строка расширения файла, по умолчанию "cfe" 
//
// Возвращаемое значение:
//   Массив   - массив структур следующего формата: 
//		ИмяРасширения 			- Строка - имя расширения
//		ВерсияРасширения 		- Строка - версия успешно подключенного расширения
//		Подключено 				- Булево - признак успешности подключения расширения
//		ТекстОшибки 			- Строка - Текст ошибки
//
Функция ГлЯдро_ПодключитьРасширения(МассивФайловРасширений, РасширениеФайла = "cfe", АдресаПеременных) Экспорт
	
	#Область НесовместимыйКодFresh
	ИмяСобытия = "ГлЯдро_ПодключитьРасширения";
	РезультатыПодключений = Новый Массив;

	Для Каждого ФайлРасширения Из МассивФайловРасширений Цикл
				
		Попытка
			
			ИмяБезРасширения 		= "";
			ИмяБезРасширения 		= СтрЗаменить(ФайлРасширения.Имя, "." + РасширениеФайла, "");
			Подключено 				= Ложь;
			ТекстОшибки 			= "";
			Версия 					= "0.0.0.0";
			
			НовыеДвоичныеДанные = ПолучитьИзВременногоХранилища(ФайлРасширения.Хранение);
			ИмяВременногоФайла = ПолучитьИмяВременногоФайла(РасширениеФайла);
			НовыеДвоичныеДанные.Записать(ИмяВременногоФайла);
			
			Попытка
				МетаданныеРасширения = Вычислить("Новый ОбъектМетаданныхКонфигурация(НовыеДвоичныеДанные)");
				ПоставщикРасширения = МетаданныеРасширения.Поставщик;
			Исключение
				ПоставщикРасширения = "Клеверенс"; // Считаем, что это наше расширение
			КонецПопытки;

			Если ВРег(ПоставщикРасширения) <> "КЛЕВЕРЕНС" Тогда
				ВызватьИсключение "Расширение выпущено не компанией ""Клеверенс""";	
			КонецЕсли;

			МассивРасширений = РасширенияКонфигурации.Получить(Новый Структура("Имя", ИмяБезРасширения));
			
			Если МассивРасширений.Количество() = 0 Тогда
				РасширениеОбъект = РасширенияКонфигурации.Создать();
			Иначе
				РасширениеОбъект = МассивРасширений[0];				
			КонецЕсли;
						
			РасширениеОбъект.БезопасныйРежим = Ложь;
			
			РасширениеОбъект.ЗащитаОтОпасныхДействий.ПредупреждатьОбОпасныхДействиях = Ложь;
						
			Ошибки = РасширениеОбъект.ПроверитьВозможностьПрименения(НовыеДвоичныеДанные, Ложь);
			Для Каждого Ошибка Из Ошибки Цикл
				Если Ошибка.Важность <> Вычислить("ВажностьПроблемыПримененияРасширенияКонфигурации.Критичная") Тогда
					Продолжить;
				КонецЕсли;
				ТекстОшибки = ТекстОшибки + Символы.ПС + Ошибка.Описание;
			КонецЦикла;
			
			Если ЗначениеЗаполнено(ТекстОшибки) Тогда
				ТекстОшибки = "Расширение не может быть применено по причине: " + ТекстОшибки;
				ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации("Подключение расширений", "Предупреждение", ТекстОшибки,, АдресаПеременных);
			Иначе
				
				РасширениеОбъект.Записать(НовыеДвоичныеДанные);
				// После записи расширения версия не обновляется, поэтому получим новую версию через РасширенияКонфигурации
				МассивРасширений = РасширенияКонфигурации.Получить(Новый Структура("Имя", ИмяБезРасширения));
				Если МассивРасширений.Количество() <> 0 Тогда
					Версия = МассивРасширений[0].Версия;
				КонецЕсли;
				
				Подключено = Истина;
				
			КонецЕсли;
			
			Файл = Новый Файл(ИмяВременногоФайла);
			
			Если Файл.Существует() Тогда
				УдалитьФайлы(ИмяВременногоФайла);			
			КонецЕсли;

		Исключение
			
			Подключено = Ложь;
			ТекстОшибки = "Ошибка подключения расширения: " + ИмяБезРасширения + ". " + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
			ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Предупреждение", ТекстОшибки,, АдресаПеременных);			
			
		КонецПопытки;
		
		РезультатПодключения = Новый Структура;
		РезультатПодключения.Вставить("ИмяРасширения", 			ИмяБезРасширения);
		РезультатПодключения.Вставить("Подключено", 			Подключено);
		РезультатПодключения.Вставить("ТекстОшибки", 			ТекстОшибки);
		РезультатПодключения.Вставить("Версия", 				Версия);
		
		РезультатыПодключений.Добавить(РезультатПодключения);
		
	КонецЦикла;
	
	Возврат РезультатыПодключений;
	#КонецОбласти //НесовместимыйКодFresh
	
КонецФункции

Функция ГлЯдро_ТаймаутыПоУмолчанию(АдресаПеременных) Экспорт
		
	МассивТаймаутов = Новый Массив;
	МассивТаймаутов.Добавить(Новый Структура("ЭтоТаблицаЗначений,КолонкиТаблицыЗначений",Истина,"ТипЗапроса,ТипЗапросаСиноним,Значение,Комментарий"));
	
	МассивТаймаутов.Добавить(Новый Структура("ТипЗапроса,ТипЗапросаСиноним,Значение,Комментарий", "ПоУмолчанию",				"По умолчанию",					30,	""));
	МассивТаймаутов.Добавить(Новый Структура("ТипЗапроса,ТипЗапросаСиноним,Значение,Комментарий", "ПроверкаСоединения",			"Проверка соединения",			30,	""));
	МассивТаймаутов.Добавить(Новый Структура("ТипЗапроса,ТипЗапросаСиноним,Значение,Комментарий", "ПолучениеМетаданных",		"Получение метаданных",			10,	""));
	МассивТаймаутов.Добавить(Новый Структура("ТипЗапроса,ТипЗапросаСиноним,Значение,Комментарий", "ПолучениеСохранениеНастроек","Получение,сохранение настроек",90,	""));
	МассивТаймаутов.Добавить(Новый Структура("ТипЗапроса,ТипЗапросаСиноним,Значение,Комментарий", "НачалоВыгрузкиТаблицы",		"Начало выгрузки таблицы",		7,	""));
	МассивТаймаутов.Добавить(Новый Структура("ТипЗапроса,ТипЗапросаСиноним,Значение,Комментарий", "ВыгрузкаТаблицы",			"Выгрузка строк таблицы",		90,	""));
	МассивТаймаутов.Добавить(Новый Структура("ТипЗапроса,ТипЗапросаСиноним,Значение,Комментарий", "КонецВыгрузкиТаблицы",		"Конец выгрузки таблицы",		90,	""));
	МассивТаймаутов.Добавить(Новый Структура("ТипЗапроса,ТипЗапросаСиноним,Значение,Комментарий", "ВыгрузкаШапкиДокумента",		"Выгрузка шапки документа",		7,	""));
	МассивТаймаутов.Добавить(Новый Структура("ТипЗапроса,ТипЗапросаСиноним,Значение,Комментарий", "ВыгрузкаСтрокДокумента",		"Выгрузка строк документа",		90,	""));
	МассивТаймаутов.Добавить(Новый Структура("ТипЗапроса,ТипЗапросаСиноним,Значение,Комментарий", "ПолучениеШапкиДокумента",	"Получение шапки документа",	7,	""));
	МассивТаймаутов.Добавить(Новый Структура("ТипЗапроса,ТипЗапросаСиноним,Значение,Комментарий", "ПолучениеПолногоДокумента",	"Получение полного документа",	90,	""));
	МассивТаймаутов.Добавить(Новый Структура("ТипЗапроса,ТипЗапросаСиноним,Значение,Комментарий", "ПолучениеСпискаДокументов",	"Получение списка документов",	90,	""));
	
	Возврат МассивТаймаутов;
		
КонецФункции

Процедура ГлЯдро_ПолучитьДанныеДляИнициализацииВФоне(Знач Параметры, Знач АдресРезультата) Экспорт

	ИмяСобытия = "ГлЯдро_ПолучитьДанныеДляИнициализацииВФоне";
	
	ЗаполнятьДанные 				= Параметры.ЗаполнятьДанные;
	// Вместо адресов переменных используем значения переменных, т.к. ФЗ выполняется в другом сеансе, 
	// поэтому временное хранилище родительского сеанса не доступно в сеансе ФЗ
	АдресаПеременных 				= Параметры.ЗначенияПеременных;
	МассивАдресовПустыхЗначений 	= Параметры.МассивАдресовПустыхЗначений;
	
	АдресаПеременных.Вставить("ЭтоФоновоеЗадание", Истина);
	ДанныеДляИнициализации = ГлЯдро_ПолучитьДанныеДляИнициализации(ЗаполнятьДанные, АдресаПеременных);
	АдресаПеременных.Удалить("ЭтоФоновоеЗадание");

    ГлЯдро_ПересохранитьЗначенияПеременныхВФЗ(АдресаПеременных, МассивАдресовПустыхЗначений);
	
	СтруктураРезультата = Новый Структура;
	СтруктураРезультата.Вставить("ДанныеДляИнициализации", 	ДанныеДляИнициализации);
	СтруктураРезультата.Вставить("АдресаПеременных", 		АдресаПеременных);
	
	ПоместитьВоВременноеХранилище(СтруктураРезультата, АдресРезультата);
	
КонецПроцедуры

Процедура ГлЯдро_ОбновитьМетаданныеДокументов1СВФоне(Знач Параметры, Знач АдресРезультата) Экспорт

	// Использование переменной АдресаПеременных в данном методе не требуется
	
	Документы1С = ГлЯдро_ОбновитьМетаданныеДокументов1С(Ложь, Неопределено);
	
	СтруктураРезультата = Новый Структура;
	СтруктураРезультата.Вставить("Документы1С", Документы1С);
	
	ПоместитьВоВременноеХранилище(СтруктураРезультата, АдресРезультата);
	
КонецПроцедуры

Функция ГлЯдро_ОбновитьМетаданныеДокументов1С(ИспользоватьХранилищеНастроек = Истина, АдресаПеременных) Экспорт
	
	ВерсияМетаданных1С = Метаданные.Версия;
	
	Если ИспользоватьХранилищеНастроек Тогда
		СохраненнаяВерсияМетаданных1С = ГлЯдро_ПолучитьДанныеИзХранилища1С("Cleverence_ВерсияМетаданных1С");
		Если НЕ ЗначениеЗаполнено(СохраненнаяВерсияМетаданных1С)
			ИЛИ СокрЛП(СохраненнаяВерсияМетаданных1С) <> СокрЛП(ВерсияМетаданных1С) Тогда
			ИспользоватьХранилищеНастроек = Ложь;
		КонецЕсли;
	КонецЕсли;
	
	Если ИспользоватьХранилищеНастроек Тогда
		Документы1С = ГлЯдро_ПолучитьДанныеИзХранилища1С("Cleverence_СтруктураМетаданных1С");
		Если ТипЗнч(Документы1С) = Тип("Структура")	И Документы1С.Количество() Тогда
			Возврат Документы1С;
		КонецЕсли;	
	КонецЕсли;		
		
	Документы1С = ГлЯдро_ПолучитьМетаданныеДокументов1С();
		
	ГлЯдро_СохранитьДанныеВХранилище1С("Cleverence_ВерсияМетаданных1С", 	ВерсияМетаданных1С);
	ГлЯдро_СохранитьДанныеВХранилище1С("Cleverence_СтруктураМетаданных1С", 	Документы1С);
	
	Возврат Документы1С;
	
КонецФункции

Функция ГлЯдро_ОбновитьМетаданныеДокументовMS(ИспользоватьХранилищеНастроек = Истина, АдресаПеременных) Экспорт

	ЕстьЧастнаяБаза = КомЯдро_ПолучитьЗначениеПеременной("ЕстьЧастнаяБаза", АдресаПеременных);
	Если ЕстьЧастнаяБаза = Истина Тогда
		ТипБазы = "Частная";
    Иначе
		ТипБазы = "Основная";
    КонецЕсли;
	
    ИдентификаторБазыMS = "";
	ВерсияМетаданныхMS  = "";
		
	ТипИнтерфейса = ГлЯдро_ПолучитьДанныеИзХранилища1С("Cleverence_ТипИнтерфейса");
	Если ТипИнтерфейса = "REST_API"	Тогда
		ПараметрыПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("ПараметрыПодключенияMS", АдресаПеременных);
		Если ПараметрыПодключенияMS = Неопределено Тогда
			ПараметрыПодключенияMS = ГлЯдро_ПолучитьДанныеИзХранилища1С("Cleverence_ПараметрыПодключенияMS");	
		КонецЕсли;
		Если ТипЗнч(ПараметрыПодключенияMS) = Тип("Структура") Тогда
			ИдентификаторБазыMS = ?(ПараметрыПодключенияMS.Свойство("Ид"), ПараметрыПодключенияMS.Ид, "");
			ВерсияМетаданныхMS =  ?(ПараметрыПодключенияMS.Свойство("ВерсияКонфигурацииSMARTS"), ПараметрыПодключенияMS.ВерсияКонфигурацииSMARTS, "");
		КонецЕсли;
	Иначе
		Если ТипБазы = "Частная" Тогда
			СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("COMЧастнойБазыMS", АдресаПеременных);
		Иначе
			СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("COMБазыMS", АдресаПеременных);
		КонецЕсли;
	    ИдентификаторБазыMS = СтруктураПодключенияMS.StorageConnector.CurrentAppSettings.ServerAppInstanceId;
		ВерсияМетаданныхMS  = СтруктураПодключенияMS.StorageConnector.GetEnvironment().Version;
		ВерсияМетаданныхMS 	= Формат(ВерсияМетаданныхMS, "ЧГ=0");
	КонецЕсли;	
	
	Если НЕ ЗначениеЗаполнено(ВерсияМетаданныхMS) Тогда
		ИспользоватьХранилищеНастроек = Ложь;	
	КонецЕсли;
	
	ИдентификаторБазыMS = СтрЗаменить(ИдентификаторБазыMS, "-", "_");
	
	ИмяПеременнойВерсия 	= "Cleverence_ВерсияМетаданныхMS_" 	  + ИдентификаторБазыMS;
	ИмяПеременнойНастройки 	= "Cleverence_СтруктураМетаданныхMS_" + ИдентификаторБазыMS;
	
	Если ИспользоватьХранилищеНастроек Тогда
		СохраненнаяВерсияМетаданныхMS = ГлЯдро_ПолучитьДанныеИзХранилища1С(ИмяПеременнойВерсия);
		Если НЕ ЗначениеЗаполнено(СохраненнаяВерсияМетаданныхMS)
			ИЛИ СокрЛП(СохраненнаяВерсияМетаданныхMS) <> СокрЛП(ВерсияМетаданныхMS) Тогда
			ИспользоватьХранилищеНастроек = Ложь;
		КонецЕсли;
	КонецЕсли;
	
	Если ИспользоватьХранилищеНастроек Тогда
		Если ТипИнтерфейса = "REST_API" Тогда
			пСтруктураМетаданных = REST_API_ПолучитьМетаданныеMSИзХранилища1С(ТипБазы, ИмяПеременнойНастройки, АдресаПеременных);
		Иначе
			пСтруктураМетаданных = КомЯдро_ПолучитьМетаданныеMSИзХранилища1С(ТипБазы, ИмяПеременнойНастройки, АдресаПеременных);
		КонецЕсли;
			
		Если пСтруктураМетаданных <> Неопределено Тогда
			Возврат пСтруктураМетаданных;
		КонецЕсли;
	КонецЕсли;
	
	Если ТипИнтерфейса = "REST_API" Тогда
		пСтруктураМетаданных = REST_API_ПолучитьМетаданныеДокументовMS(ТипБазы, ИмяПеременнойНастройки, АдресаПеременных);
	Иначе
		пСтруктураМетаданных = КомЯдро_ПолучитьМетаданныеДокументовMS(ТипБазы, ИмяПеременнойНастройки, АдресаПеременных);
	КонецЕсли;
	
	ГлЯдро_СохранитьДанныеВХранилище1С(ИмяПеременнойВерсия, ВерсияМетаданныхMS);
	
	Возврат пСтруктураМетаданных;
	
КонецФункции

Функция ГлЯдро_СоответствиеСправочниковКлючамИспользованияПоУмолчанию(АдресаПеременных) Экспорт
	СоответствиеСправочников = Новый Соответствие;
	СоответствиеСправочников.Вставить("Номенклатура",	"ВыгружатьНоменклатуруСразу");
	СоответствиеСправочников.Вставить("Контрагенты",	"ВыгружатьКонтрагентовСразу");
	СоответствиеСправочников.Вставить("Остатки",		"ВыгружатьОстаткиСразу");
	СоответствиеСправочников.Вставить("Серии",			"ВыгружатьСерииСразу");
	СоответствиеСправочников.Вставить("Склады",			"ВыгружатьСкладыСразу");
	//СоответствиеСправочников.Вставить("ФормыА",			"ВыгружатьФормыАСразу");
	СоответствиеСправочников.Вставить("Характеристики",	"ВыгружатьХарактеристикиСразу");
	СоответствиеСправочников.Вставить("Цены",			"ВыгружатьЦеныСразу");
	СоответствиеСправочников.Вставить("БутылкиЕГАИС",	"ВыгружатьАкцизныеМаркиСразу");
	СоответствиеСправочников.Вставить("КоробкиЕГАИС",	"ВыгружатьКоробкиСразу");
	СоответствиеСправочников.Вставить("Ячейки",			"ВыгружатьЯчейкиСразу");
	СоответствиеСправочников.Вставить("ОстаткиПоЯчейкам","ВыгружатьОстаткиПоЯчейкамСразу");
	СоответствиеСправочников.Вставить("ДопРеквизиты",	"ВыгружатьДополнительнуюИнформациюСразу");
	СоответствиеСправочников.Вставить("КИЗ",			"ВыгружатьКИЗСразу");
	СоответствиеСправочников.Вставить("ТранспортныеУпаковки","ВыгружатьТранспортныеУпаковкиСразу");
	
	Возврат СоответствиеСправочников; 	
КонецФункции

#КонецОбласти

#Область ГлобальныйКонтекст_Настройки_ЧтениеНастроек

// Вызывает процедуру сохранения данных для инициализации во временном хранилище
//
// Параметры:
//	ДанныеДляИнициализации - Структура - см. ГлЯдро_ПолучитьДанныеДляИнициализации	
//	АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
Процедура ГлЯдро_ОтправитьДанныеДляИнициализацииВГлКонтекст(ДанныеДляИнициализации,АдресаПеременных) Экспорт
	КомЯдро_СохранитьЗначениеПеременной("ТекущиеНастройкиMS",ДанныеДляИнициализации.ТекущиеНастройкиMS,АдресаПеременных);
	КомЯдро_СохранитьЗначениеПеременной("СтруктураМетаданных",ДанныеДляИнициализации.СтруктураМетаданных,АдресаПеременных);
	КомЯдро_СохранитьЗначениеПеременной("ДанныеТекущегоУзла",ДанныеДляИнициализации.ДанныеТекущегоУзла,АдресаПеременных);
	КомЯдро_СохранитьЗначениеПеременной("НастройкиИнициализированы",Истина,АдресаПеременных);		
КонецПроцедуры

// В COM-соединении вызывает функцию получения настроек всех баз из списка на сервере Mobile Smarts
//
// Параметры:
//	Полное - Булево - признак того, возвращается для каждой базы из списка полное (Истина) либо краткое (Ложь) описание
//	АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
//
// Возвращаемое значение:
//	Массив из Структура - см. КомЯдро_ПолучитьСписокБазНаСервереSMARTS
Функция ГлЯдро_ПолучитьСписокБазНаСервереSMARTS(Полное,АдресаПеременных) Экспорт
	Возврат КомЯдро_ПолучитьСписокБазНаСервереSMARTS(Полное,АдресаПеременных);
КонецФункции

// Вызывает функцию получения настроек на сервере Mobile Smarts и конвертации сериализуемых настроек
//
// Параметры:
//	СтруктураНастроек - Структура - ключами являются имена настроек Mobile Smarts, значения которых необходимо получить
//  УзловыеНастройки - Неопределено, Структура - ключами являются имена узловых настроек Mobile Smarts - см. ГлЯдро_ПолучитьКатегорииНастроекMS
//  ID_Узла - Строка - идентификатор узла в текущей сессии Mobile Smarts
//	АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
//
// Возвращаемое значение:
//	Структура - ключами являются имена настроек Mobile Smarts, переданные в параметре СтруктураНастроек, 
//				значениями - соответствующие значения полученных настроек
Функция ГлЯдро_ПолучитьНастройкиНаСервереSMARTS(СтруктураНастроек, УзловыеНастройки = Неопределено, ID_Узла = "", АдресаПеременных) Экспорт
	
	НачалоСобытия = ТекущаяУниверсальнаяДатаВМиллисекундах();
	ИмяСобытия = "ГлЯдро_ПолучитьНастройкиНаСервереSMARTS";
	
	ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Начало, Получение настроек на сервере SMARTS", , АдресаПеременных);
	
	ТекстСообщения = "";
	Если ТипЗнч(СтруктураНастроек) = Тип("Структура") Тогда
		Для каждого Настройка ИЗ СтруктураНастроек Цикл
			ТекстСообщения = ТекстСообщения + ?(ПустаяСтрока(ТекстСообщения), "", ", ") + Строка(Настройка.Ключ);
		КонецЦикла;
	КонецЕсли;
	ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Получаемые настройки: " + ТекстСообщения, , АдресаПеременных);
	
	Если УзловыеНастройки = Неопределено Тогда
		КатегорииНастроекMS = КомЯдро_ПолучитьЗначениеПеременной("КатегорииНастроекMS",АдресаПеременных);
		УзловыеНастройки = КатегорииНастроекMS.УзловыеНастройки;
	КонецЕслИ;
	
	// Получаем значения кэшируемых настроек, которые не нужно запрашивать и конвертировать
	АктуальныеНастройки = ГлЯдро_ПроверитьАктуальностьКэшируемыхНастроек(СтруктураНастроек, ID_Узла, АдресаПеременных);
	Для каждого АктуальнаяНастройка ИЗ АктуальныеНастройки Цикл	
		СтруктураНастроек.Удалить(АктуальнаяНастройка.Ключ);
	КонецЦикла;
	
	ТипИнтерфейса = КомЯдро_ПолучитьЗначениеПеременной("ТипИнтерфейса",АдресаПеременных);
	Если ТипИнтерфейса = "REST_API" Тогда
		СтруктураНастроек = REST_API_ЗаполнитьНастройкиSMARTS(СтруктураНастроек, УзловыеНастройки, ID_Узла,,, АдресаПеременных);
	Иначе
		СтруктураНастроек = КомЯдро_ЗаполнитьНастройкиSMARTS(СтруктураНастроек, УзловыеНастройки, ID_Узла,, АдресаПеременных);
	КонецЕсли;
	СтруктураНастроек = ГлЯдро_КонвертироватьСериализуемыеНастройки(СтруктураНастроек, "ИзСтроки",,Истина);
	
	// Кэшируем полученные из базы настройки
	ГлЯдро_СохранитьЗначенияКэшируемыхНастроек(СтруктураНастроек, ID_Узла, АдресаПеременных);
	
	// Дополняем возвращаемую структуру актуальными кэшируемыми настройками
	Для каждого АктуальнаяНастройка ИЗ АктуальныеНастройки Цикл	
		СтруктураНастроек.Вставить(АктуальнаяНастройка.Ключ, АктуальнаяНастройка.Значение);
	КонецЦикла;
	
	ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Конец, Получение настроек на сервере SMARTS", НачалоСобытия, АдресаПеременных);
	
	Возврат СтруктураНастроек;
	
КонецФункции

// Вызывает функцию получения настройки из базы Mobile Smarts по ключу
//
// Параметры:
//	КлючНастройки - Строка - имя настройки Mobile Smarts, которую необходимо получить
//	ID_Узла - Строка - идентификатор узла в текущей сессии Mobile Smarts
//  АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
//
// Возвращаемое значение:
//	Произвольный - значение настройки Mobile Smarts, переданной в параметре КлючНастройки 
Функция ГлЯдро_ПолучитьНастройкуНаСервереSMARTS(КлючНастройки, ID_Узла = "",АдресаПеременных) Экспорт
	
	СтруктураНастроек = Новый Структура(КлючНастройки, Ложь);
	СтруктураНастроек = ГлЯдро_ПолучитьНастройкиНаСервереSMARTS(СтруктураНастроек,, ID_Узла,АдресаПеременных);
	
	Возврат СтруктураНастроек[КлючНастройки];
	
КонецФункции

// Получает значение настройки Mobile Smarts из кэша
//
// Параметры:
//	КлючНастройки - Строка - имя настройки Mobile Smarts, которую необходимо получить
//  ВернутьМассивСтруктур - Булево - определяет, будет возвращено значение табличной настройки в виде массива структур (Истина) или таблицы значений (Ложь)
//	АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
//
// Возвращаемое значение:
//	Произвольный - значение настройки Mobile Smarts, переданной в параметре КлючНастройки
Функция ГлЯдро_ПолучитьИзКэшаНастройкуSMARTS(КлючНастройки,ВернутьМассивСтруктур = Ложь,АдресаПеременных) Экспорт
	
	ЗначениеНастройки = Ложь;
	
	ТекущиеНастройкиMS = КомЯдро_ПолучитьЗначениеПеременной("ТекущиеНастройкиMS",АдресаПеременных);
	
	Если ТекущиеНастройкиMS = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	НайденноеЗначение = Неопределено;
	Если ТекущиеНастройкиMS.Свойство(КлючНастройки, НайденноеЗначение) Тогда
		ЗначениеНастройки = НайденноеЗначение;
	КонецЕсли;
	
	Если ВернутьМассивСтруктур = Истина Тогда
	   
		ЗначениеНастройки = ГлЯдро_ТаблицуЗначенийВМассивСтруктур(ЗначениеНастройки);
	
	КонецЕсли;
	
	Возврат ЗначениеНастройки;
	
КонецФункции

// Получает из кэша значение табличной настройки Mobile Smarts или значение ее отдельной колонки с возможностью выполнения отбора
//
// Параметры:
//	КлючТаблицы	- Строка - имя табличной настройки Mobile Smarts, из которой необходимо получить данные
//  Отбор - Структура - в качестве ключей содержит имена колонок табличной настройки Mobile Smarts, в качестве
//						значений - значения соответствующих колонок, по которым необходимо выполнить отбор
//  ИмяКолонки - Строка - имя колонки табличной настройки Mobile Smarts, значение которой необходимо вернуть
//	АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
//
// Возвращаемое значение:
//	- ТаблицаЗначений - если значение полученной настройки хранится в кэше в виде таблицы значений
//	- Массив из Структура - если значение полученной настройки хранится в кэше в виде массива структур
//	- Произвольный - если запрошено значение одной колонки
//  - Неопределено - если значение настройки получить не удалось
Функция ГлЯдро_ПолучитьИзКэшаЗначениеТабличнойНастройкиSMARTS(КлючТаблицы, Отбор, ИмяКолонки = "",АдресаПеременных) Экспорт
	
	Результат = Неопределено;
	
	ТаблицаНастроек = ГлЯдро_ПолучитьИзКэшаНастройкуSMARTS(КлючТаблицы,,АдресаПеременных);
	РезультатОтбора = Новый Массив;
	СтруктураТЗ = Неопределено;	
	Если ТипЗнч(ТаблицаНастроек) = Тип("ТаблицаЗначений") Тогда
		РезультатОтбора = ТаблицаНастроек.Скопировать(Отбор);
		Если РезультатОтбора.Количество() > 0 Тогда
			Если ЗначениеЗаполнено(ИмяКолонки) Тогда
				Результат = ?(РезультатОтбора.Количество() = 1, РезультатОтбора[0][ИмяКолонки], "");
			Иначе
				Результат = РезультатОтбора;
			КонецЕсли;
		КонецЕсли;
	ИначеЕсли ТипЗнч(ТаблицаНастроек) = Тип("Массив") Тогда
		Для Каждого ЭлементМассива Из ТаблицаНастроек Цикл
			Если ЭлементМассива.Свойство("КолонкиТаблицыЗначений") Тогда
				СтруктураТЗ = ЭлементМассива;
				Продолжить;
			КонецЕсли;
			Подходит = Истина;
			Для Каждого ЭлементОтбора из Отбор Цикл
				Если НЕ (ЭлементМассива.Свойство(ЭлементОтбора.Ключ) 
					И ЭлементМассива[ЭлементОтбора.Ключ] = ЭлементОтбора.Значение) Тогда
					Подходит = Ложь;
					Продолжить;
				КонецЕсли;
			КонецЦикла;
			Если Подходит Тогда
				РезультатОтбора.Добавить(ЭлементМассива);
			КонецЕсли;
		КонецЦикла;
		Если РезультатОтбора.Количество() > 0 Тогда
			Если ЗначениеЗаполнено(ИмяКолонки) Тогда
				Результат = ?(РезультатОтбора.Количество() = 1, РезультатОтбора[0][ИмяКолонки], "");
			Иначе
				Если СтруктураТЗ <> Неопределено Тогда
					РезультатОтбора.Вставить(0,СтруктураТЗ);
				КонецЕсли;
				Результат = РезультатОтбора;
			КонецЕсли;
		КонецЕсли	
	КонецЕсли;	
	
	Возврат Результат;
	
КонецФункции

// Получает настройку из хранилища общих настроек
//
// Параметры:
//	КлючДляПолучения - Строка - имя настройки, которую необходимо получить	
//	ПолучитьПользовательскуюИОбщуюНастройку - определяет, нужно ли получить пользовательскую и общую настройку (Истина) или одну из них (Ложь)
//
// Возвращаемое значение:
//	- Структура - содержит:
//		* ПользовательскаяНастройка - Произвольный - значение пользовательской настройки
//      * ОбщаяНастройка - Произвольный - значение общей настройки
//	- Произвольный - значение пользовательской или - при отсутствии пользовательской - общей настройки
Функция ГлЯдро_ПолучитьДанныеИзХранилища1С(КлючДляПолучения, ПолучитьПользовательскуюИОбщуюНастройку = Ложь) Экспорт
	
	Если ПравоДоступа("АдминистрированиеДанных", Метаданные)  Тогда
		
		ПользовательскаяНастройка = ХранилищеОбщихНастроек.Загрузить(КлючДляПолучения);
		
		Если ПользовательскаяНастройка = Неопределено Тогда
			// Получение настройки по старому имени пользователя и пересохранение по новому
			НазваниеПараметраТекущегоПользователя = "ТекущийПользователь";
			Если Метаданные.ПараметрыСеанса.Найти("ТекущийПользователь") = Неопределено Тогда
				
				Если Метаданные.ПараметрыСеанса.Найти("глТекущийПользователь") <> Неопределено Тогда
					НазваниеПараметраТекущегоПользователя = "глТекущийПользователь"; // В Штрих-М 5.2 используется такой параметр
				ИначеЕсли Метаданные.ПараметрыСеанса.Найти("Пользователь") <> Неопределено Тогда
					НазваниеПараметраТекущегоПользователя = "Пользователь"; // В Альфа-Авто 5.1 используется такой параметр			
				КонецЕсли;
				
			КонецЕсли;
			
			ПользовательскаяНастройка = ХранилищеОбщихНастроек.Загрузить(КлючДляПолучения,,,ПараметрыСеанса[НазваниеПараметраТекущегоПользователя].Наименование);
			Если ПользовательскаяНастройка <> Неопределено Тогда	
				ГлЯдро_СохранитьДанныеВХранилище1С(КлючДляПолучения, ПользовательскаяНастройка);
			КонецЕсли;	
		КонецЕсли;
		
		Если ПользовательскаяНастройка = Неопределено 
			ИЛИ ПолучитьПользовательскуюИОбщуюНастройку Тогда
			ОбщаяНастройка = ХранилищеОбщихНастроек.Загрузить(КлючДляПолучения,,, "");
		КонецЕсли;
		Если ПолучитьПользовательскуюИОбщуюНастройку Тогда
			ДанныеИзХранилища = Новый Структура("ПользовательскаяНастройка,ОбщаяНастройка",ПользовательскаяНастройка,ОбщаяНастройка);
		Иначе
			ДанныеИзХранилища = ?(ПользовательскаяНастройка = Неопределено,ОбщаяНастройка,ПользовательскаяНастройка);
		КонецЕсли;
	Иначе
		ДанныеИзХранилища = ХранилищеОбщихНастроек.Загрузить(КлючДляПолучения);
	КонецЕсли;
		
	Возврат ДанныеИзХранилища;
	
КонецФункции

// Удаляет текущее значение настройки Mobile Smarts для возможности получения значения по умолчанию
//
// Параметры:
//	КлючНастройки - Строка - имя настройки Mobile Smarts, которую необходимо получить
//  ID_Узла - Строка - идентификатор узла в текущей сессии Mobile Smarts
//  АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
//
// Возвращаемое значение:
//	Произвольный - значение настройки Mobile Smarts, переданной в параметре КлючНастройки
Функция ГлЯдро_ПолучитьНастройкуПоУмолчаниюНаСервереSMARTS(КлючНастройки, ID_Узла = "",АдресаПеременных) Экспорт
	
	СтруктураНастроек = Новый Структура(КлючНастройки, Ложь);
	СтруктураНастроек = ГлЯдро_ПолучитьНастройкиПоУмолчаниюНаСервереSMARTS(СтруктураНастроек,, ID_Узла,АдресаПеременных);
	
	Возврат СтруктураНастроек[КлючНастройки];
	
КонецФункции

// Удаляет значения текущих настроек в базе Mobile Smarts для возможности получения значений по умолчанию
//
// Параметры:
//	СтруктураНастроек - Структура - ключами являются имена настроек Mobile Smarts, значения которых необходимо получить	
//  УзловыеНастройки - Неопределено, Структура - ключами являются имена узловых настроек Mobile Smarts - см. ГлЯдро_ПолучитьКатегорииНастроекMS
//  ID_Узла - Строка - идентификатор узла в текущей сессии Mobile Smarts
//  АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
//
// Возвращаемое значение:
//	Структура - структура настроек с заполненными значениями по умолчанию
Функция ГлЯдро_ПолучитьНастройкиПоУмолчаниюНаСервереSMARTS(СтруктураНастроек, УзловыеНастройки = Неопределено, ID_Узла = "",АдресаПеременных) Экспорт
	
	НачалоСобытия = ТекущаяУниверсальнаяДатаВМиллисекундах();
	ИмяСобытия = "ГлЯдро_ПолучитьНастройкиПоУмолчаниюНаСервереSMARTS";
	
	ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Начало, Получение настроек по умолчанию на сервере SMARTS", , АдресаПеременных);
	
	Если УзловыеНастройки = Неопределено Тогда
		КатегорииНастроекMS = КомЯдро_ПолучитьЗначениеПеременной("КатегорииНастроекMS", АдресаПеременных);
		Если КатегорииНастроекMS = Неопределено Тогда
			КатегорииНастроекMS = ГлЯдро_ПолучитьКатегорииНастроекMS();
		КонецЕсли;
		УзловыеНастройки = КатегорииНастроекMS.УзловыеНастройки;
	КонецЕсли;

	ГлЯдро_УдалитьНастройкиВБазеSMARTS(СтруктураНастроек, УзловыеНастройки, ID_Узла,АдресаПеременных);	
	СтруктураНастроек = ГлЯдро_ПолучитьНастройкиНаСервереSMARTS(СтруктураНастроек, УзловыеНастройки,,АдресаПеременных);
	
	ВерсияОбработки = ГлЯдро_ПолучитьИзКэшаНастройкуSMARTS("ВерсияОбработки",,АдресаПеременных);
	ВерсияОбработкиКлеверенсТСД = ГлЯдро_ПолучитьИзКэшаНастройкуSMARTS("ВерсияОбработкиКлеверенсТСД",,АдресаПеременных);
	
	// Метод может быть вызван до инициализации для получения простых настроек, реструктуризация которых не требуется
	ПроверятьВерсиюОбработки = ВерсияОбработки <> Неопределено
		И ВерсияОбработкиКлеверенсТСД <> Неопределено;
	
	Если ПроверятьВерсиюОбработки И ВерсияОбработки > ВерсияОбработкиКлеверенсТСД Тогда
		СтруктураНастроек = ГлЯдро_ВыполнитьОбновлениеНастроек(ВерсияОбработкиКлеверенсТСД,СтруктураНастроек,АдресаПеременных);
	КонецЕсли;
	
	ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Конец, Получение настроек по умолчанию на сервере SMARTS", НачалоСобытия, АдресаПеременных);
	
	Возврат СтруктураНастроек;
	
КонецФункции	

// Возвращает структуру описания базы на сервере Mobile Smarts
//
// Параметры:
//	ТипБазы - Строка - "Частная", "Временная", "Основная"
//	ТипИнтерфейса - Строка - "REST_API", "COM"
//  АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
//
// Возвращаемое значение:
//	Неопределено, Структура - см. КомЯдро_СоздатьСтруктуруОписанияБазыSMARTS или REST_API_ПолучитьОписаниеБазы (в зависимости от типа интерфейса)	
Функция ГлЯдро_НайтиБазуНаСервереСМАРТС(ТипБазы,ТипИнтерфейса,АдресаПеременных) Экспорт
	
	СтруктураДанныеБазы = Неопределено;
	
	Если ТипБазы = "Частная" Тогда
		КлючПеременной = "СтруктураПодключенияЧастнойБазыMS";	
	ИначеЕсли ТипБазы = "Временная" Тогда
		КлючПеременной = "СтруктураПодключенияВременнойБазыMS";
	Иначе
		КлючПеременной = "СтруктураПодключенияБазыMS";
	КонецЕсли;
	Если ТипИнтерфейса = "REST_API" Тогда
		КлючПеременной = "REST_API_" + КлючПеременной;
	КонецЕсли;
	
	Если ТипИнтерфейса = "REST_API" Тогда
		СтруктураПодключенияБазыMS = КомЯдро_ПолучитьЗначениеПеременной(КлючПеременной,АдресаПеременных);
		
		Если ТипЗнч(СтруктураПодключенияБазыMS) = Тип("Структура")
			И СтруктураПодключенияБазыMS.Свойство("ОписаниеБазы") Тогда
			СтруктураДанныеБазы = СтруктураПодключенияБазыMS.ОписаниеБазы;
			Если НЕ (ТипЗнч(СтруктураДанныеБазы) = Тип("Структура") 
					И СтруктураДанныеБазы.Свойство("АвторизацияВключена")
					И СтруктураДанныеБазы.АвторизацияВключена) Тогда
				СтруктураДанныеБазы = REST_API_ПолучитьОписаниеБазы(ТипБазы,АдресаПеременных);	
			КонецЕсли;
		Иначе
			СтруктураДанныеБазы = REST_API_ПолучитьОписаниеБазы(ТипБазы,АдресаПеременных);
		КонецЕсли;
	Иначе
		СтруктураПодключенияБазыMS = КомЯдро_ПолучитьЗначениеПеременной(КлючПеременной,АдресаПеременных);
		
		Если ТипЗнч(СтруктураПодключенияБазыMS) = Тип("Структура")
			И СтруктураПодключенияБазыMS.Свойство("ОписаниеБазы") Тогда
			СтруктураДанныеБазы = СтруктураПодключенияБазыMS.ОписаниеБазы;
		КонецЕсли;
	КонецЕсли;
	
	Возврат СтруктураДанныеБазы;
	
КонецФункции

// Получает базу на сервере Mobile Smarts по идентификатору и возвращает ее описание
//
// Параметры:
//	ИДБазы - Строка - идентификатор базы на сервере Mobile Smarts		
//	ТипБазы - Строка - "Частная", "Временная", "Основная"
//	АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
//
//Возвращаемое значение:
//	Неопределено, Структура - см. КомЯдро_СоздатьСтруктуруОписанияБазыSMARTS
Функция ГлЯдро_ПолучитьБазуНаСервереSMARTS(ИДБазы,ТипБазы = "Временная", АдресаПеременных) Экспорт
	
	Если НЕ КомЯдро_ПодключитьсяКСерверуSMARTS(,ТипБазы, АдресаПеременных) Тогда
		Возврат Неопределено;
	КонецЕсли;
	ОписаниеБазы = КомЯдро_ПолучитьБазуНаСервереSMARTS(ИДБазы,ТипБазы, АдресаПеременных);
	Если ОписаниеБазы = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	СтруктураДанныеБазы = КомЯдро_СоздатьСтруктуруОписанияБазыSMARTS(ОписаниеБазы);
	
	Возврат СтруктураДанныеБазы;
	
КонецФункции

// Вызывает процедуру авторизации в базе Mobile Smarts и возвращает токен авторизации
//
// Параметры:
//	СтрокаПодключения - Строка - строка подключения к базе Mobile Smarts
//	Логин - Строка - логин авторизации
//	Пароль - Строка - пароль авторизации
//	ТипБазы - Строка - "Частная", "Временная", "Основная"
//	ТипИнтерфейса - Строка - "REST_API", "COM"
//	АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных	
//
// Возвращаемое значение:
//	Строка - токен авторизации
Функция ГлЯдро_ПолучитьТокенSMARTS(СтрокаПодключения,Логин,Пароль,ТипБазы,ТипИнтерфейса,АдресаПеременных) Экспорт
	Если ТипИнтерфейса = "REST_API" Тогда
		Возврат REST_API_ПолучитьТокенSMARTS(СтрокаПодключения,Логин,Пароль,ТипБазы,АдресаПеременных);
	Иначе
		Возврат КомЯдро_ПолучитьТокенSMARTS(СтрокаПодключения,Логин,Пароль,ТипБазы,АдресаПеременных);
	КонецЕсли;
КонецФункции

// Вызывает функцию подключения к базе Mobile Smarts
//
// Параметры:
//	СтруктураПодключения - Структура - структура подключения к базе Mobile Smarts
//  Переподключиться - Булево - определяет необходимость явного переподключения к базе Mobile Smarts
//  ТипБазы - Строка - "Частная", "Временная", "Основная"
//  Интерактивно - Булево - флаг работы в интерактивном режиме
//  АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
//
// Возвращаемое значение:
//	- Структура - если необходима авторизация в интерактивном режиме - содержит:
//  	* Статус - Строка	
//      * СтрокаПодключения - Строка
//      * ИмяБазы - Строка
//      * Логин - Строка
//      * ТипБазы - Строка
//      * ДопПараметры - Структура - содержит:
//			** СтрокаПодключения - Строка
//          ** ТипБазы - Строка
//          ** СтруктураПодключения - Структура - структура подключения к базе Mobile Smarts
//          ** СохранятьАвторизацию - Булево
//          ** ИмяБазы - Строка
//			** Логин - Строка
//	- Булево - результат проверки соединения с подключенной базой Mobile Smarts
Функция ГлЯдро_ПодключитьсяКБазеSMARTS(СтруктураПодключения, Переподключиться, ТипБазы, Интерактивно, НеПроверятьАвторизацию = Ложь, АдресаПеременных) Экспорт
	
	Если СтруктураПодключения.Свойство("ТипИнтерфейса")
		И СтруктураПодключения.ТипИнтерфейса = "REST_API" Тогда
		Возврат REST_API_ПодключитьсяКБазеSMARTS(СтруктураПодключения, Интерактивно, НеПроверятьАвторизацию, АдресаПеременных);
	Иначе
		Возврат КомЯдро_ПодключитьсяКБазеSMARTS(СтруктураПодключения, Переподключиться, ТипБазы,, Интерактивно, АдресаПеременных);
	КонецЕсли;
	
КонецФункции

Функция ГлЯдро_ПолучитьТаймаутПоТипуМетода(СтруктураЗапроса, АдресаПеременных)
	
	ЗначениеТаймаутаПоУмолчанию = 7;
	
	НастройкиТаймаутов = ГлЯдро_ПолучитьИзКэшаНастройкуSMARTS("НастройкиТаймаутов",, АдресаПеременных);
	Если НастройкиТаймаутов = Неопределено Тогда// Если возвращается Неопределено, значит переменные кэша еще не созданы, возьмем напрямую настройки по умолчанию		
		НастройкиТаймаутов = ГлЯдро_ТаймаутыПоУмолчанию(АдресаПеременных);	
		
	ИначеЕсли НастройкиТаймаутов = Ложь Тогда  // если в кэше нет настроек, то вызовем обновление таймаутов, внутри обновления есть запись в кэш,
		ГлЯдро_ОбновитьНастройкиТаймаутов(АдресаПеременных); // поэтому после обновления просто переполучим из него.		
		НастройкиТаймаутов = ГлЯдро_ПолучитьИзКэшаНастройкуSMARTS("НастройкиТаймаутов",,АдресаПеременных);
		
	КонецЕсли;
	
	ТипЗапроса = "ПоУмолчанию";
	Если СтруктураЗапроса.Свойство("ТипЗапроса") // Если в структуре запроса не задан тип запроса, то берем таймаут по умолчанию
		И ЗначениеЗаполнено(СтруктураЗапроса.ТипЗапроса) Тогда
		ТипЗапроса = СтруктураЗапроса.ТипЗапроса;
	КонецЕсли;
	
	СтрокаНастройки = ГлЯдро_НайтиВМассивеСтруктурПоОтбору(НастройкиТаймаутов,Новый Структура("ТипЗапроса", ТипЗапроса));
	
	Если СтрокаНастройки = Неопределено 
		И ТипЗапроса <> "ПоУмолчанию" Тогда // Названия методов могут меняться со временем, если забыли переименовать и настройка не нашлась, то будем брать значение по умолчанию
		СтрокаНастройки = ГлЯдро_НайтиВМассивеСтруктурПоОтбору(НастройкиТаймаутов,Новый Структура("ТипЗапроса", "ПоУмолчанию"));
	КонецЕсли;
	
	Если СтрокаНастройки = Неопределено Тогда // Если по какой-то причине строки настройки всё равно нет, то назначим значение таймаута 7
		ЗначениеТаймаута = ЗначениеТаймаутаПоУмолчанию;
	Иначе
		ЗначениеТаймаута = СтрокаНастройки[0].Значение;
	КонецЕсли;
	
	Возврат ЗначениеТаймаута;
КонецФункции

Функция ГлЯдро_ОбновитьМетаданныеТаблицMS(ТипБазы = "Основная", АдресаПеременных) Экспорт

	ТипИнтерфейса = КомЯдро_ПолучитьЗначениеПеременной("ТипИнтерфейса", АдресаПеременных);
	Если ТипИнтерфейса = "REST_API" Тогда
		Таблицы = REST_API_ОбновитьМетаданныеТаблицMS(ТипБазы, АдресаПеременных);
	Иначе
		Таблицы = КомЯдро_ОбновитьМетаданныеТаблицMS(ТипБазы, АдресаПеременных);
	КонецЕсли;
	
	Возврат Таблицы;
	
КонецФункции

Функция ГлЯдро_ПолучитьСтруктуруКэшируемыхНастроек()

	КэшируемыеНастройки = Новый Структура;
	
	КэшируемыеНастройки.Вставить("НастройкиБизнесПроцессов_ПоУмолчанию",				"НастройкиБизнесПроцессов");
	КэшируемыеНастройки.Вставить("НастройкиБизнесПроцессов_Пользовательские",			"НастройкиБизнесПроцессов");
	КэшируемыеНастройки.Вставить("НастройкиБизнесПроцессов_ПользовательскиеНастройки",	"НастройкиБизнесПроцессов");
	КэшируемыеНастройки.Вставить("ПроизвольныеКоды_ПоУмолчанию",						"ПроизвольныеКоды");
	КэшируемыеНастройки.Вставить("ПроизвольныеКоды_Пользовательские",					"ПроизвольныеКоды");
	КэшируемыеНастройки.Вставить("НастройкиОтборовУзлов_Интерактивный", 				"НастройкиОтборовУзлов_Интерактивный");
	КэшируемыеНастройки.Вставить("НастройкиОтборовУзлов_Онлайн", 						"НастройкиОтборовУзлов_Онлайн");
	КэшируемыеНастройки.Вставить("ГлобальныеПараметры_ПоУмолчанию",						"ГлобальныеПараметры");
	КэшируемыеНастройки.Вставить("ГлобальныеПараметры_Пользовательские",				"ГлобальныеПараметры");
	
	// Сборные настройки
	КэшируемыеНастройки.Вставить("НастройкиБизнесПроцессов",							"НастройкиБизнесПроцессов");
	КэшируемыеНастройки.Вставить("ПроизвольныеКоды",									"ПроизвольныеКоды");
	КэшируемыеНастройки.Вставить("ГлобальныеПараметры",									"ГлобальныеПараметры");
	
    Возврат КэшируемыеНастройки;
	
КонецФункции

Функция ГлЯдро_ПолучитьЗначениеКэшируемойНастройки(КлючНастройки, ID_Узла, АдресаПеременных) Экспорт
	
	ПараметрыПодключенияMS = ГлЯдро_ПолучитьДанныеИзХранилища1С("Cleverence_ПараметрыПодключенияMS");

    ИдентификаторБазыMS = "";
	Если ТипЗнч(ПараметрыПодключенияMS) = Тип("Структура")
		И ПараметрыПодключенияMS.Свойство("Ид") Тогда
		ИдентификаторБазыMS = СтрЗаменить(ПараметрыПодключенияMS.Ид, "-", "_");
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(ИдентификаторБазыMS) Тогда
		Возврат Неопределено;		
	КонецЕсли;
	
	КатегорииНастроекMS = КомЯдро_ПолучитьЗначениеПеременной("КатегорииНастроекMS", АдресаПеременных);
	Если КатегорииНастроекMS = Неопределено Тогда
		КатегорииНастроекMS = ГлЯдро_ПолучитьКатегорииНастроекMS();		
	КонецЕсли;
	УзловыеНастройки = КатегорииНастроекMS.УзловыеНастройки;
	УзловыеНастройки.Добавить("НастройкиБизнесПроцессов");
	
	ПостфиксУзла = "";
	Если ЗначениеЗаполнено(ID_Узла) И УзловыеНастройки.Найти(КлючНастройки) <> Неопределено Тогда
		ПостфиксУзла = "_" + ID_Узла;
	КонецЕсли;
	
	КлючНастройки = "Cleverence_КэшируемыеНастройки_" + ИдентификаторБазыMS + "_" + КлючНастройки + ПостфиксУзла;
	
	ЗначениеНастройки = ГлЯдро_ПолучитьДанныеИзХранилища1С(КлючНастройки);
		
	Возврат ЗначениеНастройки;
	
КонецФункции

Функция ГлЯдро_ПолучитьЗначенияКэшируемойНастройкиПоУзлам(КлючНастройки, НастройкиПоУзлам, СписокКолонок = Неопределено, АдресаПеременных) Экспорт

	ПараметрыПодключенияMS = ГлЯдро_ПолучитьДанныеИзХранилища1С("Cleverence_ПараметрыПодключенияMS");

    ИдентификаторБазыMS = "";
	Если ТипЗнч(ПараметрыПодключенияMS) = Тип("Структура")
		И ПараметрыПодключенияMS.Свойство("Ид") Тогда
		ИдентификаторБазыMS = СтрЗаменить(ПараметрыПодключенияMS.Ид, "-", "_");
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(ИдентификаторБазыMS) Тогда
		Возврат НастройкиПоУзлам;		
	КонецЕсли;
	
	КатегорииНастроекMS = КомЯдро_ПолучитьЗначениеПеременной("КатегорииНастроекMS", АдресаПеременных);
	Если КатегорииНастроекMS = Неопределено Тогда
		КатегорииНастроекMS = ГлЯдро_ПолучитьКатегорииНастроекMS();		
	КонецЕсли;
	УзловыеНастройки = КатегорииНастроекMS.УзловыеНастройки;
	УзловыеНастройки.Добавить("НастройкиБизнесПроцессов");
	
	Для каждого Настройка ИЗ НастройкиПоУзлам Цикл
		ID_Узла = Настройка.Ключ;
		
		ПостфиксУзла = "";
		Если ID_Узла <> "ГлавныйУзел" И УзловыеНастройки.Найти(КлючНастройки) <> Неопределено Тогда
			ПостфиксУзла = "_" + ID_Узла;
		КонецЕсли;
		
		КлючПеременной = "Cleverence_КэшируемыеНастройки_" + ИдентификаторБазыMS + "_" + КлючНастройки + ПостфиксУзла;
		
		НастройкаПоУзлу = ГлЯдро_ПолучитьДанныеИзХранилища1С(КлючПеременной);
		
		Если СписокКолонок <> Неопределено И ТипЗнч(НастройкаПоУзлу) = Тип("Массив") Тогда
			НастройкаПоУзлуСОтбором = Новый Массив;
			Для каждого СтрокаНастройки ИЗ НастройкаПоУзлу Цикл
				Если СтрокаНастройки.Свойство("ЭтоТаблицаЗначений") Тогда
					Продолжить;
				КонецЕсли;
				НастройкаПоУзлуСОтбором.Добавить(ГлЯдро_СкопироватьСтруктуру(СтрокаНастройки, СписокКолонок));
			КонецЦикла;
			
			НастройкиПоУзлам.Вставить(ID_Узла, НастройкаПоУзлуСОтбором);
		Иначе
			НастройкиПоУзлам.Вставить(ID_Узла, НастройкаПоУзлу);
		КонецЕсли;			
			
	КонецЦикла;	
	
	Возврат НастройкиПоУзлам;
	
КонецФункции

Процедура ГлЯдро_СохранитьЗначениеКэшируемойНастройки(КлючНастройки, ЗначениеНастройки, ID_Узла, АдресаПеременных) Экспорт
	
	СтруктураНастроек = Новый Структура(КлючНастройки, ЗначениеНастройки);
	ГлЯдро_СохранитьЗначенияКэшируемыхНастроек(СтруктураНастроек, ID_Узла, АдресаПеременных);
	
КонецПроцедуры

Процедура ГлЯдро_СохранитьЗначенияКэшируемыхНастроек(СтруктураНастроек, ID_Узла, АдресаПеременных) Экспорт

    // Получаем переменные для формирования ключей настроек
	
	ПараметрыПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("ПараметрыПодключенияMS", АдресаПеременных);
	Если ПараметрыПодключенияMS = Неопределено Тогда
		ПараметрыПодключенияMS = ГлЯдро_ПолучитьДанныеИзХранилища1С("Cleverence_ПараметрыПодключенияMS");	
	КонецЕсли;

    ИдентификаторБазыMS = "";
	Если ТипЗнч(ПараметрыПодключенияMS) = Тип("Структура")
		И ПараметрыПодключенияMS.Свойство("Ид") Тогда
		ИдентификаторБазыMS = СтрЗаменить(ПараметрыПодключенияMS.Ид, "-", "_");
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(ИдентификаторБазыMS) Тогда
		Возврат;
	КонецЕсли;
	
	// Сохраняем переданные значения в настройки пользователя
	КэшируемыеНастройки  = ГлЯдро_ПолучитьСтруктуруКэшируемыхНастроек();
	
	КатегорииНастроекMS = КомЯдро_ПолучитьЗначениеПеременной("КатегорииНастроекMS", АдресаПеременных);
	Если КатегорииНастроекMS = Неопределено Тогда
		КатегорииНастроекMS = ГлЯдро_ПолучитьКатегорииНастроекMS();		
	КонецЕсли;
	УзловыеНастройки = КатегорииНастроекMS.УзловыеНастройки;
	УзловыеНастройки.Добавить("НастройкиБизнесПроцессов");
	
	КлючиНастроекБизнесПроцессов = Новый Массив;
	КлючиНастроекБизнесПроцессов.Добавить("НастройкиБизнесПроцессов_ПоУмолчанию");
	КлючиНастроекБизнесПроцессов.Добавить("НастройкиБизнесПроцессов_Пользовательские");
	
	ОбщаяСтруктураЗапрошена   = Ложь;
	УзловаяСтруктураЗапрошена = Ложь;

    Для каждого СохраняемаяНастройка ИЗ СтруктураНастроек Цикл	
		ИмяНастройкиКлюч = СохраняемаяНастройка.Ключ;
		
		ЭтоКэшируемаяНастройка = КэшируемыеНастройки.Свойство(ИмяНастройкиКлюч);
		ЭтоУзловаяНастройка	   = УзловыеНастройки.Найти(ИмяНастройкиКлюч) <> Неопределено;
		
		Если ЭтоКэшируемаяНастройка Тогда // Значения настроек хранятся в отдельных ключах
			ЗначениеНастройки = СохраняемаяНастройка.Значение;
			Если КлючиНастроекБизнесПроцессов.Найти(ИмяНастройкиКлюч) <> Неопределено
				И ТипЗнч(ЗначениеНастройки) = Тип("Массив") Тогда
				ЗначениеНастройки = ГлЯдро_СкомпоноватьСтруктуруНастроекДляСохранения(ЗначениеНастройки, ГлЯдро_ПолучитьВерсиюСтруктурыНастроекОбработки(), АдресаПеременных);
			КонецЕсли;
			
			КлючНастройки = "Cleverence_КэшируемыеНастройки_" + ИдентификаторБазыMS + "_" + ИмяНастройкиКлюч + ?(ЗначениеЗаполнено(ID_Узла) И ЭтоУзловаяНастройка, "_" + ID_Узла, "");
			ГлЯдро_СохранитьДанныеВХранилище1С(КлючНастройки, ЗначениеНастройки);
		Иначе // Значения настроек хранятся в общем ключе
			Если ЭтоУзловаяНастройка И ЗначениеЗаполнено(ID_Узла) Тогда
				Если НЕ УзловаяСтруктураЗапрошена Тогда
					СтруктураУзловыхНастроекSMARTS = ГлЯдро_ПолучитьДанныеИзХранилища1С("Cleverence_КэшируемыеНастройки_" + ИдентификаторБазыMS + "_СтруктураНастроекSMARTS_" + ID_Узла);
					Если НЕ ТипЗнч(СтруктураУзловыхНастроекSMARTS) = Тип("Структура") Тогда
						СтруктураУзловыхНастроекSMARTS = Новый Структура;
					КонецЕсли;
					УзловаяСтруктураЗапрошена = Истина;
				КонецЕсли;	
				СтруктураУзловыхНастроекSMARTS.Вставить(ИмяНастройкиКлюч, СохраняемаяНастройка.Значение);
			Иначе
				Если НЕ ОбщаяСтруктураЗапрошена Тогда
					СтруктураНастроекSMARTS = ГлЯдро_ПолучитьДанныеИзХранилища1С("Cleverence_КэшируемыеНастройки_" + ИдентификаторБазыMS + "_СтруктураНастроекSMARTS");
					Если НЕ ТипЗнч(СтруктураНастроекSMARTS) = Тип("Структура") Тогда
						СтруктураНастроекSMARTS = Новый Структура;
					КонецЕсли;
					ОбщаяСтруктураЗапрошена = Истина;
				КонецЕсли;	
				СтруктураНастроекSMARTS.Вставить(ИмяНастройкиКлюч, СохраняемаяНастройка.Значение);
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Если ОбщаяСтруктураЗапрошена Тогда
		ГлЯдро_СохранитьДанныеВХранилище1С("Cleverence_КэшируемыеНастройки_" + ИдентификаторБазыMS + "_СтруктураНастроекSMARTS", СтруктураНастроекSMARTS);
	КонецЕсли;
	Если УзловаяСтруктураЗапрошена Тогда
		ГлЯдро_СохранитьДанныеВХранилище1С("Cleverence_КэшируемыеНастройки_" + ИдентификаторБазыMS + "_СтруктураНастроекSMARTS_" + ID_Узла, СтруктураУзловыхНастроекSMARTS);
	КонецЕсли;
	
КонецПроцедуры

// Проверяет актуальность кэшируемых настроек по дате актуальности и очищает их, если они неактуальны
//
// Параметры:
//  ДатаАктуальностиВБазеSMARTS - Дата, Строка, Неопределено - значение ключа ДатаАктуальностиКэшируемыхНастроек в настройках базы Mobile SMARTS
//	АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
//
// Возвращаемое значение:
//	Булево - Ложь, если кэшируемые настройки оказались неактуальными и были очищены
Функция ГлЯдро_ПроверитьАктуальностьКэшируемыхНастроекПриИнициализации(ДатаАктуальностиВБазеSMARTS = Неопределено, АдресаПеременных) Экспорт

	Если ДатаАктуальностиВБазеSMARTS = Неопределено Тогда
		ДатаАктуальностиВБазеSMARTS = ГлЯдро_ПолучитьНастройкуНаСервереSMARTS("ДатаАктуальностиКэшируемыхНастроек",, АдресаПеременных);
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(ДатаАктуальностиВБазеSMARTS) ИЛИ ДатаАктуальностиВБазеSMARTS = Ложь Тогда
		Возврат Истина;		
	ИначеЕсли ТипЗнч(ДатаАктуальностиВБазеSMARTS) = Тип("Строка") Тогда
		ДатаАктуальностиВБазеSMARTS = REST_API_ПреобразоватьКДате(ДатаАктуальностиВБазеSMARTS);
	КонецЕсли;
	
	ПараметрыПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("ПараметрыПодключенияMS", АдресаПеременных);
	Если ПараметрыПодключенияMS = Неопределено Тогда
		ПараметрыПодключенияMS = ГлЯдро_ПолучитьДанныеИзХранилища1С("Cleverence_ПараметрыПодключенияMS");	
	КонецЕсли;

	ИдентификаторБазыMS = "";
	Если ТипЗнч(ПараметрыПодключенияMS) = Тип("Структура") Тогда
		ИдентификаторБазыMS = ?(ПараметрыПодключенияMS.Свойство("Ид"), СтрЗаменить(ПараметрыПодключенияMS.Ид, "-", "_"), "");
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(ИдентификаторБазыMS) Тогда
		Возврат Истина;
	КонецЕсли;
	
	СохраненнаяДатаАктуальности = ГлЯдро_ПолучитьДанныеИзХранилища1С("Cleverence_ДатаАктуальностиКэшируемыхНастроек_" + ИдентификаторБазыMS);
	
	Если НЕ ЗначениеЗаполнено(СохраненнаяДатаАктуальности)
		ИЛИ СохраненнаяДатаАктуальности < ДатаАктуальностиВБазеSMARTS Тогда
		ГлЯдро_ОчиститьКэшируемыеНастройки(ИдентификаторБазыMS,, АдресаПеременных);
	    ГлЯдро_СохранитьДанныеВХранилище1С("Cleverence_ДатаАктуальностиКэшируемыхНастроек_" + ИдентификаторБазыMS, ДатаАктуальностиВБазеSMARTS);
		
		Возврат Ложь;
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

Функция ГлЯдро_ПроверитьСохраненнуюСтрокуПодключения1С(АдресаПеременных)
	
	#Область НесовместимыйКодFresh
	База1СПодключенаДата = ГлЯдро_ПолучитьНастройкуНаСервереSMARTS("База1СПодключенаДата",, АдресаПеременных);
	
	Результат = ЗначениеЗаполнено(База1СПодключенаДата) И База1СПодключенаДата <> Ложь;
	#КонецОбласти //НесовместимыйКодFresh
	
	#Область СовместимыйКодFresh
	//База1СПодключенаДата 		   = ГлЯдро_ПолучитьНастройкуНаСервереSMARTS("База1СПодключенаДата",, АдресаПеременных);
	//База1ССтрокаСоединенияКлиент = ГлЯдро_ПолучитьНастройкуНаСервереSMARTS("ServiceHTTPAddress",, АдресаПеременных);
	//
	//Результат = ЗначениеЗаполнено(База1СПодключенаДата) И База1СПодключенаДата <> Ложь 
	//			И ЗначениеЗаполнено(База1ССтрокаСоединенияКлиент) И База1ССтрокаСоединенияКлиент <> Ложь;
	#КонецОбласти //СовместимыйКодFresh
	
	Возврат Результат;
	
КонецФункции

Функция ГлЯдро_ПроверитьАктуальностьКэшируемыхНастроек(СтруктураНастроек, ID_Узла, АдресаПеременных) Экспорт

	АктуальныеНастройки = Новый Структура;
	
	// Получаем переменные для формирования ключей настроек
	
	ПараметрыПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("ПараметрыПодключенияMS", АдресаПеременных);
	Если ПараметрыПодключенияMS = Неопределено Тогда
		ПараметрыПодключенияMS = ГлЯдро_ПолучитьДанныеИзХранилища1С("Cleverence_ПараметрыПодключенияMS");	
	КонецЕсли;
	
	ИдентификаторБазыMS = "";
	ВерсияПриложенияMS 	= "";
	Если ТипЗнч(ПараметрыПодключенияMS) = Тип("Структура") Тогда
		ИдентификаторБазыMS = ?(ПараметрыПодключенияMS.Свойство("Ид"), СтрЗаменить(ПараметрыПодключенияMS.Ид, "-", "_"), "");
		ВерсияПриложенияMS	= ?(ПараметрыПодключенияMS.Свойство("ВерсияПриложения"), ПараметрыПодключенияMS.ВерсияПриложения, "");
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(ИдентификаторБазыMS) Тогда
		Возврат АктуальныеНастройки;
	КонецЕсли;
	
	// Если версия продукта изменилась, очищаем все настройки в кэше
	
	СохраненнаяВерсияПриложенияMS = ГлЯдро_ПолучитьДанныеИзХранилища1С("Cleverence_ВерсияПриложенияMS_" + ИдентификаторБазыMS);
	Если НЕ ЗначениеЗаполнено(ВерсияПриложенияMS)
		ИЛИ НЕ ЗначениеЗаполнено(СохраненнаяВерсияПриложенияMS)
		ИЛИ ВерсияПриложенияMS <> СохраненнаяВерсияПриложенияMS Тогда
		
		ГлЯдро_ОчиститьКэшируемыеНастройки(ИдентификаторБазыMS,, АдресаПеременных);
		ГлЯдро_СохранитьДанныеВХранилище1С("Cleverence_ВерсияПриложенияMS_" + ИдентификаторБазыMS, ВерсияПриложенияMS);
		Возврат АктуальныеНастройки;
		
	КонецЕсли;
	
	// Проверяем актуальность запрашиваемых настроек
	КэшируемыеНастройки = ГлЯдро_ПолучитьСтруктуруКэшируемыхНастроек();
	
	КатегорииНастроекMS = КомЯдро_ПолучитьЗначениеПеременной("КатегорииНастроекMS", АдресаПеременных);
	Если КатегорииНастроекMS = Неопределено Тогда
		КатегорииНастроекMS = ГлЯдро_ПолучитьКатегорииНастроекMS();		
	КонецЕсли;
	УзловыеНастройки = КатегорииНастроекMS.УзловыеНастройки;
	УзловыеНастройки.Добавить("НастройкиБизнесПроцессов");
	
	ОбщаяСтруктураЗапрошена   = Ложь;
	УзловаяСтруктураЗапрошена = Ложь;
	ПроверенныеНастройки 	  = Новый Массив;	

    НекэшируемыеНастройки = Новый Массив;
	НекэшируемыеНастройки.Добавить("ДатаАктуальностиКэшируемыхНастроек");
	НекэшируемыеНастройки.Добавить("ВерсияПриложения");
	НекэшируемыеНастройки.Добавить("ВерсияПриложения_ОсновнаяОбработка");
	НекэшируемыеНастройки.Добавить("ВерсияОбработки_ОсновнаяОбработка");
	НекэшируемыеНастройки.Добавить("ПутьОсновнойОбработки");
	НекэшируемыеНастройки.Добавить("ТипОсновнойОбработки");
	НекэшируемыеНастройки.Добавить("База1СПодключенаДата");
	
	// Проверяем все настройки, а не только кэшируемые
	Для каждого ЗапрашиваемаяНастройка ИЗ СтруктураНастроек Цикл
		ИмяНастройкиКлюч = ЗапрашиваемаяНастройка.Ключ;
		Если ПроверенныеНастройки.Найти(ИмяНастройкиКлюч) <> Неопределено
			ИЛИ НекэшируемыеНастройки.Найти(ИмяНастройкиКлюч) <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		ИмяНастройкиЗначение   = Неопределено;
		ЭтоКэшируемаяНастройка = КэшируемыеНастройки.Свойство(ИмяНастройкиКлюч, ИмяНастройкиЗначение);
		ЭтоУзловаяНастройка	   = УзловыеНастройки.Найти(ИмяНастройкиКлюч) <> Неопределено;	

        Если ЭтоКэшируемаяНастройка Тогда
			КлючНастройки = "Cleverence_КэшируемыеНастройки_" + ИдентификаторБазыMS + "_" + ИмяНастройкиКлюч + ?(ЗначениеЗаполнено(ID_Узла) И ЭтоУзловаяНастройка, "_" + ID_Узла, "");
			ЗначениеНастройки = ГлЯдро_ПолучитьДанныеИзХранилища1С(КлючНастройки);
				
			Если ЗначениеЗаполнено(ЗначениеНастройки) Тогда
				АктуальныеНастройки.Вставить(ИмяНастройкиКлюч, ЗначениеНастройки);
			ИначеЕсли ПроверенныеНастройки.Найти(ИмяНастройкиЗначение) = Неопределено Тогда
				// Если настройка сборная, очищаем собранную структуру
				КлючНастройки = "Cleverence_КэшируемыеНастройки_" + ИдентификаторБазыMS + "_" + ИмяНастройкиЗначение + ?(ЗначениеЗаполнено(ID_Узла) И ЭтоУзловаяНастройка, "_" + ID_Узла, "");
				ГлЯдро_СохранитьДанныеВХранилище1С(КлючНастройки, Неопределено);

				ПроверенныеНастройки.Добавить(ИмяНастройкиЗначение);
			КонецЕсли;
		Иначе
			ЗначениеНастройки = Неопределено;
			Если ЭтоУзловаяНастройка И ЗначениеЗаполнено(ID_Узла) Тогда
				Если НЕ УзловаяСтруктураЗапрошена Тогда
					СтруктураУзловыхНастроекSMARTS = ГлЯдро_ПолучитьДанныеИзХранилища1С("Cleverence_КэшируемыеНастройки_" + ИдентификаторБазыMS + "_СтруктураНастроекSMARTS_" + ID_Узла);
					Если НЕ ТипЗнч(СтруктураУзловыхНастроекSMARTS) = Тип("Структура") Тогда
						СтруктураУзловыхНастроекSMARTS = Новый Структура;
					КонецЕсли;
					УзловаяСтруктураЗапрошена = Истина;
				КонецЕсли;	
					
				Если СтруктураУзловыхНастроекSMARTS.Свойство(ИмяНастройкиКлюч, ЗначениеНастройки) Тогда
					АктуальныеНастройки.Вставить(ИмяНастройкиКлюч, ЗначениеНастройки);	
				КонецЕсли;
			Иначе
				Если НЕ ОбщаяСтруктураЗапрошена Тогда
					СтруктураНастроекSMARTS = ГлЯдро_ПолучитьДанныеИзХранилища1С("Cleverence_КэшируемыеНастройки_" + ИдентификаторБазыMS + "_СтруктураНастроекSMARTS");
					Если НЕ ТипЗнч(СтруктураНастроекSMARTS) = Тип("Структура") Тогда
						СтруктураНастроекSMARTS = Новый Структура;
					КонецЕсли;
					ОбщаяСтруктураЗапрошена = Истина;
				КонецЕсли;	
					
				Если СтруктураНастроекSMARTS.Свойство(ИмяНастройкиКлюч, ЗначениеНастройки) Тогда
					АктуальныеНастройки.Вставить(ИмяНастройкиКлюч, ЗначениеНастройки);	
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;

	КонецЦикла;
	
	Возврат АктуальныеНастройки;
	
КонецФункции

Процедура ГлЯдро_ОчиститьКэшируемыеНастройки(ИдентификаторБазыMS = "", СтруктураНастроек = Неопределено, АдресаПеременных) Экспорт
	
	Если НЕ ЗначениеЗаполнено(ИдентификаторБазыMS) Тогда
        ПараметрыПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("ПараметрыПодключенияMS", АдресаПеременных);
		Если ПараметрыПодключенияMS = Неопределено Тогда
			ПараметрыПодключенияMS = ГлЯдро_ПолучитьДанныеИзХранилища1С("Cleverence_ПараметрыПодключенияMS");
		КонецЕсли;
		
		Если ТипЗнч(ПараметрыПодключенияMS) = Тип("Структура")
			И ПараметрыПодключенияMS.Свойство("Ид") Тогда
			ИдентификаторБазыMS = СтрЗаменить(ПараметрыПодключенияMS.Ид, "-", "_");
		КонецЕсли;
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(ИдентификаторБазыMS) Тогда	
		Возврат;
	КонецЕсли;
	
	ПолнаяОчистка = СтруктураНастроек = Неопределено ИЛИ ТипЗнч(СтруктураНастроек) <> Тип("Структура");
	ВсеУзлы 	  = Новый Массив;
	
	КлючОбщейНастройки 		= "Cleverence_КэшируемыеНастройки_" + ИдентификаторБазыMS + "_СтруктураНастроекSMARTS";
	СтруктураНастроекSMARTS = ГлЯдро_ПолучитьДанныеИзХранилища1С(КлючОбщейНастройки);
	Если ТипЗнч(СтруктураНастроекSMARTS) = Тип("Структура") Тогда
		Если СтруктураНастроекSMARTS.Свойство("Узлы")
			И ТипЗнч(СтруктураНастроекSMARTS.Узлы) = Тип("Массив") Тогда
			ВсеУзлы = СтруктураНастроекSMARTS.Узлы;
		КонецЕсли;
		
		Если НЕ ПолнаяОчистка Тогда
			Для каждого Настройка ИЗ СтруктураНастроек Цикл
		    	СтруктураНастроекSMARTS.Удалить(Настройка.Ключ);
			КонецЦикла;
		Иначе
			СтруктураНастроекSMARTS = Неопределено;
		КонецЕсли;
	Иначе
		СтруктураНастроекSMARTS = Неопределено;
	КонецЕсли;
	
	// Очищаем настройки, хранящиеся в общем ключе
	ГлЯдро_СохранитьДанныеВХранилище1С(КлючОбщейНастройки, СтруктураНастроекSMARTS);
		
	Для каждого СтрокаУзла ИЗ ВсеУзлы Цикл			
		Если СтрокаУзла.Свойство("ЭтоТаблицаЗначений") Тогда
			Продолжить;
		КонецЕсли;
		
		КлючУзловойНастройки = КлючОбщейНастройки + "_" + СтрокаУзла.ID_Узла;
		Если НЕ ПолнаяОчистка Тогда
			СтруктураНастроекSMARTS = ГлЯдро_ПолучитьДанныеИзХранилища1С(КлючУзловойНастройки);
			Если ТипЗнч(СтруктураНастроекSMARTS) = Тип("Структура") Тогда
				Для каждого Настройка ИЗ СтруктураНастроек Цикл
					СтруктураНастроекSMARTS.Удалить(Настройка.Ключ);
				КонецЦикла;
			Иначе
				СтруктураНастроекSMARTS = Неопределено;
			КонецЕсли;
		Иначе
			СтруктураНастроекSMARTS = Неопределено;
		КонецЕсли;
		
		ГлЯдро_СохранитьДанныеВХранилище1С(КлючУзловойНастройки, СтруктураНастроекSMARTS);
	КонецЦикла;
	
	// Очищаем настройки, хранящиеся в отдельных ключах
	КэшируемыеНастройки = ГлЯдро_ПолучитьСтруктуруКэшируемыхНастроек();
	
	КатегорииНастроекMS = КомЯдро_ПолучитьЗначениеПеременной("КатегорииНастроекMS", АдресаПеременных);
	Если КатегорииНастроекMS = Неопределено Тогда
		КатегорииНастроекMS = ГлЯдро_ПолучитьКатегорииНастроекMS();		
	КонецЕсли;
	УзловыеНастройки = КатегорииНастроекMS.УзловыеНастройки;
	УзловыеНастройки.Добавить("НастройкиБизнесПроцессов");	
	
    ОчищенныеНастройки = Новый Массив;
	Для каждого КэшируемаяНастройка ИЗ КэшируемыеНастройки Цикл
		Если ОчищенныеНастройки.Найти(КэшируемаяНастройка.Ключ)	<> Неопределено Тогда
			Продолжить;			
		КонецЕсли;
		Если НЕ ПолнаяОчистка
			И НЕ СтруктураНастроек.Свойство(КэшируемаяНастройка.Ключ) Тогда
			Продолжить;
		КонецЕсли;		
		
		ИмяНастройкиКлюч 	 = КэшируемаяНастройка.Ключ;
		ИмяНастройкиЗначение = КэшируемаяНастройка.Значение;
		
		КлючНастройки = "Cleverence_КэшируемыеНастройки_" + ИдентификаторБазыMS + "_" + ИмяНастройкиКлюч;
		ГлЯдро_СохранитьДанныеВХранилище1С(КлючНастройки, Неопределено);

        Если УзловыеНастройки.Найти(ИмяНастройкиКлюч) <> Неопределено Тогда
			Для каждого СтрокаУзла ИЗ ВсеУзлы Цикл			
				Если СтрокаУзла.Свойство("ЭтоТаблицаЗначений") Тогда
					Продолжить;
				КонецЕсли;
				КлючНастройки = "Cleverence_КэшируемыеНастройки_" + ИдентификаторБазыMS + "_" + ИмяНастройкиКлюч + "_" + СтрокаУзла.ID_Узла;
				ГлЯдро_СохранитьДанныеВХранилище1С(КлючНастройки, Неопределено);
			КонецЦикла;
		КонецЕсли;
				
		ОчищенныеНастройки.Добавить(ИмяНастройкиКлюч);
		
		Если ОчищенныеНастройки.Найти(ИмяНастройкиЗначение) = Неопределено Тогда
			КлючНастройки = "Cleverence_КэшируемыеНастройки_" + ИдентификаторБазыMS + "_" + ИмяНастройкиЗначение;
			ГлЯдро_СохранитьДанныеВХранилище1С(КлючНастройки, Неопределено);
			
			Если УзловыеНастройки.Найти(ИмяНастройкиЗначение) <> Неопределено Тогда
				Для каждого СтрокаУзла ИЗ ВсеУзлы Цикл			
					Если СтрокаУзла.Свойство("ЭтоТаблицаЗначений") Тогда
						Продолжить;
					КонецЕсли;
					КлючНастройки = "Cleverence_КэшируемыеНастройки_" + ИдентификаторБазыMS + "_" + ИмяНастройкиЗначение + "_" + СтрокаУзла.ID_Узла;
					ГлЯдро_СохранитьДанныеВХранилище1С(КлючНастройки, Неопределено);
				КонецЦикла;
			КонецЕсли;
			
			ОчищенныеНастройки.Добавить(ИмяНастройкиЗначение);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

Процедура ГлЯдро_ОчиститьХранилищеОбщихНастроек1С() Экспорт
	
	МассивКлючей = Новый Массив;
	МассивКлючей.Добавить("Cleverence_ПараметрыПодключенияMS");		
	МассивКлючей.Добавить("Cleverence_РасположениеКомпоненты");
	МассивКлючей.Добавить("Cleverence_ДатаАктуальностиКэша");
	МассивКлючей.Добавить("Cleverence_СтруктураМетаданныхДокументы1С");
	МассивКлючей.Добавить("Cleverence_СтруктураНастроек");
	МассивКлючей.Добавить("Cleverence_СтруктураМетаданныхДокументыMS");
	МассивКлючей.Добавить("Cleverence_ПользователиMS");
	МассивКлючей.Добавить("Cleverence_ТаблицыMS");
	МассивКлючей.Добавить("Cleverence_ИмяИнтеграционнойОбработки");
	МассивКлючей.Добавить("Cleverence_РежимВыбораБазы");
	МассивКлючей.Добавить("Cleverence_ТипИнтерфейса");
	МассивКлючей.Добавить("Cleverence_ИмяИнтеграционнойОбработки");
	
	Попытка
		КлючиНастроек = ХранилищеОбщихНастроек.Загрузить("Cleverence_КлючиНастроек",,,ПараметрыСеанса.ТекущийПользователь.Наименование);
		Если ТипЗнч(КлючиНастроек) = Тип("Массив") Тогда
			Для каждого КлючНастройки ИЗ КлючиНастроек Цикл		
				Если МассивКлючей.Найти(КлючНастройки) = Неопределено Тогда
					МассивКлючей.Добавить(КлючНастройки);				
                КонецЕсли;
			КонецЦикла;
		КонецЕсли;	
	Исключение
	КонецПопытки;
	
	Попытка
		КлючиНастроек = ХранилищеОбщихНастроек.Загрузить("Cleverence_КлючиНастроек",,,ПользователиИнформационнойБазы.ТекущийПользователь().Имя);
		Если ТипЗнч(КлючиНастроек) = Тип("Массив") Тогда
			Для каждого КлючНастройки ИЗ КлючиНастроек Цикл		
				Если МассивКлючей.Найти(КлючНастройки) = Неопределено Тогда
					МассивКлючей.Добавить(КлючНастройки);				
                КонецЕсли;
			КонецЦикла;
		КонецЕсли;	
	Исключение
	КонецПопытки;
	
	Попытка
		КлючиНастроек = ХранилищеОбщихНастроек.Загрузить("Cleverence_КлючиНастроек");
		Если ТипЗнч(КлючиНастроек) = Тип("Массив") Тогда
			Для каждого КлючНастройки ИЗ КлючиНастроек Цикл		
				Если МассивКлючей.Найти(КлючНастройки) = Неопределено Тогда
					МассивКлючей.Добавить(КлючНастройки);				
                КонецЕсли;
			КонецЦикла;
		КонецЕсли;	
	Исключение
	КонецПопытки;
	
	Для Каждого КлючОчистки Из МассивКлючей Цикл
		Попытка
			ХранилищеОбщихНастроек.Удалить(КлючОчистки,"","");
		Исключение
		КонецПопытки;
		Попытка				
			ХранилищеОбщихНастроек.Удалить(КлючОчистки,"",ПараметрыСеанса.ТекущийПользователь.Наименование);
		Исключение
		КонецПопытки;
		Попытка				
			ХранилищеОбщихНастроек.Удалить(КлючОчистки,"",ПользователиИнформационнойБазы.ТекущийПользователь().Имя);
		Исключение
		КонецПопытки;
	КонецЦикла;
	
КонецПроцедуры
#КонецОбласти

#Область ГлобальныйКонтекст_Настройки_УстановкаНастроек

// Вызывает процедуру сохранения настроек в базе Mobile Smarts
//
// Параметры:
//	СтруктураНастроек - Структура - ключами являются имена настроек Mobile Smarts, значения которых необходимо сохранить
//  ID_Узла - Строка - идентификатор узла в текущей сессии Mobile Smarts
//  АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
Процедура ГлЯдро_СохранитьНастройкиВБазеSMARTS(Знач СтруктураНастроек, ID_Узла = "",АдресаПеременных) Экспорт
	
	НачалоСобытия = ТекущаяУниверсальнаяДатаВМиллисекундах();
	ИмяСобытия = "ГлЯдро_СохранитьНастройкиВБазеSMARTS";
	
	ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Начало, Запись настроек в базу SMARTS", , АдресаПеременных);
	
	// При сохранении настроек в базу также обновляем их в настройках пользователя
	ГлЯдро_СохранитьЗначенияКэшируемыхНастроек(СтруктураНастроек, ID_Узла, АдресаПеременных);
	
	КатегорииНастроекMS = КомЯдро_ПолучитьЗначениеПеременной("КатегорииНастроекMS", АдресаПеременных);
	Если КатегорииНастроекMS = Неопределено Тогда
		КатегорииНастроекMS = ГлЯдро_ПолучитьКатегорииНастроекMS();
	КонецЕсли;
	
	СтруктураНастроекДляЗаписи = ГлЯдро_КонвертироватьСериализуемыеНастройки(СтруктураНастроек, "ВСтроку");
	
	ТипИнтерфейса = КомЯдро_ПолучитьЗначениеПеременной("ТипИнтерфейса",АдресаПеременных);
	Если ТипИнтерфейса = "REST_API" Тогда
		REST_API_ЗаписатьНастройкиSMARTS(СтруктураНастроекДляЗаписи, КатегорииНастроекMS.УзловыеНастройки, ID_Узла,АдресаПеременных);
	Иначе	
		КомЯдро_ЗаписатьНастройкиSMARTS(СтруктураНастроекДляЗаписи, КатегорииНастроекMS.УзловыеНастройки, ID_Узла,АдресаПеременных);
	КонецЕсли;
	
	ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Конец, Запись настроек в базу SMARTS", НачалоСобытия, АдресаПеременных);
	
КонецПроцедуры

// Вызывает процедуру сохранения настройки в базе Mobile Smarts по ключу
//
// Параметры:
//	КлючНастройки - Строка - имя настройки Mobile Smarts, значение которой необходимо сохранить
//	ЗначениеНастройки - Произвольный - значение настройки
//  ID_Узла - Строка - идентификатор узла в текущей сессии Mobile Smarts
//  АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
Процедура ГлЯдро_СохранитьНастройкуВБазеSMARTS(КлючНастройки, ЗначениеНастройки, ID_Узла = "",АдресаПеременных) Экспорт
	
	СтруктураНастроек = Новый Структура(КлючНастройки, ЗначениеНастройки);
	ГлЯдро_СохранитьНастройкиВБазеSMARTS(СтруктураНастроек, ID_Узла,АдресаПеременных);
	
КонецПроцедуры

// Обновляет значения текущих настроек Mobile Smarts во временном хранилище переданными значениями настроек
//
// Параметры:
//	СтруктураНастроек - Структура - ключами являются имена настроек Mobile Smarts, значения которых необходимо сохранить
//  АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
Процедура ГлЯдро_ЗаписатьВКэшНастройкиSMARTS(СтруктураНастроек, АдресаПеременных) Экспорт
	
	ТекущиеНастройкиMS = КомЯдро_ПолучитьЗначениеПеременной("ТекущиеНастройкиMS",АдресаПеременных);
	Для Каждого Настройка Из СтруктураНастроек Цикл
		ТекущиеНастройкиMS.Вставить(Настройка.Ключ, Настройка.Значение);
	КонецЦикла;
	КомЯдро_СохранитьЗначениеПеременной("ТекущиеНастройкиMS",ТекущиеНастройкиMS,АдресаПеременных);
	
КонецПроцедуры

// Обновляет значение текущей настройки Mobile Smarts во временном хранилище переданным значением
//
// Параметры:
//	КлючНастройки - Строка - имя настройки Mobile Smarts, значение которой необходимо сохранить
//  ЗначениеНастройки - Произвольный - значение настройки
//  АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
Процедура ГлЯдро_ЗаписатьВКэшНастройкуSMARTS(КлючНастройки, ЗначениеНастройки,АдресаПеременных) Экспорт
	
	СтруктураНастроек = Новый Структура(КлючНастройки, ЗначениеНастройки);
	ГлЯдро_ЗаписатьВКэшНастройкиSMARTS(СтруктураНастроек,АдресаПеременных);
	
КонецПроцедуры

// Получает данные текущего узла из массива со списком узлов и сохраняет их в кэш
//
// Параметры:
//	mXmlDoc	- Строка - строка в формате XML или JSON, содержащая информацию о текущей сессии Mobile Smarts
//  ФорматXml - Булево - определяет, передана строка mXmlDoc в формате XML (Истина) или JSON (Ложь)
//  Интерактивно - Булево - флаг работы в интерактивном режиме
//  ТипИнтерфейса - Строка - "REST_API", "COM"
//  АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
//
// Возвращаемое значение:
//	Булево - признак наличия частной базы
Функция ГлЯдро_УстановитьДанныеТекущегоУзла(mXmlDoc,ФорматXml = Истина,Интерактивно=Ложь, ТипИнтерфейса="", АдресаПеременных) Экспорт
	
	НачалоСобытия = ТекущаяУниверсальнаяДатаВМиллисекундах();
	ИмяСобытия = "ГлЯдро_УстановитьДанныеТекущегоУзла";
	// Сравнить, и при необходимости изменить текущий узел
	Если ФорматXml Тогда
		СтруктураПодключенияБазыMS = КомЯдро_ПолучитьЗначениеПеременной("COMБазыMS",АдресаПеременных);
		ИспJSON_mXmlDoc = КомЯдро_ПолучитьЗначениеПеременной("ИспJSON_mXmlDoc",АдресаПеременных);
		//Если ТипИнтерфейса = "REST_API" Тогда
		Если ИспJSON_mXmlDoc = Истина
			ИЛИ (ИспJSON_mXmlDoc = Неопределено И ТипИнтерфейса = "REST_API") Тогда
			SessionSMARTS = ГлЯдро_ЗагрузитьИзJSON(mXmlDoc);
			Попытка				
				ID_Узла = SessionSMARTS["DeviceInfo"]["ИдУзла"];
				Если ID_Узла = Неопределено Тогда ID_Узла = ""; КонецЕсли;
			Исключение
				ID_Узла = "";
			КонецПопытки;
		Иначе
			ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Получаем SessionSMARTS из XML, через ЗагрузитьОбъектИз_XML, mXmlDoc: "+ Строка(mXmlDoc),НачалоСобытия,АдресаПеременных);
			SessionSMARTS = СтруктураПодключенияБазыMS.StorageConnector.ЗагрузитьОбъектИз_XML(mXmlDoc);
			ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Получили SessionSMARTS "+ Строка(SessionSMARTS),НачалоСобытия,АдресаПеременных);
			Если ТипЗнч(SessionSMARTS) = Тип("COMОбъект") Тогда							
				Попытка				
					Если  SessionSMARTS.DeviceInfo <> Неопределено 
						И  SessionSMARTS.DeviceInfo <> "Null" Тогда 
						ID_Узла = SessionSMARTS.DeviceInfo.ПолучитьПоле("ИдУзла");
						Если ID_Узла = Неопределено Тогда ID_Узла = ""; КонецЕсли;
					Иначе
						ID_Узла = "";	
					КонецЕсли;
				Исключение
					ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Ошибка: "+ ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()),НачалоСобытия,АдресаПеременных);					
					ID_Узла = "";
				КонецПопытки;
			Иначе
				ID_Узла = "";
			КонецЕсли;
		КонецЕсли;
	Иначе
		ID_Узла = mXmlDoc;
	КонецЕсли;
		
	ЭтоВнешнееСоединение = Ложь;
	#Если ВнешнееСоединение Тогда
		ЭтоВнешнееСоединение = Истина;	
	#КонецЕсли
	ИспользоватьКэш = ЭтоWebСервис или ЭтоВнешнееСоединение;
	
	ДанныеТекущегоУзла = КомЯдро_ПолучитьЗначениеПеременной("ДанныеТекущегоУзла",АдресаПеременных);
	
	Если НЕ ФорматXml 
		ИЛИ(ДанныеТекущегоУзла <> Неопределено И ID_Узла <> ДанныеТекущегоУзла.ID_Узла) Тогда
		// изменяем данные текущего узла
		ВсеУзлы = ГлЯдро_ПолучитьИзКэшаНастройкуSMARTS("Узлы",,АдресаПеременных);
		Если ТипЗнч(ВсеУзлы) = Тип("Массив") Тогда
			ДанныеУзла = ГлЯдро_НайтиСтруктуруВМассивеПоЭлементу(ВсеУзлы,"ID_Узла",ID_Узла);
		КонецЕсли;
		Если ТипЗнч(ДанныеУзла) = Тип("Структура") Тогда
			ДанныеТекущегоУзла.Вставить("ID_Узла",      ДанныеУзла.ID_Узла);
			ДанныеТекущегоУзла.Вставить("Наименование", ДанныеУзла.Наименование);
			ДанныеТекущегоУзла.Вставить("ЧастнаяБазаMS",    ДанныеУзла.ЧастнаяБазаMS);
			ЕстьЧастнаяБаза = ДанныеУзла.ИспользоватьЧастнуюБазу;
			Если ТипЗнч(ДанныеУзла.ЧастнаяБазаMS) = Тип("Структура")
				И ЕстьЧастнаяБаза
				И НЕ Интерактивно Тогда
				ГлЯдро_ПроверитьСоединениеССерверомSMARTS(ДанныеУзла.ЧастнаяБазаMS,Истина,"Частная",Ложь,Ложь,,АдресаПеременных);
				ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Проверить соединение с ЧБ, "+ Строка(ДанныеУзла.ЧастнаяБазаMS),НачалоСобытия,АдресаПеременных);
            КонецЕсли;
		Иначе
			ДанныеТекущегоУзла.Вставить("ID_Узла",      "");
			ДанныеТекущегоУзла.Вставить("Наименование", "");
			ДанныеТекущегоУзла.Вставить("ЧастнаяБазаMS",    "");
			ЕстьЧастнаяБаза = Ложь;
		КонецЕсли;
		
		КомЯдро_СохранитьЗначениеПеременной("ЕстьЧастнаяБаза", ЕстьЧастнаяБаза, АдресаПеременных);
		КомЯдро_СохранитьЗначениеПеременной("ДанныеТекущегоУзла", ДанныеТекущегоУзла, АдресаПеременных);
		
		КатегорииНастроекMS = КомЯдро_ПолучитьЗначениеПеременной("КатегорииНастроекMS",АдресаПеременных);
		// закачиваем в кэш узловые настройки
		Если ИспользоватьКэш Тогда
			//Если ID_Узла <> "" И ID_Узла <> Неопределено Тогда 
			//	НастройкиУзла = ГлЯдро_ПолучитьДанныеИзХранилища1С("Cleverence_СтруктураНастроек_" + ID_Узла);
			//Иначе
			//	НастройкиУзла = ГлЯдро_ПолучитьДанныеИзХранилища1С("Cleverence_СтруктураНастроек");
			//КонецЕсли;
			СтруктураНастроек = КомЯдро_ПолучитьЗначениеПеременной("ТекущиеНастройкиMS_" + ?(ЗначениеЗаполнено(ID_Узла), ID_Узла, "ГлавныйУзел"), АдресаПеременных);
			Если СтруктураНастроек = Неопределено Тогда
				СтруктураНастроек = ГлЯдро_СобратьСтруктуруНастроекИзКэша(ID_Узла, АдресаПеременных);
				КомЯдро_СохранитьЗначениеПеременной("ТекущиеНастройкиMS_" + ?(ЗначениеЗаполнено(ID_Узла), ID_Узла, "ГлавныйУзел"), СтруктураНастроек, АдресаПеременных);
				ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Получение структуры настроек из настроек пользователя, ИдУзла = " + Строка(ID_Узла), НачалоСобытия, АдресаПеременных);
			КонецЕсли;
		Иначе
			// Вызывается из ГлЯдро_ПолучитьДанныеДляИнициализации, где настройки уже получены с сервера
			СтруктураНастроек = КомЯдро_ПолучитьЗначениеПеременной("ТекущиеНастройкиMS", АдресаПеременных);
		КонецЕсли;
		
		ГлЯдро_ЗаписатьВКэшНастройкиSMARTS(СтруктураНастроек, АдресаПеременных);
		
		Если ИспользоватьКэш Тогда
			Если НЕ СтруктураНастроек.Свойство("НастройкиБизнесПроцессов") ИЛИ СтруктураНастроек.НастройкиБизнесПроцессов = Ложь Тогда
				ГлЯдро_СобратьОбщуюСтруктуруБизнесПроцессов(АдресаПеременных);
				СтруктураНастроек.Вставить("НастройкиБизнесПроцессов", ГлЯдро_ПолучитьИзКэшаНастройкуSMARTS("НастройкиБизнесПроцессов",, АдресаПеременных));
			КонецЕсли;
			Если НЕ СтруктураНастроек.Свойство("ПроизвольныеКоды") ИЛИ СтруктураНастроек.ПроизвольныеКоды = Ложь Тогда
				ГлЯдро_СобратьОбщуюСтруктуруПроизвольныхКодов(АдресаПеременных);
				СтруктураНастроек.Вставить("ПроизвольныеКоды", ГлЯдро_ПолучитьИзКэшаНастройкуSMARTS("ПроизвольныеКоды",, АдресаПеременных));
			КонецЕсли;
			Если НЕ СтруктураНастроек.Свойство("ГлобальныеПараметры") ИЛИ СтруктураНастроек.ГлобальныеПараметры = Ложь Тогда
				ГлЯдро_СобратьОбщуюСтруктуруГлобальныхПараметров(АдресаПеременных);
				СтруктураНастроек.Вставить("ГлобальныеПараметры", ГлЯдро_ПолучитьИзКэшаНастройкуSMARTS("ГлобальныеПараметры",, АдресаПеременных));
			КонецЕсли;
		Иначе
			ГлЯдро_СобратьОбщуюСтруктуруБизнесПроцессов(АдресаПеременных);
			ГлЯдро_СобратьОбщуюСтруктуруПроизвольныхКодов(АдресаПеременных);
			ГлЯдро_СобратьОбщуюСтруктуруГлобальныхПараметров(АдресаПеременных);
        КонецЕсли;

		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "ЕстьЧастнаяБаза "+ Строка(ЕстьЧастнаяБаза),НачалоСобытия,АдресаПеременных);
		Возврат ЕстьЧастнаяБаза;
	КонецЕсли;
	Возврат Ложь;
	
КонецФункции

// Сохраняет переданные настройки в хранилище общих настроек
//
// Параметры:
//	 КлючДляСохранения - Строка - ключ настройки для сохранения
//   ДанныеДляСохранения - Произвольный - значение настройки для сохранения
Процедура ГлЯдро_СохранитьДанныеВХранилище1С(КлючДляСохранения, ДанныеДляСохранения) Экспорт
	
	Если ПравоДоступа("АдминистрированиеДанных", Метаданные)  Тогда	
		ХранилищеОбщихНастроек.Сохранить(КлючДляСохранения, "", ДанныеДляСохранения, , "");
		
		ХранилищеОбщихНастроек.Сохранить(КлючДляСохранения, "", ДанныеДляСохранения);
		
		Если ДанныеДляСохранения = Неопределено Тогда
			// Сохранение по старому ключу, чтобы после обнуления кэша из него не подтянулись данные
			НазваниеПараметраТекущегоПользователя = "ТекущийПользователь";
			Если Метаданные.ПараметрыСеанса.Найти("ТекущийПользователь") = Неопределено Тогда
				
				Если Метаданные.ПараметрыСеанса.Найти("глТекущийПользователь") <> Неопределено Тогда
					НазваниеПараметраТекущегоПользователя = "глТекущийПользователь"; // В Штрих-М 5.2 используется такой параметр
				ИначеЕсли Метаданные.ПараметрыСеанса.Найти("Пользователь") <> Неопределено Тогда
					НазваниеПараметраТекущегоПользователя = "Пользователь"; // В Альфа-Авто 5.1 используется такой параметр			
				КонецЕсли;
				
			КонецЕсли;
			ХранилищеОбщихНастроек.Сохранить(КлючДляСохранения, "", ДанныеДляСохранения, , ПараметрыСеанса[НазваниеПараметраТекущегоПользователя].Наименование);
		КонецЕсли;
	Иначе
		ХранилищеОбщихНастроек.Сохранить(КлючДляСохранения, "", ДанныеДляСохранения);
	КонецЕсли;
	
	КлючиНастроек = ГлЯдро_ПолучитьДанныеИзХранилища1С("Cleverence_КлючиНастроек");
	Если ТипЗнч(КлючиНастроек) <> Тип("Массив") Тогда
		КлючиНастроек = Новый Массив;		
	КонецЕсли;
		
	Если КлючиНастроек.Найти(КлючДляСохранения) = Неопределено Тогда
		КлючиНастроек.Добавить(КлючДляСохранения);		
		ГлЯдро_СохранитьДанныеВХранилище1С("Cleverence_КлючиНастроек", КлючиНастроек);
	КонецЕсли;
	
КонецПроцедуры

// Вызывает процедуру обновления шаблонов весового товара в базе Mobile Smarts
//
// Параметры:
//	ТаблицаШаблонов - Массив из Структура - содержит:
//		* Префикс - Строка	
//      * ЦелаяЧасть - Строка
//      * ДробнаяЧасть - Строка
//      * ДлинаКодаВесовогоТовара - Строка
//      * ПрефиксВключенВКод - Булево
//  АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
Процедура ГлЯдро_СохранитьШаблоныВесовогоТовараВБазеSMARTS(ТаблицаШаблонов, ТипБазы, АдресаПеременных) Экспорт
	
	ТипИнтерфейса = КомЯдро_ПолучитьЗначениеПеременной("ТипИнтерфейса",АдресаПеременных);
	Если ТипИнтерфейса = "REST_API" Тогда		
		REST_API_ОбновитьШаблоныВесовогоТовараMS(ТаблицаШаблонов, ТипБазы, АдресаПеременных);		
	Иначе
		КомЯдро_ОбновитьШаблоныВесовогоТовараMS(ТаблицаШаблонов, АдресаПеременных);
	КонецЕсли;
	
КонецПроцедуры

// Устанавливает в базе Mobile Smarts флаг, определяющий, будет ли доступен поиск по наименованию для выгруженной номенклатуры
//
// Параметры:
//	УстановитьПоискПоНаименованиюИАртикулу - флаг, определяющий, будет ли доступен в Mobile Smarts поиск по наименованию для выгруженной номенклатуры
//  АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
Процедура ГлЯдро_УстановитьПоискПоНаименованиюИАртикулу(УстановитьПоискПоНаименованиюИАртикулу, АдресаПеременных) Экспорт
	КомЯдро_УстановитьПоискПоНаименованиюИАртикулу(УстановитьПоискПоНаименованиюИАртикулу, АдресаПеременных);	
КонецПроцедуры

// Вызывает процедуру удаления настроек в базе Mobile Smarts
//
// Параметры:
//	СтруктураНастроек - Структура - ключами являются имена настроек Mobile Smarts, которые необходимо удалить
//  УзловыеНастройки - Неопределено, Структура - ключами являются имена узловых настроек Mobile Smarts - см. ГлЯдро_ПолучитьКатегорииНастроекMS
//  ID_Узла - Строка - идентификатор узла в текущей сессии Mobile Smarts
//  АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
Процедура ГлЯдро_УдалитьНастройкиВБазеSMARTS(СтруктураНастроек, УзловыеНастройки, ID_Узла = "",АдресаПеременных) Экспорт
	
	НачалоСобытия = ТекущаяУниверсальнаяДатаВМиллисекундах();
	ИмяСобытия = "ГлЯдро_УдалитьНастройкиВБазеSMARTS";
	
	ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Начало, Удаление настроек в базе SMARTS", , АдресаПеременных);
		
	// При удалении настроек из базы также удаляем их из настроек пользователя
	ГлЯдро_ОчиститьКэшируемыеНастройки(, СтруктураНастроек, АдресаПеременных);
	
	Если УзловыеНастройки = Неопределено Тогда
		КатегорииНастроекMS = КомЯдро_ПолучитьЗначениеПеременной("КатегорииНастроекMS",АдресаПеременных);
		УзловыеНастройки = КатегорииНастроекMS.УзловыеНастройки;
	КонецЕслИ;
	
	ТипИнтерфейса = КомЯдро_ПолучитьЗначениеПеременной("ТипИнтерфейса",АдресаПеременных);
	Если ТипИнтерфейса = "REST_API" Тогда
		REST_API_УдалитьНастройкиSMARTS(СтруктураНастроек, УзловыеНастройки, ID_Узла,АдресаПеременных);
	Иначе
		КомЯдро_УдалитьНастройкиSMARTS(СтруктураНастроек, УзловыеНастройки, ID_Узла,АдресаПеременных);
	КонецЕсли;
	
	ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Конец, Удаление настроек в базе SMARTS", НачалоСобытия, АдресаПеременных);
	
КонецПроцедуры	

#КонецОбласти

#Область ГлобальныйКонтекст_Настройки_ВспомогательныеМеханизмы

Функция ГлЯдро_КонвертироватьСериализуемыеНастройки(СтруктураНастроек, Направление, СериализуемыеНастройки = Неопределено, КонвертироватьТаблицуЗначенийВМассивСтруктур=Ложь)
	
	Если СериализуемыеНастройки = Неопределено Тогда
		КатегорииНастроекMS = ГлЯдро_ПолучитьКатегорииНастроекMS();
		СериализуемыеНастройки = КатегорииНастроекMS.СериализуемыеНастройки;
	КонецЕсли;
	
	Для Каждого Настройка Из СтруктураНастроек Цикл
		Если НЕ Настройка.Значение = Ложь И СериализуемыеНастройки.Найти(Настройка.Ключ) <> Неопределено Тогда
			ЗначениеНастройки = Настройка.Значение;
			Если НЕ ЗначениеНастройки = Неопределено Тогда
				Если Направление = "ИзСтроки" И ТипЗнч(ЗначениеНастройки) = Тип("Строка") Тогда
					ЗначениеНастройки = ГлЯдро_ЗначениеИзСтрокиXML(ЗначениеНастройки);
				ИначеЕсли Направление = "ВСтроку" Тогда	
					ЗначениеНастройки = ГлЯдро_ЗначениеВСтрокуXML(ЗначениеНастройки);
				КонецЕсли;
			КонецЕсли;
			Если ТипЗнч(ЗначениеНастройки) = Тип ("ТаблицаЗначений") И КонвертироватьТаблицуЗначенийВМассивСтруктур Тогда
				ЗначениеНастройки = ГлЯдро_ТаблицуЗначенийВМассивСтруктур(ЗначениеНастройки);
			КонецЕсли;
			СтруктураНастроек.Вставить(Настройка.Ключ, ЗначениеНастройки);
		КонецЕсли;
	КонецЦикла;
	
	Возврат СтруктураНастроек;
	
КонецФункции

Функция ГлЯдро_ПроверитьТекущиеНастройки(АдресаПеременных)	
	
	СтруктураМетаданных = КомЯдро_ПолучитьЗначениеПеременной("СтруктураМетаданных",АдресаПеременных);
	
	Возврат ТипЗнч(СтруктураМетаданных) = Тип("Структура")
			И СтруктураМетаданных.Свойство("Документы1С")
			И ТипЗнч(СтруктураМетаданных.Документы1С) = Тип("Структура")
			И СтруктураМетаданных.Свойство("НастройкиMS")
			И ТипЗнч(СтруктураМетаданных.НастройкиMS) = Тип("Структура")
			И СтруктураМетаданных.Свойство("ДокументыMS")
			И ТипЗнч(СтруктураМетаданных.ДокументыMS) = Тип("Структура");             
			
КонецФункции

// Находит первое вхождение искомой строки как подстроки в исходной строке.
// Сравнение выполняется с учетом регистра.
//
// Параметры:
//	Строка - Строка - исходная строка
//  ПодстрокаПоиска - Строка - искомая подстрока
//  НаправлениеПоиска - Неопределено, Строка - направление поиска подстроки в строке ("СНачала", "СКонца")
//  НачальнаяПозиция - Неопределено, Число - позиция в строке, с которой начинается поиск
//	НомерВхождения - Число - номер вхождения искомой подстроки в исходной строке
//
// Возвращаемое значение:
//	Число - номер вхождения искомой подстроки в исходной строке
Функция ГлЯдро_СтрНайти(Строка, ПодстрокаПоиска, НаправлениеПоиска = Неопределено, НачальнаяПозиция = Неопределено, НомерВхождения = 1) Экспорт
	
	Результат = 0;
	
	// НаправлениеПоиска: СКонца,СНачала. По умолчанию: СНачала
	Если Строка = "" и ПодстрокаПоиска = "" Тогда
		// чтобы отрабатывало как в платформе
		Если НаправлениеПоиска = "СКонца" Тогда
			Если НомерВхождения = 1 Тогда
				Возврат 1;
			Иначе
				Возврат 0;
			КонецЕсли;
		Иначе
			Возврат мин(НомерВхождения, ?(НачальнаяПозиция=Неопределено, 1, НачальнаяПозиция));
		КонецЕсли;
	КонецЕсли;
	
	Если НачальнаяПозиция = Неопределено Тогда
		Если НаправлениеПоиска = "СКонца" Тогда
			лНачальнаяПозиция = СтрДлина(Строка);
		Иначе
			лНачальнаяПозиция = 1;
		КонецЕсли;
	Иначе
		лНачальнаяПозиция = НачальнаяПозиция;
	КонецЕсли;
	
	Если НаправлениеПоиска = "СКонца" Тогда
		лСтрока = "";
		Для сч = 1 По СтрДлина(Строка) Цикл
			лСтрока = Сред(Строка, сч, 1) + лСтрока;
		КонецЦикла;
		лПодстрокаПоиска = "";
		Для сч = 1 По СтрДлина(ПодстрокаПоиска) Цикл
			лПодстрокаПоиска = Сред(ПодстрокаПоиска, сч, 1) + лПодстрокаПоиска;
		КонецЦикла;
		лНачальнаяПозиция = макс(1, СтрДлина(Строка)-лНачальнаяПозиция-СтрДлина(ПодстрокаПоиска)+2);
	Иначе
		лСтрока = Строка;
		лПодстрокаПоиска = ПодстрокаПоиска;
		лНачальнаяПозиция = лНачальнаяПозиция;
	КонецЕсли;
	
	лНомерВхождения = 0;
	Результат = Найти(Сред(лСтрока, лНачальнаяПозиция), лПодстрокаПоиска);
	Пока Результат Цикл
		лНачальнаяПозиция = Результат + лНачальнаяПозиция + СтрДлина(ПодстрокаПоиска)-1;
		лНомерВхождения = лНомерВхождения + 1;
		Если лНомерВхождения = НомерВхождения Тогда
			Прервать;
		КонецЕсли;
		Результат = Найти(Сред(лСтрока, лНачальнаяПозиция), лПодстрокаПоиска);
	КонецЦикла;
	
	Если лНомерВхождения = НомерВхождения Тогда
		Результат = лНачальнаяПозиция - СтрДлина(ПодстрокаПоиска);
	Иначе
		Результат = 0;
	КонецЕсли;
	
	Если НаправлениеПоиска = "СКонца" И Результат<>0 Тогда
		Результат = СтрДлина(Строка) - Результат - СтрДлина(ПодстрокаПоиска) + 2;
	КонецЕсли;
	
	Возврат Результат;        
			
КонецФункции

// Разделяет строку на части по указанным символам-разделителям
//
// Параметры:
//  Строка			 - Строка	 -  Разделяемая строка
//  Разделитель		 - Строка	 -  Строка символов, каждый из которых является индивидуальным разделителем
//  ВключатьПустые	 - Булево	 -  Указывает необходимость включать в результат пустые строки, 
//									которые могут образоваться в результате разделения исходной строки
// Возвращаемое значение:
//  Результат - Массив	- Массив со строками, которые получились в результате разделения исходной строки.
//
Функция ГлЯдро_СтрРазделить(Строка, Разделитель, ВключатьПустые = Истина) Экспорт
	
	Результат = Новый Массив;
	
	// Для обеспечения обратной совместимости.
	Если ПустаяСтрока(Строка) Тогда 
		Если Разделитель = " " Тогда
			Результат.Добавить("");
		КонецЕсли;
		Возврат Результат;
	КонецЕсли;	
	
	Позиция = ГлЯдро_СтрНайти(Строка, Разделитель);
	Пока Позиция > 0 Цикл
		Подстрока = Лев(Строка, Позиция - 1);
		Если ВключатьПустые Или Не ПустаяСтрока(Подстрока) Тогда
			Если ВключатьПустые Тогда
				Результат.Добавить(Подстрока);				
			Иначе
				Результат.Добавить(СокрЛП(Подстрока));
			КонецЕсли;
		КонецЕсли;
		Строка = Сред(Строка, Позиция + СтрДлина(Разделитель));
		Позиция = ГлЯдро_СтрНайти(Строка, Разделитель);
	КонецЦикла;
	
	Если ВключатьПустые Или Не ПустаяСтрока(Строка) Тогда
		Если ВключатьПустые Тогда
			Результат.Добавить(Строка);			
		Иначе
			Результат.Добавить(СокрЛП(Строка));
		КонецЕсли;
	КонецЕсли;
	
	Возврат Результат;       
			
КонецФункции

Функция ГлЯдро_ПолучитьМаксимальныйКодСимволаСтроки(СтрокаАнализа) Экспорт
	
	ДлинаСтрокиАнализа = СтрДлина(СтрокаАнализа);
	
	МаксимальныйКодСимвола = 0;
	
	Для Счетчик = 1 По ДлинаСтрокиАнализа Цикл
				
		КодТекущегоСимвола = КодСимвола(СтрокаАнализа, Счетчик);
		Если КодТекущегоСимвола > МаксимальныйКодСимвола Тогда
			МаксимальныйКодСимвола = КодТекущегоСимвола;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат МаксимальныйКодСимвола;
	
КонецФункции

Функция ГлЯдро_ПолучитьКлючШифрования(лПароль, ДлинаКодируемойСтроки) Экспорт
	
	лПароль_Длина 	= СтрДлина(лПароль);
	КлючШифрования	= "";
	
	ЧислоДляИнциализацииГенератораСлучаныхЧисел = ГлЯдро_ПолучитьМаксимальныйКодСимволаСтроки(лПароль_Длина);
	
	ЧислоДляИнциализацииГенератораСлучаныхЧисел = ЧислоДляИнциализацииГенератораСлучаныхЧисел + ДлинаКодируемойСтроки;
	
	ГенераторСлучаныхЧисел = Новый ГенераторСлучайныхЧисел(ЧислоДляИнциализацииГенератораСлучаныхЧисел);
		
	СчетчикПоПаролю = Неопределено;
	
	Для Счетчик = 1 По ДлинаКодируемойСтроки Цикл
		
		Если (СчетчикПоПаролю = Неопределено) ИЛИ (СчетчикПоПаролю > лПароль_Длина) Тогда
			
			СчетчикПоПаролю = 1;
				
		КонецЕсли;
		
		СлучайноеСмещение = ГенераторСлучаныхЧисел.СлучайноеЧисло(1, ЧислоДляИнциализацииГенератораСлучаныхЧисел);
				
		СимволПароля = Сред(лПароль, СчетчикПоПаролю, 1);
		
		КлючШифрования = КлючШифрования + Символ(КодСимвола(СимволПароля) + СлучайноеСмещение);
		
		СчетчикПоПаролю = СчетчикПоПаролю + 1;
		
	КонецЦикла;
	
	Возврат КлючШифрования;
	
КонецФункции

Функция ГлЯдро_ЗашифроватьСтроку(КодируемаяСтрока, КлючШифрования) Экспорт
	
	ДлинаКодируемойСтроки = СтрДлина(КодируемаяСтрока);
	
	ЧислоДляИнциализацииГенератораСлучаныхЧисел = ГлЯдро_ПолучитьМаксимальныйКодСимволаСтроки(КлючШифрования);
	
	ЧислоДляИнциализацииГенератораСлучаныхЧисел = ЧислоДляИнциализацииГенератораСлучаныхЧисел + ДлинаКодируемойСтроки;
	
	ГенераторСлучаныхЧисел = Новый ГенераторСлучайныхЧисел(ЧислоДляИнциализацииГенератораСлучаныхЧисел);
	
	ЗакодированнаяСтрока = "";
	
	Для Счетчик = 1 ПО ДлинаКодируемойСтроки Цикл
		
		КодСимволаИсходнойСтроки 	= КодСимвола(КодируемаяСтрока, Счетчик);
		КодСимволаКлючаШифрования 	= КодСимвола(КлючШифрования, Счетчик);		
		СлучайнаяСоставляющая		= ГенераторСлучаныхЧисел.СлучайноеЧисло(1, ЧислоДляИнциализацииГенератораСлучаныхЧисел);
		
		КодЗакодированныгоСимвола = КодСимволаИсходнойСтроки + КодСимволаКлючаШифрования + СлучайнаяСоставляющая;
		
		ЗакодированнаяСтрока = ЗакодированнаяСтрока + Символ(КодЗакодированныгоСимвола);
		
	КонецЦикла;
	
	Возврат ЗакодированнаяСтрока;
	
КонецФункции

Функция ГлЯдро_РасшифроватьСтроку(КодируемаяСтрока, КлючШифрования) Экспорт
	
	ДлинаКодируемойСтроки = СтрДлина(КодируемаяСтрока);
	
	ЧислоДляИнциализацииГенератораСлучаныхЧисел = ГлЯдро_ПолучитьМаксимальныйКодСимволаСтроки(КлючШифрования);
	
	ЧислоДляИнциализацииГенератораСлучаныхЧисел = ЧислоДляИнциализацииГенератораСлучаныхЧисел + ДлинаКодируемойСтроки;

	ГенераторСлучаныхЧисел = Новый ГенераторСлучайныхЧисел(ЧислоДляИнциализацииГенератораСлучаныхЧисел);
	
	ЗакодированнаяСтрока = "";
	
	Для Счетчик = 1 ПО ДлинаКодируемойСтроки Цикл
		
		КодСимволаКлючаШифрования 	= КодСимвола(КлючШифрования, Счетчик);			
		КодЗакодированныгоСимвола 	= КодСимвола(КодируемаяСтрока, Счетчик);
		СлучайнаяСоставляющая		= ГенераторСлучаныхЧисел.СлучайноеЧисло(1, ЧислоДляИнциализацииГенератораСлучаныхЧисел);
		
		КодСимволаИсходнойСтроки = КодЗакодированныгоСимвола - КодСимволаКлючаШифрования - СлучайнаяСоставляющая;
		
		ЗакодированнаяСтрока = ЗакодированнаяСтрока + Символ(КодСимволаИсходнойСтроки);
		
	КонецЦикла;
	
	Возврат ЗакодированнаяСтрока;
	
КонецФункции

// Получает актуальную структуру параметров подключения базы SMARTS
Функция ГлЯдро_ПолучитьСтруктуруПараметровПодключенияSMARTS()
	
	СтруктураПараметровПодключения = Новый Структура;
	СтруктураПараметровПодключения.Вставить("Ид", 							"");
	СтруктураПараметровПодключения.Вставить("Имя", 							"");
	СтруктураПараметровПодключения.Вставить("ИдПриложения", 				"");			
	СтруктураПараметровПодключения.Вставить("ИмяПриложения", 				"");
	СтруктураПараметровПодключения.Вставить("УровеньПриложения", 			0);
	СтруктураПараметровПодключения.Вставить("СтрокаПодключения", 			"");
	СтруктураПараметровПодключения.Вставить("ИдОсновногоПриложения", 		"");
	СтруктураПараметровПодключения.Вставить("РабочийКаталог", 				Ложь);
	СтруктураПараметровПодключения.Вставить("ИмяИнтеграционнойОбработки",	Неопределено);
	СтруктураПараметровПодключения.Вставить("ПутьИнтеграционнойОбработки",	Неопределено);
	СтруктураПараметровПодключения.Вставить("ТипОсновнойОбработки",			"");
	СтруктураПараметровПодключения.Вставить("ПутьОсновнойОбработки",		Неопределено);			
	СтруктураПараметровПодключения.Вставить("УровеньПриложенияСтрокой",		"");
	СтруктураПараметровПодключения.Вставить("ТипУстановленногоПродукта",	"");
	СтруктураПараметровПодключения.Вставить("ТипОбработки",					"");
	СтруктураПараметровПодключения.Вставить("АвторизацияВключена", 			Ложь);
	СтруктураПараметровПодключения.Вставить("АвторизацияЛогин", 			"");
	СтруктураПараметровПодключения.Вставить("АвторизацияТокен", 			"");
	СтруктураПараметровПодключения.Вставить("АвторизацияРефрешТокен",		"");
	СтруктураПараметровПодключения.Вставить("СтрокаПодключенияСМАРТС",		"");
	СтруктураПараметровПодключения.Вставить("IdBaseSMARTS", 				"");
	СтруктураПараметровПодключения.Вставить("QR", 							"");
	СтруктураПараметровПодключения.Вставить("ВерсияПриложения", 			"");
	СтруктураПараметровПодключения.Вставить("Комментарий", 					Неопределено);
	СтруктураПараметровПодключения.Вставить("РаботаСКаталогом", 			Ложь);
	СтруктураПараметровПодключения.Вставить("РаботаСЛокальнымСервером", 	Неопределено);
	СтруктураПараметровПодключения.Вставить("РаботаССервером", 				Ложь);
	СтруктураПараметровПодключения.Вставить("РаботаСУдаленнымСервером", 	Неопределено);
	СтруктураПараметровПодключения.Вставить("РаботаСУстройствомНапрямую", 	Неопределено);
	СтруктураПараметровПодключения.Вставить("ПапкаОбмена", 					"");

	Возврат СтруктураПараметровПодключения;
	
КонецФункции

// Проверка соответствия структуры сохраненных параметров подключения базы SMARTS актуальным
// и в случае необходимости дополнение свойств (для исключения ошибок после обновления)
Функция ГлЯдро_АктуализацияСтруктурыПараметровПодключенияSMARTS(Знач СохраненныеПараметрыПодключения) Экспорт
	
	Если СохраненныеПараметрыПодключения <> Неопределено Тогда
			
		АктуальныеНастройки = ГлЯдро_ПолучитьСтруктуруПараметровПодключенияSMARTS();
		
		Для Каждого АктуальнаяНастройка Из АктуальныеНастройки Цикл
			
			Если Не СохраненныеПараметрыПодключения.Свойство(АктуальнаяНастройка.Ключ) Тогда
				СохраненныеПараметрыПодключения.Вставить(АктуальнаяНастройка.Ключ, АктуальнаяНастройка.Значение);
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат СохраненныеПараметрыПодключения;
	
КонецФункции

// Получает структуру параметров настройки для сохранения на сервере SMARTS
Функция ГлЯдро_СкомпоноватьСтруктуруНастроекДляСохранения(НастройкиБизнесПроцессов, ВерсияНастроек, АдресаПеременных) Экспорт
	
	НовыйФорматНастроек = КомЯдро_ПолучитьЗначениеПеременной("НовыеНастройкиБизнесПроцессов", АдресаПеременных);
	
	Если НовыйФорматНастроек = Неопределено Тогда
		НастройкиБизнесПроцессов_ПоУмолчанию = ГлЯдро_ПолучитьЗначениеКэшируемойНастройки("НастройкиБизнесПроцессов_ПоУмолчанию",, АдресаПеременных);
		
		НовыйФорматНастроек = НастройкиБизнесПроцессов_ПоУмолчанию = Неопределено
			ИЛИ НастройкиБизнесПроцессов_ПоУмолчанию = Ложь
			ИЛИ ТипЗнч(НастройкиБизнесПроцессов_ПоУмолчанию) = Тип("Структура");
		КомЯдро_СохранитьЗначениеПеременной("НовыеНастройкиБизнесПроцессов", НовыйФорматНастроек, АдресаПеременных);
	КонецЕсли;
	
	Если НовыйФорматНастроек Тогда	
		СтруктураНастроек = Новый Структура("ВерсияНастроек, НастройкиБизнесПроцессов", ВерсияНастроек, НастройкиБизнесПроцессов);
	Иначе
		// Для баз со старыми настройками оставляем сохранение настроек как есть, чтобы не сломать работу в случае случайного открытия новой обработки
		СтруктураНастроек = НастройкиБизнесПроцессов;
	КонецЕсли;
		
	Возврат СтруктураНастроек;	
	
КонецФункции

// Получение структуры настроек бизнес-процессов с учетом возможного наличия старых ключей и свойств настроек
//
Функция ГлЯдро_ПолучитьИзКэшаСтруктуруПользовательскихНастроекБизнесПроцессов(АдресаПеременных) Экспорт
	
	Возврат ГлЯдро_ПолучитьИзКэшаСтруктуруНастроекБизнесПроцессов("ВерсияНастроек", "НастройкиБизнесПроцессов_Пользовательские", АдресаПеременных);	
	
КонецФункции

Функция ГлЯдро_ПолучитьИзКэшаСтруктуруИзмененныхТиповыхНастроекБизнесПроцессов(АдресаПеременных) Экспорт
	
	Возврат ГлЯдро_ПолучитьИзКэшаСтруктуруНастроекБизнесПроцессов("ВерсияНастроек", "НастройкиБизнесПроцессов_ПользовательскиеНастройки", АдресаПеременных);	
	
КонецФункции

Функция ГлЯдро_ПолучитьИзКэшаСтруктуруНастроекПоУмолчаниюБизнесПроцессов(АдресаПеременных) Экспорт
	
	Возврат ГлЯдро_ПолучитьИзКэшаСтруктуруНастроекБизнесПроцессов("ВерсияНастроек_ПоУмолчанию", "НастройкиБизнесПроцессов_ПоУмолчанию", АдресаПеременных);	
	
КонецФункции

Функция ГлЯдро_ПолучитьИзКэшаСтруктуруНастроекБизнесПроцессов(ВерсияНастроекИмя = "", НастройкиБизнесПроцессовИмя = "", АдресаПеременных) Экспорт
	
	СтруктураВозврат = Новый Структура("ВерсияНастроек,НастройкиБизнесПроцессов", Неопределено, Неопределено);	
	
	СтруктураНастроекБизнесПроцессов = ГлЯдро_ПолучитьИзКэшаНастройкуSMARTS(НастройкиБизнесПроцессовИмя,, АдресаПеременных);
	
	Если ТипЗнч(СтруктураНастроекБизнесПроцессов) = Тип("Структура") Тогда
		ЗаполнитьЗначенияСвойств(СтруктураВозврат, СтруктураНастроекБизнесПроцессов);				
	Иначе	
		СтруктураВозврат.ВерсияНастроек 			= ГлЯдро_ПолучитьИзКэшаНастройкуSMARTS(ВерсияНастроекИмя,, АдресаПеременных);
		СтруктураВозврат.НастройкиБизнесПроцессов 	= СтруктураНастроекБизнесПроцессов;
	КонецЕсли;     	
	
	Возврат СтруктураВозврат;
	
КонецФункции

Функция ГлЯдро_ПолучитьСтруктуруПользовательскихНастроекБизнесПроцессовНаСервереSMARTS(ID_Узла = "", АдресаПеременных) Экспорт
	
	Возврат ГлЯдро_ПолучитьСтруктуруНастроекБизнесПроцессовНаСервереSMARTS("ВерсияНастроек", "НастройкиБизнесПроцессов_Пользовательские", ID_Узла, АдресаПеременных);	
	
КонецФункции

Функция ГлЯдро_ПолучитьСтруктуруИзмененныхТиповыхНастроекБизнесПроцессовНаСервереSMARTS(ID_Узла = "", АдресаПеременных) Экспорт
	
	Возврат ГлЯдро_ПолучитьСтруктуруНастроекБизнесПроцессовНаСервереSMARTS("ВерсияНастроек", "НастройкиБизнесПроцессов_ПользовательскиеНастройки", ID_Узла, АдресаПеременных);	
	
КонецФункции

Функция ГлЯдро_ПолучитьСтруктуруНастроекБизнесПроцессовПоУмолчаниюНаСервереSMARTS(ID_Узла = "", АдресаПеременных) Экспорт
	
	Возврат ГлЯдро_ПолучитьСтруктуруНастроекБизнесПроцессовНаСервереSMARTS("ВерсияНастроек_ПоУмолчанию", "НастройкиБизнесПроцессов_ПоУмолчанию", ID_Узла, АдресаПеременных);	
	
КонецФункции

Функция ГлЯдро_ПолучитьСтруктуруНастроекБизнесПроцессовНаСервереSMARTS(ВерсияНастроекИмя = "", НастройкиБизнесПроцессовИмя = "", ID_Узла, АдресаПеременных) Экспорт
	
	СтруктураВозврат = Новый Структура("ВерсияНастроек,НастройкиБизнесПроцессов", Неопределено, Неопределено);	
	
	пСтруктураНастроек = Новый Структура;
	пСтруктураНастроек.Вставить(НастройкиБизнесПроцессовИмя, Ложь);
	пСтруктураНастроек.Вставить(ВерсияНастроекИмя, Ложь); 
	
	СтруктураНастроек = ГлЯдро_ПолучитьНастройкиНаСервереSMARTS(пСтруктураНастроек,, ID_Узла, АдресаПеременных);		
	СтруктураНастроекБизнесПроцессов = СтруктураНастроек[НастройкиБизнесПроцессовИмя];
		
	Если ТипЗнч(СтруктураНастроекБизнесПроцессов) = Тип("Структура") Тогда
		ЗаполнитьЗначенияСвойств(СтруктураВозврат, СтруктураНастроекБизнесПроцессов);		
	Иначе		
		СтруктураВозврат.ВерсияНастроек 			= СтруктураНастроек[ВерсияНастроекИмя];
		СтруктураВозврат.НастройкиБизнесПроцессов 	= СтруктураНастроекБизнесПроцессов;
	КонецЕсли;                 	
	
	Возврат СтруктураВозврат;
	
КонецФункции

// Возвращает версию структуры настроек из структуры СведенияОВнешнейОбработке
//
Функция ГлЯдро_ПолучитьВерсиюСтруктурыНастроекОбработки() Экспорт
	
	Возврат СведенияОВнешнейОбработке().ВерсияСтруктурыНастроек;
	
КонецФункции

// Возвращает признак использования новых настроек в базе
//
Функция ГлЯдро_ПроверитьИспользованиеНовойСтруктурыНастроекБизнесПроцессов(АдресаПеременных) Экспорт
	
	НастройкиБизнесПроцессов_ПоУмолчанию = ГлЯдро_ПолучитьИзКэшаСтруктуруНастроекПоУмолчаниюБизнесПроцессов(АдресаПеременных);
	
	НетТиповыхНастроек = (НастройкиБизнесПроцессов_ПоУмолчанию = Неопределено Или НастройкиБизнесПроцессов_ПоУмолчанию = Ложь);
	
	ИспользоватьСтруктуру = НетТиповыхНастроек Или ТипЗнч(НастройкиБизнесПроцессов_ПоУмолчанию) = Тип("Структура");
	
	Возврат ИспользоватьСтруктуру;
	
КонецФункции

Функция ГлЯдро_ДеревоПользователейВоВременноеХранилище(СписокПользователейMS) Экспорт
	Если ТипЗнч(СписокПользователейMS)  <> Тип("СписокЗначений") Тогда
		Возврат Неопределено;
	КонецЕсли; 

	ПользователиMS = Новый ДеревоЗначений;
	ПользователиMS.Колонки.Добавить("Выгружать", 			Новый ОписаниеТипов("Булево"), "Выгружать");
	ПользователиMS.Колонки.Добавить("ГруппаПользователь", 	Новый ОписаниеТипов("Строка"), "Группа/пользователь");
	ПользователиMS.Колонки.Добавить("ИдГруппыПользователя", Новый ОписаниеТипов("Строка"), "Ид группы/пользователя");	
	
	Для Каждого Пользователь из СписокПользователейMS Цикл
		
		ИдИИмяПользователя 	= ГлЯдро_РазложитьСтрокуВМассивПодстрок(Пользователь.Значение, 		";");
		ИдИИмяГруппы 		= ГлЯдро_РазложитьСтрокуВМассивПодстрок(Пользователь.Представление, ";");
		
		Если ИдИИмяГруппы.Количество() >= 2 Тогда
			ИдГруппы  	= ИдИИмяГруппы[0];
			ИмяГруппы 	= ИдИИмяГруппы[1];			
		Иначе
			ИдГруппы 	= Неопределено;
			ИмяГруппы 	= Неопределено;			
		КонецЕсли;	
		
		ИдПользователя  = ИдИИмяПользователя[0];
		ИмяПользователя = ИдИИмяПользователя[1];		
		
		// Если у элемента нет группы, значит, элемент сам является группой, добавляем его в корень дерева пользователей MS
		Если ИдГруппы = Неопределено Тогда
			
			СтрокаДерева 						= ПользователиMS.Строки.Добавить();
			СтрокаДерева.ИдГруппыПользователя 	= ИдПользователя;
			СтрокаДерева.ГруппаПользователь 	= ИмяПользователя;					
			
		Иначе	
			
			// иначе - ищем группу в корне дерева
			СтрокаПоискаГруппы = ПользователиMS.Строки.Найти(ИдГруппы, "ИдГруппыПользователя");			
			
			// если не нашли, добавляем группу в корень дерева, а в группу - пользователя
			Если СтрокаПоискаГруппы = Неопределено Тогда
				
				СтрокаГруппы 						= ПользователиMS.Строки.Добавить();
				СтрокаГруппы.ИдГруппыПользователя 	= ИдГруппы;
				СтрокаГруппы.ГруппаПользователь 	= ИмяГруппы;
				
				СтрокаПользователя 						= СтрокаГруппы.Строки.Добавить();
				СтрокаПользователя.ИдГруппыПользователя = ИдПользователя;
				СтрокаПользователя.ГруппаПользователь 	= ИмяПользователя;			
				
			Иначе
				
				// иначе - добавляем в найденную группу пользователя
				СтрокаДерева 						= СтрокаПоискаГруппы.Строки.Добавить();
				СтрокаДерева.ИдГруппыПользователя 	= ИдПользователя;
				СтрокаДерева.ГруппаПользователь 	= ИмяПользователя;			
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла; 
	
	Возврат ПоместитьВоВременноеХранилище(ПользователиMS,Новый УникальныйИдентификатор());
	
КонецФункции

Функция ГлЯдро_ДеревоУстройствВоВременноеХранилище(СписокУстройствMS, флЛегкоеОблако = Ложь)
	
	Если ТипЗнч(СписокУстройствMS) <> Тип("СписокЗначений") Тогда
		Возврат Неопределено;
	КонецЕсли; 

	УстройстваMS = Новый ДеревоЗначений;
	УстройстваMS.Колонки.Добавить("Выгружать", 			  Новый ОписаниеТипов("Булево"), "Выгружать");
	Если флЛегкоеОблако Тогда
		УстройстваMS.Колонки.Добавить("ПинКод",   		  Новый ОписаниеТипов("Строка"), "Пин-код");
	КонецЕсли;
	УстройстваMS.Колонки.Добавить("ГруппаПользователь",   Новый ОписаниеТипов("Строка"), "Группа/пользователь");
	УстройстваMS.Колонки.Добавить("ИдГруппыПользователя", Новый ОписаниеТипов("Строка"), "Ид группы/пользователя");	
	
	Для Каждого Устройство из СписокУстройствMS Цикл
		
		ИдИИмяУстройства = ГлЯдро_РазложитьСтрокуВМассивПодстрок(Устройство.Значение, ";");
		
		Если флЛегкоеОблако Тогда
			ПинУстройства  	= ИдИИмяУстройства[0];
			ИдУстройства  	= ИдИИмяУстройства[1];
			ИмяУстройства 	= ИдИИмяУстройства[2];		
		Иначе
			ИдУстройства  	= ИдИИмяУстройства[0];
			ИмяУстройства 	= ИдИИмяУстройства[1];		
		КонецЕсли;
		
		СтрокаДерева 						= УстройстваMS.Строки.Добавить();
		СтрокаДерева.ИдГруппыПользователя 	= ИдУстройства;
		СтрокаДерева.ГруппаПользователь 	= ИмяУстройства;					
		Если флЛегкоеОблако Тогда
			СтрокаДерева.ПинКод				= ПинУстройства;					
		КонецЕсли;
		
	КонецЦикла; 
	
	Возврат ПоместитьВоВременноеХранилище(УстройстваMS, Новый УникальныйИдентификатор());
	
КонецФункции

Процедура ГлЯдро_ПересохранитьЗначенияПеременныхВФЗ(АдресаПеременных, МассивАдресовПустыхЗначений)

	ИмяСобытия = "ГлЯдро_ПересохранитьЗначенияПеременныхВФЗ";
	
	Индекс = 0;
	
	КоличествоАдресовПустыхЗначений = МассивАдресовПустыхЗначений.Количество();
	
	// Пересохраняем значения, записанные в кэш в фоновом задании, т.к.
	// значение должно быть сохранено по адресу врем хранилища, переданному из родительского сеанса.
	// Делаем пересохранение в конце ФЗ, т.к. если это сделать в методе КомЯдро_СохранитьЗначениеПеременной, 
	// то значения не будут доступны в самом ФЗ	
	Для Каждого ЭлементАдресовПеременных Из АдресаПеременных Цикл
		
		Если ЭлементАдресовПеременных.Ключ = "ИдентификаторФормы" Тогда
			// Не обрабатываем
			Продолжить;
		КонецЕсли;
		
		Если Не ЭтоАдресВременногоХранилища(ЭлементАдресовПеременных.Значение) И
			ЭлементАдресовПеременных.Значение <> Неопределено Тогда
			
			Если ТипЗнч(ЭлементАдресовПеременных.Значение) = Тип("Структура") Тогда
				СтруктураЭлементаАдресовПеременных = ЭлементАдресовПеременных.Значение;
				Для каждого ЭлементСтруктуры ИЗ СтруктураЭлементаАдресовПеременных Цикл
				    Если ЭтоАдресВременногоХранилища(ЭлементСтруктуры.Значение) Тогда
						Если Индекс >= КоличествоАдресовПустыхЗначений Тогда
							ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Переполнение пула адресов пустых значений!",, АдресаПеременных);
							Прервать;
						КонецЕсли;
						
						ЗначениеИзВременногоХранилища = ПолучитьИзВременногоХранилища(ЭлементСтруктуры.Значение);
						СтруктураЭлементаАдресовПеременных.Вставить(ЭлементСтруктуры.Ключ, ПоместитьВоВременноеХранилище(ЗначениеИзВременногоХранилища, МассивАдресовПустыхЗначений[Индекс]));
						Индекс = Индекс + 1;	
					КонецЕсли;
				КонецЦикла;
			КонецЕсли;
			
			Если Индекс >= КоличествоАдресовПустыхЗначений Тогда
				ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Переполнение пула адресов пустых значений!",, АдресаПеременных);
				Прервать;
			КонецЕсли;
			
			// Необходимо сохранить во врем хранилище по адресу, полученному из родительского сеанса
			АдресаПеременных.Вставить(ЭлементАдресовПеременных.Ключ, ПоместитьВоВременноеХранилище(ЭлементАдресовПеременных.Значение, МассивАдресовПустыхЗначений[Индекс]));
			
			Индекс = Индекс + 1;
		КонецЕсли;
	
	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти

#Область ГлобальныйКонтекст_Настройки_ПрочиеМетоды

// Получает подходящую настройку (настройки) бизнес-процесса
//
// Параметры:
//	ID_БизнесПроцесса - Строка - идентификатор бизнес-процесса, настройку которого необходимо получить	
//  ТипДокументаMS - Строка - тип документа Mobile Smarts, для которого выполняется получение настройки
//	НастройкиДляОбмена - Неопределено, ТаблицаЗначений, Массив из Структура - таблица настроек бизнес-процессов
//	АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
//
// Возвращаемое значение:
//	- Неопределено - если получить подходящую настройку бизнес-процесса не удалось
//	- Структура - содержит:
//		* Статус - Булево - признак того, что получена единственная настройки
//      * Данные - Структура - содержит настройку бизнес-процесса, если она единственная
//				 - Массив из СтрокаТаблицыЗначений - если настройки бизнес-процессов хранятся в виде таблицы значений
//				 - Массив из Структура - если настройки бизнес-процессов хранятся в виде массива структур
Функция ГлЯдро_ПолучитьНастройкуБизнесПроцесса(ID_БизнесПроцесса, ТипДокументаMS, НастройкиДляОбмена = Неопределено, ВключаяОтключенные = Ложь, АдресаПеременных) Экспорт
	
	Результат = Неопределено;
	
	Если НастройкиДляОбмена = Неопределено Тогда
		НастройкиДляОбмена = ГлЯдро_ПолучитьИзКэшаНастройкуSMARTS("НастройкиБизнесПроцессов",,АдресаПеременных);
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ID_БизнесПроцесса) Тогда
		Если ВключаяОтключенные = Истина Тогда
			Отбор = Новый Структура("ID_БизнесПроцесса", ID_БизнесПроцесса);
		Иначе
			Отбор = Новый Структура("ID_БизнесПроцесса,Используется", ID_БизнесПроцесса, Истина);	
		КонецЕсли;
		Если ТипЗнч(НастройкиДляОбмена) = Тип("ТаблицаЗначений") Тогда
			ПодходящиеНастройки = НастройкиДляОбмена.НайтиСтроки(Отбор);
		Иначе
			ПодходящиеНастройки = ГлЯдро_СкопироватьМассив(НастройкиДляОбмена,Отбор);
		КонецЕсли;
	Иначе
		Если ВключаяОтключенные = Истина Тогда
			Отбор = Новый Структура("ТипДокументаMS,ТипИсходногоДокумента1С", ТипДокументаMS, "");
		Иначе
			Отбор = Новый Структура("ТипДокументаMS,ТипИсходногоДокумента1С,Используется", ТипДокументаMS, "", Истина);	
		КонецЕсли;
		Если ТипЗнч(НастройкиДляОбмена) = Тип("ТаблицаЗначений") Тогда
			ПодходящиеНастройки = НастройкиДляОбмена.НайтиСтроки(Отбор);
		Иначе
			ПодходящиеНастройки = ГлЯдро_СкопироватьМассив(НастройкиДляОбмена,Отбор);
		КонецЕсли;
	КонецЕсли;
	
	Если ПодходящиеНастройки.Количество() = 1 Тогда
		СтрокаНастройки = ПодходящиеНастройки[0];
		Если ТипЗнч(НастройкиДляОбмена) = Тип("ТаблицаЗначений") Тогда 
			НастройкаБП = Новый Структура;
			Для Каждого Колонка Из НастройкиДляОбмена.Колонки Цикл
				НастройкаБП.Вставить(Колонка.Имя, СтрокаНастройки[Колонка.Имя]);
			КонецЦикла;
		Иначе
			НастройкаБП = СтрокаНастройки;
		КонецЕсли;
		Результат = Новый Структура("Статус,Данные", Истина, НастройкаБП);
	Иначе
		Результат = Новый Структура("Статус,Данные", Ложь, ПодходящиеНастройки);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции
 
// Получает сведения о внешней обработке по заданному ключу
//
// Параметры:
//	КлючИнформации - Строка - ключ сведений о внешней обработке, которые необходимо получить	
//
// Возвращаемое значение:
//  - Произвольный - значение, полученное из сведений о внешней обработке - см. СведенияОВнешнейОбработке
//	- Неопределено - если в сведениях о внешней обработке нет ключа, переданного в параметре КлючИнформации
Функция ГлЯдро_ПолучитьИнформациюОВнешнейОбработке(КлючИнформации) Экспорт
	
	ДанныеОбработки = Неопределено;
	
	ИнформацияОбработки = СведенияОВнешнейОбработке();
	Если ИнформацияОбработки.Свойство(КлючИнформации) Тогда
		ДанныеОбработки = ИнформацияОбработки[КлючИнформации];
	КонецЕсли;
	
	Возврат ДанныеОбработки;
	
КонецФункции

Функция ГлЯдро_НастройкиИзменились(АдресаПеременных)
		
	ПараметрыПодключенияMS = ГлЯдро_ПолучитьДанныеИзХранилища1С("Cleverence_ПараметрыПодключенияMS");
	Если ТипЗнч(ПараметрыПодключенияMS) = Тип("Структура")
		И ПараметрыПодключенияMS.Свойство("Ид") Тогда
		ПостфиксБазы = СтрЗаменить(ПараметрыПодключенияMS.Ид,"-","_");
	Иначе
		Возврат Ложь; //Вернем ложь т.к. все равно не можем ничего поделать :(
	КонецЕсли;
	
	ДатаАктуальностиНастроекв1С = ГлЯдро_ПолучитьДанныеИзХранилища1С("Cleverence_ДатаАктуальностиНастроек_"+ПостфиксБазы);
	
	ЭтоВнешнееСоединение = Ложь;
	#Если ВнешнееСоединение Тогда
		ЭтоВнешнееСоединение = Истина;	
	#КонецЕсли
	
	Если ЭтоWebСервис ИЛИ ЭтоВнешнееСоединение Тогда
		ДатаАктуальностиТекущихНастроек = ГлЯдро_ПолучитьДанныеИзХранилища1С("Cleverence_ДатаАктуальностиКэша");
	Иначе
		ДатаАктуальностиТекущихНастроек = КомЯдро_ПолучитьЗначениеПеременной("ДатаАктуальностиНастроек",АдресаПеременных);
	КонецЕсли;
		
	Если ДатаАктуальностиТекущихНастроек = Неопределено 
		ИЛИ ТипЗнч(ДатаАктуальностиТекущихНастроек) <> Тип("Дата") Тогда
		ДатаАктуальностиТекущихНастроек = ТекущаяДата();
		КомЯдро_СохранитьЗначениеПеременной("ДатаАктуальностиНастроек",ДатаАктуальностиТекущихНастроек,АдресаПеременных);
		Возврат Истина;
	КонецЕсли;
	
	Если ДатаАктуальностиНастроекв1С = Неопределено 
		ИЛИ ТипЗнч(ДатаАктуальностиНастроекв1С) <> Тип("Дата")
		ИЛИ ДатаАктуальностиНастроекв1С < ДатаАктуальностиТекущихНастроек Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

// Возвращает информацию об основной обработке
//
// Возвращаемое значение:
//   Структура - составные части URI согласно формату:
//		ПутьОсновнойОбработки 	- Строка, СправочникСсылка - путь основной обработки
//		ТипОсновнойОбработки 	- Строка - тип основной обработки. Например, "ФайлНаДиске", "СправочникСсылка", "Встроенная"
//		ИмяОсновнойОбработки 	- Строка - имя основной обработки
Функция ГлЯдро_ПолучитьИнформациюОсновнойОбработки() Экспорт
	
	ДанныеОсновнойОбработки = Новый Структура;
	
	#Область НесовместимыйКодFresh
	ПутьОсновнойОбработки 	= ЭтотОбъект.ИспользуемоеИмяФайла;
	#КонецОбласти //НесовместимыйКодFresh
	#Область СовместимыйКодFresh
	//ПутьОсновнойОбработки = "";
	#КонецОбласти //СовместимыйКодFresh
	ТипОсновнойОбработки 	= "ФайлНаДиске";
	
	ИмяМетаданных = ЭтотОбъект.Метаданные().Имя;
	
	//ЭтоВстроеннаяОбработка = Метаданные.Обработки.Найти(ИмяМетаданных) <> Неопределено;
	//Если ЭтоВстроеннаяОбработка Тогда
	//	ПутьОсновнойОбработки 	= ИмяМетаданных;	
	//	ТипОсновнойОбработки 	= "Встроенная";
	//КонецЕсли;
	
	//ИспользованиеДопОтчетовИОбработок = ГлЯдро_ПолучитьИспользованиеДополнительныхОтчетовИОбработок();
	//
	//Если ИспользованиеДопОтчетовИОбработок
	//	И Метаданные.Справочники.Найти("ДополнительныеОтчетыИОбработки") <> Неопределено Тогда
	//	
	//	СсылкаНаОбработку = Справочники["ДополнительныеОтчетыИОбработки"].НайтиПоНаименованию(ИмяМетаданных);
	//	Если ЗначениеЗаполнено(СсылкаНаОбработку) И Не СсылкаНаОбработку.ПометкаУдаления Тогда
	//		ПутьОсновнойОбработки = СсылкаНаОбработку;
	//		ТипОсновнойОбработки = "СправочникСсылка";
	//	КонецЕсли;
	//	
	//КонецЕсли;
	
	ДанныеОсновнойОбработки.Вставить("ПутьОсновнойОбработки", 	ПутьОсновнойОбработки);
	ДанныеОсновнойОбработки.Вставить("ТипОсновнойОбработки", 	ТипОсновнойОбработки);
	ДанныеОсновнойОбработки.Вставить("ИмяОсновнойОбработки", 	ИмяМетаданных);
	
	Возврат ДанныеОсновнойОбработки;
	
КонецФункции

// Получает признак использования в конфигурации дополнительных отчетов и обработок
//
// Возвращаемое значение:
//   Булево 	- использование в конфигурации дополнительных отчетов и обработок
//
Функция ГлЯдро_ПолучитьИспользованиеДополнительныхОтчетовИОбработок(АдресаПеременных) Экспорт
	
	ИмяСобытия = "ГлЯдро_ПолучитьИспользованиеДополнительныхОтчетовИОбработок";
	
	Результат = Ложь;
	
	#Если ТолстыйКлиентОбычноеПриложение Тогда
		Если Метаданные.Справочники.Найти("ВнешниеОбработки") <> Неопределено
			Или Метаданные.Справочники.Найти("ВнешниеПечатныеФормы") <> Неопределено Тогда
			Результат = Истина;
		КонецЕсли;
	#Иначе
		ФункцОпцияНеНайдена 			= Ложь;
		ИспользоватьДопОтчетыИОбработки = Ложь;
		
		Если Метаданные.ФункциональныеОпции.Найти("ИспользоватьДополнительныеОтчетыИОбработки") <> Неопределено Тогда
			ИмяКонстанты = Метаданные.ФункциональныеОпции.ИспользоватьДополнительныеОтчетыИОбработки.Хранение.Имя;
			ИспользоватьДопОтчетыИОбработки = Константы[ИмяКонстанты].Получить();
			//Включение использования доп отчетов и обработок
			Если Не ИспользоватьДопОтчетыИОбработки Тогда
				Попытка
					Константы[ИмяКонстанты].Установить(Истина);
					ИспользоватьДопОтчетыИОбработки = Истина;
				Исключение
					ТекстОшибки = "Ошибка установки значения константы " + ИмяКонстанты + ": " + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
					ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", ТекстОшибки,, АдресаПеременных);					
				КонецПопытки;
			КонецЕсли;			
		Иначе
			ФункцОпцияНеНайдена = Истина;
		КонецЕсли;
		
		Если (ИспользоватьДопОтчетыИОбработки Или ФункцОпцияНеНайдена)
			И Метаданные.Справочники.Найти("ДополнительныеОтчетыИОбработки") <> Неопределено Тогда
			Результат = Истина;
		КонецЕсли;
		
	#КонецЕсли

	Возврат Результат;
	
КонецФункции

// Возвращает структуру с именами расширений, где Ключ - некоторое внутреннее обозначение расширения, Значение - имя файла расширения
// В данной функции необходимо задавать имена файлов расширений, а в коде искать расширение по ключу
//
// Возвращаемое значение:
//   Структура   - структура имен расширений, где Ключ - некоторое внутреннее обозначение расширения, Значение - имя файла расширения
//
Функция ГлЯдро_ПолучитьСтруктуруИменРасширений() Экспорт

	СтруктураИменРасширений = Новый Структура;
	
	СтруктураИменРасширений.Вставить("РасширениеСКнопкамиОбмена", 	"CleverenceButtonsExtension");
	СтруктураИменРасширений.Вставить("РасширениеДляВебСервиса", 	"CleverenceWebExtension");
	СтруктураИменРасширений.Вставить("РасширениеТабак", 			"CleverenceTobaccoExtension");	
	
	Возврат СтруктураИменРасширений;

КонецФункции

// Подключает файл в справочник дополнительных отчетов и обработок
//
// Параметры:
//	АдресФайла 									- Строка - адрес файла во временном хранилище
//	ИмяФайла 									- Строка - имя файла
//	ОтключатьКонфликтующие 						- Булево - признак отключения обработок/отчетов с аналогичным именем
//	ДобавитьВБыстрыйДоступТекПользователя		- Булево - необходимость добавления в быстрый доступ текущего пользователя
//	ПеренестиБыстрыйДоступИзПредыдущейВерсии 	- Булево - необходимость заполнения быстрого доступа значениями из предыдущей версии обработки/отчета
//	ДобавитьВоВсеРазделы 						- Булево - необходимость добавления обработки/отчета во все разделы
//	ПеренестиРазделыИзПредыдущейВерсии 			- Булево - необходимость заполнения разделов значениями из предыдущей версии обработки/отчета
//
// Возвращаемое значение:
//   Структура   - структура результата подключения в следующем формате:
//		* Подключено - Булево - признак успешности подлючения файла в справочник
//		* ПодключеноРанее 	- Булево - признак, что файл с таким именем уже подключен в справочник
//		* ТекстОшибки 		- Строка - информация об ошибке при подключении
//		* ТипОбработки 		- Строка - тип обработки
//		* ИмяФайла 			- Строка - имя подключаемого файла
//		* ОбработкаСсылка 	- СправочникСсылка.ДополнительныеОтчетыИОбработки - ссылка на подключенную обработку/отчет
//		* Версия 			- Строка - версия подключенной обработки/отчета
//
Функция ГлЯдро_ПодключитьФайлВСправочникДополнительныхОтчетовИОбработок(АдресФайла, ИмяФайла, ОтключатьКонфликтующие = Ложь, ДобавитьВБыстрыйДоступТекПользователя = Ложь, 
	ПеренестиБыстрыйДоступИзПредыдущейВерсии = Ложь, ДобавитьВоВсеРазделы = Ложь, ПеренестиРазделыИзПредыдущейВерсии = Ложь, ИмяОсновнойОбработки = Ложь, 
	ИмяИнтеграционнойОбработки = Ложь, ВерсияПриложенияАктуальная = Ложь, НеОбновлятьВерсиюПриложения = Ложь, АдресаПеременных) Экспорт

	#Область НесовместимыйКодFresh
	ИмяСобытия = "ГлЯдро_ПодключитьФайлВСправочникДополнительныхОтчетовИОбработок";
	
	УстановитьПривилегированныйРежим(Истина);
	
	РезультатПодключения = Новый Структура;
	
	Подключено 				= Ложь;
	ПодключеноРанее			= Ложь;
	ТекстОшибки 			= "";
	ТипОбработки 			= "ФайлНаДиске";
	ОбработкаСсылка 		= Неопределено;
	Версия 					= "0.0.0.0";
	СинонимСправочника 		= ""; // Для вывода сообщения о необходимости перезапуска обработки из справочника
	
	Если ГлЯдро_ПолучитьИспользованиеДополнительныхОтчетовИОбработок(АдресаПеременных) Тогда
		#Если ТолстыйКлиентОбычноеПриложение Тогда
			Метаданные_Справочник = Метаданные.Справочники.Найти("ВнешниеОбработки");
			Если Метаданные_Справочник = Неопределено Тогда
				Метаданные_Справочник = Метаданные.Справочники.Найти("ВнешниеПечатныеФормы");
			КонецЕсли;
			
			ИмяСправочника 		= Метаданные_Справочник.Имя;
			СинонимСправочника 	= Метаданные_Справочник.Синоним;
			
			Попытка
				
				ОбъектСправочника = Справочники[ИмяСправочника].СоздатьЭлемент();
				
				Если ЭтоАдресВременногоХранилища(АдресФайла) Тогда
					ДвоичныеДанные = ПолучитьИзВременногоХранилища(АдресФайла);
					ИмяОбработки = ПолучитьИмяВременногоФайла();
					ДвоичныеДанные.Записать(ИмяОбработки);

					ВнешняяОбработка = ВнешниеОбработки.Создать(ИмяОбработки, Ложь);
					
					ОбъектСправочника.Наименование 	= ВнешняяОбработка.Метаданные().Имя;
					
					МетаданныеСправочника 	= ОбъектСправочника.Метаданные();
					РеквизитыСправочника 	= МетаданныеСправочника.Реквизиты;
					Для каждого Реквизит Из РеквизитыСправочника Цикл
						Если Реквизит.Тип.СодержитТип(Тип("ХранилищеЗначения")) Тогда
							ОбъектСправочника[Реквизит.Имя] = Новый ХранилищеЗначения(ДвоичныеДанные);
							Прервать;
						КонецЕсли;
					КонецЦикла;
					
					//Заполнение реквизита "ВидОбработки"
					Если РеквизитыСправочника.Найти("ВидОбработки") <> Неопределено Тогда
						ОписаниеТипаРеквизита = РеквизитыСправочника["ВидОбработки"].Тип;
						//Берем первый тип из описания типов
						ТипРеквизита = ОписаниеТипаРеквизита.Типы()[0];
						МетаданныеПеречисления = Метаданные.НайтиПоТипу(ТипРеквизита);
						Если МетаданныеПеречисления <> Неопределено Тогда
							
							//Поиск по значениям перечисления
							ЗначенияПеречисления = МетаданныеПеречисления.ЗначенияПеречисления;
							Для каждого ЗначениеПеречисления Из ЗначенияПеречисления Цикл
							    //Если в имени значения есть "Обработка", то выбираем это значение
								Если ГлЯдро_СтрНайти(ЗначениеПеречисления.Имя, "Обработка") > 0 Тогда
									ОбъектСправочника["ВидОбработки"] = Перечисления[МетаданныеПеречисления.Имя][ЗначениеПеречисления.Имя];
									Прервать;
								КонецЕсли;							
							КонецЦикла;
						КонецЕсли;
					КонецЕсли;
										
					РегистрационныеДанные = ВнешняяОбработка.СведенияОВнешнейОбработке();
					Версия = РегистрационныеДанные.Версия;
					
					Если ИмяСправочника = "ВнешниеПечатныеФормы" Тогда
						ОбъектСправочника.Родитель 		= Справочники[ИмяСправочника].НайтиПоНаименованию("Внешние обработки");
						ОбъектСправочника.ВерсияФормы 	= ТекущаяДатаСеанса();
					КонецЕсли;
					
					ОбъектСправочника.Записать();
					
					Подключено = Истина;
					ТипОбработки = "СправочникСсылка";
					ОбработкаСсылка = ОбъектСправочника.Ссылка;
					
				КонецЕсли;
			Исключение
				ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());				
			КонецПопытки;
		#Иначе
			Метаданные_МодульДопОтчетыИОбработки = Метаданные.ОбщиеМодули.Найти("ДополнительныеОтчетыИОбработки");
			
			Если Метаданные_МодульДопОтчетыИОбработки <> Неопределено Тогда
				
				МодульДопОтчетыИОбработки = Вычислить(Метаданные_МодульДопОтчетыИОбработки.Имя);
				
				Метаданные_Справочник = Метаданные.Справочники.ДополнительныеОтчетыИОбработки;
				СинонимСправочника = Метаданные_Справочник.Синоним;
				
				ОбъектСправочника = Справочники[Метаданные_Справочник.Имя].СоздатьЭлемент();
				ОбъектСправочника.Заполнить(Новый Структура); //Для заполнения реквизитов значениями из свойства "ЗначениеЗаполнения"
				
				ПараметрыРегистрации = Новый Структура;
				ПараметрыРегистрации.Вставить("АдресДанныхОбработки", 	АдресФайла);
				ПараметрыРегистрации.Вставить("ЭтоОтчет", 				Ложь);
				ПараметрыРегистрации.Вставить("ОтключатьКонфликтующие", ОтключатьКонфликтующие);
				ПараметрыРегистрации.Вставить("Конфликтующие", 			Новый СписокЗначений);
				ПараметрыРегистрации.Вставить("ИмяФайла", 				ИмяФайла);
				ПараметрыРегистрации.Вставить("ОтключатьПубликацию", 	Ложь);
				ПараметрыРегистрации.Вставить("Успех", 					Ложь);
				
				РезультатРегистрации = Неопределено;
				Попытка //Т.к. в разных версиях БСП процедура может отличаться, то используем попытку
					РезультатРегистрации = МодульДопОтчетыИОбработки.ЗарегистрироватьОбработку(ОбъектСправочника, ПараметрыРегистрации);
				Исключение
					ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
					Если Найти(ТекстОшибки, "Метод объекта не обнаружен") Тогда
						ТекстОшибки = "";
						Попытка
							РезультатРегистрации = ГлЯдро_ЗарегистрироватьОбработку(ОбъектСправочника, ПараметрыРегистрации, АдресФайла);
						Исключение
							ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
						КонецПопытки;
					КонецЕсли;
				КонецПопытки;
				
				ПредыдущаяПодключеннаяОбработка = Неопределено;
				
				Если ТипЗнч(РезультатРегистрации) = Тип("Структура") Тогда					 
					Если РезультатРегистрации.Свойство("Конфликтующие")
						И ТипЗнч(РезультатРегистрации.Конфликтующие) = Тип("СписокЗначений")
						И РезультатРегистрации.Конфликтующие.Количество() > 0 Тогда
						
						ПредыдущаяПодключеннаяОбработка = РезультатРегистрации.Конфликтующие[РезультатРегистрации.Конфликтующие.Количество() - 1].Значение;
						
						Если ОтключатьКонфликтующие Тогда
							//Запускаем регистрацию обработки еще раз, но уже с заполненным списком конфликтующих
							ПараметрыРегистрации.Конфликтующие = РезультатРегистрации.Конфликтующие;
							РезультатРегистрации = Неопределено;
							Попытка //Т.к. в разных версиях БСП процедура может отличаться, то используем попытку
								РезультатРегистрации = МодульДопОтчетыИОбработки.ЗарегистрироватьОбработку(ОбъектСправочника, ПараметрыРегистрации);
							Исключение
								ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
								Если Найти(ТекстОшибки, "Метод объекта не обнаружен") Тогда
									ТекстОшибки = "";
									Попытка
										РезультатРегистрации = ГлЯдро_ЗарегистрироватьОбработку(ОбъектСправочника, ПараметрыРегистрации, АдресФайла);
									Исключение
										ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
									КонецПопытки;
								КонецЕсли;
							КонецПопытки;
							// Пометим на удаление конфликтующие обработки, т.к. при отключении они были переведены в режим "Отладка"
							Для Каждого Конфликтующая Из ПараметрыРегистрации.Конфликтующие Цикл
								КонфликтующаяСсылка = Конфликтующая.Значение;
								КонфликтующийОбъект = КонфликтующаяСсылка.ПолучитьОбъект();
								КонфликтующийОбъект.УстановитьПометкуУдаления(Истина);
							КонецЦикла;
						КонецЕсли;
						
					КонецЕсли;
				КонецЕсли;
				
				Если ТипЗнч(РезультатРегистрации) = Тип("Структура") Тогда
					Если (РезультатРегистрации.Свойство("Успех") И РезультатРегистрации.Успех)
						Или (РезультатРегистрации.Свойство("Успешно") И РезультатРегистрации.Успешно) Тогда
						Попытка
							ДвоичныеДанныеФайла = ПолучитьИзВременногоХранилища(АдресФайла);
							ОбъектСправочника.ХранилищеОбработки = Новый ХранилищеЗначения(ДвоичныеДанныеФайла, Новый СжатиеДанных(9));;
							
							// Добавление в разделы
							СтруктураПолученияРазелов = ГлЯдро_ПолучитьДоступныеРазделыДляРазмещенияОбработки("Обработка", МодульДопОтчетыИОбработки, ДобавитьВоВсеРазделы, ПеренестиРазделыИзПредыдущейВерсии, ПредыдущаяПодключеннаяОбработка);
							
							Если ЗначениеЗаполнено(СтруктураПолученияРазелов.ТекстОшибки) Тогда
								СообщениеОбОшибке = "Ошибка получения разделов для размещения в них обработки/отчета из файла " + ИмяФайла + ": " + СтруктураПолученияРазелов.ТекстОшибки;
								ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", СообщениеОбОшибке,, АдресаПеременных);
							Иначе
								ТекстОшибкиДобавленияВРазделы = ГлЯдро_РазместитьОбработкуВРазделах(ОбъектСправочника, СтруктураПолученияРазелов.МассивРазделов);
								Если ЗначениеЗаполнено(ТекстОшибкиДобавленияВРазделы) Тогда
									ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", 
									"Ошибка размещения обработки/отчета из файла " + ИмяФайла + " в разделах: " + ТекстОшибкиДобавленияВРазделы,, АдресаПеременных);
								КонецЕсли;
							КонецЕсли;
							
							// Заполнение быстрого доступа
							Попытка
								ТаблицаБыстрогоДоступа = ГлЯдро_ЗаполнитьПолучитьБыстрыйДоступВнешнейОбработкиОтчета(ОбъектСправочника, ДобавитьВБыстрыйДоступТекПользователя, ПеренестиБыстрыйДоступИзПредыдущейВерсии, ПредыдущаяПодключеннаяОбработка);
							Исключение
								ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Ошибка заполнения быстрого доступа для файла " + ИмяФайла,, АдресаПеременных);
							КонецПопытки;

							ОбъектСправочника.Записать();
							
							ОбработкаСсылка = ОбъектСправочника.Ссылка;
							
							// В некоторых конфигурациях при записи объекта быстрый доступ не записывется в регистр. Попробуем записать его напрямую
							Если ТипЗнч(ТаблицаБыстрогоДоступа) = Тип("ТаблицаЗначений")
								И ТаблицаБыстрогоДоступа.Количество() <> 0 Тогда
								Попытка
									МодульДопОтчетыИОбработки.ЗаписатьНастройкиБыстрогоДоступа(ОбработкаСсылка, ТаблицаБыстрогоДоступа);
								Исключение
								КонецПопытки;	
							КонецЕсли;
							
							МодульДопОтчетыИОбработки.ПодключитьВнешнююОбработку(ОбработкаСсылка);
													
							Версия 			= ОбъектСправочника.Версия;
							Подключено 		= Истина;
							ТипОбработки 	= "СправочникСсылка";
						Исключение
							ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
						КонецПопытки;
					ИначеЕсли РезультатРегистрации.Свойство("ИмяОбъектаЗанято") И РезультатРегистрации.ИмяОбъектаЗанято Тогда
						// Представление занявших объектов.
						ПредставлениеЗанявших = "";
						Для Каждого ЭлементСписка Из РезультатРегистрации.Конфликтующие Цикл
							Если СтрДлина(ПредставлениеЗанявших) > 80 Тогда
								ПредставлениеЗанявших = ПредставлениеЗанявших + "... ";
								Прервать;
							КонецЕсли;
							ПредставлениеЗанявших = ПредставлениеЗанявших
							+ ?(ПредставлениеЗанявших = "", "", ", ")
							+ """" + СокрЛП(ЭлементСписка.Представление) + """";
							ПодключеноРанее = Истина;
						КонецЦикла;						
						ТекстОшибки = "Внутреннее имя обработки " + РезультатРегистрации.ИмяОбъекта + " уже занято внешней обработкой";
					ИначеЕсли РезультатРегистрации.Свойство("ТекстОшибки") Тогда
						ТекстОшибки = РезультатРегистрации.ТекстОшибки;
					КонецЕсли;	
				КонецЕсли;
				
			КонецЕсли;
		#КонецЕсли
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ТекстОшибки) Тогда
		ТекстОшибки = "Ошибка подключения файла " + ИмяФайла + " в справочник доп отчетов и обработок:" + Символы.ПС + ТекстОшибки;
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", ТекстОшибки,, АдресаПеременных);
		Если Не Подключено Тогда
			Сообщить("Не удалось подключить файл " + ИмяФайла + " в справочник справочник доп отчетов и обработок. Подробности в журнале регистраци");
		КонецЕсли;		
	КонецЕсли;
	
	РезультатПодключения.Вставить("Подключено", 			Подключено);
	РезультатПодключения.Вставить("ПодключеноРанее", 		ПодключеноРанее);	
	РезультатПодключения.Вставить("ТекстОшибки", 			ТекстОшибки);
	РезультатПодключения.Вставить("ТипОбработки", 			ТипОбработки);
	РезультатПодключения.Вставить("ИмяФайла", 				ИмяФайла);
	РезультатПодключения.Вставить("ОбработкаСсылка",		ОбработкаСсылка);
	РезультатПодключения.Вставить("Версия",					Версия);
	РезультатПодключения.Вставить("СинонимСправочника", 	СинонимСправочника);
	
	Попытка
		
		ПараметрыПодключенияMS = ГлЯдро_ПолучитьДанныеИзХранилища1С("Cleverence_ПараметрыПодключенияMS");
		
		ПерезаписатьНастройки1С = Ложь;
		
		Если РезультатПодключения.Подключено Тогда
			Если РезультатПодключения.ИмяФайла = ИмяОсновнойОбработки Тогда
				
				ПараметрыПодключенияMS.Вставить("ПутьОсновнойОбработки", РезультатПодключения.ОбработкаСсылка);
				ПараметрыПодключенияMS.Вставить("ТипОсновнойОбработки", РезультатПодключения.ТипОбработки);
				
				Путь = ГлЯдро_ЗначениеВСтрокуXML(РезультатПодключения.ОбработкаСсылка);
				
				РезультатПодключения.Вставить("Путь", Путь);
				
				РасположениеКомпоненты 	= КомЯдро_ПолучитьЗначениеПеременной("РасположениеКомпоненты", АдресаПеременных);
				Если РасположениеКомпоненты = "НаСервере" Тогда
					// Сохраняем настройки только, если режим работы - НаСервере. Более подробное описание есть в методе ЛокЯдро_ПодключитьФайлыВСправочникДопОтчетовОбработокЗавершение
					ГлЯдро_СохранитьНастройкуВБазеSMARTS("ПутьОсновнойОбработки", Путь, , АдресаПеременных);
					ГлЯдро_СохранитьНастройкуВБазеSMARTS("ТипОсновнойОбработки", РезультатПодключения.ТипОбработки, , АдресаПеременных);
					ГлЯдро_СохранитьНастройкуВБазеSMARTS("ВерсияОбработки_" + "ОсновнаяОбработка", РезультатПодключения.Версия, , АдресаПеременных);
					ГлЯдро_СохранитьНастройкуВБазеSMARTS("ВерсияПриложения_" + "ОсновнаяОбработка", ВерсияПриложенияАктуальная, , АдресаПеременных);
				КонецЕсли;
				
				ПерезаписатьНастройки1С = Истина;
				
			ИначеЕсли РезультатПодключения.ИмяФайла = ИмяИнтеграционнойОбработки Тогда
				
				// Параметры до изменения понадобятся, если ИО не подключится
				ПараметрыПодключенияMSДоИзменения = ГлЯдро_СкопироватьСтруктуру(ПараметрыПодключенияMS);
				
				ПараметрыПодключенияMS.ИмяИнтеграционнойОбработки = РезультатПодключения.ИмяФайла;
				ПараметрыПодключенияMS.ПутьИнтеграционнойОбработки = РезультатПодключения.ОбработкаСсылка;
				ПараметрыПодключенияMS.Вставить("ТипОбработки", РезультатПодключения.ТипОбработки);
				
				ПерезаписатьНастройки1С = Истина;
				
				Путь = ГлЯдро_ЗначениеВСтрокуXML(РезультатПодключения.ОбработкаСсылка);
				
				РезультатПодключения.Вставить("Путь", Путь);
				//ГлЯдро_СохранитьНастройкуВБазеSMARTS("ИмяИнтеграционнойОбработкиКонфигурации1С", РезультатПодключения.ИмяФайла, , АдресаПеременных);
				//ГлЯдро_СохранитьНастройкуВБазеSMARTS("ПутьИнтеграционнойОбработкиКонфигурации1С", Путь, , АдресаПеременных);
				//ГлЯдро_СохранитьНастройкуВБазеSMARTS("ТипОбработки", РезультатПодключения.ТипОбработки, , АдресаПеременных);
				//ГлЯдро_СохранитьНастройкуВБазеSMARTS("ВерсияОбработки_" + ИмяПараметраНастройкиИО, РезультатПодключения.Версия, , АдресаПеременных);
								
				РезультатПодключенияИнтеграционнойОбработки = ГлЯдро_ПодключитьИнтеграционнуюОбработку(,, ПараметрыПодключенияMS,, АдресаПеременных);
				Если Не ЭтоАдресВременногоХранилища(РезультатПодключенияИнтеграционнойОбработки) Тогда
					// Ошибка подключения была записана в ЖР в функции ГлЯдро_ПодключитьИнтеграционнуюОбработку, поэтому не делаем еще одну запись в ЖР
					// Возвращаем настройки до изменения, т.к. при неудачном подключении ИО были затерты настройки ИО в параметрах подключения
					ГлЯдро_СохранитьДанныеВХранилище1С("Cleverence_ПараметрыПодключенияMS", ПараметрыПодключенияMSДоИзменения);
					// Если ИО не подключилась, считаем, что добавление новой ИО не удалось, хоть и создался элемент в справочнике
					РезультатПодключения.Подключено = Ложь;
					// Пометим на удаление созданный элемент справочника
					ОбработкаОбъект = РезультатПодключения.ОбработкаСсылка.ПолучитьОбъект();
					Попытка
						// Выполняем в попытке, т.к. у пользователя может не быть прав на установку пометки удаления
						ОбработкаОбъект.УстановитьПометкуУдаления(Истина);
					Исключение
					КонецПопытки;
					ПерезаписатьНастройки1С = Ложь;
				Иначе
					ИнформацияСовместимости = ГлЯдро_ПолучитьИнформациюСовместимости(АдресаПеременных);
					КомЯдро_СохранитьЗначениеПеременной("ИнформацияСовместимости", ИнформацияСовместимости, АдресаПеременных);
				КонецЕсли;
				
			КонецЕсли;
						
		КонецЕсли;
		
		Если РезультатПодключения.Подключено Тогда
			ТекстИнформации = "Добавлена дополнительная обработка (отчет) " + РезультатПодключения.ИмяФайла;
			ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", ТекстИнформации, , АдресаПеременных);
		КонецЕсли;
		
		Если ПерезаписатьНастройки1С Тогда
			ГлЯдро_СохранитьДанныеВХранилище1С("Cleverence_ПараметрыПодключенияMS", ПараметрыПодключенияMS);
			КомЯдро_СохранитьЗначениеПеременной("ПараметрыПодключенияMS", ПараметрыПодключенияMS, АдресаПеременных);
			Попытка
				// На момент подключения обработок переменной ТекущиеНастройкиMS может не быть в кэше
				ГлЯдро_ЗаписатьВКэшНастройкуSMARTS("ПараметрыПодключенияMS", ПараметрыПодключенияMS, АдресаПеременных);
			Исключение
			КонецПопытки;
		КонецЕсли;
		
		Если Не НеОбновлятьВерсиюПриложения Тогда
			Если РасположениеКомпоненты = "НаСервере" Тогда
				// Сохраняем настройки только, если режим работы - НаСервере. Более подробное описание есть в методе ЛокЯдро_ПодключитьФайлыВСправочникДопОтчетовОбработокЗавершение
				ГлЯдро_СохранитьНастройкуВБазеSMARTS("ВерсияПриложения", ВерсияПриложенияАктуальная, , АдресаПеременных);
			КонецЕсли;
			ГлЯдро_ЗаписатьВКэшНастройкуSMARTS("ВерсияПриложения", ВерсияПриложенияАктуальная, АдресаПеременных);
		КонецЕсли;
		
	Исключение	
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()),, АдресаПеременных);
	КонецПопытки;
		
	Возврат РезультатПодключения;
	#КонецОбласти //НесовместимыйКодFresh
	
КонецФункции

// Подключает файл в справочник дополнительных отчетов и обработок
//
// Параметры:
//	МассивПараметровФайлов	- Массив - массив, содержащий структуры формата см. параметры "ГлЯдро_ПодключитьФайлВСправочникДополнительныхОтчетовИОбработок"
//
// Возвращаемое значение:
//   Массив   - массив структур результатов подключения см. "ГлЯдро_ПодключитьФайлВСправочникДополнительныхОтчетовИОбработок"
//
Функция ГлЯдро_ПодключитьФайлыВСправочникДополнительныхОтчетовИОбработок(МассивПараметровФайлов, АдресаПеременных) Экспорт
	
	#Область НесовместимыйКодFresh
	ИмяСобытия = "ГлЯдро_ПодключитьФайлыВСправочникДополнительныхОтчетовИОбработок";
	
	РезультатыПодключений = Новый Массив;
	
	Для Каждого СтрукутраПараметровФайла Из МассивПараметровФайлов Цикл
		
		Если НЕ СтрукутраПараметровФайла.Свойство("ОтключатьКонфликтующие") Тогда
			СтрукутраПараметровФайла.Вставить("ОтключатьКонфликтующие", Ложь);
		КонецЕсли;
		Если НЕ СтрукутраПараметровФайла.Свойство("ДобавитьВБыстрыйДоступТекПользователя") Тогда
			СтрукутраПараметровФайла.Вставить("ДобавитьВБыстрыйДоступТекПользователя", Ложь);
		КонецЕсли;
		Если НЕ СтрукутраПараметровФайла.Свойство("ПеренестиБыстрыйДоступИзПредыдущейВерсии") Тогда
			СтрукутраПараметровФайла.Вставить("ПеренестиБыстрыйДоступИзПредыдущейВерсии", Ложь);
		КонецЕсли;
		Если НЕ СтрукутраПараметровФайла.Свойство("ДобавитьВоВсеРазделы") Тогда
			СтрукутраПараметровФайла.Вставить("ДобавитьВоВсеРазделы", Ложь);
		КонецЕсли;
		Если НЕ СтрукутраПараметровФайла.Свойство("ПеренестиРазделыИзПредыдущейВерсии") Тогда
			СтрукутраПараметровФайла.Вставить("ПеренестиРазделыИзПредыдущейВерсии", Ложь);
		КонецЕсли;
		Если НЕ СтрукутраПараметровФайла.Свойство("ИмяОсновнойОбработки") Тогда
			СтрукутраПараметровФайла.Вставить("ИмяОсновнойОбработки", Ложь);
		КонецЕсли;
		Если НЕ СтрукутраПараметровФайла.Свойство("ИмяИнтеграционнойОбработки") Тогда
			СтрукутраПараметровФайла.Вставить("ИмяИнтеграционнойОбработки", Ложь);
		КонецЕсли;
		Если НЕ СтрукутраПараметровФайла.Свойство("ВерсияПриложенияАктуальная") Тогда
			СтрукутраПараметровФайла.Вставить("ВерсияПриложенияАктуальная", Ложь);
		КонецЕсли;
		Если НЕ СтрукутраПараметровФайла.Свойство("НеОбновлятьВерсиюПриложения") Тогда
			СтрукутраПараметровФайла.Вставить("НеОбновлятьВерсиюПриложения", Ложь);
		КонецЕсли;
		
		РезультатПодключения = ГлЯдро_ПодключитьФайлВСправочникДополнительныхОтчетовИОбработок(СтрукутраПараметровФайла.АдресФайла, СтрукутраПараметровФайла.ИмяФайла, СтрукутраПараметровФайла.ОтключатьКонфликтующие, СтрукутраПараметровФайла.ДобавитьВБыстрыйДоступТекПользователя, 
			СтрукутраПараметровФайла.ПеренестиБыстрыйДоступИзПредыдущейВерсии, СтрукутраПараметровФайла.ДобавитьВоВсеРазделы, СтрукутраПараметровФайла.ПеренестиРазделыИзПредыдущейВерсии, СтрукутраПараметровФайла.ИмяОсновнойОбработки, 
			СтрукутраПараметровФайла.ИмяИнтеграционнойОбработки, СтрукутраПараметровФайла.ВерсияПриложенияАктуальная, СтрукутраПараметровФайла.НеОбновлятьВерсиюПриложения, АдресаПеременных);
		РезультатыПодключений.Добавить(РезультатПодключения);
		
	КонецЦикла;
	
	Возврат РезультатыПодключений;
    #КонецОбласти //НесовместимыйКодFresh
	
КонецФункции

// Получает сведения о подключенных расширениях Клеверенс
//
// Возвращаемое значение:
//   Строка   - информация о подключенных расширениях
//
Функция ГлЯдро_ПолучитьИнформациюОПодключенныхРасширениях() Экспорт
	
	ИнформацияОРасширениях = "";
	
	#Область НесовместимыйКодFresh
	Попытка
		ПодключенныеРасширения = РасширенияКонфигурации.Получить();
	Исключение
		ПодключенныеРасширения = Новый Массив;
	КонецПопытки;
	
	Для каждого ПодключенноеРасширение Из ПодключенныеРасширения Цикл
		
		Попытка
			Активно = ПодключенноеРасширение.Активно; //Доступно с версии 8.3.12
		Исключение
			Активно = Истина;
		КонецПопытки;
		
		Если Активно Тогда
			
			Если Найти(ВРег(ПодключенноеРасширение.Имя), "CLEVERENCE") > 0 Тогда
				ПоставщикРасширения = "Клеверенс";
			КонецЕсли;
			
			Если ВРег(ПоставщикРасширения) = "КЛЕВЕРЕНС" Тогда
				
				ИнформацияОРасширениях = ИнформацияОРасширениях + ПодключенноеРасширение.Имя + "," 
				+ ПодключенноеРасширение.Версия + ";" + Символы.ПС;
				
			КонецЕсли;
		КонецЕсли;
		
	КонецЦикла;
	
	Если ЗначениеЗаполнено(ИнформацияОРасширениях) Тогда
		ИнформацияОРасширениях = Лев(ИнформацияОРасширениях, СтрДлина(ИнформацияОРасширениях) - 2);
	Иначе
		ИнформацияОРасширениях = "Не подключено";
	КонецЕсли;
	#КонецОбласти //НесовместимыйКодFresh
	
	Возврат ИнформацияОРасширениях;
	
КонецФункции

// Получает разделы для размещения дополнительной обработки/отчета
//
// Параметры:
//  ВидОбработки  						- Строка - вид дополнительной обработки или отчета
//  МодульДопОтчетыИОбработки  			- ОбщийМодуль - Общий модуль дополнительных отчетов и обработок
//	ДобавитьВоВсеРазделы 				- Булево - необходимость добавления обработки/отчета во все разделы
//	ПеренестиРазделыИзПредыдущейВерсии 	- Булево - необходимость заполнения разделов значениями из предыдущей версии обработки/отчета
//	ПредыдущаяПодключеннаяОбработка 	- СправочникСсылка.ДополнительныеОтчетыИОбработки - аналогичная обработка подключенная ранее
//
// Возвращаемое значение:
//   Структура   - массив подсистем, доступных для размещения доп обработки/отчета
//
Функция ГлЯдро_ПолучитьДоступныеРазделыДляРазмещенияОбработки(ВидОбработки, МодульДопОтчетыИОбработки, ДобавитьВоВсеРазделы, ПеренестиРазделыИзПредыдущейВерсии, ПредыдущаяПодключеннаяОбработка)
	
	#Область НесовместимыйКодFresh
	СтруктураРезультата = Новый Структура;
	
	МассивРазделов 	= Новый Массив;
	ТекстОшибки 	= "";
	
	Попытка
		Если ВидОбработки = "Обработка" Тогда
			Если ДобавитьВоВсеРазделы Тогда
				Попытка
					ДоступныеРазделы = МодульДопОтчетыИОбработки.РазделыДополнительныхОбработок();
				Исключение
					ДоступныеРазделы = Новый Массив;
					АльтернативныйМодульДопОтчетыИОбработки = Вычислить("ДополнительныеОтчетыИОбработкиПереопределяемый");
					АльтернативныйМодульДопОтчетыИОбработки.ОпределитьРазделыСДополнительнымиОбработками(ДоступныеРазделы);
				КонецПопытки;
				
				ДобавленПустойИдентификатор = Ложь;
				Для Каждого ДоступныйРаздел Из ДоступныеРазделы Цикл
					Если ТипЗнч(ДоступныйРаздел) = Тип("ОбъектМетаданных") Тогда
						МассивРазделов.Добавить(ИдентификаторОбъектаМетаданных(ДоступныйРаздел));
					ИначеЕсли Не ДобавленПустойИдентификатор Тогда
						// Добавляем только один раз
						МассивРазделов.Добавить(Справочники.ИдентификаторыОбъектовМетаданных.ПустаяСсылка());
						ДобавленПустойИдентификатор = Истина;
					КонецЕсли;
				КонецЦикла;
			ИначеЕсли ПеренестиРазделыИзПредыдущейВерсии
				И ПеренестиРазделыИзПредыдущейВерсии Тогда
				МассивРазделов = ПредыдущаяПодключеннаяОбработка.Разделы.ВыгрузитьКолонку("Раздел");		
			КонецЕсли;
		КонецЕсли;
	Исключение
		ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
	КонецПопытки;
	
	СтруктураРезультата.Вставить("МассивРазделов", МассивРазделов);
	СтруктураРезультата.Вставить("ТекстОшибки", ТекстОшибки);
	
	Возврат СтруктураРезультата;
    #КонецОбласти //НесовместимыйКодFresh
	
КонецФункции

// Добавляет дополнительную обработку/отчет в переданные разделы
//
// Параметры:
//  ОбработкаОбъект  - СправочникОбъект.ДополнительныеОтчетыИОбработки - обработка/отчет, которая добавляется в разделы
//  МассивРазделов  - Массив - массив разделов, в которые добавляется обработка/отчет
//
// Возвращаемое значение:
//   Строка   - текст ошибки
//
Функция ГлЯдро_РазместитьОбработкуВРазделах(ОбработкаОбъект, МассивРазделов)

	ТекстОшибки = "";
	
	Попытка
		Для Каждого Раздел Из МассивРазделов Цикл
			СтрокаРаздела = ОбработкаОбъект.Разделы.Добавить();
			СтрокаРаздела.Раздел = Раздел;
		КонецЦикла;	
	Исключение
		ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
	КонецПопытки;
	
	Возврат ТекстОшибки;
	
КонецФункции

// Заполняет и возращает таблицу быстрого доступа у доп обработки/отчета
//
// Параметры:
//  ОбработкаОтчет  							- СправочникОбъект.ДополнительныеОтчетыИОбработки - обработка/отчет, для которой будет заполнен быстрый доступ
//	ДобавитьВБыстрыйДоступТекПользователя		- Булево - необходимость добавления в быстрый доступ текущего пользователя
//	ПеренестиБыстрыйДоступИзПредыдущейВерсии 	- Булево - необходимость заполнения быстрого доступа значениями из предыдущей версии обработки/отчета
//	ПредыдущаяПодключеннаяОбработка 			- СправочникСсылка.ДополнительныеОтчетыИОбработки - аналогичная обработка подключенная ранее
//
Функция ГлЯдро_ЗаполнитьПолучитьБыстрыйДоступВнешнейОбработкиОтчета(ОбъектСправочника, ДобавитьВБыстрыйДоступТекПользователя, ПеренестиБыстрыйДоступИзПредыдущейВерсии, ПредыдущаяПодключеннаяОбработка)
	
	ТаблицаБыстрогоДоступа = Новый ТаблицаЗначений;
	// В разных конфигурациях колонка с идентификатором называется по-разному. Создадим оба варианта. Заполнять будем одинаково
	ТаблицаБыстрогоДоступа.Колонки.Добавить("ИдентификаторКоманды");
	ТаблицаБыстрогоДоступа.Колонки.Добавить("Идентификатор");
	ТаблицаБыстрогоДоступа.Колонки.Добавить("Пользователь");
	
	Если ОбъектСправочника.Команды.Количество() <> 0 Тогда
				
		Если ДобавитьВБыстрыйДоступТекПользователя Тогда
			
			МассивПользователейБыстрогоДоступа = ГлЯдро_ПолучитьМассивПользователейБыстрогоДоступа(ОбъектСправочника);
						
			Для Каждого Команда Из ОбъектСправочника.Команды Цикл
				ИдентификаторКоманды = Команда.Идентификатор;
				Для Каждого ПользовательБыстрогоДоступа Из МассивПользователейБыстрогоДоступа Цикл
					НоваяСтрока = ТаблицаБыстрогоДоступа.Добавить();
					
					НоваяСтрока.ИдентификаторКоманды 	= ИдентификаторКоманды;
					НоваяСтрока.Идентификатор 			= ИдентификаторКоманды;
					НоваяСтрока.Пользователь 			= ПользовательБыстрогоДоступа;
				КонецЦикла;
				
				Прервать; // Заполняем только первую команду. Для изменения закомментировать
			КонецЦикла;
			
		ИначеЕсли ПеренестиБыстрыйДоступИзПредыдущейВерсии
			И ПредыдущаяПодключеннаяОбработка <> Неопределено Тогда
			
		    ТаблицаБыстрогоДоступаПредОбработки = ГлЯдро_ПолучитьТаблицуБыстрогоДоступа(ПредыдущаяПодключеннаяОбработка);
			
			Для Каждого Команда Из ОбъектСправочника.Команды Цикл
				ИдентификаторКоманды = Команда.Идентификатор;
				
				НайденныеСтроки = ТаблицаБыстрогоДоступаПредОбработки.НайтиСтроки(Новый Структура("ИдентификаторКоманды", ИдентификаторКоманды));
				
				Если НайденныеСтроки.Количество() = 0 Тогда
					// Поиск по представлению
					НайденныеСтроки = ТаблицаБыстрогоДоступаПредОбработки.НайтиСтроки(Новый Структура("ПредставлениеКоманды", Команда.Представление));					
				КонецЕсли;
				
				Если НайденныеСтроки.Количество() <> 0 Тогда
					Для Каждого НайденнаяСтрока Из НайденныеСтроки Цикл
						НоваяСтрока = ТаблицаБыстрогоДоступа.Добавить();
						
						НоваяСтрока.ИдентификаторКоманды 	= ИдентификаторКоманды;
						НоваяСтрока.Идентификатор 			= ИдентификаторКоманды;						
						НоваяСтрока.Пользователь 			= НайденнаяСтрока.Пользователь;
					КонецЦикла;
				КонецЕсли;
				
				Прервать; // Заполняем только первую команду. Для изменения закомментировать				
			КонецЦикла;
			
		КонецЕсли;
		
		Если ТаблицаБыстрогоДоступа.Количество() <> 0 Тогда
			// Добавляем таблицу быстрого доступа в доп свойства объекта. При записи объекта быстрый доступ будет зафиксирован
			ОбъектСправочника.ДополнительныеСвойства.Вставить("БыстрыйДоступ", ТаблицаБыстрогоДоступа);
			
			КопияТаблицыБыстрогоДоступа = ТаблицаБыстрогоДоступа.Скопировать();
			КопияТаблицыБыстрогоДоступа.Свернуть("Идентификатор");
			КопияТаблицыБыстрогоДоступа.Колонки.Добавить("БыстрыйСписокДоступа");
			Для Каждого СтрокаКопии Из КопияТаблицыБыстрогоДоступа Цикл
				Идентификатор = СтрокаКопии.Идентификатор;
				СписокПользователей = Новый СписокЗначений;
				
				НайденныеСтроки = ТаблицаБыстрогоДоступа.НайтиСтроки(Новый Структура("Идентификатор", Идентификатор));
				Для Каждого НайденнаяСтрока Из НайденныеСтроки Цикл
					СписокПользователей.Добавить(НайденнаяСтрока.Пользователь);	
				КонецЦикла;
				СтрокаКопии.БыстрыйСписокДоступа = СписокПользователей;
			КонецЦикла;
			
		КонецЕсли;
		
	КонецЕсли;

	Возврат КопияТаблицыБыстрогоДоступа;
	
КонецФункции

// Получает массив пользователей, для которых будет добавлен быстрый доступ к обработке/отчету
//
// Параметры:
//  ОбработкаОтчет 	- СправочникОбъект.ДополнительныеОтчетыИОбработки - обработка/отчет, для которой будет получен массив пользователей
//
// Возвращаемое значение:
//   Массив   - массив пользователей, для которых будет добавлен быстрый доступ к обработке/отчету
//
Функция ГлЯдро_ПолучитьМассивПользователейБыстрогоДоступа(ОбработкаОтчетСсылка)

	МассивПользователейБыстрогоДоступа = Новый Массив;
	
	НазваниеПараметраТекущегоПользователя = "ТекущийПользователь";
	Если Метаданные.ПараметрыСеанса.Найти("ТекущийПользователь") = Неопределено Тогда
		
		Если Метаданные.ПараметрыСеанса.Найти("глТекущийПользователь") <> Неопределено Тогда
			НазваниеПараметраТекущегоПользователя = "глТекущийПользователь"; // В Штрих-М 5.2 используется такой параметр
		ИначеЕсли Метаданные.ПараметрыСеанса.Найти("Пользователь") <> Неопределено Тогда
			НазваниеПараметраТекущегоПользователя = "Пользователь"; // В Альфа-Авто 5.1 используется такой параметр			
		КонецЕсли;
		
	КонецЕсли;
	
	ТекущиеПользователь = ПараметрыСеанса[НазваниеПараметраТекущегоПользователя];	
	
	МассивПользователейБыстрогоДоступа.Добавить(ТекущиеПользователь);

	Возврат МассивПользователейБыстрогоДоступа;

КонецФункции

// Получает таблицу быстрого доступа доп обработки/отчета
//
// Параметры:
//  ОбработкаОтчет 	- СправочникОбъект.ДополнительныеОтчетыИОбработки - обработка/отчет, для которой будет получена таблица быстрого доступа
//
// Возвращаемое значение:
//   ТаблицаЗначений   - таблица быстрого доступа
//
Функция ГлЯдро_ПолучитьТаблицуБыстрогоДоступа(ОбработкаОтчетСсылка)
		
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Ссылка", 	ОбработкаОтчетСсылка);
	Запрос.УстановитьПараметр("Команды", 	ОбработкаОтчетСсылка.Команды.Выгрузить(, "Идентификатор, Представление"));
	
	Запрос.Текст =
	"ВЫБРАТЬ
	|	Команды.Идентификатор КАК Идентификатор,
	|	Команды.Представление КАК Представление
	|ПОМЕСТИТЬ втКоманды
	|ИЗ
	|	&Команды КАК Команды
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	ДанныеРегистра.ИдентификаторКоманды КАК ИдентификаторКоманды,
	|	ДанныеРегистра.Пользователь КАК Пользователь,
	|	ЕСТЬNULL(втКоманды.Представление, """") КАК ПредставлениеКоманды
	|ИЗ
	|	РегистрСведений.ПользовательскиеНастройкиДоступаКОбработкам КАК ДанныеРегистра
	|		ЛЕВОЕ СОЕДИНЕНИЕ втКоманды КАК втКоманды
	|		ПО ДанныеРегистра.ИдентификаторКоманды = втКоманды.Идентификатор
	|ГДЕ
	|	ДанныеРегистра.ДополнительныйОтчетИлиОбработка = &Ссылка
	|	И ДанныеРегистра.Доступно = ИСТИНА
	|	И НЕ ДанныеРегистра.Пользователь.ПометкаУдаления
	|	И НЕ ДанныеРегистра.Пользователь.Недействителен";
	
	ТаблицаБыстрогоДоступа = Запрос.Выполнить().Выгрузить();	

	Возврат ТаблицаБыстрогоДоступа;

КонецФункции

// Возвращает наименование текущего пользователя из параметра сеанса
Функция ГлЯдро_ПолучитьНаименованиеТекущегоПользователя()

	НазваниеПараметраТекущегоПользователя = "ТекущийПользователь";
	Если Метаданные.ПараметрыСеанса.Найти("ТекущийПользователь") = Неопределено Тогда
		
		Если Метаданные.ПараметрыСеанса.Найти("глТекущийПользователь") <> Неопределено Тогда
			НазваниеПараметраТекущегоПользователя = "глТекущийПользователь"; // В Штрих-М 5.2 используется такой параметр
		ИначеЕсли Метаданные.ПараметрыСеанса.Найти("Пользователь") <> Неопределено Тогда
			НазваниеПараметраТекущегоПользователя = "Пользователь"; // В Альфа-Авто 5.1 используется такой параметр			
		КонецЕсли;
		
	КонецЕсли;
			
	Возврат ПараметрыСеанса[НазваниеПараметраТекущегоПользователя].Наименование;
	
КонецФункции

// Возвращает УИД текущего пользователя из параметра сеанса
Функция ГлЯдро_ПолучитьУИДТекущегоПользователя(АдресаПеременных) Экспорт

	НазваниеПараметраТекущегоПользователя = "ТекущийПользователь";
	Если Метаданные.ПараметрыСеанса.Найти("ТекущийПользователь") = Неопределено Тогда
		
		Если Метаданные.ПараметрыСеанса.Найти("глТекущийПользователь") <> Неопределено Тогда
			НазваниеПараметраТекущегоПользователя = "глТекущийПользователь"; // В Штрих-М 5.2 используется такой параметр
		ИначеЕсли Метаданные.ПараметрыСеанса.Найти("Пользователь") <> Неопределено Тогда
			НазваниеПараметраТекущегоПользователя = "Пользователь"; // В Альфа-Авто 5.1 используется такой параметр			
		КонецЕсли;
		
	КонецЕсли;
			
	Возврат ПараметрыСеанса[НазваниеПараметраТекущегоПользователя].УникальныйИдентификатор();
	
КонецФункции

// Возвращает ссылку, соответствующую объекту метаданных, для использования в базе данных.
// См. также ОбщегоНазначения.ИдентификаторыОбъектовМетаданных.
//
// Ссылки возвращаются для следующих объектов метаданных:
// - Подсистемы (см. также ОбщегоНазначенияПереопределяемый.ПриДобавленииПереименованийОбъектовМетаданных);
// - Роли (см. также ОбщегоНазначенияПереопределяемый.ПриДобавленииПереименованийОбъектовМетаданных);
// - ПланыОбмена;
// - Константы;
// - Справочники;
// - Документы;
// - ЖурналыДокументов;
// - Отчеты;
// - Обработки;
// - ПланыВидовХарактеристик;
// - ПланыСчетов;
// - ПланыВидовРасчета;
// - РегистрыСведений;
// - РегистрыНакопления;
// - РегистрыБухгалтерии;
// - РегистрыРасчета;
// - БизнесПроцессы;
// - Задачи.
// 
// Параметры:
//  ОписаниеОбъектаМетаданных - ОбъектМетаданных - объект метаданных конфигурации;
//                            - Тип - тип, который можно использовать в функции Метаданные.НайтиПоТипу;
//                            - Строка - полное имя объекта метаданных, которое можно 
//                                       использовать в функции Метаданные.НайтиПоПолномуИмени.
//
//  ВызыватьИсключение - Булево - если Ложь, тогда в случае, когда передан несуществующий объект метаданных
//                                возвращается Null вместо вызова исключения.
//
// Возвращаемое значение:
//  - СправочникСсылка.ИдентификаторыОбъектовМетаданных, СправочникСсылка.ИдентификаторыОбъектовРасширений - ссылка.
//  - Null - если параметр ВызыватьИсключение = Ложь и запрашиваемый объект метаданных не существует.
//  
// Пример:
//  Идентификатор = ОбщегоНазначения.ИдентификаторОбъектаМетаданных(ТипЗнч(Ссылка));
//  Идентификатор = ОбщегоНазначения.ИдентификаторОбъектаМетаданных(ОбъектМетаданных);
//  Идентификатор = ОбщегоНазначения.ИдентификаторОбъектаМетаданных("Справочник.Организации");
//
Функция ИдентификаторОбъектаМетаданных(ОписаниеОбъектаМетаданных, ВызыватьИсключение = Истина) Экспорт
	
	#Область НесовместимыйКодFresh
	ИдентификаторОбъектаМетаданных = Вычислить("ОбщегоНазначения.ИдентификаторОбъектаМетаданных(ОписаниеОбъектаМетаданных)");
	
	Возврат ИдентификаторОбъектаМетаданных;
	#КонецОбласти //НесовместимыйКодFresh
	
КонецФункции

// Получает имя конфигурации
//
// Возвращаемое значение:
//   Строка   - имя конфигурации
//
Функция ГлЯдро_ПолучитьИмяКонфигурации() Экспорт

	Возврат Метаданные.Имя;

КонецФункции

// Проверяет, существует ли объект метаданных
//
// Параметры:
//  ПолноеИмя  - Строка - полное имя объекта метаданных (например, Справочник.Номенклатура, Документ.ПриемНаРаботу.)
//
// Возвращаемое значение:
//   Булево   - признак наличия объекта метаданных
//
Функция ГлЯдро_ПроверитьОбъектМетаданныхСуществует(ПолноеИмя, АдресаПеременных) Экспорт
	
	ОбъектСуществует = Метаданные.НайтиПоПолномуИмени(ПолноеИмя) <> Неопределено;
	
	Возврат ОбъектСуществует;
	
КонецФункции

Функция ГлЯдро_ПолучитьПользователейSMARTS(ТипБазы, ТипИнтерфейса, АдресаПеременных) Экспорт
	
	Если ТипИнтерфейса = "REST_API" Тогда
		ПользователиMS = REST_API_ПолучитьПользователейSMARTS(ТипБазы, АдресаПеременных);
	Иначе
		ПользователиMS = КомЯдро_ПолучитьПользователейSMARTS(ТипБазы, АдресаПеременных);
	КонецЕсли;        
	
	Возврат ПользователиMS;
	
КонецФункции

Функция ГлЯдро_ПолучитьСкладыSMARTS(ТипБазы, ТипИнтерфейса, АдресаПеременных) Экспорт
	
	Если ТипИнтерфейса = "REST_API" Тогда
		СкладыMS = REST_API_ПолучитьСкладыSMARTS(ТипБазы, АдресаПеременных);
	Иначе
		СкладыMS = КомЯдро_ПолучитьСкладыSMARTS(ТипБазы, АдресаПеременных);
	КонецЕсли;        
	
	Возврат СкладыMS;
	
КонецФункции

Функция ГлЯдро_ПолучитьГруппыПользователейSMARTS(ТипБазы, ТипИнтерфейса, АдресаПеременных) Экспорт
	
	Если ТипИнтерфейса = "REST_API" Тогда
		ПользователиMS = REST_API_ПолучитьГруппыПользователейSMARTS(ТипБазы, АдресаПеременных);
	Иначе
		ПользователиMS = КомЯдро_ПолучитьГруппыПользователейSMARTS(ТипБазы, АдресаПеременных);
	КонецЕсли;        
	
	Возврат ПользователиMS;
	
КонецФункции

Функция ГлЯдро_ЗагрузитьПользователейВSMARTS(ПараметрыПользователя, ТипБазы, ТипИнтерфейса, АдресаПеременных) Экспорт
	
	Если ТипИнтерфейса = "REST_API" Тогда
		ПараметрыПользователя.Удалить("allWarehouses"); // Это спец. свойство для Кома, в Ресте оно недопустимо
		Результат = REST_API_ЗагрузитьПользователейВSMARTS(ПараметрыПользователя, ТипБазы, АдресаПеременных);
	Иначе
		Результат = КомЯдро_ЗагрузитьПользователейВSMARTS(ПараметрыПользователя, ТипБазы, АдресаПеременных);
	КонецЕсли;        
	
	Возврат Результат;
	
КонецФункции

Функция ГлЯдро_ЗагрузитьГруппыПользователейВSMARTS(ПараметрыГруппы, ТипБазы, ТипИнтерфейса, АдресаПеременных) Экспорт
	
	Если ТипИнтерфейса = "REST_API" Тогда  
		ПараметрыГруппы.Удалить("AlldocumentTypeNames"); // Это спец. свойство для Кома, в Ресте оно недопустимо
		Результат = REST_API_ЗагрузитьГруппыПользователейВSMARTS(ПараметрыГруппы, ТипБазы, АдресаПеременных);
	Иначе
		Результат = КомЯдро_ЗагрузитьГруппыПользователейВSMARTS(ПараметрыГруппы, ТипБазы, АдресаПеременных);
	КонецЕсли;        
	
	Возврат Результат;
	
КонецФункции

Функция ГлЯдро_УдалитьПользователейВSMARTS(ПараметрыПользователя, ТипБазы, ТипИнтерфейса, АдресаПеременных) Экспорт
	
	Если ТипИнтерфейса = "REST_API" Тогда
		Результат = REST_API_УдалитьПользователейВSMARTS(ПараметрыПользователя, ТипБазы, АдресаПеременных);
	Иначе
		Результат = КомЯдро_УдалитьПользователейВSMARTS(ПараметрыПользователя, ТипБазы, АдресаПеременных);
	КонецЕсли;        
	
	Возврат Результат;
	
КонецФункции

Функция ГлЯдро_УдалитьГруппыПользователейВSMARTS(ПараметрыГруппы, ТипБазы, ТипИнтерфейса, АдресаПеременных) Экспорт
	
	Если ТипИнтерфейса = "REST_API" Тогда
		Результат = REST_API_УдалитьГруппыПользователейВSMARTS(ПараметрыГруппы, ТипБазы, АдресаПеременных);
	Иначе
		Результат = КомЯдро_УдалитьГруппыПользователейВSMARTS(ПараметрыГруппы, ТипБазы, АдресаПеременных);
	КонецЕсли;        
	
	Возврат Результат;
	
КонецФункции
        
Функция ГлЯдро_ПолучитьСписокСлужебныхДокументовMS(ТипБазы, ТипИнтерфейса, АдресаПеременных) Экспорт
	
	Если ТипИнтерфейса = "REST_API" Тогда
		Результат = REST_API_ПолучитьСписокСлужебныхДокументовMS(ТипБазы, АдресаПеременных);
	Иначе
		Результат = КомЯдро_ПолучитьСписокСлужебныхДокументовMS(ТипБазы, АдресаПеременных);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции
        
Функция ГлЯдро_ОбновитьМетаданныеПользователейMS(ТипБазы, ТипИнтерфейса, АдресаПеременных) Экспорт
	
	Если ТипИнтерфейса = "REST_API" Тогда
		Результат = REST_API_ОбновитьМетаданныеПользователейMS(ТипБазы, АдресаПеременных);
	Иначе
		Результат = КомЯдро_ОбновитьМетаданныеПользователейMS(ТипБазы, АдресаПеременных);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

Процедура ГлЯдро_ОбновитьМетаданныеПользователейMSВХранилище1С(СписокПользователейMS, ПользователиMSАдрес, АдресаПеременных)

	СтруктураМетаданных = КомЯдро_ПолучитьЗначениеПеременной("СтруктураМетаданных", АдресаПеременных);
	Если ТипЗнч(СтруктураМетаданных) <> Тип("Структура") Тогда
		Возврат;		
	КонецЕсли;
	
	ИдентификаторБазыMS = "";
	
	ПараметрыПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("ПараметрыПодключенияMS", АдресаПеременных);
	Если ПараметрыПодключенияMS = Неопределено Тогда
		ПараметрыПодключенияMS = ГлЯдро_ПолучитьДанныеИзХранилища1С("Cleverence_ПараметрыПодключенияMS");	
	КонецЕсли;
	
	Если ТипЗнч(ПараметрыПодключенияMS) = Тип("Структура") Тогда
		ИдентификаторБазыMS = ?(ПараметрыПодключенияMS.Свойство("Ид"), ПараметрыПодключенияMS.Ид, "");
		ИдентификаторБазыMS = СтрЗаменить(ИдентификаторБазыMS, "-", "_");
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(ИдентификаторБазыMS) Тогда
		Возврат;	
	КонецЕсли;	
	
	ИмяПеременнойНастройки 	= "Cleverence_СтруктураМетаданныхMS_" + ИдентификаторБазыMS;
	
	СтруктураМетаданных.Вставить("ПользователиMS", СписокПользователейMS);
	
	ГлЯдро_СохранитьДанныеВХранилище1С(ИмяПеременнойНастройки, СтруктураМетаданных);
		
	СтруктураМетаданных.Вставить("ПользователиMS", ПользователиMSАдрес);
	
	КомЯдро_СохранитьЗначениеПеременной("СтруктураМетаданных", СтруктураМетаданных, АдресаПеременных);
	
КонецПроцедуры

Функция ГлЯдро_ПолучитьМобильныеУстройстваSMARTS(ТипБазы, ТипИнтерфейса, АдресаПеременных) Экспорт
	
	Если ТипИнтерфейса = "REST_API" Тогда
		ПользователиMS = REST_API_ПолучитьМобильныеУстройстваSMARTS(ТипБазы, АдресаПеременных);
	Иначе
		ПользователиMS = КомЯдро_ПолучитьМобильныеУстройстваSMARTS(ТипБазы, АдресаПеременных);
	КонецЕсли;        
	
	Возврат ПользователиMS;
	
КонецФункции

#КонецОбласти

#Область ГлобальныйКонтекст_Настройки_Обновление

// Преобразует строковые представления версий настроек в числовые, при необходимости вызывает обновление настроек.
// 
// Параметры:
//	пСтруктураНастроек - Структура - содержит:
//		* ВерсияОбработкиНастроек - Строка - строковое представление версии в формате (1.0.1.1) сохранённых настроек в базе SMARTS 
//		* ВерсияОбработкиКлеверенсТСД - Строка - строковое представление версии в формате (1.0.1.1) значений по умолчанию в базе SMARTS
//	КлючНастройки - Строка, Неопределено - ключ обновляемой настройки
//	ЗначениеНастройки - Структура, Неопределено - структура со значениями настроек для обновления
//
// Возвращаемое значение:
//	Структура - обновленные настройки - содержит:
//		* ИзмененияВКэше - Структура - настройки для сохранения в кэш
//		* ИзменениеВНастройках - Структура - настройки для сохранения в базу SMARTS
Функция ГлЯдро_ВыполнитьОбновлениеСтруктурыНастроек(пСтруктураНастроек,КлючНастройки=Неопределено,ЗначениеНастройки=Неопределено,АдресаПеременных) Экспорт	
	
	НачалоСобытия = ТекущаяУниверсальнаяДатаВМиллисекундах();
	ИмяСобытия = "ГлЯдро_ВыполнитьОбновлениеСтруктурыНастроек";
	
	ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Начало, Обновление структуры настроек", , АдресаПеременных);
		
	ВерсияНастроек_ПоУмолчанию = пСтруктураНастроек.ВерсияОбработкиКлеверенсТСД;
	Если НЕ ЗначениеЗаполнено(ВерсияНастроек_ПоУмолчанию)
		ИЛИ ВерсияНастроек_ПоУмолчанию = Ложь Тогда
		// Подменяем устаревшую настройку "ВерсияОбработкиКлеверенсТСД" настройками по-умолчанию
		ВерсияНастроек_ПоУмолчанию = пСтруктураНастроек.ВерсияНастроек_ПоУмолчанию;
		Если НЕ ЗначениеЗаполнено(ВерсияНастроек_ПоУмолчанию)
			ИЛИ ВерсияНастроек_ПоУмолчанию = Ложь Тогда
			ВерсияНастроек_ПоУмолчанию = 0;
		КонецЕсли;
	КонецЕсли;
	
	Если ВерсияНастроек_ПоУмолчанию <> 0 Тогда		
		ВерсияВМассив 				= ГлЯдро_РазложитьСтрокуВМассивПодстрок(ВерсияНастроек_ПоУмолчанию,".");
		ВерсияНастроек_ПоУмолчанию 	= Число(ВерсияВМассив[0])*1000000000
			+ВерсияВМассив[1]*1000000
			+ВерсияВМассив[2]*1000
			+ВерсияВМассив[3];                    	
	КонецЕсли;
		
	РегистрационныеДанные = СведенияОВнешнейОбработке();
	ВерсияОбработки = РегистрационныеДанные.ВерсияСтруктурыНастроек;
		
	ВерсияВМассив 	= ГлЯдро_РазложитьСтрокуВМассивПодстрок(ВерсияОбработки,".");
	ВерсияОбработки = Число(ВерсияВМассив[0])*1000000000
		+Число(ВерсияВМассив[1])*1000000
		+Число(ВерсияВМассив[2])*1000
		+ВерсияВМассив[3];
	
	//ВерсияОбработкиНастроек уже хранится как число
	ВерсияНастроек = пСтруктураНастроек.ВерсияОбработкиНастроек;	
	Если НЕ ЗначениеЗаполнено(ВерсияНастроек)
		ИЛИ ВерсияНастроек = Ложь Тогда
		ВерсияНастроек = 0;	
	КонецЕсли;
	
	ИзмененияВКэше  	 = Новый Структура("ВерсияОбработки, ВерсияОбработкиНастроек, ВерсияОбработкиКлеверенсТСД", ВерсияОбработки, ВерсияНастроек, ВерсияНастроек_ПоУмолчанию);
	ИзменениеВНастройках = Новый Структура();
	
	// Обновление глобальных параметров
	ОбновлятьГлобальныеПараметры = Истина;

	Если пСтруктураНастроек.Свойство("ВыполненоОбновлениеГлобальныхПараметров") Тогда
		ОбновлятьГлобальныеПараметры = Ложь;
	ИначеЕсли НЕ пСтруктураНастроек.Свойство("ВерсияГлобальныеПараметры") Тогда
		ОбновлятьГлобальныеПараметры = Ложь;
	Иначе
		ВерсияГлобальныхПараметров = пСтруктураНастроек.ВерсияГлобальныеПараметры;
		Если ЗначениеЗаполнено(ВерсияГлобальныхПараметров)
			И НЕ ВерсияГлобальныхПараметров = Ложь
			И ВерсияГлобальныхПараметров >= 1003014000 Тогда
			ОбновлятьГлобальныеПараметры = Ложь;				
		КонецЕсли;
	КонецЕсли;
	
	Если ОбновлятьГлобальныеПараметры Тогда
		ГлЯдро_ВыполнитьОбновлениеГлобальныхПараметров(ИзменениеВНастройках, ИзмененияВКэше, АдресаПеременных);
	КонецЕсли;
	
	Если КлючНастройки = Неопределено Тогда
		Если ВерсияОбработки > ВерсияНастроек Тогда
			Если ГлЯдро_ВыполнитьОбработчикОбновления(ВерсияНастроек, Ложь, ИзменениеВНастройках,,АдресаПеременных) = Истина Тогда
				ИзмененияВКэше.Вставить("ВерсияОбработкиНастроек",ИзменениеВНастройках.ВерсияОбработкиНастроек)	;
			КонецЕсли;
		КонецЕсли;

		Если ВерсияОбработки > ВерсияНастроек_ПоУмолчанию Тогда
			Если ГлЯдро_ВыполнитьОбработчикОбновления(ВерсияНастроек_ПоУмолчанию, Истина, ИзмененияВКэше,,АдресаПеременных) = Истина Тогда

			КонецЕсли;
		КонецЕсли;
		
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Конец, Обновление структуры настроек", НачалоСобытия, АдресаПеременных);
	
		Возврат Новый Структура("ИзмененияВКэше,ИзменениеВНастройках",ИзмененияВКэше,ИзменениеВНастройках);
	Иначе //Реструктуризация по ключу настройки
		Если ВерсияОбработки > ВерсияНастроек_ПоУмолчанию Тогда
			Если ГлЯдро_ВыполнитьОбработчикОбновления(ВерсияНастроек_ПоУмолчанию, Истина, ЗначениеНастройки,КлючНастройки,АдресаПеременных) = Истина Тогда

			КонецЕсли;
		КонецЕсли;
		
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Конец, Обновление структуры настроек", НачалоСобытия, АдресаПеременных);
		
		Возврат ЗначениеНастройки;
	КонецЕсли;	
	
КонецФункции

// Определяет, сколько этапов обновления нужно пройти, начиная с версии в параметре ВерсияНастроек, и вызывает методы обновления по очереди.
// Вызывается в трех режимах:
// 	1. Если ОбновлениеКэша = Ложь и КлючНастройки = Неопределено. 
// 			Обновление настроек, которые после реструктуризации отправятся в базу SMARTS и сохранится версия настроек (customsettings)
// 	2. Если ОбновлениеКэша = Истина и КлючНастройки = Неопределено.
// 			Обновление настроек, которые сохранить нет возможности, а все изменения возвращаются в кэш без сохранения (default_customsettings)
// 	3. Если КлючНастройки <> Неопределено и ИзмененияВСтруктуре <> Неопределено
// 			Обновляются только настройки по ключу и только переданные в параметре ИзмененияВСтруктуре. Используется метод при получении настроек по умолчанию.
// 
// Параметры:
// 	ВерсияНастроек - Число - версия настроек в формате 1000001001
// 	ОбновлениеКэша - Булево - режим обновления не сохраняемых настроек
// 	ИзмененияВСтруктуре - Структура - структура с настройками для изменения
// 	КлючНастройки - Строка, Неопределено - ключ изменяемой настройки
//
// Возвращаемое значение:
// 	Строка, Булево - Флаг успешного выполнения или описание ошибки при выполнении обновления
Функция ГлЯдро_ВыполнитьОбработчикОбновления(ВерсияНастроек,ОбновлениеКэша = Ложь,ИзмененияВСтруктуре=Неопределено,КлючНастройки=Неопределено,АдресаПеременных)

	МассивПереходныхВерсий = Новый СписокЗначений;
	МассивПереходныхВерсий.Добавить(1000001001,"1_0_1_1");
	МассивПереходныхВерсий.Добавить(1000001002,"1_0_1_2");
	МассивПереходныхВерсий.Добавить(1000001003,"1_0_1_3");
	МассивПереходныхВерсий.Добавить(1003000001,"1_3_0_1");
	МассивПереходныхВерсий.Добавить(1003000002,"1_3_0_2");
	МассивПереходныхВерсий.Добавить(1003004001,"1_3_4_1");
	МассивПереходныхВерсий.Добавить(1003005001,"1_3_5_1");
	
	Если ИзмененияВСтруктуре=Неопределено Тогда
		ИзмененияВСтруктуре=Новый Структура();
	КонецЕсли;
	
	ИндексВерсии = 0;
	Для каждого ЧислоВерсии из МассивПереходныхВерсий Цикл
		Если ЧислоВерсии.Значение > ВерсияНастроек Тогда
			Прервать;
		КонецЕсли;
		ИндексВерсии = ИндексВерсии + 1;
	КонецЦикла;
	
	СообщатьОПроблемах = Истина;
	
	Пока ИндексВерсии < МассивПереходныхВерсий.Количество() Цикл
		РезультатВыполнения = ложь;
		Попытка
			//Выполнить("РезультатВыполнения = ГлЯдро_ОбновлениеНастроекДоВерсии_"+МассивПереходныхВерсий[ИндексВерсии].Представление+"(ВерсияНастроек,ОбновлениеКэша,ИзмененияВСтруктуре,КлючНастройки,АдресаПеременных)"); 
			СтрокаВызова = "РезультатВыполнения = Параметры.ОсновнаяОбработка.ГлЯдро_ОбновлениеНастроекДоВерсии_" + МассивПереходныхВерсий[ИндексВерсии].Представление + "(ВерсияНастроек,ОбновлениеКэша,ИзмененияВСтруктуре,КлючНастройки,АдресаПеременных)";
			СтрокаВызова = СтрЗаменить(СтрокаВызова, "РезультатВыполнения", "Параметры.РезультатВыполнения");
			СтрокаВызова = СтрЗаменить(СтрокаВызова, "ВерсияНастроек", "Параметры.ВерсияНастроек");
			СтрокаВызова = СтрЗаменить(СтрокаВызова, "ОбновлениеКэша", "Параметры.ОбновлениеКэша");
			СтрокаВызова = СтрЗаменить(СтрокаВызова, "ИзмененияВСтруктуре", "Параметры.ИзмененияВСтруктуре");
			СтрокаВызова = СтрЗаменить(СтрокаВызова, "КлючНастройки", "Параметры.КлючНастройки");
			СтрокаВызова = СтрЗаменить(СтрокаВызова, "АдресаПеременных", "Параметры.АдресаПеременных");
			ПараметрыАлгоритма = Новый Структура;
			ПараметрыАлгоритма.Вставить("РезультатВыполнения", 	РезультатВыполнения);
			ПараметрыАлгоритма.Вставить("ОсновнаяОбработка", 	ЭтотОбъект);
			ПараметрыАлгоритма.Вставить("ВерсияНастроек", 		ВерсияНастроек);
			ПараметрыАлгоритма.Вставить("ОбновлениеКэша", 		ОбновлениеКэша);
			ПараметрыАлгоритма.Вставить("ИзмененияВСтруктуре", 	ИзмененияВСтруктуре);
			ПараметрыАлгоритма.Вставить("КлючНастройки", 		КлючНастройки);
			ПараметрыАлгоритма.Вставить("АдресаПеременных", 	АдресаПеременных);
			
			ГлЯдро_ВыполнитьВБезопасномРежиме(СтрокаВызова, ПараметрыАлгоритма, АдресаПеременных);
			РезультатВыполнения = ПараметрыАлгоритма.РезультатВыполнения;
		Исключение
			РезультатВыполнения = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		КонецПопытки;
		
		Если СообщатьОПроблемах Тогда
			Если РезультатВыполнения <> Истина Тогда
				Сообщение = ?(ОбновлениеКэша,"	При обновлении кэша произшла ошибка:","При обновлении настроек произшла ошибка:") +"
				| Переход на версию: "+МассивПереходныхВерсий[ИндексВерсии].Представление+?(РезультатВыполнения <> Ложь,"
				| Ошибка: "+РезультатВыполнения,"");
				
				Сообщить(Сообщение);
				
				ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации("ГлЯдро_ВыполнитьОбработчикОбновления", "Ошибка", Сообщение, , АдресаПеременных);
				
				Прервать;
			Иначе 
				ИзмененияВСтруктуре.Вставить(?(ОбновлениеКэша,"ВерсияОбработкиКлеверенсТСД","ВерсияОбработкиНастроек"),МассивПереходныхВерсий[ИндексВерсии].Значение);
			КонецЕсли;
			ИндексВерсии = ИндексВерсии + 1;
		КонецЕсли;

	КонецЦикла;
	
	Возврат РезультатВыполнения;
	
КонецФункции

// Выполняет обновление по каждому ключу из структуры настроек
// 
// Параметры:
// 	ВерсияНастроек - Число - версия настроек для обновления в формате 1000001001
// 	СтруктураНастроек - Структура - структура обновляемых настроек
//
// Возвращаемое значение:
// 	Структура - обновленная структура настроек
Функция ГлЯдро_ВыполнитьОбновлениеНастроек(ВерсияНастроек,Знач СтруктураНастроек,АдресаПеременных) Экспорт
	
	НачалоСобытия = ТекущаяУниверсальнаяДатаВМиллисекундах();
	ИмяСобытия = "ГлЯдро_ВыполнитьОбновлениеНастроек";
	
	ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Начало, Обновление настроек", , АдресаПеременных);
	
	КопияСтруктураНастроек = ГлЯдро_СкопироватьСтруктуру(СтруктураНастроек);
	Для каждого КлючЗначение из КопияСтруктураНастроек Цикл
		ГлЯдро_ВыполнитьОбработчикОбновления(ВерсияНастроек,Ложь,СтруктураНастроек,КлючЗначение.Ключ,АдресаПеременных);	
	КонецЦикла;
	
	ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Конец, Обновление настроек", НачалоСобытия, АдресаПеременных);
	
	Возврат СтруктураНастроек;
	
КонецФункции

// В настройки бизнес-процессов были добавлены поля Обработчик_ПослеОткрытияФормыДокумента, 
// ВыполнитьТолькоПроизвольныйКодВыгрузка, ОбработчикВыгрузкиДокумента и ОбработчикЗагрузкиДокумента
Функция ГлЯдро_ОбновлениеНастроекДоВерсии_1_0_1_1(ВерсияНастроек,ОбновлениеКэша,ИзмененияВСтруктуре,КлючНастройки,АдресаПеременных) Экспорт
	
	Если НЕ ЗначениеЗаполнено(КлючНастройки) Тогда
		пКлюч = ?(ОбновлениеКэша,"НастройкиБизнесПроцессов_ПоУмолчанию","НастройкиБизнесПроцессов_Пользовательские");
		Если ИзмененияВСтруктуре.Свойство(пКлюч) Тогда
			СтруктураНастроекБизнесПроцессов = ИзмененияВСтруктуре[пКлюч];
		Иначе
			Если ОбновлениеКэша Тогда
				СтруктураНастроекБизнесПроцессов = ГлЯдро_ПолучитьИзКэшаСтруктуруНастроекПоУмолчаниюБизнесПроцессов(АдресаПеременных);
			Иначе
				СтруктураНастроекБизнесПроцессов = ГлЯдро_ПолучитьИзКэшаСтруктуруПользовательскихНастроекБизнесПроцессов(АдресаПеременных);
			КонецЕсли;
			СтруктураНастроекБизнесПроцессов.ВерсияНастроек = ГлЯдро_ПолучитьВерсиюСтруктурыНастроекОбработки();
		КонецЕсли;                                                 				
	Иначе
		Если КлючНастройки = "НастройкиБизнесПроцессов_ПоУмолчанию" И  ИзмененияВСтруктуре.Свойство("НастройкиБизнесПроцессов_ПоУмолчанию") Тогда
			СтруктураНастроекБизнесПроцессов = ИзмененияВСтруктуре.НастройкиБизнесПроцессов_ПоУмолчанию;
		Иначе	//Вернем истина т.к. эти настройки мы не изменяем
			Возврат Истина;
		КонецЕсли;
	КонецЕсли;
	
	Если ТипЗнч(СтруктураНастроекБизнесПроцессов) = Тип("Структура") Тогда
		НастройкиБизнесПроцессов = СтруктураНастроекБизнесПроцессов.НастройкиБизнесПроцессов;	
	Иначе
		НастройкиБизнесПроцессов = СтруктураНастроекБизнесПроцессов;	
	КонецЕсли;
	
	Если ТипЗнч(НастройкиБизнесПроцессов) = Тип("Строка") Тогда
		НастройкиБизнесПроцессов = ГлЯдро_ЗначениеИзСтрокиXML(НастройкиБизнесПроцессов);	
	КонецЕсли;
	
	Если ТипЗнч(НастройкиБизнесПроцессов) = Тип("ТаблицаЗначений") Тогда
		НастройкиБизнесПроцессов = ГлЯдро_ТаблицуЗначенийВМассивСтруктур(НастройкиБизнесПроцессов);	
	КонецЕсли;
	
	Если ТипЗнч(НастройкиБизнесПроцессов) = Тип("Массив") Тогда

		Для Каждого НастройкаБП Из  НастройкиБизнесПроцессов Цикл
			Если НастройкаБП.Свойство("ЭтоТаблицаЗначений") Тогда
				Если НЕ Найти(НастройкаБП.КолонкиТаблицыЗначений, "Обработчик_ПослеОткрытияФормыДокумента") Тогда
					НастройкаБП.КолонкиТаблицыЗначений = НастройкаБП.КолонкиТаблицыЗначений
						+ ",Обработчик_ПослеОткрытияФормыДокумента";
				КонецЕсли;
				Если НЕ Найти(НастройкаБП.КолонкиТаблицыЗначений, "ВыполнитьТолькоПроизвольныйКодВыгрузка") Тогда
					НастройкаБП.КолонкиТаблицыЗначений = НастройкаБП.КолонкиТаблицыЗначений
						+ ",ВыполнитьТолькоПроизвольныйКодВыгрузка";
				КонецЕсли;
				Если НЕ Найти(НастройкаБП.КолонкиТаблицыЗначений, "ОбработчикВыгрузкиДокумента") Тогда
					НастройкаБП.КолонкиТаблицыЗначений = НастройкаБП.КолонкиТаблицыЗначений
						+ ",ОбработчикВыгрузкиДокумента";
				КонецЕсли;
				Если НЕ Найти(НастройкаБП.КолонкиТаблицыЗначений, "ОбработчикЗагрузкиДокумента") Тогда
					НастройкаБП.КолонкиТаблицыЗначений = НастройкаБП.КолонкиТаблицыЗначений
						+ ",ОбработчикЗагрузкиДокумента";
				КонецЕсли;
			КонецЕсли;
			Если НЕ НастройкаБП.Свойство("Обработчик_ПослеОткрытияФормыДокумента") Тогда
				НастройкаБП.Вставить("Обработчик_ПослеОткрытияФормыДокумента",Неопределено);	
			КонецЕсли;
			Если НЕ НастройкаБП.Свойство("ВыполнитьТолькоПроизвольныйКодВыгрузка") Тогда
				НастройкаБП.Вставить("ВыполнитьТолькоПроизвольныйКодВыгрузка",Ложь);	
			КонецЕсли;
			Если НЕ НастройкаБП.Свойство("ОбработчикВыгрузкиДокумента") Тогда
				НастройкаБП.Вставить("ОбработчикВыгрузкиДокумента","");	
			КонецЕсли;
			Если НЕ НастройкаБП.Свойство("ОбработчикЗагрузкиДокумента") Тогда
				НастройкаБП.Вставить("ОбработчикЗагрузкиДокумента","");	
			КонецЕсли;
		КонецЦикла;
		
	КонецЕсли;
	
	НовыйФорматНастроек = КомЯдро_ПолучитьЗначениеПеременной("НовыеНастройкиБизнесПроцессов", АдресаПеременных);
	Если НовыйФорматНастроек Тогда	
		Если ТипЗнч(СтруктураНастроекБизнесПроцессов) <> Тип("Структура") Тогда
			Если ОбновлениеКэша Тогда
				СтруктураНастроекБизнесПроцессов = ГлЯдро_ПолучитьИзКэшаСтруктуруНастроекПоУмолчаниюБизнесПроцессов(АдресаПеременных);
			Иначе
				СтруктураНастроекБизнесПроцессов = ГлЯдро_ПолучитьИзКэшаСтруктуруПользовательскихНастроекБизнесПроцессов(АдресаПеременных);
			КонецЕсли;						
		КонецЕсли;              				
		СтруктураНастроекБизнесПроцессов.НастройкиБизнесПроцессов = НастройкиБизнесПроцессов;	
	Иначе
		СтруктураНастроекБизнесПроцессов = НастройкиБизнесПроцессов;
	КонецЕсли;
	
	ИзмененияВСтруктуре.Вставить(?(ОбновлениеКэша,"НастройкиБизнесПроцессов_ПоУмолчанию","НастройкиБизнесПроцессов_Пользовательские"), СтруктураНастроекБизнесПроцессов);

	Возврат Истина;
	
КонецФункции

Функция ГлЯдро_ОбновлениеНастроекДоВерсии_1_0_1_2(ВерсияНастроек,ОбновлениеКэша,ИзмененияВСтруктуре,КлючНастройки,АдресаПеременных) Экспорт
	
	Если НЕ ЗначениеЗаполнено(КлючНастройки) Тогда
		пКлюч = ?(ОбновлениеКэша,"НастройкиБизнесПроцессов_ПоУмолчанию","НастройкиБизнесПроцессов_Пользовательские");
		Если ИзмененияВСтруктуре.Свойство(пКлюч) Тогда
			СтруктураНастроекБизнесПроцессов = ИзмененияВСтруктуре[пКлюч];
		Иначе
			Если ОбновлениеКэша Тогда
				СтруктураНастроекБизнесПроцессов = ГлЯдро_ПолучитьИзКэшаСтруктуруНастроекПоУмолчаниюБизнесПроцессов(АдресаПеременных);
			Иначе
				СтруктураНастроекБизнесПроцессов = ГлЯдро_ПолучитьИзКэшаСтруктуруПользовательскихНастроекБизнесПроцессов(АдресаПеременных);
			КонецЕсли;
			СтруктураНастроекБизнесПроцессов.ВерсияНастроек = ГлЯдро_ПолучитьВерсиюСтруктурыНастроекОбработки();
		КонецЕсли;                                                 				
	Иначе
		Если КлючНастройки = "НастройкиБизнесПроцессов_ПоУмолчанию" И  ИзмененияВСтруктуре.Свойство("НастройкиБизнесПроцессов_ПоУмолчанию") Тогда
			СтруктураНастроекБизнесПроцессов = ИзмененияВСтруктуре.НастройкиБизнесПроцессов_ПоУмолчанию;
		ИначеЕсли КлючНастройки = "НастройкиБизнесПроцессов_Пользовательские" И  ИзмененияВСтруктуре.Свойство("НастройкиБизнесПроцессов_Пользовательские") Тогда
			СтруктураНастроекБизнесПроцессов = ИзмененияВСтруктуре.НастройкиБизнесПроцессов_Пользовательские;			
		Иначе //Вернем истина т.к. эти настройки мы не изменяем
			Возврат Истина;
		КонецЕсли;
	КонецЕсли;
	
	Если ТипЗнч(СтруктураНастроекБизнесПроцессов) = Тип("Структура") Тогда
		НастройкиБизнесПроцессов = СтруктураНастроекБизнесПроцессов.НастройкиБизнесПроцессов;	
	Иначе
		НастройкиБизнесПроцессов = СтруктураНастроекБизнесПроцессов;	
	КонецЕсли;
	
	Если ТипЗнч(НастройкиБизнесПроцессов) = Тип("Строка") Тогда
		НастройкиБизнесПроцессов = ГлЯдро_ЗначениеИзСтрокиXML(НастройкиБизнесПроцессов);	
	КонецЕсли;
	
	Если ТипЗнч(НастройкиБизнесПроцессов) = Тип("ТаблицаЗначений") Тогда
		НастройкиБизнесПроцессов = ГлЯдро_ТаблицуЗначенийВМассивСтруктур(НастройкиБизнесПроцессов);	
	КонецЕсли;
	
	Если ТипЗнч(НастройкиБизнесПроцессов) = Тип("Массив") Тогда

		Для Каждого НастройкаБП Из  НастройкиБизнесПроцессов Цикл
			Если НастройкаБП.Свойство("ЭтоТаблицаЗначений") Тогда
				Продолжить;
			КонецЕсли;
			
			Если НастройкаБП.Свойство("ЗаписыватьДокументПослеЗагрузки")
				И ТипЗнч(НастройкаБП.ЗаписыватьДокументПослеЗагрузки) = Тип("Булево") Тогда
				НастройкаБП.ЗаписыватьДокументПослеЗагрузки = ?(НастройкаБП.ЗаписыватьДокументПослеЗагрузки	= Истина,"Всегда","ПриОнлайн");
			КонецЕсли;
			
			МатаданныеДокумента = Метаданные.Документы.Найти(НастройкаБП.ТипРезультирующегоДокумента1С);
			Если МатаданныеДокумента <> Неопределено Тогда
				
				Если НастройкаБП.Свойство("НастройкаЗагрузкиТЧ")
					И ТипЗнч(НастройкаБП.НастройкаЗагрузкиТЧ) = Тип("Массив") Тогда
					
					Для Каждого НастройкаТЧ Из НастройкаБП.НастройкаЗагрузкиТЧ Цикл
						Если НастройкаТЧ.Свойство("ЭтоТаблицаЗначений") Тогда
							НастройкаТЧ.КолонкиТаблицыЗначений = СтрЗаменить(НастройкаТЧ.КолонкиТаблицыЗначений,",УдалятьСтрокиСНулевымКоличеством","");
							Если НЕ Найти(НастройкаТЧ.КолонкиТаблицыЗначений, "УдалятьСтрокиПоУсловиюСтрокой") Тогда
								НастройкаТЧ.КолонкиТаблицыЗначений = НастройкаТЧ.КолонкиТаблицыЗначений
								+ ",УдалятьСтрокиПоУсловиюСтрокой";
							КонецЕсли;
							Продолжить;
						КонецЕсли;
						Если НастройкаТЧ.Свойство("УдалятьСтрокиСНулевымКоличеством")
							И НастройкаТЧ.УдалятьСтрокиСНулевымКоличеством = Истина Тогда
							НастройкаТЧ.Вставить("УдалятьСтрокиПоУсловиюСтрокой",Неопределено);
							
							Если МатаданныеДокумента.ТабличныеЧасти.Найти(НастройкаТЧ.НастройкаТЧСтрокой) <> Неопределено Тогда
								Если НастройкаТЧ.Свойство("ТабличнаяЧастьДокумента1С") Тогда
									ТабличнаяЧастьДокумента1С = НастройкаТЧ.ТабличнаяЧастьДокумента1С;
								ИначеЕсли НастройкаТЧ.Свойство("ТабличнаяЧастьДокумента1ССтрокой") Тогда
									ТабличнаяЧастьДокумента1С = ГлЯдро_ЗначениеИзСтрокиXML(НастройкаТЧ.ТабличнаяЧастьДокумента1ССтрокой);
								Иначе
									Продолжить;
								КонецЕсли;
								НайденнаяСтрока = ГлЯдро_СкопироватьМассив(ТабличнаяЧастьДокумента1С,Новый Структура("ИмяИсточника","КоличествоФакт"));
								Если НайденнаяСтрока.Количество() = 0 Тогда
									НайденнаяСтрока = ГлЯдро_СкопироватьМассив(ТабличнаяЧастьДокумента1С,Новый Структура("ИмяИсточника","CurrentQuantity"));
									Если НайденнаяСтрока.Количество() = 0 Тогда
										Продолжить;
									КонецЕсли;	
								КонецЕсли;	
								
								ИмяРеквизитаДляПроверки = НайденнаяСтрока[0].ИмяПриемника;			
								
								КомпоновщикНастроек = Новый КомпоновщикНастроекКомпоновкиДанных;
								НовыйОтбор = КомпоновщикНастроек.Настройки.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
								НовыйОтбор.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ИмяРеквизитаДляПроверки);
								НовыйОтбор.ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
								НовыйОтбор.ПравоеЗначение = 0;
								НовыйОтбор.Использование = Истина;
								НастройкаТЧ.Вставить("УдалятьСтрокиПоУсловиюСтрокой",ГлЯдро_ЗначениеВСтрокуXML(КомпоновщикНастроек.ПолучитьНастройки()));
							КонецЕсли;							
							
						КонецЕсли;
					КонецЦикла;
				КонецЕсли;	
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЕсли;
	
	НовыйФорматНастроек = КомЯдро_ПолучитьЗначениеПеременной("НовыеНастройкиБизнесПроцессов", АдресаПеременных);
	Если НовыйФорматНастроек Тогда	
		Если ТипЗнч(СтруктураНастроекБизнесПроцессов) <> Тип("Структура") Тогда
			Если ОбновлениеКэша Тогда
				СтруктураНастроекБизнесПроцессов = ГлЯдро_ПолучитьИзКэшаСтруктуруНастроекПоУмолчаниюБизнесПроцессов(АдресаПеременных);
			Иначе
				СтруктураНастроекБизнесПроцессов = ГлЯдро_ПолучитьИзКэшаСтруктуруПользовательскихНастроекБизнесПроцессов(АдресаПеременных);
			КонецЕсли;						
		КонецЕсли;              				
		СтруктураНастроекБизнесПроцессов.НастройкиБизнесПроцессов = НастройкиБизнесПроцессов;	
	Иначе
		СтруктураНастроекБизнесПроцессов = НастройкиБизнесПроцессов;
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(КлючНастройки) Тогда
		ИзмененияВСтруктуре.Вставить(?(ОбновлениеКэша,"НастройкиБизнесПроцессов_ПоУмолчанию","НастройкиБизнесПроцессов_Пользовательские"), СтруктураНастроекБизнесПроцессов);
	Иначе
		ИзмененияВСтруктуре.Вставить(КлючНастройки, СтруктураНастроекБизнесПроцессов);
	КонецЕсли;

	Возврат Истина;
	
КонецФункции

Функция ГлЯдро_ОбновлениеНастроекДоВерсии_1_0_1_3(ВерсияНастроек,ОбновлениеКэша,ИзмененияВСтруктуре,КлючНастройки,АдресаПеременных) Экспорт
	
	Если НЕ ЗначениеЗаполнено(КлючНастройки) Тогда
		пКлюч = ?(ОбновлениеКэша,"НастройкиБизнесПроцессов_ПоУмолчанию","НастройкиБизнесПроцессов_Пользовательские");
		Если ИзмененияВСтруктуре.Свойство(пКлюч) Тогда
			СтруктураНастроекБизнесПроцессов = ИзмененияВСтруктуре[пКлюч];
		Иначе
			Если ОбновлениеКэша Тогда
				СтруктураНастроекБизнесПроцессов = ГлЯдро_ПолучитьИзКэшаСтруктуруНастроекПоУмолчаниюБизнесПроцессов(АдресаПеременных);
			Иначе
				СтруктураНастроекБизнесПроцессов = ГлЯдро_ПолучитьИзКэшаСтруктуруПользовательскихНастроекБизнесПроцессов(АдресаПеременных);
			КонецЕсли;
			СтруктураНастроекБизнесПроцессов.ВерсияНастроек = ГлЯдро_ПолучитьВерсиюСтруктурыНастроекОбработки();		
		КонецЕсли;                                                 				
	Иначе
		Если КлючНастройки = "НастройкиБизнесПроцессов_ПоУмолчанию" И  ИзмененияВСтруктуре.Свойство("НастройкиБизнесПроцессов_ПоУмолчанию") Тогда
			СтруктураНастроекБизнесПроцессов = ИзмененияВСтруктуре.НастройкиБизнесПроцессов_ПоУмолчанию;
		ИначеЕсли КлючНастройки = "НастройкиБизнесПроцессов_Пользовательские" И  ИзмененияВСтруктуре.Свойство("НастройкиБизнесПроцессов_Пользовательские") Тогда
			СтруктураНастроекБизнесПроцессов = ИзмененияВСтруктуре.НастройкиБизнесПроцессов_Пользовательские;			
		Иначе //Вернем истина т.к. эти настройки мы не изменяем
			Возврат Истина;
		КонецЕсли;
	КонецЕсли;
	
	Если ТипЗнч(СтруктураНастроекБизнесПроцессов) = Тип("Структура") Тогда
		НастройкиБизнесПроцессов = СтруктураНастроекБизнесПроцессов.НастройкиБизнесПроцессов;	
	Иначе
		НастройкиБизнесПроцессов = СтруктураНастроекБизнесПроцессов;	
	КонецЕсли;
	
	Если ТипЗнч(НастройкиБизнесПроцессов) = Тип("Строка") Тогда
		НастройкиБизнесПроцессов = ГлЯдро_ЗначениеИзСтрокиXML(НастройкиБизнесПроцессов);	
	КонецЕсли;
	
	Если ТипЗнч(НастройкиБизнесПроцессов) = Тип("ТаблицаЗначений") Тогда
		НастройкиБизнесПроцессов = ГлЯдро_ТаблицуЗначенийВМассивСтруктур(НастройкиБизнесПроцессов);	
	КонецЕсли;
	
	Если ТипЗнч(НастройкиБизнесПроцессов) = Тип("Массив") Тогда

		Для Каждого НастройкаБП Из  НастройкиБизнесПроцессов Цикл
			Если НастройкаБП.Свойство("ЭтоТаблицаЗначений") Тогда
				Продолжить;
			КонецЕсли;
			
			Если НастройкаБП.Свойство("НастройкаЗагрузкиТЧ")
					И ТипЗнч(НастройкаБП.НастройкаЗагрузкиТЧ) = Тип("Массив") Тогда
					
					Для Каждого НастройкаТЧ Из НастройкаБП.НастройкаЗагрузкиТЧ Цикл
						Если НастройкаТЧ.Свойство("ЭтоТаблицаЗначений") Тогда
							Если НЕ Найти(НастройкаТЧ.КолонкиТаблицыЗначений, "УдалятьСтрокиПоУсловиюФлаг") Тогда
								НастройкаТЧ.КолонкиТаблицыЗначений = НастройкаТЧ.КолонкиТаблицыЗначений
								+ ",УдалятьСтрокиПоУсловиюФлаг";
							КонецЕсли;
							Продолжить;
						КонецЕсли;
						
						Если НЕ НастройкаТЧ.Свойство("УдалятьСтрокиПоУсловиюСтрокой")
							ИЛИ НЕ ЗначениеЗаполнено(НастройкаТЧ.УдалятьСтрокиПоУсловиюСтрокой) Тогда
							Продолжить;
						КонецЕсли;
						
						Если НЕ НастройкаТЧ.Свойство("УдалятьСтрокиПоУсловиюФлаг") Тогда
							
							пНастройкиКомпоновки = ГлЯдро_ЗначениеИзСтрокиXML(СтрЗаменить(НастройкаТЧ.УдалятьСтрокиПоУсловиюСтрокой, Символы.ВК, "")); 	
							
							Если пНастройкиКомпоновки = Неопределено
								ИЛИ пНастройкиКомпоновки.Отбор.Элементы.Количество() = 0 Тогда
								УдалятьСтрокиПоУсловиюФлаг = Ложь;
							Иначе
								УдалятьСтрокиПоУсловиюФлаг = Истина;
							КонецЕсли;
							
							НастройкаТЧ.Вставить("УдалятьСтрокиПоУсловиюФлаг",УдалятьСтрокиПоУсловиюФлаг);
							
						КонецЕсли;						
					КонецЦикла;	
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЕсли;
	
	НовыйФорматНастроек = КомЯдро_ПолучитьЗначениеПеременной("НовыеНастройкиБизнесПроцессов", АдресаПеременных);
	Если НовыйФорматНастроек Тогда	
		Если ТипЗнч(СтруктураНастроекБизнесПроцессов) <> Тип("Структура") Тогда
			Если ОбновлениеКэша Тогда
				СтруктураНастроекБизнесПроцессов = ГлЯдро_ПолучитьИзКэшаСтруктуруНастроекПоУмолчаниюБизнесПроцессов(АдресаПеременных);
			Иначе
				СтруктураНастроекБизнесПроцессов = ГлЯдро_ПолучитьИзКэшаСтруктуруПользовательскихНастроекБизнесПроцессов(АдресаПеременных);
			КонецЕсли;						
		КонецЕсли;              				
		СтруктураНастроекБизнесПроцессов.НастройкиБизнесПроцессов = НастройкиБизнесПроцессов;	
	Иначе
		СтруктураНастроекБизнесПроцессов = НастройкиБизнесПроцессов;
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(КлючНастройки) Тогда
		ИзмененияВСтруктуре.Вставить(?(ОбновлениеКэша,"НастройкиБизнесПроцессов_ПоУмолчанию","НастройкиБизнесПроцессов_Пользовательские"), СтруктураНастроекБизнесПроцессов);
	Иначе
		ИзмененияВСтруктуре.Вставить(КлючНастройки, СтруктураНастроекБизнесПроцессов);
	КонецЕсли;

	Возврат Истина;
КонецФункции

Функция ГлЯдро_ОбновлениеНастроекДоВерсии_1_3_0_1(ВерсияНастроек,ОбновлениеКэша,ИзмененияВСтруктуре,КлючНастройки,АдресаПеременных) Экспорт
	Возврат Истина;	
КонецФункции

// В настройки бизнес-процессов были добавлены поля ID_ПроизвольногоКода_Выгрузка_Документ, ID_ПроизвольногоКода_Загрузка_Документ,
// ТипОбработчикаВыгрузки, ТипОбработчикаЗагрузки
Функция ГлЯдро_ОбновлениеНастроекДоВерсии_1_3_0_2(ВерсияНастроек,ОбновлениеКэша,ИзмененияВСтруктуре,КлючНастройки,АдресаПеременных) Экспорт
	
	Если НЕ ЗначениеЗаполнено(КлючНастройки) Тогда
		пКлюч = ?(ОбновлениеКэша,"НастройкиБизнесПроцессов_ПоУмолчанию","НастройкиБизнесПроцессов_Пользовательские");
		Если ИзмененияВСтруктуре.Свойство(пКлюч) Тогда
			СтруктураНастроекБизнесПроцессов = ИзмененияВСтруктуре[пКлюч];
		Иначе
			Если ОбновлениеКэша Тогда
				СтруктураНастроекБизнесПроцессов = ГлЯдро_ПолучитьИзКэшаСтруктуруНастроекПоУмолчаниюБизнесПроцессов(АдресаПеременных);
			Иначе
				СтруктураНастроекБизнесПроцессов = ГлЯдро_ПолучитьИзКэшаСтруктуруПользовательскихНастроекБизнесПроцессов(АдресаПеременных);
			КонецЕсли;
			СтруктураНастроекБизнесПроцессов.ВерсияНастроек = ГлЯдро_ПолучитьВерсиюСтруктурыНастроекОбработки();
		КонецЕсли;                                                 				
	Иначе
		Если КлючНастройки = "НастройкиБизнесПроцессов_ПоУмолчанию" И  ИзмененияВСтруктуре.Свойство("НастройкиБизнесПроцессов_ПоУмолчанию") Тогда
			СтруктураНастроекБизнесПроцессов = ИзмененияВСтруктуре.НастройкиБизнесПроцессов_ПоУмолчанию;
		Иначе	//Вернем истина т.к. эти настройки мы не изменяем
			Возврат Истина;
		КонецЕсли;
	КонецЕсли;
	
	Если ТипЗнч(СтруктураНастроекБизнесПроцессов) = Тип("Структура") Тогда
		НастройкиБизнесПроцессов = СтруктураНастроекБизнесПроцессов.НастройкиБизнесПроцессов;	
	Иначе
		НастройкиБизнесПроцессов = СтруктураНастроекБизнесПроцессов;	
	КонецЕсли;
	
	Если ТипЗнч(НастройкиБизнесПроцессов) = Тип("Строка") Тогда
		НастройкиБизнесПроцессов = ГлЯдро_ЗначениеИзСтрокиXML(НастройкиБизнесПроцессов);	
	КонецЕсли;
	
	Если ТипЗнч(НастройкиБизнесПроцессов) = Тип("ТаблицаЗначений") Тогда
		НастройкиБизнесПроцессов = ГлЯдро_ТаблицуЗначенийВМассивСтруктур(НастройкиБизнесПроцессов);	
	КонецЕсли;
	
	Если ТипЗнч(НастройкиБизнесПроцессов) = Тип("Массив") Тогда

		Для Каждого НастройкаБП Из  НастройкиБизнесПроцессов Цикл
			Если НастройкаБП.Свойство("ЭтоТаблицаЗначений") Тогда
				Если НЕ Найти(НастройкаБП.КолонкиТаблицыЗначений, "ID_ПроизвольногоКода_Выгрузка_Документ") Тогда
					НастройкаБП.КолонкиТаблицыЗначений = НастройкаБП.КолонкиТаблицыЗначений
						+ ",ID_ПроизвольногоКода_Выгрузка_Документ";
				КонецЕсли;
				Если НЕ Найти(НастройкаБП.КолонкиТаблицыЗначений, "ID_ПроизвольногоКода_Загрузка_Документ") Тогда
					НастройкаБП.КолонкиТаблицыЗначений = НастройкаБП.КолонкиТаблицыЗначений
						+ ",ID_ПроизвольногоКода_Загрузка_Документ";
				КонецЕсли;
				Если НЕ Найти(НастройкаБП.КолонкиТаблицыЗначений, "ТипОбработчикаВыгрузки") Тогда
					НастройкаБП.КолонкиТаблицыЗначений = НастройкаБП.КолонкиТаблицыЗначений
						+ ",ТипОбработчикаВыгрузки";
				КонецЕсли;
				Если НЕ Найти(НастройкаБП.КолонкиТаблицыЗначений, "ТипОбработчикаЗагрузки") Тогда
					НастройкаБП.КолонкиТаблицыЗначений = НастройкаБП.КолонкиТаблицыЗначений
						+ ",ТипОбработчикаЗагрузки";
				КонецЕсли;					
			КонецЕсли;
			Если НЕ НастройкаБП.Свойство("ID_ПроизвольногоКода_Выгрузка_Документ") Тогда
				НастройкаБП.Вставить("ID_ПроизвольногоКода_Выгрузка_Документ","");	
			КонецЕсли;
			Если НЕ НастройкаБП.Свойство("ID_ПроизвольногоКода_Загрузка_Документ") Тогда
				НастройкаБП.Вставить("ID_ПроизвольногоКода_Загрузка_Документ","");	
			КонецЕсли;
			Если НЕ НастройкаБП.Свойство("ТипОбработчикаВыгрузки") Тогда
				НастройкаБП.Вставить("ТипОбработчикаВыгрузки",1);	
			КонецЕсли;
			Если НЕ НастройкаБП.Свойство("ТипОбработчикаЗагрузки") Тогда
				НастройкаБП.Вставить("ТипОбработчикаЗагрузки",1);	
			КонецЕсли;			
		КонецЦикла;
		
	КонецЕсли;

	НовыйФорматНастроек = КомЯдро_ПолучитьЗначениеПеременной("НовыеНастройкиБизнесПроцессов", АдресаПеременных);
	Если НовыйФорматНастроек Тогда	
		Если ТипЗнч(СтруктураНастроекБизнесПроцессов) <> Тип("Структура") Тогда
			Если ОбновлениеКэша Тогда
				СтруктураНастроекБизнесПроцессов = ГлЯдро_ПолучитьИзКэшаСтруктуруНастроекПоУмолчаниюБизнесПроцессов(АдресаПеременных);
			Иначе
				СтруктураНастроекБизнесПроцессов = ГлЯдро_ПолучитьИзКэшаСтруктуруПользовательскихНастроекБизнесПроцессов(АдресаПеременных);
			КонецЕсли;						
		КонецЕсли;              				
		СтруктураНастроекБизнесПроцессов.НастройкиБизнесПроцессов = НастройкиБизнесПроцессов;	
	Иначе
		СтруктураНастроекБизнесПроцессов = НастройкиБизнесПроцессов;
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(КлючНастройки) Тогда
		ИзмененияВСтруктуре.Вставить(?(ОбновлениеКэша,"НастройкиБизнесПроцессов_ПоУмолчанию","НастройкиБизнесПроцессов_Пользовательские"), СтруктураНастроекБизнесПроцессов);
	Иначе
		ИзмененияВСтруктуре.Вставить(КлючНастройки, СтруктураНастроекБизнесПроцессов);
	КонецЕсли;
	
	Возврат Истина;	
КонецФункции

// В настройки бизнес-процессов были добавлены поля обработчиков выгрузки типа "ВидОбработчика_" и "Обработчик_"
//
Функция ГлЯдро_ОбновлениеНастроекДоВерсии_1_3_4_1(ВерсияНастроек,ОбновлениеКэша,ИзмененияВСтруктуре,КлючНастройки,АдресаПеременных) Экспорт
	
	Если НЕ ЗначениеЗаполнено(КлючНастройки) Тогда
		пКлюч = ?(ОбновлениеКэша, "НастройкиБизнесПроцессов_ПоУмолчанию", "НастройкиБизнесПроцессов_Пользовательские");
		Если ИзмененияВСтруктуре.Свойство(пКлюч) Тогда
			СтруктураНастроекБизнесПроцессов = ИзмененияВСтруктуре[пКлюч];
		Иначе
			Если ОбновлениеКэша Тогда
				СтруктураНастроекБизнесПроцессов = ГлЯдро_ПолучитьИзКэшаСтруктуруНастроекПоУмолчаниюБизнесПроцессов(АдресаПеременных);
			Иначе
				СтруктураНастроекБизнесПроцессов = ГлЯдро_ПолучитьИзКэшаСтруктуруПользовательскихНастроекБизнесПроцессов(АдресаПеременных);
			КонецЕсли;
			СтруктураНастроекБизнесПроцессов.ВерсияНастроек = ГлЯдро_ПолучитьВерсиюСтруктурыНастроекОбработки();
		КонецЕсли;                                                 				
	Иначе
		Если КлючНастройки = "НастройкиБизнесПроцессов_ПоУмолчанию" И  ИзмененияВСтруктуре.Свойство("НастройкиБизнесПроцессов_ПоУмолчанию") Тогда
			СтруктураНастроекБизнесПроцессов = ИзмененияВСтруктуре.НастройкиБизнесПроцессов_ПоУмолчанию;
		Иначе	
			Возврат Истина;
		КонецЕсли;
	КонецЕсли;
	
	Если ТипЗнч(СтруктураНастроекБизнесПроцессов) = Тип("Структура") Тогда
		НастройкиБизнесПроцессов = СтруктураНастроекБизнесПроцессов.НастройкиБизнесПроцессов;	
	Иначе
		НастройкиБизнесПроцессов = СтруктураНастроекБизнесПроцессов;	
	КонецЕсли;
	
	Если ТипЗнч(НастройкиБизнесПроцессов) = Тип("Строка") Тогда
		НастройкиБизнесПроцессов = ГлЯдро_ЗначениеИзСтрокиXML(НастройкиБизнесПроцессов);	
	КонецЕсли;
	
	Если ТипЗнч(НастройкиБизнесПроцессов) = Тип("ТаблицаЗначений") Тогда
		НастройкиБизнесПроцессов = ГлЯдро_ТаблицуЗначенийВМассивСтруктур(НастройкиБизнесПроцессов);	
	КонецЕсли;
	
	Если ТипЗнч(НастройкиБизнесПроцессов) = Тип("Массив") Тогда

		МассивОсновныхНовыхСвойств = Новый Массив;
		МассивОсновныхНовыхСвойств.Добавить(Новый Структура("Имя, Значение", "ВидОбработчика_ПередВыгрузкойДокумента", 		0));
		МассивОсновныхНовыхСвойств.Добавить(Новый Структура("Имя, Значение", "ВидОбработчика_ПослеВыгрузкиДокумента", 		0));
		МассивОсновныхНовыхСвойств.Добавить(Новый Структура("Имя, Значение", "ВидОбработчика_ПослеОтправкиДокумента", 		0));
		МассивОсновныхНовыхСвойств.Добавить(Новый Структура("Имя, Значение", "ВидОбработчика_ПередЗаполнениемДокумента",	0));
		МассивОсновныхНовыхСвойств.Добавить(Новый Структура("Имя, Значение", "ВидОбработчика_ПослеЗаполненияДокумента", 	0));
		МассивОсновныхНовыхСвойств.Добавить(Новый Структура("Имя, Значение", "ВидОбработчика_ПослеОткрытияФормыДокумента", 	0));
		МассивОсновныхНовыхСвойств.Добавить(Новый Структура("Имя, Значение", "Обработчик_ПередВыгрузкойДокумента", 			""));
		МассивОсновныхНовыхСвойств.Добавить(Новый Структура("Имя, Значение", "Обработчик_ПослеВыгрузкиДокумента", 			""));
		МассивОсновныхНовыхСвойств.Добавить(Новый Структура("Имя, Значение", "Обработчик_ПослеОтправкиДокумента", 			""));		
		
		МассивНовыхСвойствВыгрузкиТЧ = Новый Массив;
		МассивНовыхСвойствВыгрузкиТЧ.Добавить(Новый Структура("Имя, Значение", "ВидОбработчика_ПередВыгрузкойТабличнойЧасти", 			0));
		МассивНовыхСвойствВыгрузкиТЧ.Добавить(Новый Структура("Имя, Значение", "ВидОбработчика_ПередВыгрузкойСтрокиТабличнойЧасти", 	0));
		МассивНовыхСвойствВыгрузкиТЧ.Добавить(Новый Структура("Имя, Значение", "ВидОбработчика_ПослеВыгрузкиСтрокиТабличнойЧасти", 		0));
		МассивНовыхСвойствВыгрузкиТЧ.Добавить(Новый Структура("Имя, Значение", "ВидОбработчика_ПослеВыгрузкиТабличнойЧасти",			0));
		МассивНовыхСвойствВыгрузкиТЧ.Добавить(Новый Структура("Имя, Значение", "ВидОбработчика_ПослеОбъединенияТабличнойЧасти", 		0));
		МассивНовыхСвойствВыгрузкиТЧ.Добавить(Новый Структура("Имя, Значение", "ВидОбработчика_ПослеОбъединенияСтрокиТабличнойЧасти",	0));	
		МассивНовыхСвойствВыгрузкиТЧ.Добавить(Новый Структура("Имя, Значение", "Обработчик_ПередВыгрузкойТабличнойЧасти", 				""));
		МассивНовыхСвойствВыгрузкиТЧ.Добавить(Новый Структура("Имя, Значение", "Обработчик_ПередВыгрузкойСтрокиТабличнойЧасти", 		""));
		МассивНовыхСвойствВыгрузкиТЧ.Добавить(Новый Структура("Имя, Значение", "Обработчик_ПослеВыгрузкиСтрокиТабличнойЧасти", 			""));
		МассивНовыхСвойствВыгрузкиТЧ.Добавить(Новый Структура("Имя, Значение", "Обработчик_ПослеВыгрузкиТабличнойЧасти", 				""));
		МассивНовыхСвойствВыгрузкиТЧ.Добавить(Новый Структура("Имя, Значение", "Обработчик_ПослеОбъединенияТабличнойЧасти", 			""));
		МассивНовыхСвойствВыгрузкиТЧ.Добавить(Новый Структура("Имя, Значение", "Обработчик_ПослеОбъединенияСтрокиТабличнойЧасти", 		""));
		
		МассивНовыхСвойствЗагрузкиТЧ = Новый Массив;
		МассивНовыхСвойствЗагрузкиТЧ.Добавить(Новый Структура("Имя, Значение", "ВидОбработчика_ПередЗаполнениемТабличнойЧасти", 		0));
		МассивНовыхСвойствЗагрузкиТЧ.Добавить(Новый Структура("Имя, Значение", "ВидОбработчика_ПередЗаполнениемСтрокиТабличнойЧасти", 	0));
		МассивНовыхСвойствЗагрузкиТЧ.Добавить(Новый Структура("Имя, Значение", "ВидОбработчика_ПослеЗаполненияСтрокиТабличнойЧасти", 	0));
		МассивНовыхСвойствЗагрузкиТЧ.Добавить(Новый Структура("Имя, Значение", "ВидОбработчика_ПослеЗаполненияТабличнойЧасти",			0));
		
		Для Каждого НастройкаБП Из НастройкиБизнесПроцессов Цикл
			
			Если НастройкаБП.Свойство("ЭтоТаблицаЗначений") Тогда
				
				Для Каждого ОсновноеНовоеСвойство Из МассивОсновныхНовыхСвойств Цикл
					Если Не Найти(НастройкаБП.КолонкиТаблицыЗначений, ОсновноеНовоеСвойство.Имя) Тогда
						НастройкаБП.КолонкиТаблицыЗначений = НастройкаБП.КолонкиТаблицыЗначений
						+ "," + ОсновноеНовоеСвойство.Имя;
					КонецЕсли;				
				КонецЦикла;
				
			КонецЕсли;
			
			Для Каждого ОсновноеНовоеСвойство Из МассивОсновныхНовыхСвойств Цикл
				
				Если Не НастройкаБП.Свойство(ОсновноеНовоеСвойство.Имя) Тогда
					НастройкаБП.Вставить(ОсновноеНовоеСвойство.Имя, ОсновноеНовоеСвойство.Значение);	
				КонецЕсли;				
				
			КонецЦикла;
									
			Если НастройкаБП.Свойство("НастройкаВыгрузкиТЧ") И ТипЗнч(НастройкаБП.НастройкаВыгрузкиТЧ) = Тип("Массив") Тогда
				
				Для Каждого НастройкаТЧ Из НастройкаБП.НастройкаВыгрузкиТЧ Цикл
					
					Если НастройкаТЧ.Свойство("ЭтоТаблицаЗначений") Тогда
						
						Для Каждого НовоеСвойствоТЧ Из МассивНовыхСвойствВыгрузкиТЧ Цикл
							Если Не Найти(НастройкаТЧ.КолонкиТаблицыЗначений, НовоеСвойствоТЧ.Имя) Тогда
								НастройкаТЧ.КолонкиТаблицыЗначений = НастройкаТЧ.КолонкиТаблицыЗначений
								+ "," + НовоеСвойствоТЧ.Имя;
							КонецЕсли;				
						КонецЦикла;						
									
					КонецЕсли;
					
					Для Каждого НовоеСвойствоТЧ Из МассивНовыхСвойствВыгрузкиТЧ Цикл
						
						Если Не НастройкаТЧ.Свойство(НовоеСвойствоТЧ.Имя) Тогда
							НастройкаТЧ.Вставить(НовоеСвойствоТЧ.Имя, НовоеСвойствоТЧ.Значение);	
						КонецЕсли;				
						
					КонецЦикла;
												
				КонецЦикла;
				
			КонецЕсли;
			
			Если НастройкаБП.Свойство("НастройкаЗагрузкиТЧ") И ТипЗнч(НастройкаБП.НастройкаЗагрузкиТЧ) = Тип("Массив") Тогда
				
				Для Каждого НастройкаТЧ Из НастройкаБП.НастройкаЗагрузкиТЧ Цикл
					
					Если НастройкаТЧ.Свойство("ЭтоТаблицаЗначений") Тогда
						
						Для Каждого НовоеСвойствоТЧ Из МассивНовыхСвойствЗагрузкиТЧ Цикл
							Если Не Найти(НастройкаТЧ.КолонкиТаблицыЗначений, НовоеСвойствоТЧ.Имя) Тогда
								НастройкаТЧ.КолонкиТаблицыЗначений = НастройкаТЧ.КолонкиТаблицыЗначений
								+ "," + НовоеСвойствоТЧ.Имя;
							КонецЕсли;				
						КонецЦикла;						
									
					КонецЕсли;
					
					Для Каждого НовоеСвойствоТЧ Из МассивНовыхСвойствЗагрузкиТЧ Цикл
						
						Если Не НастройкаТЧ.Свойство(НовоеСвойствоТЧ.Имя) Тогда
							НастройкаТЧ.Вставить(НовоеСвойствоТЧ.Имя, НовоеСвойствоТЧ.Значение);	
						КонецЕсли;				
						
					КонецЦикла;
												
				КонецЦикла;
				
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЕсли;

	НовыйФорматНастроек = КомЯдро_ПолучитьЗначениеПеременной("НовыеНастройкиБизнесПроцессов", АдресаПеременных);
	Если НовыйФорматНастроек Тогда	                                                                		
		Если ТипЗнч(СтруктураНастроекБизнесПроцессов) <> Тип("Структура") Тогда
			Если ОбновлениеКэша Тогда
				СтруктураНастроекБизнесПроцессов = ГлЯдро_ПолучитьИзКэшаСтруктуруНастроекПоУмолчаниюБизнесПроцессов(АдресаПеременных);
			Иначе
				СтруктураНастроекБизнесПроцессов = ГлЯдро_ПолучитьИзКэшаСтруктуруПользовательскихНастроекБизнесПроцессов(АдресаПеременных);
			КонецЕсли;						
		КонецЕсли;              		
		СтруктураНастроекБизнесПроцессов.НастройкиБизнесПроцессов = НастройкиБизнесПроцессов;	
	Иначе
		СтруктураНастроекБизнесПроцессов = НастройкиБизнесПроцессов;
	КонецЕсли;
	
	Если Не ЗначениеЗаполнено(КлючНастройки) Тогда
		ИзмененияВСтруктуре.Вставить(?(ОбновлениеКэша, "НастройкиБизнесПроцессов_ПоУмолчанию", "НастройкиБизнесПроцессов_Пользовательские"), СтруктураНастроекБизнесПроцессов);
	Иначе
		ИзмененияВСтруктуре.Вставить(КлючНастройки, СтруктураНастроекБизнесПроцессов);
	КонецЕсли;
	
	Возврат Истина;	
	
КонецФункции

// Изменения:
//	* Настройки бизнес-процессов теперь хранятся в виде структуры: 
//		- ВерсияНастроек - версия структуры настроек (вместо отдельного ключа настроек)
//		- НастройкиБизнесПроцессов - собственно таблица с настройками.
//	* Формат сохарения/чтения настроек изменен со СтрокиВнутр на XML.
//
Функция ГлЯдро_ОбновлениеНастроекДоВерсии_1_3_5_1(ВерсияНастроек,ОбновлениеКэша,ИзмененияВСтруктуре,КлючНастройки,АдресаПеременных) Экспорт
	
	Если НЕ ЗначениеЗаполнено(КлючНастройки) Тогда
		пКлюч = ?(ОбновлениеКэша, "НастройкиБизнесПроцессов_ПоУмолчанию", "НастройкиБизнесПроцессов_Пользовательские");
		Если ИзмененияВСтруктуре.Свойство(пКлюч) Тогда
			СтруктураНастроекБизнесПроцессов = ИзмененияВСтруктуре[пКлюч];
		Иначе
			Если ОбновлениеКэша Тогда
				СтруктураНастроекБизнесПроцессов = ГлЯдро_ПолучитьИзКэшаСтруктуруНастроекПоУмолчаниюБизнесПроцессов(АдресаПеременных);
			Иначе
				СтруктураНастроекБизнесПроцессов = ГлЯдро_ПолучитьИзКэшаСтруктуруПользовательскихНастроекБизнесПроцессов(АдресаПеременных);
			КонецЕсли;
			СтруктураНастроекБизнесПроцессов.ВерсияНастроек = ГлЯдро_ПолучитьВерсиюСтруктурыНастроекОбработки();
		КонецЕсли;                                                 				
	Иначе
		Если КлючНастройки = "НастройкиБизнесПроцессов_ПоУмолчанию" И  ИзмененияВСтруктуре.Свойство("НастройкиБизнесПроцессов_ПоУмолчанию") Тогда
			СтруктураНастроекБизнесПроцессов = ИзмененияВСтруктуре.НастройкиБизнесПроцессов_ПоУмолчанию;
		Иначе	
			Возврат Истина;
		КонецЕсли;
	КонецЕсли;
	
	Если ТипЗнч(СтруктураНастроекБизнесПроцессов) = Тип("Структура") Тогда
		НастройкиБизнесПроцессов = СтруктураНастроекБизнесПроцессов.НастройкиБизнесПроцессов;	
	Иначе
		НастройкиБизнесПроцессов = СтруктураНастроекБизнесПроцессов;	
	КонецЕсли;
	
	Если ТипЗнч(НастройкиБизнесПроцессов) = Тип("Строка") Тогда
		НастройкиБизнесПроцессов = ГлЯдро_ЗначениеИзСтрокиXML(НастройкиБизнесПроцессов);	
	КонецЕсли;
	
	Если ТипЗнч(НастройкиБизнесПроцессов) = Тип("ТаблицаЗначений") Тогда
		НастройкиБизнесПроцессов = ГлЯдро_ТаблицуЗначенийВМассивСтруктур(НастройкиБизнесПроцессов);	
	КонецЕсли;
	
	НовыйФорматНастроек = КомЯдро_ПолучитьЗначениеПеременной("НовыеНастройкиБизнесПроцессов", АдресаПеременных);
	Если НовыйФорматНастроек Тогда	
		Если ТипЗнч(СтруктураНастроекБизнесПроцессов) <> Тип("Структура") Тогда
			Если ОбновлениеКэша Тогда
				СтруктураНастроекБизнесПроцессов = ГлЯдро_ПолучитьИзКэшаСтруктуруНастроекПоУмолчаниюБизнесПроцессов(АдресаПеременных);
			Иначе
				СтруктураНастроекБизнесПроцессов = ГлЯдро_ПолучитьИзКэшаСтруктуруПользовательскихНастроекБизнесПроцессов(АдресаПеременных);
			КонецЕсли;						
		КонецЕсли;              				
		СтруктураНастроекБизнесПроцессов.НастройкиБизнесПроцессов = НастройкиБизнесПроцессов;	
	Иначе
		СтруктураНастроекБизнесПроцессов = НастройкиБизнесПроцессов;
	КонецЕсли;
	
	Если Не ЗначениеЗаполнено(КлючНастройки) Тогда
		ИзмененияВСтруктуре.Вставить(?(ОбновлениеКэша, "НастройкиБизнесПроцессов_ПоУмолчанию", "НастройкиБизнесПроцессов_Пользовательские"), СтруктураНастроекБизнесПроцессов);
	Иначе
		ИзмененияВСтруктуре.Вставить(КлючНастройки, СтруктураНастроекБизнесПроцессов);
	КонецЕсли;
	
	Возврат Истина;	
	
КонецФункции

Функция ГлЯдро_ОбновитьНастройкиТаймаутов(АдресаПеременных) Экспорт
	
	ТаймаутыПоУмолчанию = ГлЯдро_ТаймаутыПоУмолчанию(АдресаПеременных);
	
	ОбновленныеНастройки = Ложь;
	
	ТекущаяНастройка = ГлЯдро_ПолучитьИзКэшаНастройкуSMARTS("НастройкиТаймаутов",Ложь,АдресаПеременных);
	Если ТекущаяНастройка = Неопределено 
		Или ТекущаяНастройка = Ложь Тогда
		ОбновленныеНастройки =  ТаймаутыПоУмолчанию;
	Иначе
		ТаблицаТекущихНастроек 	= ГлЯдро_МассивСтруктурВТаблицуЗначений(ТекущаяНастройка);
		ТаблицаПоУмолчанию 		= ГлЯдро_МассивСтруктурВТаблицуЗначений(ТаймаутыПоУмолчанию);
		Для Каждого СтрокаНастройки Из ТаблицаПоУмолчанию Цикл
			Если ТаблицаТекущихНастроек.Найти(СтрокаНастройки.ТипЗапроса, "ТипЗапроса") = Неопределено Тогда
				НС = ТаблицаТекущихНастроек.Добавить();
				ЗаполнитьЗначенияСвойств(НС,СтрокаНастройки);
			КонецЕсли;
		КонецЦикла;
		ОбновленныеНастройки = ГлЯдро_ТаблицуЗначенийВМассивСтруктур(ТаблицаТекущихНастроек);
	КонецЕсли;
	
	ГлЯдро_ЗаписатьВКэшНастройкуSMARTS("НастройкиТаймаутов",ОбновленныеНастройки,АдресаПеременных);
	
	Возврат ОбновленныеНастройки;
КонецФункции

// Изменение структуры глобальных параметров:
// 	1. ГлобальныеПараметры разделены на ГлобальныеПараметры_ПоУмолчанию и ГлобальныеПараметры_Пользовательские
// 	2. Для хранения параметров главного узла используется настройка ГлобальныеПараметры_Значения вместо ГлобальныеПараметры
// 	3. Настройка ЗначенияПараметровУзлов_[УзелN] переименована в ГлобальныеПараметры_Значения_[УзелN]
Функция ГлЯдро_ВыполнитьОбновлениеГлобальныхПараметров(ИзмененияВСтруктуре, ИзмененияВКэше, АдресаПеременных) Экспорт

	ID_ТекущегоУзла = "";
	
	ДанныеТекущегоУзла = КомЯдро_ПолучитьЗначениеПеременной("ДанныеТекущегоУзла", АдресаПеременных);
	Если ТипЗнч(ДанныеТекущегоУзла) = Тип("Структура") Тогда
		ID_ТекущегоУзла = ДанныеТекущегоУзла.ID_Узла;		
	КонецЕсли;
	
	ГлобальныеПараметры = ГлЯдро_ПолучитьИзКэшаНастройкуSMARTS("ГлобальныеПараметры",, АдресаПеременных);
	
	Если ЗначениеЗаполнено(ГлобальныеПараметры) И НЕ ГлобальныеПараметры = Ложь Тогда
		ГлобальныеПараметры_Значения 		 = ГлЯдро_ПолучитьНастройкуНаСервереSMARTS("ГлобальныеПараметры_Значения",, 	 АдресаПеременных);
	    ГлобальныеПараметры_ПоУмолчанию 	 = ГлЯдро_ПолучитьИзКэшаНастройкуSMARTS("ГлобальныеПараметры_ПоУмолчанию",, 	 АдресаПеременных);
		ГлобальныеПараметры_Пользовательские = ГлЯдро_ПолучитьИзКэшаНастройкуSMARTS("ГлобальныеПараметры_Пользовательские",, АдресаПеременных);
		
		ЕстьГлобальныеПараметры_Значения 		 = ЗначениеЗаполнено(ГлобальныеПараметры_Значения) И НЕ ГлобальныеПараметры_Значения = Ложь;
		ЕстьГлобальныеПараметры_ПоУмолчанию 	 = ЗначениеЗаполнено(ГлобальныеПараметры_ПоУмолчанию) И НЕ ГлобальныеПараметры_ПоУмолчанию = Ложь;
		ЕстьГлобальныеПараметры_Пользовательские = ЗначениеЗаполнено(ГлобальныеПараметры_Пользовательские) И НЕ ГлобальныеПараметры_Пользовательские = Ложь;
		
		Если НЕ ЕстьГлобальныеПараметры_Значения Тогда
			ГлобальныеПараметры_Значения = Новый Массив;
			ГлобальныеПараметры_Значения.Добавить(Новый Структура("ЭтоТаблицаЗначений, КолонкиТаблицыЗначений", Истина, "Использование, Наименование, Значение, ID_Параметра, Комментарий"));
		КонецЕсли;
		
		Если НЕ ЕстьГлобальныеПараметры_Пользовательские Тогда
			ГлобальныеПараметры_Пользовательские = Новый Массив;
			ГлобальныеПараметры_Пользовательские.Добавить(Новый Структура("ЭтоТаблицаЗначений, КолонкиТаблицыЗначений", Истина, "Использование, Наименование, Значение, ID_Параметра, Комментарий"));
		КонецЕсли;
			
		Для каждого СтрокаПараметра ИЗ ГлобальныеПараметры Цикл	
			Если СтрокаПараметра.Свойство("ЭтоТаблицаЗначений") Тогда
				Продолжить;
			КонецЕсли;
						
			// Дополняем ключ ГлобальныеПараметры_Значения значениями ключа ГлобальныеПараметры
			НайденныйПараметр = ГлЯдро_НайтиСтруктуруВМассивеПоЭлементу(ГлобальныеПараметры_Значения, "ID_Параметра", СтрокаПараметра.ID_Параметра);
			Если НайденныйПараметр = Неопределено Тогда
				ГлобальныеПараметры_Значения.Добавить(ГлЯдро_СкопироватьСтруктуру(СтрокаПараметра));	
			КонецЕсли;
						
			// Дополняем ключ ГлобальныеПараметры_Пользовательские по наличию настроек в ключе ГлобальныеПараметры_ПоУмолчанию
			Если ЕстьГлобальныеПараметры_ПоУмолчанию Тогда
				НайденныйПараметр = ГлЯдро_НайтиСтруктуруВМассивеПоЭлементу(ГлобальныеПараметры_ПоУмолчанию, "ID_Параметра", СтрокаПараметра.ID_Параметра);
				Если НайденныйПараметр <> Неопределено Тогда
					Продолжить;						
				КонецЕсли;
						
				НайденныйПараметр = ГлЯдро_НайтиСтруктуруВМассивеПоЭлементу(ГлобальныеПараметры_Пользовательские, "ID_Параметра", СтрокаПараметра.ID_Параметра);
				Если НайденныйПараметр = Неопределено Тогда
					ГлобальныеПараметры_Пользовательские.Добавить(ГлЯдро_СкопироватьСтруктуру(СтрокаПараметра));
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
		
		ГлЯдро_УдалитьНастройкиВБазеSMARTS(Новый Структура("ГлобальныеПараметры"),,, АдресаПеременных);
		ГлЯдро_СохранитьЗначениеКэшируемойНастройки("ГлобальныеПараметры", Неопределено, "", АдресаПеременных);
		
		// Если нет ключа ГлобальныеПараметры_ПоУмолчанию, дополняем ключ ГлобальныеПараметры_Пользовательские по наличию настроек в ключе ГлобальныеПараметры 
		Если НЕ ЕстьГлобальныеПараметры_ПоУмолчанию Тогда
            ГлобальныеПараметры_ПоУмолчанию = ГлЯдро_ПолучитьНастройкуНаСервереSMARTS("ГлобальныеПараметры",, АдресаПеременных);
			Если ЗначениеЗаполнено(ГлобальныеПараметры_ПоУмолчанию) И НЕ ГлобальныеПараметры_ПоУмолчанию = Ложь Тогда
                Для каждого СтрокаПараметра ИЗ ГлобальныеПараметры Цикл	
					Если СтрокаПараметра.Свойство("ЭтоТаблицаЗначений") Тогда
						Продолжить;
					КонецЕсли;
				
					НайденныйПараметр = ГлЯдро_НайтиСтруктуруВМассивеПоЭлементу(ГлобальныеПараметры_ПоУмолчанию, "ID_Параметра", СтрокаПараметра.ID_Параметра);
					Если НайденныйПараметр <> Неопределено Тогда
						Продолжить;						
					КонецЕсли;
							
					НайденныйПараметр = ГлЯдро_НайтиСтруктуруВМассивеПоЭлементу(ГлобальныеПараметры_Пользовательские, "ID_Параметра", СтрокаПараметра.ID_Параметра);
					Если НайденныйПараметр = Неопределено Тогда
						ГлобальныеПараметры_Пользовательские.Добавить(ГлЯдро_СкопироватьСтруктуру(СтрокаПараметра));
					КонецЕсли;
				КонецЦикла;
				
				ИзмененияВКэше.Вставить("ГлобальныеПараметры_ПоУмолчанию", ГлобальныеПараметры_ПоУмолчанию);
			КонецЕсли;
			ГлЯдро_СохранитьЗначениеКэшируемойНастройки("ГлобальныеПараметры", Неопределено, "", АдресаПеременных);
		КонецЕсли;
		
		ИзмененияВСтруктуре.Вставить("ГлобальныеПараметры_Значения", 		 ГлобальныеПараметры_Значения);
		ИзмененияВСтруктуре.Вставить("ГлобальныеПараметры_Пользовательские", ГлобальныеПараметры_Пользовательские);
		
		ИзмененияВКэше.Вставить("ГлобальныеПараметры_Пользовательские", 	 ГлобальныеПараметры_Пользовательские);
		ИзмененияВКэше.Вставить("ГлобальныеПараметры", 						 Неопределено);
		
		Если ID_ТекущегоУзла = "" Тогда
			ИзмененияВКэше.Вставить("ГлобальныеПараметры_Значения", 	 	 ГлобальныеПараметры_Пользовательские);	
		КонецЕсли;
	КонецЕсли;
	
	ВсеУзлы = ГлЯдро_ПолучитьИзКэшаНастройкуSMARTS("Узлы",, АдресаПеременных);
	Если ТипЗнч(ВсеУзлы) = Тип("Массив") Тогда
		Для каждого СтрокаУзла ИЗ ВсеУзлы Цикл
			Если СтрокаУзла.Свойство("ЭтоТаблицаЗначений") Тогда
				Продолжить;
			КонецЕсли;
			
			ID_Узла = СтрокаУзла.ID_Узла;
			
			// ЗначенияПараметровУзлов_[Узел] заменяем на ГлобальныеПараметры_Значения_[Узел]
			ЗначенияПараметровУзлов = ГлЯдро_ПолучитьНастройкуНаСервереSMARTS("ЗначенияПараметровУзлов", ID_Узла, АдресаПеременных);
			Если ЗначениеЗаполнено(ЗначенияПараметровУзлов) И НЕ ЗначенияПараметровУзлов = Ложь Тогда
				ГлобальныеПараметры_Значения = ГлЯдро_ПолучитьНастройкуНаСервереSMARTS("ГлобальныеПараметры_Значения", ID_Узла, АдресаПеременных);
			    
				ЕстьГлобальныеПараметры_Значения = ЗначениеЗаполнено(ГлобальныеПараметры_Значения) И НЕ ГлобальныеПараметры_Значения = Ложь;
				Если НЕ ЕстьГлобальныеПараметры_Значения Тогда
					ГлобальныеПараметры_Значения = Новый Массив;
					ГлобальныеПараметры_Значения.Добавить(Новый Структура("ЭтоТаблицаЗначений, КолонкиТаблицыЗначений", Истина, "Использование, Наименование, Значение, ID_Параметра, Комментарий"));
				КонецЕсли;
				
				Для каждого СтрокаПараметра ИЗ ЗначенияПараметровУзлов Цикл	
					Если СтрокаПараметра.Свойство("ЭтоТаблицаЗначений") Тогда
						Продолжить;
					КонецЕсли;
								
					// Дополняем ключ ГлобальныеПараметры_Значения_[Узел] значениями ключа ЗначенияПараметровУзлов_[Узел]
					НайденныйПараметр = ГлЯдро_НайтиСтруктуруВМассивеПоЭлементу(ГлобальныеПараметры_Значения, "ID_Параметра", СтрокаПараметра.ID_Параметра);
					Если НайденныйПараметр = Неопределено Тогда
						ГлобальныеПараметры_Значения.Добавить(ГлЯдро_СкопироватьСтруктуру(СтрокаПараметра));	
					КонецЕсли;
				КонецЦикла;
				
				ГлЯдро_УдалитьНастройкиВБазеSMARTS(Новый Структура("ЗначенияПараметровУзлов"),, ID_Узла, АдресаПеременных);
				
				ГлЯдро_СохранитьНастройкуВБазеSMARTS("ГлобальныеПараметры_Значения", ГлобальныеПараметры_Значения, ID_Узла, АдресаПеременных);
				
				Если ID_ТекущегоУзла = ID_Узла Тогда
					ИзмененияВКэше.Вставить("ГлобальныеПараметры_Значения", ГлобальныеПараметры_Пользовательские);
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	ГлЯдро_СохранитьНастройкуВБазеSMARTS("ВерсияГлобальныеПараметры", 1003014000,, АдресаПеременных);
	
	Возврат Истина;	
	
КонецФункции

#КонецОбласти

#КонецОбласти

#Область ГлобальныйКонтекст_СправочникиИТаблицы

// Преобразует массив структур в таблицу значений
//
// Параметры:
//  МассивСтруктур - Массив из Структура - исходный массив структур
//
// Возвращаемое значение:
//	ТаблицаЗначений - полученная таблица значений
Функция ГлЯдро_МассивСтруктурВТаблицуЗначений(МассивСтруктур) Экспорт
	
	ТекстОшибки = "";
	
	Если ТипЗнч(МассивСтруктур) <> Тип("Массив") Тогда
	    ТекстОшибки = "Ошибка преобразования массива структур в таблицу значений: Параметр не является массивом!";
		Сообщение = Новый СообщениеПользователю;
		Сообщение.Текст = ТекстОшибки;
		Сообщение.Сообщить(); 
		Возврат Неопределено;
	КонецЕсли; 
	
	Если МассивСтруктур.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ОписаниеТЗ = МассивСтруктур[0];
	Если ТипЗнч(ОписаниеТЗ) <> Тип("Структура") Тогда
		ТекстОшибки = "Ошибка преобразования массива структур в таблицу значений: Не обнаружено описание таблицы значений!";
		Сообщение = Новый СообщениеПользователю;
		Сообщение.Текст = ТекстОшибки;
		Сообщение.Сообщить(); 
		Возврат Неопределено;
	КонецЕсли;
	
	КолонкиТЗ = "";
	Если НЕ ОписаниеТЗ.Свойство("ЭтоТаблицаЗначений") ИЛИ НЕ ОписаниеТЗ.Свойство("КолонкиТаблицыЗначений") Тогда
		МассивКолонок = Новый Массив;
		Для Каждого Колонка Из ОписаниеТЗ Цикл
			МассивКолонок.Добавить(Колонка.Ключ);	
		КонецЦикла;
		ИндексНачала = 0;
	Иначе 
		КолонкиТЗ = ОписаниеТЗ.КолонкиТаблицыЗначений;
		МассивКолонок = ГлЯдро_РазложитьСтрокуВМассивПодстрок(КолонкиТЗ, ",");
		ИндексНачала = 1;
	КонецЕсли;
	
	ТаблицаЗначений = Новый ТаблицаЗначений;
	
	Для каждого НаименованиеКолонки Из МассивКолонок Цикл
		ТаблицаЗначений.Колонки.Добавить(НаименованиеКолонки);
	КонецЦикла; 
	
	Для Сч = ИндексНачала По МассивСтруктур.Количество() - 1 Цикл
		
		Если ТипЗнч(МассивСтруктур[Сч]) = Тип("Структура") Тогда
			НоваяСтрока = ТаблицаЗначений.Добавить();
			Результат = Новый Структура();
			Для каждого Элемент Из МассивСтруктур[Сч] Цикл
			
				Если ТипЗнч(Элемент.Значение) = Тип("Массив")Тогда
				
					Результат.Вставить(Элемент.Ключ, ГлЯдро_МассивСтруктурВТаблицуЗначений(Элемент.Значение));
					
				Иначе
					
					Результат.Вставить(Элемент.Ключ, Элемент.Значение);
					
				КонецЕсли; 
			
			КонецЦикла; 
		    ЗаполнитьЗначенияСвойств(НоваяСтрока, Результат);
		КонецЕсли;
		
	КонецЦикла; 
	
	Возврат ТаблицаЗначений;

КонецФункции

// Преобразует таблицу значений в массив структур.
// Может использоваться для передачи на клиент данных в том случае, если таблица
// значений содержит только такие значения, которые могут
// быть переданы с сервера на клиент.
//
// Полученный массив содержит структуры, каждая из которых повторяет
// структуру колонок таблицы значений.
//
// Не рекомендуется использовать для преобразования таблиц значений
// с большим количеством строк.
//
// Параметры:
//	ТаблицаЗначений - ТаблицаЗначений - исходная таблица значений.
//
// Возвращаемое значение:
//	Массив из Структура - коллекция строк таблицы в виде структур.
Функция ГлЯдро_ТаблицуЗначенийВМассивСтруктур(ТаблицаЗначений) Экспорт
	
	Если ТипЗнч(ТаблицаЗначений) = Тип("Массив") Тогда
		Возврат ТаблицаЗначений;
	КонецЕсли;
	
	Массив = Новый Массив();
	
	Если ТипЗнч(ТаблицаЗначений) <> Тип("ТаблицаЗначений") И ТипЗнч(ТаблицаЗначений) <> Тип("ДеревоЗначений") Тогда
	    Возврат Массив;
	КонецЕсли; 

	СтруктураСтрокой = "";
	НужнаЗапятая = Ложь;
	Для Каждого Колонка Из ТаблицаЗначений.Колонки Цикл
		Если НужнаЗапятая Тогда
			СтруктураСтрокой = СтруктураСтрокой + ",";
		КонецЕсли;
		СтруктураСтрокой = СтруктураСтрокой + Колонка.Имя;
		НужнаЗапятая = Истина;
	КонецЦикла;
	
	СтруктураСтрокой = СтруктураСтрокой;
	
	ОписаниеТаблицыЗначений = Новый Структура("ЭтоТаблицаЗначений, КолонкиТаблицыЗначений", Истина, СтруктураСтрокой); 
	Массив.Добавить(ОписаниеТаблицыЗначений);
	
	Для Каждого Строка Из ТаблицаЗначений Цикл
		НоваяСтрока = Новый Структура(СтруктураСтрокой);
		ЗаполнитьЗначенияСвойств(НоваяСтрока, Строка);
		Для каждого ЭлементСтруктуры Из НоваяСтрока Цикл
		
			Если ТипЗнч(ЭлементСтруктуры.Значение) = Тип("ТаблицаЗначений") Тогда
				НоваяСтрока.Вставить(ЭлементСтруктуры.Ключ, ГлЯдро_ТаблицуЗначенийВМассивСтруктур(ЭлементСтруктуры.Значение));
			КонецЕсли; 
		
		КонецЦикла; 
		Массив.Добавить(НоваяСтрока);
	КонецЦикла;
	
	Возврат Массив;

КонецФункции

// Создает массив копированием исходного по заданному отбору
//
// Параметры:
//	МассивИсточник - Массив из Произвольный - исходный массив
//	Отбор - Неопределено, Структура - отбор, применяемый в случае, когда элементами исходного массива являются структуры
//
// Возвращаемое значение:
//	- Массив из Произвольный - полученный массив
//  - Неопределено - если в параметр МассивИсточник передан не массив
Функция ГлЯдро_СкопироватьМассив(МассивИсточник,Отбор = Неопределено) Экспорт
	Если ТипЗнч(МассивИсточник)<>Тип("Массив") Тогда
		Возврат Неопределено;	
	КонецЕсли;
	
	МассивПриемник = Новый Массив;
	Для Каждого ЭлементМассива Из МассивИсточник Цикл
		Если ТипЗнч(ЭлементМассива) = Тип("Структура") Тогда
			Если Отбор <> Неопределено 
				И НЕ ГлЯдро_СтруктураПодходитПодОтбор(ЭлементМассива,Отбор) Тогда
				Продолжить;
			КонецЕсли;
			МассивПриемник.Добавить(ГлЯдро_СкопироватьСтруктуру(ЭлементМассива));
		ИначеЕсли ТипЗнч(ЭлементМассива) = Тип("Массив") Тогда
			МассивПриемник.Добавить(ГлЯдро_СкопироватьМассив(ЭлементМассива));
		Иначе
			МассивПриемник.Добавить(ЭлементМассива);
		КонецЕсли;
	КонецЦикла;	
	Возврат МассивПриемник;
КонецФункции

// Создает структуру копированием исходной
//
// Параметры:
//	СтруктураИсточник - Структура - исходная структура.
//	СписокКолонок - Неопределено, Строка - список ключей структуры, разделенных запятыми, которые необходимо скопировать.
//										   Если параметр не передан, копируются все ключи.
//
// Возвращаемое значение:
//	Структура - полученная структура.
Функция ГлЯдро_СкопироватьСтруктуру(СтруктураИсточник,СписокКолонок = Неопределено) Экспорт
	СтруктураПриемник = Новый Структура;
	
	Если СписокКолонок <> Неопределено Тогда
		Колонки = ГлЯдро_РазложитьСтрокуВМассивПодстрок(СписокКолонок, ",");
	КонецЕсли;
	
	Для Каждого ЭлементСтруктуры Из СтруктураИсточник Цикл
		
		Если СписокКолонок <> Неопределено 
			И Колонки.Найти(ЭлементСтруктуры.Ключ) = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		Если ТипЗнч(ЭлементСтруктуры.Значение) = Тип("Структура") Тогда
			СтруктураПриемник.Вставить(ЭлементСтруктуры.Ключ, ГлЯдро_СкопироватьСтруктуру(ЭлементСтруктуры.Значение));
		ИначеЕсли ТипЗнч(ЭлементСтруктуры.Значение) = Тип("Массив") Тогда
			СтруктураПриемник.Вставить(ЭлементСтруктуры.Ключ, ГлЯдро_СкопироватьМассив(ЭлементСтруктуры.Значение));
		Иначе
			СтруктураПриемник.Вставить(ЭлементСтруктуры.Ключ, ЭлементСтруктуры.Значение);
		КонецЕсли;
	КонецЦикла;
	Возврат СтруктураПриемник;
КонецФункции

// Проверяет соответствие произвольной структуры переданному отбору
// Соответствие подразумевает, что в структуре есть все ключи, содержащиеся в отборе,
// и значения структуры и отбора по одинаковым ключам совпадают.
//
// Параметры:
//	Структура - Структура - структура, которую требуется проверить на соответствие отбору.
//	Отбор - Структура - отбор, по которому требуется проверить соответствие.
//
// Возвращаемое значение:
//	Булево - признак соответствия структуры переданному отбору.
Функция ГлЯдро_СтруктураПодходитПодОтбор(Структура,Отбор) Экспорт
	Для Каждого ЭлементОтбора Из Отбор Цикл
		Если НЕ Структура.Свойство(ЭлементОтбора.Ключ)
			ИЛИ Структура[ЭлементОтбора.Ключ] <> ЭлементОтбора.Значение Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	Возврат Истина;
КонецФункции

// Вызывает функции преобразования данных выгружаемой таблицы и выгрузки подготовленной таблицы на сервер Mobile Smarts 
//
// Параметры:
//	ИмяТаблицы - Строка - имя выгружаемой таблицы
//	ТаблицаДляВыгрузки - ТаблицаЗначений, Массив из Структура, Структура - данные выгружаемой таблицы
//	ТипБазы - Строка - "Частная", "Временная", "Основная"
//	АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
//
// Возвращаемое значение:
//	Структура - содержит:
//		* Статус - Булево - признак успешности выгрузки таблицы		
//		* Сообщение - Строка - информационное сообщение о результате выгрузки таблицы
Функция ГлЯдро_ВыгрузитьПодготовленнуюТаблицуНаСерверSMARTS(ИмяТаблицы, Знач ТаблицаДляВыгрузки, ТипБазы, АдресаПеременных) Экспорт
	
	НачалоСобытия = ТекущаяУниверсальнаяДатаВМиллисекундах();
	ИмяСобытия = "ГлЯдро_ВыгрузитьПодготовленнуюТаблицуНаСерверSMARTS";
	
	Если ЭтоАдресВременногоХранилища(ТаблицаДляВыгрузки) Тогда
		ТаблицаДляВыгрузки = ПолучитьИзВременногоХранилища(ТаблицаДляВыгрузки);
	КонецЕсли;
	
	ДанныеДляВыгрузки = ГлЯдро_СформироватьМассивыДляВыгрузкиТаблиц(ИмяТаблицы, ТаблицаДляВыгрузки, ТипБазы, АдресаПеременных);
	
	ТипИнтерфейса = ГлЯдро_ПолучитьТипИнтерфейса(ТипБазы, АдресаПеременных); // ТипИнтерфейса = КомЯдро_ПолучитьЗначениеПеременной("ТипИнтерфейса",АдресаПеременных);
	
	ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Начало, Выгрузка подготовленной таблицы на сервер SMARTS. Имя таблицы: " + Строка(ИмяТаблицы) + ", тип интерфейса: " + Строка(ТипИнтерфейса), НачалоСобытия, АдресаПеременных);
	
	Если ИмяТаблицы = "Узлы"
		ИЛИ ИмяТаблицы = "БизнесПроцессы" Тогда
		ОчищатьСправочникПередВыгрузкой = Истина; // Эти таблицы всегда очищаются принудительно
	Иначе
		ОчищатьСправочникПередВыгрузкой = ГлЯдро_ПолучитьИзКэшаЗначениеТабличнойНастройкиSMARTS("НастройкиОбменаСправочников", Новый Структура("ИмяТаблицы", ИмяТаблицы), "ОчищатьПередВыгрузкой", АдресаПеременных);
	    Если ОчищатьСправочникПередВыгрузкой = Неопределено Тогда
			ПереписыватьНоменклатуруПриВыгрузке = ГлЯдро_ПолучитьИзКэшаНастройкуSMARTS("ПереписыватьНоменклатуруПриВыгрузке",, АдресаПеременных);
			ОчищатьСправочникПередВыгрузкой = ?(ПереписыватьНоменклатуруПриВыгрузке = Неопределено, Ложь, ПереписыватьНоменклатуруПриВыгрузке);
		КонецЕсли;
	КонецЕсли;
	
	Если ТипИнтерфейса = "REST_API" Тогда
		РезультатВыгрузки = REST_API_ВыгрузитьТаблицуНаСерверSMARTS(ИмяТаблицы, ДанныеДляВыгрузки, ТипБазы, ОчищатьСправочникПередВыгрузкой, АдресаПеременных);		
	Иначе
		РезультатВыгрузки = КомЯдро_ВыгрузитьТаблицуНаСерверSMARTS(ИмяТаблицы, ДанныеДляВыгрузки, ТипБазы, ОчищатьСправочникПередВыгрузкой, АдресаПеременных);
	КонецЕсли;
	
	Если НЕ РезультатВыгрузки.Статус Тогда
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", РезультатВыгрузки.Сообщение, , АдресаПеременных);
	КонецЕсли;
	
	ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Конец, Выгрузка подготовленной таблицы на сервер SMARTS. Имя таблицы: " + Строка(ИмяТаблицы) + ", тип интерфейса: " + Строка(ТипИнтерфейса), НачалоСобытия, АдресаПеременных);
	
	Возврат РезультатВыгрузки;
	
КонецФункции

// Последовательно вызывает функции получения данных таблицы и выгрузки полученных данных на сервер Mobile Smarts
//
// Параметры:
//	ИмяТаблицы - Строка - имя выгружаемой таблицы
//  НастройкиКомпоновщика - Неопределено, Булево, НастройкиКомпоновкиДанных - содержит настройки, установленные для схемы компоновки данных, описанной в интеграционной
//															          		  обработке и используемой для получения данных таблицы при выгрузке на сервер Mobile Smarts
//  ПараметрыКомпоновщика - Неопределено, Булево, Массив из Структура - содержит параметры схемы компоновки данных, описанной в интеграционной 
//																		обработке и используемой для получения данных таблицы при выгрузке на сервер Mobile Smarts
//  ТипБазы - Строка - "Частная", "Временная", "Основная" 
//  ОчищатьСправочникПередВыгрузкой - Булево - флаг, определяющий нужно ли перезаписывать номенклатуру при выгрузке или добавлять к существующей номенклатуре
//  РаботаБезАлкоголя - Булево - признак отсутствия (Истина) или наличия (Ложь) данных об алкогольной продукции в базе 1С
//	АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
//
// Возвращаемое значение:
//	Структура - содержит:
//		* Статус - Булево - признак успешности выгрузки таблицы
//		* Сообщение - Строка - информационное сообщение о результате выгрузки таблицы
Функция ГлЯдро_ВыгрузитьТаблицуНаСерверSMARTS(ИмяТаблицы, НастройкиКомпоновщика = Ложь, ПараметрыКомпоновщика = Ложь, ТипБазы, ОчищатьСправочникПередВыгрузкой = Ложь, РаботаБезАлкоголя = Ложь, ПараметрыВыгрузки = Неопределено, АдресаПеременных) Экспорт
	
	НачалоСобытия = ТекущаяУниверсальнаяДатаВМиллисекундах();
	ИмяСобытия = "ГлЯдро_ВыгрузитьТаблицуНаСерверSMARTS";
	
	РезультатВыгрузки = Неопределено;
	
	ТипИнтерфейса = ГлЯдро_ПолучитьТипИнтерфейса(ТипБазы, АдресаПеременных); // ТипИнтерфейса = КомЯдро_ПолучитьЗначениеПеременной("ТипИнтерфейса",АдресаПеременных);
	
	ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Начало, Выгрузка таблицы на сервер SMARTS. Имя таблицы: " + Строка(ИмяТаблицы) + ", тип интерфейса: " + Строка(ТипИнтерфейса), , АдресаПеременных);
	
	// *****************************************************************************************************************************
	
	// +++ 15.06.20
	ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Начало.ИмяТаблицы:"+ИмяТаблицы+" НастройкиКомпоновщика:"+?(НастройкиКомпоновщика=Ложь,"Ложь","Заполнено")+" ПараметрыКомпоновщика:"+?(ПараметрыКомпоновщика=Ложь,"Ложь","Заполнено"), ,АдресаПеременных);
	
	Отбор = Новый Структура("ИмяТаблицы", ИмяТаблицы);
	Если НастройкиКомпоновщика = Ложь Тогда
		НастройкаКомпоновщикаСтрокой = ГлЯдро_ПолучитьИзКэшаЗначениеТабличнойНастройкиSMARTS("НастройкиОбменаСправочников", Отбор, "НастройкаКомпоновщикаСтрокой",АдресаПеременных);
		Если ЗначениеЗаполнено(НастройкаКомпоновщикаСтрокой) Тогда
			НастройкиКомпоновщика = ГлЯдро_ЗначениеИзСтрокиXML(НастройкаКомпоновщикаСтрокой);
			ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Настройки компоновщика найдены. ИмяТаблицы:"+ИмяТаблицы, ,АдресаПеременных);
		Иначе
			НастройкиКомпоновщика = "";
			ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Настройки компоновщика не найдены. ИмяТаблицы:"+ИмяТаблицы, ,АдресаПеременных);
		КонецЕслИ;
	КонецЕсли;
	
	Если ПараметрыВыгрузки <> Неопределено И ПараметрыВыгрузки.Свойство("ОчищатьПередВыгрузкой") Тогда
		ОчищатьСправочникПередВыгрузкой = ПараметрыВыгрузки.ОчищатьПередВыгрузкой;		
	Иначе
		ОчищатьСправочникПередВыгрузкой = ГлЯдро_ПолучитьИзКэшаЗначениеТабличнойНастройкиSMARTS("НастройкиОбменаСправочников", Отбор, "ОчищатьПередВыгрузкой", АдресаПеременных);
	КонецЕсли;
	
	Если ПараметрыКомпоновщика = Ложь Тогда
		ПараметрыКомпоновщика = ГлЯдро_ПолучитьЗначенияГлобальныхПараметров(,,,АдресаПеременных);
	КонецЕсли;
			
	ПереписыватьНоменклатуруПриВыгрузке 	= ГлЯдро_ПолучитьИзКэшаНастройкуSMARTS("ПереписыватьНоменклатуруПриВыгрузке",,АдресаПеременных);		
	РаботаБезАлкоголя 						= ГлЯдро_ПолучитьИзКэшаНастройкуSMARTS("РаботаБезАлкоголя",,АдресаПеременных);
	
	Если ИмяТаблицы = "Узлы"
		ИЛИ ИмяТаблицы = "БизнесПроцессы" Тогда // Эти таблицы всегда очищаются принудительно
		ОчищатьСправочникПередВыгрузкой = Истина;
	ИначеЕсли ОчищатьСправочникПередВыгрузкой = Неопределено Тогда
		ОчищатьСправочникПередВыгрузкой = ?(ПереписыватьНоменклатуруПриВыгрузке = Неопределено, Ложь, ПереписыватьНоменклатуруПриВыгрузке);	
	КонецЕсли;
	
	ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "После получения настроек.ИмяТаблицы:"+ИмяТаблицы+" НастройкиКомпоновщика:"+?(НастройкиКомпоновщика=Ложь Или НастройкиКомпоновщика="","Ложь","Заполнено")+" ПараметрыКомпоновщика:"+?(ПараметрыКомпоновщика=Ложь,"Ложь","Заполнено"), ,АдресаПеременных);
	// --- 15.06.20
	
	НачалоПолученияДанныхИз1С 		= ТекущаяДата();
	ДанныеДляВыгрузки 				= ГлЯдро_ПолучитьМассивыТаблицыДляВыгрузкиНаСерверSMARTS(ИмяТаблицы, НастройкиКомпоновщика, ПараметрыКомпоновщика, РаботаБезАлкоголя, ПараметрыВыгрузки, ТипБазы, АдресаПеременных);
	
	Если ДанныеДляВыгрузки = Неопределено Тогда
		Возврат Новый Структура("Статус,Сообщение",Ложь,"Не удалось получить данные для выгрузки таблицы ["+ИмяТаблицы+"]. Подробности смотрите в журнале регистрации");
	КонецЕсли;
	
	ОкончаниеПолученияДанныхИз1С 	= ТекущаяДата();
	ВремяПолученияДанныхИз1С 		= ОкончаниеПолученияДанныхИз1С - НачалоПолученияДанныхИз1С;
		
	// *****************************************************************************************************************************	
	
	НачалоВыгрузкиДанныхНаСерверSMARTS 		= ТекущаяДата();	
	
	Если ТипИнтерфейса = "REST_API" Тогда
		РезультатВыгрузки						= REST_API_ВыгрузитьТаблицуНаСерверSMARTS(ИмяТаблицы, ДанныеДляВыгрузки, ТипБазы, ОчищатьСправочникПередВыгрузкой, АдресаПеременных);		
	Иначе
		РезультатВыгрузки						= КомЯдро_ВыгрузитьТаблицуНаСерверSMARTS(ИмяТаблицы, ДанныеДляВыгрузки, ТипБазы, ОчищатьСправочникПередВыгрузкой, АдресаПеременных);		
	КонецЕсли;
	ОкончаниеВыгрузкиДанныхНаСерверSMARTS 	= ТекущаяДата();
	ВремяВыгрузкиДанныхНаСерверSMARTS		= ОкончаниеВыгрузкиДанныхНаСерверSMARTS - НачалоВыгрузкиДанныхНаСерверSMARTS;
	
	ОбщееВремяВыгрузки						= ВремяПолученияДанныхИз1С + ВремяВыгрузкиДанныхНаСерверSMARTS; 
		
	// *****************************************************************************************************************************	
	
	// Если выгрузка прошла успешно, добавляем в сообщение дополнительную информацию о выгрузке
	Если РезультатВыгрузки.Статус Тогда		
		
		ПредставлениеВремени1С 		= ГлЯдро_ПредставлениеВремени(ВремяПолученияДанныхИз1С);
		ПредставлениеВремениMS 		= ГлЯдро_ПредставлениеВремени(ВремяВыгрузкиДанныхНаСерверSMARTS);
		ПредставлениеВремениОбщее 	= ГлЯдро_ПредставлениеВремени(ОбщееВремяВыгрузки);
		
		РезультатВыгрузки.Сообщение = ГлЯдро_СформироватьПодробноеСообщениеОВыгрузкеТаблицы(РезультатВыгрузки.Сообщение, ПредставлениеВремениОбщее, ПредставлениеВремени1С, ПредставлениеВремениMS);		
		
	Иначе
		
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", РезультатВыгрузки.Сообщение, , АдресаПеременных);
		
	КонецЕсли;
	
	ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Конец, Выгрузка таблицы на сервер SMARTS. Имя таблицы: " + Строка(ИмяТаблицы) + ", тип интерфейса: " + Строка(ТипИнтерфейса), НачалоСобытия, АдресаПеременных);
	
	Возврат РезультатВыгрузки;
	
КонецФункции

// Выгружает на сервер Mobile SMARTS данные таблицы порциями. Работает только для справочника "Номенклатура"
// Некорректен с точки зрения инкапсуляции - в одном методе смешался функционал получения данных из базы 1С и функционал выгрузки данных в Mobile SMARTS
// Это вынужденная реализация, потому что методы "TerminalConnector.НачатьВыгрузкуТоваров()" и "TerminalConnector.ЗавершитьВыгрузкуТоваров()"
// можно вызывать только по 1 разу во время всего процесса выгрузки справочника номенклатуры
//
// Параметры:
//	ИмяТаблицы - Строка - имя выгружаемой таблицы
//	НастройкиКомпоновщика - Неопределено, Булево, НастройкиКомпоновкиДанных - содержит настройки, установленные для схемы компоновки данных, описанной в интеграционной
//															          		  обработке и используемой для получения данных таблицы при выгрузке на сервер Mobile Smarts
//  ПараметрыКомпоновщика - Неопределено, Булево, Массив из Структура - содержит параметры схемы компоновки данных, описанной в интеграционной 
//																		обработке и используемой для получения данных таблицы при выгрузке на сервер Mobile Smarts
//	ТипБазы - Строка - "Частная", "Временная", "Основная"
//	ОчищатьСправочникПередВыгрузкой - Булево - флаг, определяющий нужно ли перезаписывать номенклатуру при выгрузке или добавлять к существующей номенклатуре
//  РазмерПорцииНоменклатуры - Число - определяет количество выгружаемых в одной партии строк
//  РаботаБезАлкоголя - Булево - признак отсутствия (Истина) или наличия (Ложь) данных об алкогольной продукции в базе 1С
//  АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
//
// Возвращаемое значение:
//	Структура - содержит:
//		* Статус - Булево - признак успешности выгрузки таблицы
//		* Сообщение - Строка - информационное сообщение о результате выгрузки таблицы
Функция ГлЯдро_ВыгрузитьТаблицуНаСерверSMARTSПорциями(ИмяТаблицы, НастройкиКомпоновщика = Ложь, ПараметрыКомпоновщика = Ложь, ТипБазы = Неопределено, ОчищатьСправочникПередВыгрузкой = Ложь, РазмерПорцииНоменклатуры = 1000, РаботаБезАлкоголя = Ложь, ПараметрыВыгрузки = "", АдресаПеременных) Экспорт
	
	НачалоСобытия = ТекущаяУниверсальнаяДатаВМиллисекундах();
	ИмяСобытия = "ГлЯдро_ВыгрузитьТаблицуНаСерверSMARTSПорциями";
	
	ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Начало, Выгрузка таблицы на сервер SMARTS порциями. Имя таблицы: " + Строка(ИмяТаблицы), , АдресаПеременных);
	
	ЕстьЧастнаяБаза = КомЯдро_ПолучитьЗначениеПеременной("ЕстьЧастнаяБаза",АдресаПеременных);
	
	Если ТипБазы = Неопределено Тогда
		ТипБазы = ?(ЕстьЧастнаяБаза = Истина,"Частная","Основная");
	КонецЕсли;
	
	Если ТипБазы = "Частная" Тогда
		СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("COMЧастнойБазыMS",АдресаПеременных);
	ИначеЕсли ТипБазы = "Временная" Тогда
		СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("COMВременнойБазыMS",АдресаПеременных);
	Иначе
		СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("COMБазыMS",АдресаПеременных);
	КонецЕсли;		
	
	РезультатВыгрузки = Новый Структура;
	Сообщение = "Начало выгрузки таблицы [" + ИмяТаблицы + "] порциями";
	РезультатВыгрузки.Вставить("Сообщение"	, Сообщение);
	РезультатВыгрузки.Вставить("Статус"		, Истина);	
	Сообщить(Сообщение);
	
	ТипИнтерфейса = ГлЯдро_ПолучитьТипИнтерфейса(ТипБазы, АдресаПеременных); // ТипИнтерфейса = КомЯдро_ПолучитьЗначениеПеременной("ТипИнтерфейса", АдресаПеременных);
	ЭтоREST_API = ТипИнтерфейса = "REST_API";
	
	Если Не ЭтоREST_API Тогда
		Если НЕ КомЯдро_ПодключитьсяКСерверуSMARTS(Ложь,ТипБазы, АдресаПеременных) Тогда		
			
			Сообщение = "База Mobile SMARTS недоступна!";
			РезультатВыгрузки.Вставить("Статус"		, Ложь);				
			РезультатВыгрузки.Вставить("Сообщение"	, Сообщение);
			Сообщить(Сообщение);
			
			ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", Сообщение, , АдресаПеременных);
			ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Конец, Выгрузка таблицы на сервер SMARTS порциями. Имя таблицы: " + Строка(ИмяТаблицы), НачалоСобытия, АдресаПеременных);
			
			Возврат РезультатВыгрузки;		
			
		КонецЕсли;
	КонецЕсли;
	
	// +++ 15.06.20
	ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Начало.ИмяТаблицы:"+ИмяТаблицы+" НастройкиКомпоновщика:"+?(НастройкиКомпоновщика=Ложь,"Ложь","Заполнено")+" ПараметрыКомпоновщика:"+?(ПараметрыКомпоновщика=Ложь,"Ложь","Заполнено"), ,АдресаПеременных);
	
	Отбор = Новый Структура("ИмяТаблицы", ИмяТаблицы);
	Если НастройкиКомпоновщика = Ложь Тогда
		НастройкаКомпоновщикаСтрокой = ГлЯдро_ПолучитьИзКэшаЗначениеТабличнойНастройкиSMARTS("НастройкиОбменаСправочников", Отбор, "НастройкаКомпоновщикаСтрокой",АдресаПеременных);
		Если ЗначениеЗаполнено(НастройкаКомпоновщикаСтрокой) Тогда
			НастройкиКомпоновщика = ГлЯдро_ЗначениеИзСтрокиXML(НастройкаКомпоновщикаСтрокой);
			ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Настройки компоновщика найдены. ИмяТаблицы:"+ИмяТаблицы, ,АдресаПеременных);
		Иначе
			НастройкиКомпоновщика = "";
			ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Настройки компоновщика не найдены. ИмяТаблицы:"+ИмяТаблицы, ,АдресаПеременных);
		КонецЕслИ;
	КонецЕсли;
	
	Если ПараметрыВыгрузки <> Неопределено И ПараметрыВыгрузки.Свойство("ОчищатьПередВыгрузкой") Тогда
		ОчищатьСправочникПередВыгрузкой = ПараметрыВыгрузки.ОчищатьПередВыгрузкой;		
	Иначе
		ОчищатьСправочникПередВыгрузкой = ГлЯдро_ПолучитьИзКэшаЗначениеТабличнойНастройкиSMARTS("НастройкиОбменаСправочников", Отбор, "ОчищатьПередВыгрузкой", АдресаПеременных);
	КонецЕсли;
	
	Если ПараметрыКомпоновщика = Ложь Тогда
		ПараметрыКомпоновщика = ГлЯдро_ПолучитьЗначенияГлобальныхПараметров(,,,АдресаПеременных);
	КонецЕсли;
			
	ПереписыватьНоменклатуруПриВыгрузке 	= ГлЯдро_ПолучитьИзКэшаНастройкуSMARTS("ПереписыватьНоменклатуруПриВыгрузке",,АдресаПеременных);		
	РаботаБезАлкоголя 						= ГлЯдро_ПолучитьИзКэшаНастройкуSMARTS("РаботаБезАлкоголя",,АдресаПеременных);
	
	Если ИмяТаблицы = "Узлы"
		ИЛИ ИмяТаблицы = "БизнесПроцессы" Тогда // Эти таблицы всегда очищаются принудительно
		ОчищатьСправочникПередВыгрузкой = Истина;	
	ИначеЕсли ОчищатьСправочникПередВыгрузкой = Неопределено Тогда
		ОчищатьСправочникПередВыгрузкой = ?(ПереписыватьНоменклатуруПриВыгрузке = Неопределено, Ложь, ПереписыватьНоменклатуруПриВыгрузке);	
	КонецЕсли;
	
	ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "После получения настроек.ИмяТаблицы:"+ИмяТаблицы+" НастройкиКомпоновщика:"+?(НастройкиКомпоновщика=Ложь Или НастройкиКомпоновщика="","Ложь","Заполнено")+" ПараметрыКомпоновщика:"+?(ПараметрыКомпоновщика=Ложь,"Ложь","Заполнено"), ,АдресаПеременных);
	// --- 15.06.20

	МассивСсылокНоменклатуры 			= ГлЯдро_ПолучитьМассивСсылокНоменклатуры(АдресаПеременных);		
	
	КоличествоСтрок 					= МассивСсылокНоменклатуры.Количество();
	КоличествоПорций 					= (КоличествоСтрок - КоличествоСтрок % РазмерПорцииНоменклатуры) / РазмерПорцииНоменклатуры + ?(КоличествоСтрок % РазмерПорцииНоменклатуры <> 0, 1, 0);			
	// Временное решение. При обновлении локального кэша не обновляется глобальный кэш, поэтому переменную получаем из входных параметров
	//ПереписыватьНоменклатуруПриВыгрузке = ГлЯдро_ПолучитьИзКэшаНастройкуSMARTS("ПереписыватьНоменклатуруПриВыгрузке");			
	
	ВсегоСтрок 							= 0;
	ОтборПоНоменклатуре 				= Новый Массив;
	НачатаВыгрузкаТаблицы 				= Ложь;
	ВремяПолученияДанныхИз1С			= 0;
	ВремяВыгрузкиДанныхНаСерверSMARTS 	= 0;
	СоответствиеРазличныхТоваров		= Новый Соответствие;
	ИндексИдТовара						= -1;
	СообщениеПорции 					= "";
		
	Для НомерПорции = 1 По КоличествоПорций Цикл				
		
		НачалоВыгрузкиПорции 		= ТекущаяДата();		
		НачалоПолученияДанныхИз1С 	= ТекущаяДата();
		
		ОтборПоНоменклатуре.Очистить();
		
		Для Сч = 1 По РазмерПорцииНоменклатуры Цикл
			
			ИндексСтроки = (НомерПорции - 1) * РазмерПорцииНоменклатуры + Сч - 1;
			
			Если ИндексСтроки > КоличествоСтрок - 1 Тогда
				Прервать;
			КонецЕсли;	
			
			ОтборПоНоменклатуре.Добавить(МассивСсылокНоменклатуры[ИндексСтроки]);
			
		КонецЦикла;					
		
		ДанныеДляВыгрузки = ГлЯдро_ПолучитьТаблицуДляВыгрузкиСправочников(ИмяТаблицы, НастройкиКомпоновщика, ПараметрыКомпоновщика, , , ОтборПоНоменклатуре, РаботаБезАлкоголя, ПараметрыВыгрузки, АдресаПеременных);
		КоличествоСтрокВПорции = ДанныеДляВыгрузки.Количество();		
		
		// Если данных в порции нет, то и выгружать нечего
		Если КоличествоСтрокВПорции = 0 Тогда
			Продолжить;
		КонецЕсли;			
		
		ГлЯдро_ОбработатьРезультатыВыгрузкиТаблицы(ДанныеДляВыгрузки, ИмяТаблицы, ПараметрыВыгрузки, АдресаПеременных);	
		
		ДанныеДляВыгрузки = ГлЯдро_СформироватьМассивыДляВыгрузкиТаблиц(ИмяТаблицы, ДанныеДляВыгрузки, ТипБазы, АдресаПеременных);
		
		// Для того чтобы искать индекс только один раз, а не на каждой итерации
		Если ИмяТаблицы = "Номенклатура" И ИндексИдТовара = -1 Тогда
			ИндексИдТовара = ГлЯдро_НайтиИндексИдТовараВМассивеИмен(ДанныеДляВыгрузки.МассивИмен);
		КонецЕсли;
		
		ОкончаниеПолученияДанныхИз1С 	= ТекущаяДата();
		ВремяПолученияДанныхИз1С 		= ВремяПолученияДанныхИз1С + (ОкончаниеПолученияДанныхИз1С - НачалоПолученияДанныхИз1С);			
		
		НачалоВыгрузкиДанныхНаСерверSMARTS = ТекущаяДата();		
		
		// Если выгружается первая порция (до этого не было порций с данными), содержащая ненулевое количество строк, то используем флаг из настроек, иначе - дописываем номенклатуру
		ОчищатьСправочникПередВыгрузкой = ?(ВсегоСтрок = 0 И КоличествоСтрокВПорции > 0, ОчищатьСправочникПередВыгрузкой, Ложь);
		
		Если ЭтоREST_API Тогда
			РезультатВыгрузкиПорции = REST_API_ВыгрузитьТаблицуНаСерверSMARTS(ИмяТаблицы, ДанныеДляВыгрузки, ?(ТипБазы = "Частная", "Частная", "Основная"), ОчищатьСправочникПередВыгрузкой, АдресаПеременных);
			
			Если Не РезультатВыгрузкиПорции.Статус Тогда
				Сообщить(РезультатВыгрузкиПорции.Сообщение);
				РезультатВыгрузки.Вставить("Сообщение", РезультатВыгрузкиПорции.Сообщение);
				РезультатВыгрузки.Вставить("Статус", Ложь);					
				Прервать;
			КонецЕсли;
			
		Иначе
			
			// При получении из 1С первой непустой порции данных вызываем соответствующий метод для начала выгрузки таблицы
			Если НЕ НачатаВыгрузкаТаблицы Тогда
				
				Если ИмяТаблицы = "Номенклатура" Тогда
					СтруктураПодключенияMS.TerminalConnector.ПерезаписыватьНоменклатуру(ОчищатьСправочникПередВыгрузкой);
					РезультатПопытки = СтруктураПодключенияMS.TerminalConnector.НачатьВыгрузкуТоваров(ДанныеДляВыгрузки.МассивИмен);
				Иначе
					РезультатПопытки = СтруктураПодключенияMS.TerminalConnector.НачатьВыгрузкуТаблицы(ИмяТаблицы, ДанныеДляВыгрузки.МассивИмен, Истина);
				КонецЕсли;
				
				Если НЕ РезультатПопытки Тогда
					
					ОписаниеОшибки = КомЯдро_ПолучитьОшибку(ТипБазы,АдресаПеременных);		
					Сообщение = "Таблица [" + ИмяТаблицы + "] не выгружается!" + Символы.ВК + ОписаниеОшибки;
					РезультатВыгрузки.Вставить("Статус"		, Ложь);				
					РезультатВыгрузки.Вставить("Сообщение"	, Сообщение);
					Сообщить(Сообщение);				
					
					ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", Сообщение, , АдресаПеременных);
					ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Конец, Выгрузка таблицы на сервер SMARTS порциями. Имя таблицы: " + Строка(ИмяТаблицы), НачалоСобытия, АдресаПеременных);
					
					Возврат РезультатВыгрузки;
					
				Иначе
					НачатаВыгрузкаТаблицы = РезультатПопытки; 
				КонецЕсли;		
				
			КонецЕсли;
			
			Если РезультатВыгрузки.Статус Тогда
				
				Для Каждого МассивСтрокиВыгрузки из ДанныеДляВыгрузки.МассивыСтрок Цикл
					
					Если ИмяТаблицы = "Номенклатура" Тогда
						РезультатПопытки = СтруктураПодключенияMS.TerminalConnector.ДобавитьВВыгрузкуТоваров(МассивСтрокиВыгрузки);
						// Подсчет количества различных товаров в выгрузке
						Если ИндексИдТовара <> -1 Тогда
							СоответствиеРазличныхТоваров.Вставить(МассивСтрокиВыгрузки[ИндексИдТовара]);
						КонецЕсли;						
					Иначе
						РезультатПопытки = СтруктураПодключенияMS.TerminalConnector.ДобавитьВВыгрузкуТаблицы(МассивСтрокиВыгрузки);
					КонецЕсли;
					
					Если НЕ РезультатПопытки Тогда
						
						ОписаниеОшибки = КомЯдро_ПолучитьОшибку(ТипБазы,АдресаПеременных);		
						Сообщение = "Ошибка выгрузки таблицы [" + ИмяТаблицы + "]." + Символы.ВК + ОписаниеОшибки;
						РезультатВыгрузки.Вставить("Статус"		, Ложь);				
						РезультатВыгрузки.Вставить("Сообщение"	, Сообщение);
						Сообщить(Сообщение);					
						СтруктураПодключенияMS.TerminalConnector.ПрерватьВыгрузкуТаблицы();			
						Прервать;
						
					КонецЕсли;
					
				КонецЦикла;
				
			КонецЕсли;		
			
		КонецЕсли;
		
		ВсегоСтрок = ВсегоСтрок + КоличествоСтрокВПорции;								

		ОкончаниеВыгрузкиДанныхНаСерверSMARTS 	= ТекущаяДата();
		ВремяВыгрузкиДанныхНаСерверSMARTS		= ВремяВыгрузкиДанныхНаСерверSMARTS + (ОкончаниеВыгрузкиДанныхНаСерверSMARTS - НачалоВыгрузкиДанныхНаСерверSMARTS);			
		
		ОкончаниеВыгрузкиПорции = ТекущаяДата();
		ВремяВыгрузкиПорции		= ОкончаниеВыгрузкиПорции - НачалоВыгрузкиПорции;			
		
		ПредставлениеВремениВыгрузки = ГлЯдро_ПредставлениеВремени(ВремяВыгрузкиПорции);		
		
		СообщениеПорции = СообщениеПорции + 
			"Выгрузка таблицы [" + ИмяТаблицы + "] порциями. Выгружена порция №" + СокрЛП(НомерПорции) + " из " + СокрЛП(КоличествоПорций) + ", содержащая " + СокрЛП(КоличествоСтрокВПорции) + " строк. Всего выгружено " + СокрЛП(ВсегоСтрок) + " строк. Затраченное время: " + ПредставлениеВремениВыгрузки +
			Символы.ПС;
		
	КонецЦикла;			
	
	Если ЗначениеЗаполнено(СообщениеПорции) Тогда
		Сообщить(СообщениеПорции);
	КонецЕсли;
	
	Если РезультатВыгрузки.Статус Тогда
		
		НачалоЗавершенияВыгрузкиНаСерверSMARTS = ТекущаяДата();		
		
		Если Не ЭтоREST_API Тогда
			Если ИмяТаблицы = "Номенклатура" Тогда
				РезультатПопытки = СтруктураПодключенияMS.TerminalConnector.ЗавершитьВыгрузкуТоваров();	
			Иначе
				РезультатПопытки = СтруктураПодключенияMS.TerminalConnector.ЗавершитьВыгрузкуТаблицы();	
			КонецЕсли;			
			
			Если НЕ РезультатПопытки Тогда
				ОписаниеОшибки = КомЯдро_ПолучитьОшибку(ТипБазы,АдресаПеременных);		
				Сообщение = "Не удалось закончить выгрузку таблицы [" + ИмяТаблицы + "]." + Символы.ВК + ОписаниеОшибки;
				РезультатВыгрузки.Вставить("Статус"		, Ложь);				
				РезультатВыгрузки.Вставить("Сообщение"	, Сообщение);
				Сообщить(Сообщение);
			КонецЕсли;
		Иначе
			РезультатПопытки = Истина;
		КонецЕсли;
		
		Если РезультатПопытки Тогда
			
			ОкончаниеЗавершенияВыгрузкиНаСерверSMARTS 	= ТекущаяДата();
			ВремяЗавершенияВыгрузкиНаСерверSMARTS		= ОкончаниеЗавершенияВыгрузкиНаСерверSMARTS - НачалоЗавершенияВыгрузкиНаСерверSMARTS;
			
			ВремяВыгрузкиДанныхНаСерверSMARTS 			= ВремяВыгрузкиДанныхНаСерверSMARTS + ВремяЗавершенияВыгрузкиНаСерверSMARTS;		

			ПредставлениеВремениЗавершенияВыгрузкиНаСерверSMARTS = ГлЯдро_ПредставлениеВремени(ВремяЗавершенияВыгрузкиНаСерверSMARTS);
			
			Сообщение = "Завершение выгрузки таблицы [" + ИмяТаблицы + "] порциями. Затраченное время: " + ПредставлениеВремениЗавершенияВыгрузкиНаСерверSMARTS;
			Сообщить(Сообщение);
			
			ПодробноеСообщение = Символы.ВК + "Таблица [" + ИмяТаблицы + "] успешно выгружена порциями по " + СокрЛП(РазмерПорцииНоменклатуры) + " позиций. Выгружено:"
							   + Символы.ВК + Символы.Таб + "- " + Формат(ВсегоСтрок, "ЧН=0; ЧГ=3,0") + " строк";
						
			Если ИмяТаблицы = "Номенклатура" Тогда																					
				ПодробноеСообщение = ПодробноеСообщение 
									+ Символы.ВК + Символы.Таб + "- " + Формат(СоответствиеРазличныхТоваров.Количество(), "ЧН=0; ЧГ=3,0") + " товаров";
			КонецЕсли;																				
			
			ОбщееВремяВыгрузки 			= ВремяПолученияДанныхИз1С + ВремяВыгрузкиДанныхНаСерверSMARTS; 				
			
			ПредставлениеВремени1С 		= ГлЯдро_ПредставлениеВремени(ВремяПолученияДанныхИз1С);
			ПредставлениеВремениMS 		= ГлЯдро_ПредставлениеВремени(ВремяВыгрузкиДанныхНаСерверSMARTS);
			ПредставлениеВремениОбщее 	= ГлЯдро_ПредставлениеВремени(ОбщееВремяВыгрузки);			
			
			ПодробноеСообщение = ГлЯдро_СформироватьПодробноеСообщениеОВыгрузкеТаблицы(ПодробноеСообщение, ПредставлениеВремениОбщее, ПредставлениеВремени1С, ПредставлениеВремениMS);				
			Сообщить(ПодробноеСообщение);
			
			ИтоговоеСообщение = СообщениеПорции + Сообщение + Символы.ПС + ПодробноеСообщение;
			
			РезультатВыгрузки.Вставить("Статус"		, Истина);				
			РезультатВыгрузки.Вставить("Сообщение"	, ИтоговоеСообщение);			
			
		КонецЕсли;
		
	Иначе
		
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", РезультатВыгрузки.Сообщение, , АдресаПеременных);
		
	КонецЕсли;	
	
	Если Не ЭтоREST_API Тогда
		СтруктураПодключенияMS.TerminalConnector.ОсвободитьРесурсы();
	КонецЕсли;
	
	ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Конец, Выгрузка таблицы на сервер SMARTS порциями. Имя таблицы: " + Строка(ИмяТаблицы), НачалоСобытия, АдресаПеременных);
	
	Возврат РезультатВыгрузки;
	
КонецФункции // ГлЯдро_ВыгрузитьТаблицуНаСерверSMARTSПорциями()

// Вызывает функцию выгрузки на сервер Mobile Smarts подготовленной - т.е. преобразованной в массив значений либо соответствие в зависимости от типа интерфейса - таблицы
//
// Параметры:
//	ИмяТаблицы - Строка - имя выгружаемой таблицы	
//	ДанныеДляВыгрузки - Структура - для COM - содержит:
//							* МассивИмен - Массив из Строка - содержит имена колонок выгружаемой таблицы
//							* МассивыСтрок - Массив из Массив - содержит строки выгружаемой таблицы в виде массивов значений
//      					* КоличествоТоваров - Число - содержит количество выгружаемых товаров для таблицы "Номенклатура"
//					  - Массив из Соответствие - для REST_API - содержит строки выгружаемой таблицы в виде соответствий, ключами которых 
//											  					являются названия колонок таблицы, переведенные в транслит, значениями - 
//											  					значения соответствующих колонок.                                               
//	ТипБазы - Строка - "Частная", "Временная", "Основная"
//	ОчищатьСправочникПередВыгрузкой - Булево - флаг, определяющий нужно ли перезаписывать номенклатуру при выгрузке или добавлять к существующей номенклатуре
//  АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
//
// Возвращаемое значение:
//	Структура - содержит:
//		* Статус - Булево - признак успешности выгрузки таблицы
//		* Сообщение - Строка - информационное сообщение о результате выгрузки таблицы
Функция ГлЯдро_ВыгрузитьПодготовленныйМассивНаСерверSMARTS(ИмяТаблицы, ДанныеДляВыгрузки, ТипБазы, ОчищатьСправочникПередВыгрузкой, АдресаПеременных) Экспорт
	
	НачалоСобытия = ТекущаяУниверсальнаяДатаВМиллисекундах();
	ИмяСобытия = "ГлЯдро_ВыгрузитьПодготовленныйМассивНаСерверSMARTS";
	
	ТипИнтерфейса = ГлЯдро_ПолучитьТипИнтерфейса(ТипБазы, АдресаПеременных); // ТипИнтерфейса = КомЯдро_ПолучитьЗначениеПеременной("ТипИнтерфейса",АдресаПеременных);
	
	ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Начало, Выгрузка подготовленного массива на сервер SMARTS. Имя таблицы: " + Строка(ИмяТаблицы) + ", тип интерфейса: " + Строка(ТипИнтерфейса), , АдресаПеременных);
	
	Если ТипИнтерфейса = "REST_API" Тогда
		РезультатВыгрузки = REST_API_ВыгрузитьТаблицуНаСерверSMARTS(ИмяТаблицы, ДанныеДляВыгрузки, ТипБазы, ОчищатьСправочникПередВыгрузкой, АдресаПеременных);		
	Иначе
		РезультатВыгрузки = КомЯдро_ВыгрузитьТаблицуНаСерверSMARTS(ИмяТаблицы, ДанныеДляВыгрузки, ТипБазы, ОчищатьСправочникПередВыгрузкой, АдресаПеременных);
	КонецЕсли;
	
	Если НЕ РезультатВыгрузки.Статус Тогда
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", РезультатВыгрузки.Сообщение, , АдресаПеременных);
	КонецЕсли;
	
	ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Конец, Выгрузка подготовленного массива на сервер SMARTS. Имя таблицы: " + Строка(ИмяТаблицы) + ", тип интерфейса: " + Строка(ТипИнтерфейса), НачалоСобытия, АдресаПеременных);
	
	Возврат РезультатВыгрузки;
	
КонецФункции

// Получает порцию строк таблицы "Номенклатура", преобразованных в массив значений либо соответствие в зависимости от типа интерфейса, для выгрузки на сервер Mobile Smarts
//
// Параметры:
//	ИмяТаблицы - Строка - имя выгружаемой таблицы
//	НастройкиКомпоновщика - Неопределено, Булево, НастройкиКомпоновкиДанных - содержит настройки, установленные для схемы компоновки данных, описанной в интеграционной
//															          		  обработке и используемой для получения данных таблицы при выгрузке на сервер Mobile Smarts
//  ПараметрыКомпоновщика - Неопределено, Булево, Массив из Структура - содержит параметры схемы компоновки данных, описанной в интеграционной 
//																		обработке и используемой для получения данных таблицы при выгрузке на сервер Mobile Smarts
//	ID_БазыSMARTS - Строка - идентификатор базы Mobile Smarts, в которую производится выгрузка
//  ОтборПоНоменклатуре - Массив из СправочникСсылка.Номенклатура - массив ссылок для отбора при выгрузке таблицы "Номенклатура"
//  РаботаБезАлкоголя - Булево - признак отсутствия (Истина) или наличия (Ложь) данных об алкогольной продукции в базе 1С
//  АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
//
// Возвращаемое значение:
//	- Структура - для COM - содержит:
//		* МассивИмен - Массив из Строка - содержит имена колонок выгружаемой таблицы
//		* МассивыСтрок - Массив из Массив - содержит строки выгружаемой таблицы в виде массивов значений
//      * КоличествоТоваров - Число - содержит количество выгружаемых товаров для таблицы "Номенклатура"
//	- Массив из Соответствие - для REST_API - содержит строки выгружаемой таблицы в виде соответствий, ключами которых 
//											  являются названия колонок таблицы, переведенные в транслит, значениями - 
//											  значения соответствующих колонок.
Функция ГлЯдро_ПолучитьПорциюДанныхДляВыгрузки(ИмяТаблицы, НастройкиКомпоновщика = Ложь, ПараметрыКомпоновщика = Ложь, ТипБазы = "", ОтборПоНоменклатуре = Неопределено, РаботаБезАлкоголя = Ложь, ПараметрыВыгрузки = Неопределено, ID_БазыSMARTS = "", АдресаПеременных) Экспорт
	
	ДанныеДляВыгрузки = ГлЯдро_ПолучитьТаблицуДляВыгрузкиСПравочников(ИмяТаблицы, НастройкиКомпоновщика, ПараметрыКомпоновщика, , , ОтборПоНоменклатуре, РаботаБезАлкоголя, ПараметрыВыгрузки, АдресаПеременных);
	
	ГлЯдро_ОбработатьРезультатыВыгрузкиТаблицы(ДанныеДляВыгрузки, ИмяТаблицы, ПараметрыВыгрузки, АдресаПеременных);	
	
	МассивыДляВыгрузки 	= ГлЯдро_СформироватьМассивыДляВыгрузкиТаблиц(ИмяТаблицы, ДанныеДляВыгрузки, ТипБазы, АдресаПеременных);
	
	Возврат МассивыДляВыгрузки;		
	
КонецФункции

// Вызывает функцию получения запроса для выгрузки таблицы на сервер Mobile Smarts, выполняет его и обрабатывает полученную таблицу значений
//
// Параметры:
//	ИмяТаблицы - Строка - имя выгружаемой таблицы	
//  НастройкиКомпоновщика - Неопределено, Булево, НастройкиКомпоновкиДанных - содержит настройки, установленные для схемы компоновки данных, описанной в интеграционной
//															          		  обработке и используемой для получения данных таблицы при выгрузке на сервер Mobile Smarts
//  ПараметрыКомпоновщика - Неопределено, Булево, Массив из Структура - содержит параметры схемы компоновки данных, описанной в интеграционной 
//																		обработке и используемой для получения данных таблицы при выгрузке на сервер Mobile Smarts
//	ПараметрыОнлайн - Строка, Структура - содержит дополнительные параметры для формирования запроса выгрузки таблицы в онлайн-режиме
//  РаботаБезАлкоголя - Булево - признак отсутствия (Истина) или наличия (Ложь) данных об алкогольной продукции в базе 1С
//  АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
//
// Возвращаемое значение:
//	ТаблицаЗначений - содержит данные таблицы для выгрузки на сервер Mobile Smarts	
Функция ГлЯдро_ПолучитьДанныеТаблицыДляВыгрузкиНаСерверSMARTS(ИмяТаблицы, НастройкиКомпоновщика = "", ПараметрыКомпоновщика = Ложь, ПараметрыОнлайн = "", РаботаБезАлкоголя = Ложь, ПараметрыВыгрузки = Неопределено, АдресаПеременных) Экспорт
	
	ДанныеДляВыгрузки = ГлЯдро_ПолучитьТаблицуДляВыгрузкиСПравочников(ИмяТаблицы, НастройкиКомпоновщика, ПараметрыКомпоновщика,, ПараметрыОнлайн, , РаботаБезАлкоголя, ПараметрыВыгрузки, АдресаПеременных);
	
	ГлЯдро_ОбработатьРезультатыВыгрузкиТаблицы(ДанныеДляВыгрузки, ИмяТаблицы, ПараметрыВыгрузки, АдресаПеременных);
	
	Возврат ДанныеДляВыгрузки;
	
КонецФункции

// Получает из интеграционной обработки схему компоновки данных, используемую для выгрузки таблицы на сервер Mobile Smarts.
// Устанавливает параметры полученной схемы компоновки данных.
//
// Параметры:
//	ИмяТаблицы - Строка - имя выгружаемой таблицы
//  ПараметрыКомпоновщика - Неопределено, Массив из Структура - содержит параметры компоновщика для установки в полученной схеме компоновки данных
//	РаботаБезАлкоголя - Булево - признак отсутствия (Истина) или наличия (Ложь) данных об алкогольной продукции в базе 1С	
//	АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
//
// Возвращаемое значение:
//	- СхемаКомпоновкиДанных - схема компоновки данных для выгрузки таблицы на сервер Mobile Smarts
//  - Неопределено - если не удалось получить интеграционную обработку
Функция ГлЯдро_ПолучитьСхемуСКДДляВыгрузкиСправочников(ИмяТаблицы, ПараметрыКомпоновщика, ПараметрыПолученияМакета, ПараметрыВыгрузки = Неопределено, АдресаПеременных) Экспорт
	
	НачалоСобытия = ТекущаяУниверсальнаяДатаВМиллисекундах();
	ИмяСобытия = "ГлЯдро_ПолучитьСхемуСКДДляВыгрузкиСправочников";	
	
	ЭтоВнешнееСоединение = Ложь;
	ИспользоватьКэшированиеСКД = Ложь;
	#Если ВнешнееСоединение Тогда
		ЭтоВнешнееСоединение = Истина;	
	#КонецЕсли
	Если ЭтоВнешнееСоединение Или ЭтоWebСервис Тогда
		ИспользоватьКэшированиеСКД = Истина;
	КонецЕсли;		
	
	МакетПолучен = Ложь;
	Если ИспользоватьКэшированиеСКД Тогда 
		РежимЗапроса = "";
		Если ПараметрыПолученияМакета.Свойство("ПараметрыОнлайн")
			И ТипЗнч(ПараметрыПолученияМакета.ПараметрыОнлайн) = Тип("Структура")
			И ПараметрыПолученияМакета.ПараметрыОнлайн.Свойство("Режим") Тогда
			РежимЗапроса = ПараметрыПолученияМакета.ПараметрыОнлайн.Режим;
		КонецЕсли;
		СоответствияСКДИменамТаблиц = КомЯдро_ПолучитьЗначениеПеременной("МакетыСКД",АдресаПеременных);
		Если СоответствияСКДИменамТаблиц <> Неопределено Тогда
			СхемаСКД = СоответствияСКДИменамТаблиц.Получить(ИмяТаблицы+РежимЗапроса);
			Если СхемаСКД <> Неопределено Тогда
				МакетПолучен = Истина;
			Конецесли;
		КонецЕсли;
	КонецЕсли;
	
	Если Не МакетПолучен Тогда
		СтруктураИО = КомЯдро_ПолучитьЗначениеПеременной("ИнтеграционнаяОбработка",АдресаПеременных);
			
		Если (СтруктураИО = Неопределено
			ИЛИ НЕ ТипЗнч(СтруктураИО) = Тип("Структура")
			ИЛИ НЕ СтруктураИО.Свойство("ИнтеграционнаяОбработка")
			ИЛИ СтруктураИО.ИнтеграционнаяОбработка = Неопределено)		
			И НЕ ГлЯдро_ПересоздатьИнтеграционнуюОбработку(АдресаПеременных) Тогда
			Возврат Неопределено;
		КонецЕсли;
		СтруктураИО = КомЯдро_ПолучитьЗначениеПеременной("ИнтеграционнаяОбработка",АдресаПеременных);
		ИнтеграционнаяОбработка = СтруктураИО.ИнтеграционнаяОбработка;
		
		СпособВыгрузки 					= Неопределено;
		ИмяМакетаИО 					= Неопределено;
		ТекстЗапросаВыгрузкиНаТСД		= Неопределено;
		ТекстКодаПолучениеПараметров 	= Неопределено;
		ТаблицаСопоставленияПолей 		= Неопределено;
		
		Если ТипЗнч(ПараметрыВыгрузки) = Тип("Структура") Тогда
			Если ПараметрыВыгрузки.Свойство("СпособВыгрузки") Тогда
				СпособВыгрузки = ПараметрыВыгрузки.СпособВыгрузки;
				
				Если СпособВыгрузки = "СвойМакетСКД" Тогда
					Если ПараметрыВыгрузки.Свойство("ИмяМакетаИО") Тогда
						ИмяМакетаИО = ПараметрыВыгрузки.ИмяМакетаИО;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		
		Если ЗначениеЗаполнено(СпособВыгрузки) 
			И СпособВыгрузки <> "ПоУмолчанию" Тогда
			Если СпособВыгрузки = "СвойМакетСКД"
				И ЗначениеЗаполнено(ИмяМакетаИО) Тогда
				СтруктураСхемыСКД = ИнтеграционнаяОбработка.ПолучитьМакет(ИмяМакетаИО);
			ИначеЕсли СпособВыгрузки = "ПроизвольныйЗапрос" Тогда
				СтруктураСхемыСКД = ГлЯдро_ПолучитьСхемуСКДПоТекстуЗапроса(ПараметрыВыгрузки, АдресаПеременных);
			КонецЕсли;
		Иначе
			Попытка
				ИнформацияСовместимости = ИнтеграционнаяОбработка.ИнформацияСовместимости();
				ВерсияAPI = ИнформацияСовместимости.ВерсияAPI;
			Исключение
				ВерсияAPI = 3;
			КонецПопытки;
			
			Если ВерсияAPI >= 4 Тогда
				СтруктураСхемыСКД = ИнтеграционнаяОбработка.ПолучитьМакетСКД(ИмяТаблицы, ПараметрыПолученияМакета);
			Иначе
				СтруктураСхемыСКД = ИнтеграционнаяОбработка.ПолучитьМакетСКД(ИмяТаблицы, ПараметрыПолученияМакета.РаботаБезАлкоголя);
			КонецЕсли;
		КонецЕсли;
		
		Если ТипЗнч(СтруктураСхемыСКД) = Тип("Структура") 
			И СтруктураСхемыСКД.Свойство("ОписаниеОшибки")  Тогда
			Если ЗначениеЗаполнено(СтруктураСхемыСКД.ОписаниеОшибки) Тогда
				ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", СтруктураСхемыСКД.ОписаниеОшибки, НачалоСобытия, АдресаПеременных);
				Возврат Неопределено;
			Иначе
				СхемаСКД = СтруктураСхемыСКД.Макет;
			КонецЕсли; 
		Иначе
			СхемаСКД = СтруктураСхемыСКД;
		КонецЕсли;
		
		Если ИспользоватьКэшированиеСКД Тогда
			Если СоответствияСКДИменамТаблиц = Неопределено Тогда
				СоответствияСКДИменамТаблиц = Новый Соответствие;
			КонецЕсли;
			СоответствияСКДИменамТаблиц.Вставить(ИмяТаблицы+РежимЗапроса,СхемаСКД);
			КомЯдро_СохранитьЗначениеПеременной("МакетыСКД",СоответствияСКДИменамТаблиц,АдресаПеременных);
		КонецЕсли;
	КонецЕсли;
	
	// Определяемые общие параметры
	Если ТипЗнч(ПараметрыКомпоновщика) = Тип("Массив") Тогда
		Для Каждого ПараметрКомпоновки Из ПараметрыКомпоновщика Цикл
			ПараметрыСКД = СхемаСКД.Параметры;
			НайденныйПараметрСКД = ПараметрыСКД.Найти(ПараметрКомпоновки.ID_Параметра);
			Если НайденныйПараметрСКД = Неопределено Тогда
		        ПараметрСхемыКомпоновкиДанных = ПараметрыСКД.Добавить();
		        ПараметрСхемыКомпоновкиДанных.Имя                      = ПараметрКомпоновки.ID_Параметра;
		        ПараметрСхемыКомпоновкиДанных.Заголовок                = СокрЛП(ПараметрКомпоновки.Наименование);
		        ПараметрСхемыКомпоновкиДанных.ВключатьВДоступныеПоля   = Истина;
				ПараметрСхемыКомпоновкиДанных.ОграничениеИспользования = Истина;
				ПараметрСхемыКомпоновкиДанных.Использование            = ИспользованиеПараметраКомпоновкиДанных.Авто;
				ПараметрСхемыКомпоновкиДанных.ТипЗначения.Типы().Добавить(ТипЗнч(ПараметрКомпоновки.Значение));
				ПараметрСхемыКомпоновкиДанных.Значение                 = ПараметрКомпоновки.Значение;
			Иначе
				НайденныйПараметрСКД.Значение = ПараметрКомпоновки.Значение;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Конец получения макета СКД.",НачалоСобытия,АдресаПеременных);
	
	Возврат СхемаСКД;
	
КонецФункции

// Последовательно вызывает функции получения данных таблицы для выгрузки на сервер Mobile Smarts и преобразования
// полученной таблицы значений в массивы значений либо соответствия в зависимости от типа интерфейса
//
// Параметры:
//	ИмяТаблицы - Строка - имя выгружаемой таблицы
//  НастройкиКомпоновщика - Неопределено, Булево, НастройкиКомпоновкиДанных - содержит настройки, установленные для схемы компоновки данных, описанной в интеграционной
//															          		  обработке и используемой для получения данных таблицы при выгрузке на сервер Mobile Smarts
//  ПараметрыКомпоновщика - Неопределено, Булево, Массив из Структура - содержит параметры схемы компоновки данных, описанной в интеграционной 
//																		обработке и используемой для получения данных таблицы при выгрузке на сервер Mobile Smarts 
//  РаботаБезАлкоголя - Булево - признак отсутствия (Истина) или наличия (Ложь) данных об алкогольной продукции в базе 1С
//  АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
//
// Возвращаемое значение:
//	- Структура - для COM - содержит:
//		* МассивИмен - Массив из Строка - содержит имена колонок выгружаемой таблицы
//		* МассивыСтрок - Массив из Массив - содержит строки выгружаемой таблицы в виде массивов значений
//      * КоличествоТоваров - Число - содержит количество выгружаемых товаров для таблицы "Номенклатура"
//	- Массив из Соответствие - для REST_API - содержит строки выгружаемой таблицы в виде соответствий, ключами которых 
//											  являются названия колонок таблицы, переведенные в транслит, значениями - 
//											  значения соответствующих колонок.	
Функция ГлЯдро_ПолучитьМассивыТаблицыДляВыгрузкиНаСерверSMARTS(ИмяТаблицы, НастройкиКомпоновщика = "", ПараметрыКомпоновщика = Ложь, РаботаБезАлкоголя = Ложь, ПараметрыВыгрузки = Неопределено, ТипБазы = "", АдресаПеременных) Экспорт
	
	ДанныеДляВыгрузки = ГлЯдро_ПолучитьДанныеТаблицыДляВыгрузкиНаСерверSMARTS(ИмяТаблицы, НастройкиКомпоновщика, ПараметрыКомпоновщика, , РаботаБезАлкоголя, ПараметрыВыгрузки, АдресаПеременных);
	
	Если ДанныеДляВыгрузки = Неопределено 
		Или (ТипЗнч(ДанныеДляВыгрузки) = Тип("ТаблицаЗначений") 
			 И ДанныеДляВыгрузки.Колонки.Количество() = 0) Тогда
		Возврат Неопределено;
	КонецЕсли;
		
	ДанныеДляВыгрузки = ГлЯдро_СформироватьМассивыДляВыгрузкиТаблиц(ИмяТаблицы, ДанныеДляВыгрузки, ТипБазы, АдресаПеременных);
	
	Возврат ДанныеДляВыгрузки;
	
КонецФункции

// Преобразует данные выгружаемой таблицы в массивы значений либо соответствия в зависимости от типа интерфейса
//
// Параметры:
//	ИмяТаблицы - Строка - имя выгружаемой таблицы
//	ДанныеДляВыгрузки - ТаблицаЗначений, Массив из Структура, Структура - данные выгружаемой таблицы
//	АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
//
// Возвращаемое значение:
//	- Структура - для COM - содержит:
//		* МассивИмен - Массив из Строка - содержит имена колонок выгружаемой таблицы
//		* МассивыСтрок - Массив из Массив - содержит строки выгружаемой таблицы в виде массивов значений
//      * КоличествоТоваров - Число - содержит количество выгружаемых товаров для таблицы "Номенклатура"
//	- Массив из Соответствие - для REST_API - содержит строки выгружаемой таблицы в виде соответствий, ключами которых 
//											  являются названия колонок таблицы, переведенные в транслит, значениями - 
//											  значения соответствующих колонок.
Функция ГлЯдро_СформироватьМассивыДляВыгрузкиТаблиц(ИмяТаблицы, Знач ДанныеДляВыгрузки, ТипБазы = "", АдресаПеременных) Экспорт
	
	ТипИнтерфейса = ГлЯдро_ПолучитьТипИнтерфейса(ТипБазы, АдресаПеременных); // ТипИнтерфейса = КомЯдро_ПолучитьЗначениеПеременной("ТипИнтерфейса",АдресаПеременных);
	Если ЭтоАдресВременногоХранилища(ДанныеДляВыгрузки) Тогда
		ДанныеДляВыгрузки = ПолучитьИзВременногоХранилища(ДанныеДляВыгрузки);
	КонецЕсли;
	
	Если ТипИнтерфейса = "REST_API"
		И ИмяТаблицы <> "Номенклатура" Тогда
		МассивСоответствий = Новый Массив;

		Если ИмяТаблицы = "Ячейки" Тогда			
			МассивСоответствий = Новый Массив;
			СоответствиеКолонок = Новый Соответствие;
			Для каждого Колонка из ДанныеДляВыгрузки.Колонки Цикл
				СоответствиеКолонок.Вставить(Колонка.Имя,ГлЯдро_СтрокуВТранслитENG(Колонка.Имя));	
			КонецЦикла;
			Для Каждого СтрокаТЗ из ДанныеДляВыгрузки Цикл
				нЯчейка = Новый Соответствие;
				Для каждого Колонка из СоответствиеКолонок Цикл
					ЗначениеКолонки = REST_API_ОбработатьЗначениеДляВыгрузки(СтрокаТЗ[Колонка.Ключ]);
					нЯчейка.Вставить(Колонка.Значение,ЗначениеКолонки);
				КонецЦикла;
				нЯчейка.Вставить("warehouseId","1");
				МассивСоответствий.Добавить(нЯчейка);	
			КонецЦикла;
		Иначе
			Если ТипЗнч(ДанныеДляВыгрузки) = Тип("ТаблицаЗначений") Тогда
				СоответствиеКолонок = Новый Соответствие;
				Для каждого Колонка из ДанныеДляВыгрузки.Колонки Цикл
					СоответствиеКолонок.Вставить(Колонка.Имя,ГлЯдро_СтрокуВТранслитENG(Колонка.Имя));	
				КонецЦикла;
				Для Каждого СтрокаТЗ из ДанныеДляВыгрузки Цикл
					НовойеСоответствие = Новый Соответствие;
					Для каждого Колонка из СоответствиеКолонок Цикл
						ЗначениеКолонки = REST_API_ОбработатьЗначениеДляВыгрузки(СтрокаТЗ[Колонка.Ключ]);
						НовойеСоответствие.Вставить(Колонка.Значение,ЗначениеКолонки);
					КонецЦикла;
					МассивСоответствий.Добавить(НовойеСоответствие);	
				КонецЦикла;
			ИначеЕсли ТипЗнч(ДанныеДляВыгрузки) = Тип("Массив")
				ИЛИ ТипЗнч(ДанныеДляВыгрузки) = Тип("Структура") Тогда
				
				ЭтоСтруктура = ТипЗнч(ДанныеДляВыгрузки) = Тип("Структура");
				СоответствиеКолонок = Новый Соответствие;
				
				Для Каждого СтрокаДляВыгрузки Из ДанныеДляВыгрузки Цикл
					ЭлементМ = ?(ЭтоСтруктура,СтрокаДляВыгрузки.Значение,СтрокаДляВыгрузки);	
					Если НЕ ТипЗнч(ЭлементМ) = Тип("Структура")	Тогда
						Прервать;
					КонецЕсли;
					
					Если ЭлементМ.Свойство("ЭтоТаблицаЗначений") Тогда
						Продолжить;
					КонецЕсли;
					
					Для Каждого Парам из ЭлементМ Цикл
						Если СоответствиеКолонок.Получить(Парам.Ключ) = Неопределено Тогда
							СоответствиеКолонок.Вставить(Парам.Ключ,ГлЯдро_СтрокуВТранслитENG(Парам.Ключ));
						КонецЕсли;
					КонецЦикла;
					Прервать;
				КонецЦикла;
				
				Если СоответствиеКолонок.Количество() > 0 Тогда
					пЗначение = Неопределено;
					Для Каждого ЭлементМ Из ДанныеДляВыгрузки Цикл
						НовойеСоответствие = Новый Соответствие;
						ЭлементМ = ?(ЭтоСтруктура,ЭлементМ.Значение,ЭлементМ);
						МассивТекущейСтроки = Новый Массив;
						Для Каждого пКлюч из СоответствиеКолонок Цикл
							ЭлементМ.Свойство(пКлюч.Ключ,пЗначение);
							пЗначение = REST_API_ОбработатьЗначениеДляВыгрузки(пЗначение);
							НовойеСоответствие.Вставить(пКлюч.Значение,пЗначение);		
						КонецЦикла;
						МассивСоответствий.Добавить(НовойеСоответствие);	
					КонецЦикла;
				КонецЕсли;	
			Иначе
				МассивСоответствий = ДанныеДляВыгрузки;
			КонецЕсли;
		КонецЕсли;
		СтруктураМассивов = МассивСоответствий;
	Иначе
		
	//COM
		СтруктураМассивов = Новый Структура("МассивИмен,МассивыСтрок"); 
	
		МассивИмен = Новый Массив;
		МассивИменДляПоиска = Новый Массив;
		
		Если ТипЗнч(ДанныеДляВыгрузки) = Тип("ТаблицаЗначений") Тогда
			Для Каждого Колонка Из ДанныеДляВыгрузки.Колонки Цикл
				ИмяДляМассива = Колонка.Имя;
				// Реальное имя в таблице запроса
				МассивИменДляПоиска.Добавить(ИмяДляМассива);
				// Имя для выгрузки онлайн
				ИмяДляМассива = СтрЗаменить(ИмяДляМассива, "Product_", "Product.");
				ИмяДляМассива = СтрЗаменить(ИмяДляМассива, "Packing_", "Packing.");
				МассивИмен.Добавить(ИмяДляМассива);
			КонецЦИкла;
			
			МассивыСтрок = Новый Массив;
			Для Каждого СтрокаВыгрузки Из ДанныеДляВыгрузки Цикл
				МассивТекущейСтроки = Новый Массив;
				Для Каждого ИмяКолонки Из МассивИменДляПоиска Цикл
					Значение = СтрокаВыгрузки[ИмяКолонки];
					МассивТекущейСтроки.Добавить(?(Значение = null,"",Значение));
				КонецЦикла;
				МассивыСтрок.Добавить(МассивТекущейСтроки);
			КонецЦикла;
			
			СтруктураМассивов.Вставить("МассивИмен", МассивИмен);
			СтруктураМассивов.Вставить("МассивыСтрок", МассивыСтрок);
			
			Если ИмяТаблицы = "Номенклатура" 
				И ДанныеДляВыгрузки.Колонки.Найти("Product_Id") <> Неопределено Тогда

				тзКолонкаТовары = ДанныеДляВыгрузки.Скопировать(,"Product_Id");
				тзКолонкаТовары.Свернуть("Product_Id");
				КоличествоТоваров = тзКолонкаТовары.Количество();
				
				СтруктураМассивов.Вставить("КоличествоТоваров",КоличествоТоваров);				
				
			КонецЕсли; 
			
		ИначеЕсли ТипЗнч(ДанныеДляВыгрузки) = Тип("Массив")
			ИЛИ ТипЗнч(ДанныеДляВыгрузки) = Тип("Структура") Тогда
			
			ЭтоСтруктура = ТипЗнч(ДанныеДляВыгрузки) = Тип("Структура");
			
			МассивыСтрок = Новый Массив;
			Для Каждого СтрокаДляВыгрузки Из ДанныеДляВыгрузки Цикл
				ЭлементМ = ?(ЭтоСтруктура,СтрокаДляВыгрузки.Значение,СтрокаДляВыгрузки);	
				Если НЕ ТипЗнч(ЭлементМ) = Тип("Структура")	Тогда
					Прервать;
				КонецЕсли;
				
				Если ЭлементМ.Свойство("ЭтоТаблицаЗначений") Тогда
					Продолжить;
				КонецЕсли;
				
				Для Каждого Парам из ЭлементМ Цикл
					Если МассивИмен.Найти(Парам.Ключ) = Неопределено Тогда
						МассивИмен.Добавить(Парам.Ключ);		
					КонецЕсли;
				КонецЦикла;
				Прервать;
			КонецЦикла;
			
			Если ИмяТаблицы = "Номенклатура" Тогда				
				СоответствиеРазличныхТоваров 	= Новый Соответствие;
				ИндексИдТовара 					= ГлЯдро_НайтиИндексИдТовараВМассивеИмен(МассивИмен);
			КонецЕсли; 
			
			Если МассивИмен.Количество() > 0 Тогда
				пЗначение = Неопределено;
				Для Каждого ЭлементМ Из ДанныеДляВыгрузки Цикл
					ЭлементМ = ?(ЭтоСтруктура,ЭлементМ.Значение,ЭлементМ);
					МассивТекущейСтроки = Новый Массив;
					Для Каждого пКлюч из МассивИмен Цикл
						ЭлементМ.Свойство(пКлюч,пЗначение);
						МассивТекущейСтроки.Добавить(пЗначение);		
					КонецЦикла;
					МассивыСтрок.Добавить(МассивТекущейСтроки);
					Если ИмяТаблицы = "Номенклатура" И ИндексИдТовара <> -1 Тогда
						СоответствиеРазличныхТоваров.Вставить(МассивТекущейСтроки[ИндексИдТовара]);
					КонецЕсли;	
				КонецЦикла;
				СтруктураМассивов.Вставить("МассивИмен", МассивИмен);
				СтруктураМассивов.Вставить("МассивыСтрок", МассивыСтрок);
			Иначе
				СтруктураМассивов.Вставить("МассивИмен", Новый Массив);
				СтруктураМассивов.Вставить("МассивыСтрок", Новый Массив);
			КонецЕсли;
			Если ИмяТаблицы = "Номенклатура" Тогда
				СтруктураМассивов.Вставить("КоличествоТоваров",СоответствиеРазличныхТоваров.Количество());	
			КонецЕсли;	
		Иначе
			СтруктураМассивов = ДанныеДляВыгрузки;
		КонецЕсли;
	КонецЕсли;
	
	Возврат СтруктураМассивов;
	
КонецФункции

Процедура ГлЯдро_ОбработатьРезультатыВыгрузкиТаблицы(ДанныеДляОбработки, ИмяТаблицы, ПараметрыВыгрузки, АдресаПеременных)
	
	Если ДанныеДляОбработки.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	ПараметрыПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("ПараметрыПодключенияMS",АдресаПеременных);
	
	ТаблицаЗаменыGUID = Новый ТаблицаЗначений;
	ТаблицаЗаменыGUID.Колонки.Добавить("КолонкаСсылка");
	ТаблицаЗаменыGUID.Колонки.Добавить("КолонкаGUID");
	
	Для Каждого Колонка Из ДанныеДляОбработки.Колонки Цикл
		Если Найти(Колонка.Имя, "_GUID") Тогда
			НоваяСтрока = ТаблицаЗаменыGUID.Добавить();
			НоваяСтрока.КолонкаСсылка = Колонка.Имя;
			НоваяСтрока.КолонкаGUID = СтрЗаменить(Колонка.Имя, "_GUID", "");
			ДанныеДляОбработки.Колонки.Добавить(НоваяСтрока.КолонкаGUID);
		КонецЕсли;
	КонецЦикла;
	
	// Если в таблице существует иерархия на ИдРодителя, то ниже будем проверять его наличие в спике, на случай если установлены отборы по группам или наименованию
	флПроверятьРодителей = Ложь;
	Если (ИмяТаблицы = "Номенклатура" ИЛИ ИмяТаблицы = "Склады")
		И ДанныеДляОбработки.Колонки.Найти("ИдРодителя")  <> Неопределено 
		И ДанныеДляОбработки.Колонки.Найти("Ид_GUID") <> Неопределено Тогда
		Если ИмяТаблицы = "Номенклатура" Тогда
			флПроверятьРодителей = Истина;
		ИначеЕсли ТипЗнч(ПараметрыВыгрузки) = Тип("Структура")
			И ПараметрыВыгрузки.Свойство("флПроверятьРодителей") Тогда
			флПроверятьРодителей = Истина;
		КонецЕсли;
	КонецЕсли;			
	Если флПроверятьРодителей Тогда
		МассивИдентификаторов = ДанныеДляОбработки.ВыгрузитьКолонку("Ид_GUID");		
	КонецЕсли;
	
	ДлинаКодаВесовогоТовара = Число(ГлЯдро_ПолучитьИзКэшаНастройкуSMARTS("ДлинаКодаВесовогоТовара",,АдресаПеременных));
	
	Если ИмяТаблицы = "Номенклатура" Тогда
		// В некоторых конфигурациях код номенклатуры задан числом, поэтому при преобразовании в строку может остаться только один символ
		// поэтому была добавлена отдельная колонка с кодом, значени из которой будут преобразованы и записаны в другую колонку
		ЕстьКолонкаКода = Ложь;
		КолонкаКод = ДанныеДляОбработки.Колонки.Найти("Код");
		Если КолонкаКод <> Неопределено Тогда
			ЕстьКолонкаКода = Истина;
		КонецЕсли;
	КонецЕсли;
	
	// Если для выгрузки используются нетиповые макеты, то запишем это в СпособВыгрузкиИзменен
	// Не выполняем обработку таблицы данных номенклатуры, если для выгрузки используются нетиповые макеты
	СпособВыгрузкиИзменен = Ложь;	
	Если ТипЗнч(ПараметрыВыгрузки) = Тип("Структура")
		И ПараметрыВыгрузки.Свойство("СпособВыгрузки")
		И ПараметрыВыгрузки.СпособВыгрузки <> "ПоУмолчанию"
		И ПараметрыВыгрузки.СпособВыгрузки <> "" Тогда
		СпособВыгрузкиИзменен = Истина;
	КонецЕсли;
	
	Для Каждого СтрокаТаблицы из ДанныеДляОбработки Цикл 
		
		// Если родителя нет в выгрузке, то не будем его прописывать
		Если флПроверятьРодителей 
			И ДанныеДляОбработки.Колонки.Найти("ИдРодителя_GUID") <> Неопределено Тогда
			Если МассивИдентификаторов.Найти(СтрокаТаблицы.ИдРодителя_GUID) = Неопределено Тогда
				СтрокаТаблицы.ИдРодителя_GUID = "";		
			КонецЕсли;
		КонецЕсли;
		
		// Заменяем ссылки на текстовые гуиды
		Для Каждого СтрокаЗамены Из ТаблицаЗаменыGUID Цикл
			Если ЗначениеЗаполнено(СтрокаТаблицы[СтрокаЗамены.КолонкаСсылка]) Тогда
				ИдСсылки = XMLСтрока(СтрокаТаблицы[СтрокаЗамены.КолонкаСсылка]);
				Если ИмяТаблицы = "Контрагенты" И СтрокаЗамены.КолонкаGUID = "Ид" Тогда                           				
					// В MS не должно быть одинаковых ссылок в одной таблице, но, например, у контрагентов и партнеров такое вполне может быть, поэтому надо обработать это
					Если ДанныеДляОбработки.Найти(ИдСсылки, СтрокаЗамены.КолонкаGUID) = Неопределено Тогда
						СтрокаТаблицы[СтрокаЗамены.КолонкаGUID] = ИдСсылки; 
					Иначе
						СтрокаТаблицы[СтрокаЗамены.КолонкаGUID] = "";
					КонецЕсли;
				Иначе
					СтрокаТаблицы[СтрокаЗамены.КолонкаGUID] = ИдСсылки; 
				КонецЕсли;
			Иначе
				СтрокаТаблицы[СтрокаЗамены.КолонкаGUID] = ""; // В MS нельзя отправлять значения "Неопределено" и "NULL", можно только значения примитивных типов	
			КонецЕсли;
		КонецЦикла;
		
		// приводим необходимые поисковые поля в нужный регистр
		Если ДанныеДляОбработки.Колонки.Найти("НаименованиеДляПоиска") <> Неопределено Тогда
			СтрокаТаблицы.НаименованиеДляПоиска = НРег(СтрокаТаблицы.НаименованиеДляПоиска);
		КонецЕсли;
				
		// Дополнительная обработка в зависимости от имени таблицы
		Если ИмяТаблицы = "Номенклатура"
			И Не СпособВыгрузкиИзменен Тогда
				
			// Переводим необходимые числа в строки, удаляем непереносимые пробелы, весовые коды добиваем нулями до значения параметра "ДлинаКодаВесовогоТовара"
			СтрокаТаблицы.Product_Barcode = ?(ЕстьКолонкаКода, Строка(СтрокаТаблицы.Код), СтрокаТаблицы.Product_Barcode);
			СтрокаТаблицы.Product_Barcode = СтрЗаменить(СокрЛП(СтрокаТаблицы.Product_Barcode), Символы.НПП, "");
			СтрокаТаблицы.Product_Marking = СтрЗаменить(СокрЛП(СтрокаТаблицы.Product_Marking), Символы.НПП, "");
			Если ТипЗнч(СтрокаТаблицы.Product_Marking) = Тип("Число") Тогда
				СтрокаТаблицы.Product_Marking = Строка(СтрокаТаблицы.Product_Marking);
			КонецЕсли;
			СтрокаТаблицы.Packing_Barcode 		= СтрЗаменить(СокрЛП(СтрокаТаблицы.Packing_Barcode), Символы.НПП, "");
			Весовой = ?(ДанныеДляОбработки.Колонки.Найти("Product_Весовой") <> Неопределено, СтрокаТаблицы.Product_Весовой, СтрокаТаблицы.Весовой);
			Если Весовой Тогда
				Если ЗначениеЗаполнено(СтрокаТаблицы.Packing_Barcode) И СтрДлина(СтрокаТаблицы.Packing_Barcode) < ДлинаКодаВесовогоТовара Тогда
					Для Сч = СтрДлина(СтрокаТаблицы.Packing_Barcode) По ДлинаКодаВесовогоТовара - 1 Цикл
						СтрокаТаблицы.Packing_Barcode = "0" + СтрокаТаблицы.Packing_Barcode;
					КонецЦикла;
				КонецЕсли;
			КонецЕсли;
			
			// если Штрихкод указан в виде шаблона, выделяем код товара из шаблона
			Если Весовой и СтрДлина(СтрокаТаблицы.Packing_Barcode) > ДлинаКодаВесовогоТовара Тогда
				
				Штрихкод = СтрокаТаблицы.Packing_Barcode;
				СтруктураШтрихкода = ГлЯдро_ПолучитьСтруктуруШтрихкодаEAN13(Штрихкод, АдресаПеременных);
				
				Если СтруктураШтрихкода.Свойство("КодСтрока") И Не ПустаяСтрока(СтруктураШтрихкода.КодСтрока) Тогда
					СтрокаТаблицы.Packing_Barcode = СтруктураШтрихкода.КодСтрока;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		
		Если ИмяТаблицы = "Ячейки"
			И Не ЗначениеЗаполнено(СтрокаТаблицы.Barcode)
			И Не СпособВыгрузкиИзменен Тогда
			СтрокаТаблицы.Barcode 	= ГлЯдро_ЧисловойКодПоСсылке(СтрокаТаблицы.Id_GUID);			
		КонецЕсли; 		
		
		Если ИмяТаблицы = "Резерв"
			И Не СпособВыгрузкиИзменен Тогда
			СтрокаТаблицы.ИдДокумента = ?(СтрокаТаблицы.ИдДокумента.Пустая(), "", XMLСтрока(СтрокаТаблицы.ИдДокумента));								
		КонецЕсли;	
		
	КонецЦикла;	
	
	Если ИмяТаблицы = "Номенклатура"
		И ЕстьКолонкаКода Тогда
		// Удаляем колонку кода, чтобы она не выводилась
		ДанныеДляОбработки.Колонки.Удалить("Код");
	КонецЕсли;
	
	Если ИмяТаблицы = "ДопРеквизиты" Тогда				
		
		ИмяКолонкиДвоичныеДанные 	= "ДвоичныеДанныеИзображения";
		ИмяКолонкиИзображение 		= "Изображение";		
		КолонкиТаблицы				= ДанныеДляОбработки.Колонки;
		КолонкаДвоичныеДанные		= КолонкиТаблицы.Найти(ИмяКолонкиДвоичныеДанные);								
		
		Если КолонкаДвоичныеДанные <> Неопределено Тогда			
			
			Если ПараметрыПодключенияMS.ТипУстановленногоПродукта = "Прайсчекер" 
				И ПараметрыПодключенияMS.УровеньПриложенияСтрокой = "Полный" Тогда				
				
				КолонкиТаблицы.Добавить(ИмяКолонкиИзображение, Новый ОписаниеТипов("Строка", , , , Новый КвалификаторыСтроки(0, ДопустимаяДлина.Переменная)));
				
				Для Каждого СтрокаТаблицы из ДанныеДляОбработки Цикл 
					Если ТипЗнч(СтрокаТаблицы[ИмяКолонкиДвоичныеДанные]) = Тип("ХранилищеЗначения") Тогда
						ДвоичныеДанные = СтрокаТаблицы[ИмяКолонкиДвоичныеДанные].Получить();
						Если ТипЗнч(ДвоичныеДанные) = Тип("Картинка") Тогда
							ДвоичныеДанные = ДвоичныеДанные.ПолучитьДвоичныеДанные();
						КонецЕсли;
						СтрокаТаблицы[ИмяКолонкиИзображение] = Base64Строка(ДвоичныеДанные);																	
					КонецЕсли; 							
				КонецЦикла;
				
			КонецЕсли;	
			
			КолонкиТаблицы.Удалить(КолонкаДвоичныеДанные);
			
		КонецЕсли;							
		
	КонецЕсли; 
	
	Если ИмяТаблицы = "ФормыА" Тогда
		// Переименовываем колонки для форм А
		ДанныеДляОбработки.Колонки.Найти("НачалоДействия").Имя = "Начало";
		ДанныеДляОбработки.Колонки.Найти("КонецДействия").Имя = "Конец";
	КонецЕсли;	
	
	// Формируем новую таблицу с переменной длиной имени ячеек (для исключения пробелов в SMARTS)
	Если ИмяТаблицы = "Ячейки" 
		И Не СпособВыгрузкиИзменен Тогда				
		НоваяТаблицаЯчеек = ДанныеДляОбработки.СкопироватьКолонки("Barcode,Id,Id_GUID");
		НоваяТаблицаЯчеек.Колонки.Добавить("Name", Новый ОписаниеТипов("Строка",,,, Новый КвалификаторыСтроки(50, ДопустимаяДлина.Переменная)));
			
		Для Каждого СтрокаТаблицы из ДанныеДляОбработки Цикл
			НоваяСтрокаЯчеек = НоваяТаблицаЯчеек.Добавить();
			ЗаполнитьЗначенияСвойств(НоваяСтрокаЯчеек, СтрокаТаблицы,, "Name");
			НоваяСтрокаЯчеек.Name = СокрЛП(СтрокаТаблицы.Name);
		КонецЦикла;	                            
		
		ДанныеДляОбработки = НоваяТаблицаЯчеек;
	КонецЕсли;
	
	ГлЯдро_ОбработатьРезультатыВыгрузкиТаблицыДополнительно(ДанныеДляОбработки, ИмяТаблицы ,АдресаПеременных);
	
	// удаляем колонки с ссылками
	Для Каждого СтрокаЗамены Из ТаблицаЗаменыGUID Цикл
		ДанныеДляОбработки.Колонки.Удалить(СтрокаЗамены.КолонкаСсылка);
	КонецЦикла;
	
КонецПроцедуры

Процедура ГлЯдро_ПроверитьПодключенныеРасширенияИПатчи(АдресаПеременных) Экспорт
	
	ИмяСобытия = "ГлЯдро_ПроверитьПодключенныеРасширенияИПатчи";
	
	Расширения 	= Новый Массив;
	Патчи 		= Новый Массив;
	
	Попытка
		СписокПодключенныхРасширений = РасширенияКонфигурации.Получить();
	Исключение
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Конфигурация не поддерживаниет механизм расширений",, АдресаПеременных);
		Возврат;
	КонецПопытки;
	
	Для Каждого Расширение Из СписокПодключенныхРасширений Цикл
		Если Не Расширение.Активно Тогда
			Продолжить;
		КонецЕсли;
		Если ГлЯдро_СтрНайти(Расширение.Имя, "EF_") > 0 Тогда
			Патчи.Добавить(Расширение);
		Иначе
			Расширения.Добавить(Расширение);			
		КонецЕсли;
	КонецЦикла;
	
	Если Расширения.Количество() Тогда 
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "К конфигурации подключены следующие расширения:",, АдресаПеременных);
		Для Каждого ТекРасширение Из Расширения Цикл
			ТекстКомментария = ТекРасширение.Синоним + "(Версия " + ТекРасширение.Версия + ", Безопасный режим = " + ТекРасширение.БезопасныйРежим + ")";
			ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", ТекстКомментария,, АдресаПеременных);
		КонецЦикла;
	Иначе
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "У конфигурации отсутствуют подключенные расширения",, АдресаПеременных);
	КонецЕсли;
	
	Если Патчи.Количество() Тогда 
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "К конфигурации подключены следующие патчи от фирмы 1С:",, АдресаПеременных);
		Для Каждого ТекПатч Из Патчи Цикл			
			ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", ТекПатч.Синоним,, АдресаПеременных);
		КонецЦикла;
	Иначе
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "У конфигурации отсутствуют подключенные патчи от фирмы 1С",, АдресаПеременных);
	КонецЕсли;
		
КонецПроцедуры

Процедура ГлЯдро_ПроверитьДоступностьРаботыСДокументами1С(МассивИменТиповДокументов1С, АдресаПеременных) Экспорт
	
	ИмяСобытия = "ГлЯдро_ПроверитьДоступностьРаботыСДокументами1С";
	
	МассивМетаданныхДокументов1С 			= Новый Массив;
	МассивМетаданныхНедоступныхДокументов1С = Новый Массив;
	
	Для Каждого ИмяТипаДокумента1С Из МассивИменТиповДокументов1С Цикл
		
		МетаданныеДокумента = Метаданные.Документы.Найти(ИмяТипаДокумента1С);
		
		Если МетаданныеДокумента <> Неопределено Тогда
			МассивМетаданныхДокументов1С.Добавить(МетаданныеДокумента);
		Иначе
			ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "В конфигурации отсутствует документ с типом " + ИмяТипаДокумента1С,, АдресаПеременных);
		КонецЕсли;
		
	КонецЦикла;
	
	// Проверка, включены ли функц опций документов
	Для Каждого МетаданныеДокумента1С Из МассивМетаданныхДокументов1С Цикл
		
		ДокументДоступен = Истина; // Пока не нашли выключенные функциональные опции у документа, будем считать, что он доступен
		Для Каждого МетаданныеФункциональнойОпции Из Метаданные.ФункциональныеОпции Цикл
			
			Если МетаданныеФункциональнойОпции.Состав.Найти(МетаданныеДокумента1С) <> Неопределено Тогда
				// Проверяем только те функц опции, значения которых хранятся в константах, т.к. другие значения параметризуемые, т.е. зависят от измерений регистра или какого-либо реквизита
				Если Метаданные.Константы.Найти(МетаданныеФункциональнойОпции.Хранение.Имя) <> Неопределено Тогда
					ДокументДоступен = ПолучитьФункциональнуюОпцию(МетаданныеФункциональнойОпции.Имя);
					Если ДокументДоступен Тогда
						Прервать; // Функциональная опция включена, документ доступен
					Иначе
						ВыключеннаяФункциональнаяОпция = МетаданныеФункциональнойОпции.Синоним;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
						
		КонецЦикла;
		
		Если ДокументДоступен Тогда
			ТекстИнформации = "Тип документа " + МетаданныеДокумента1С.Синоним + " доступен.";
			ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", ТекстИнформации,, АдресаПеременных);			
		Иначе
			ТекстОшибки = "Тип документа " + МетаданныеДокумента1С.Синоним + " недоступен. Выключена функциональная опция " + ВыключеннаяФункциональнаяОпция;
			ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", ТекстОшибки,, АдресаПеременных);
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

#Область ГлобальныйКонтекст_СправочникиИТаблицы_ДополнительноДляНоменклатуры

// Возвращает номенклатуру, не помеченную на удаление и не являющуюся группой
//
// Параметры:
//	АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
//
// Возвращаемое значение:
//	Массив из СправочникСсылка.Номенклатура
Функция ГлЯдро_ПолучитьМассивСсылокНоменклатуры(АдресаПеременных) Экспорт

	МетаданныеНСИ 				= Конф_ПолучитьМетаданныеНСИ(АдресаПеременных);	
	ИмяСправочникаНоменклатура 	= МетаданныеНСИ.Номенклатура.ИмяСправочника;
	
	Запрос = Новый Запрос("ВЫБРАТЬ
	                      |	Номенклатура.Ссылка
	                      |ИЗ
	                      |	Справочник." + ИмяСправочникаНоменклатура + " КАК Номенклатура
	                      |ГДЕ
	                      |	НЕ Номенклатура.ПометкаУдаления
						  |	И НЕ Номенклатура.ЭтоГруппа     
						  |");
	
	МассивСсылокНоменклатуры = Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Ссылка");			
	
	Возврат МассивСсылокНоменклатуры;

КонецФункции

// Возвращает индекс колонки "Product.Id" в массиве имен колонок таблицы, выгружаемой на сервер Mobile Smarts
//
// Параметры:
//	МассивИмен - Массив из Строка - содержит имена колонок таблицы
//
// Возвращаемое значение:
//	Число - индекс колонки "Product.Id" в массиве имен колонок таблицы
Функция ГлЯдро_НайтиИндексИдТовараВМассивеИмен(МассивИмен) Экспорт		
	
	ИндексКолонкиСТоваром = 0;	
	// воспользоваться методом "Найти()" не получится,
	// т.к. в этом методе строки чувствительны к регистру,
	// поэтому используем прямой перебор всех элементов массива
	Для каждого Элемент Из МассивИмен Цикл		
		Если ВРег(СокрЛП(Элемент)) = ВРег(СокрЛП("Product.Id")) Тогда			
			Возврат ИндексКолонкиСТоваром;			
		КонецЕсли;			
		ИндексКолонкиСТоваром = ИндексКолонкиСТоваром + 1;
	КонецЦикла; 
		
	Возврат -1;				
	
КонецФункции

Процедура ГлЯдро_УстановитьПараметрыСКДДляНоменклатуры(КомпоновщикСКД, ПараметрыОнлайн, АдресаПеременных)
	
	МетаданныеНСИ = ГлЯдро_ПолучитьМетаданныеНСИ(АдресаПеременных);
	ИмяСправочникаНоменклатуры = МетаданныеНСИ.Номенклатура.ИмяСправочника;
	ИмяСправочникаЕИ = МетаданныеНСИ.ЕдиницыИзмерения.ИмяСправочника;
	
	Если МетаданныеНСИ.Номенклатура.Свойство("БазоваяЕдиницаИзмерения") Тогда
		МассивЕИ = Новый Массив;
		МассивЕИ.Добавить(ИмяСправочникаЕИ);
		МассивЕИ.Добавить(МетаданныеНСИ.Номенклатура.БазоваяЕдиницаИзмерения.ИмяСправочника);
		ИмяСправочникаЕИ = МассивЕИ;
	КонецЕсли;	
	
	ИспользоватьХарактеристикиНоменклатуры 	= Конф_ИспользоватьХарактеристикиНоменклатуры(АдресаПеременных);
	РежимЗапроса 							= "";
    ПараметрНоменклатуры 					= Новый Массив;
    ПараметрУпаковки 						= Новый Массив;
    СтрокаПоиска 							= "%%";
    ЧислоПоиска 							= -1;
    ЭтоВесовойТовар 						= Ложь;
	
	Если ЗначениеЗаполнено(ПараметрыОнлайн) Тогда
	    РежимЗапроса = ПараметрыОнлайн.Режим;
		Если ПараметрыОнлайн.Режим = "ПоискПоАртикулуКодуШК" Тогда
			ЭтоВесовойТовар 	= ПараметрыОнлайн.СтруктураШтрихкода.ЭтоВесовойТовар;
			ЧислоПоиска 		= ПараметрыОнлайн.СтруктураШтрихкода.КодЧисло;
			СтрокаПоиска 		= ПараметрыОнлайн.СтруктураШтрихкода.КодСтрока;
		ИначеЕсли ПараметрыОнлайн.Режим = "ПоискПоНоменклатуреУпаковке" Тогда
			МассивНоменклатур = Новый Массив;
			МассивУпаковок = Новый Массив;
			СсылкаНоменклатуры = ГлЯдро_ПолучитьЗначениеСправочникаПоID(ИмяСправочникаНоменклатуры, ПараметрыОнлайн.ПараметрНоменклатуры);
			Если ЗначениеЗаполнено(СсылкаНоменклатуры) Тогда
				МассивНоменклатур.Добавить(СсылкаНоменклатуры);
				СсылкаУпаковки = ГлЯдро_ПолучитьЗначениеСправочникаПоID(ИмяСправочникаЕИ, ПараметрыОнлайн.ПараметрУпаковки);
				Если ЗначениеЗаполнено(СсылкаУпаковки) Тогда
					МассивУпаковок.Добавить(СсылкаУпаковки);
				КонецЕсли;
			КонецЕсли;
			ПараметрНоменклатуры 	= МассивНоменклатур;
			ПараметрУпаковки 		= МассивУпаковок;
		ИначеЕсли ПараметрыОнлайн.Режим = "ПоискПоМассивамНоменклатурыУпаковки" Тогда
			МассивНоменклатур = Новый Массив;
			МассивУпаковок = Новый Массив;
			Если ТипЗнч(ПараметрыОнлайн.ПараметрНоменклатуры) = Тип("COMSafeArray") Тогда
				ПараметрНоменклатуры = ПараметрыОнлайн.ПараметрНоменклатуры.Выгрузить();
			ИначеЕсли ТипЗнч(ПараметрыОнлайн.ПараметрНоменклатуры) = Тип("Соответствие") Тогда 
				ПараметрНоменклатуры = ПараметрыОнлайн.ПараметрНоменклатуры.Получить("$values");
			Иначе
				ПараметрНоменклатуры = ПараметрыОнлайн.ПараметрНоменклатуры;
			КонецЕсли;
			Если ТипЗнч(ПараметрыОнлайн.ПараметрУпаковки) = Тип("COMSafeArray") Тогда
				ПараметрУпаковки = ПараметрыОнлайн.ПараметрУпаковки.Выгрузить();
			ИначеЕсли ТипЗнч(ПараметрыОнлайн.ПараметрУпаковки) = Тип("Соответствие") Тогда 
				ПараметрУпаковки = ПараметрыОнлайн.ПараметрУпаковки.Получить("$values");
			Иначе
				ПараметрУпаковки = ПараметрыОнлайн.ПараметрУпаковки;
			КонецЕсли;			
			Для Индекс = 0 По ПараметрНоменклатуры.ВГраница() Цикл
				СтрокаНоменклатуры = ПараметрНоменклатуры[Индекс];
				СсылкаНоменклатуры = ГлЯдро_ПолучитьЗначениеСправочникаПоID(ИмяСправочникаНоменклатуры, СтрокаНоменклатуры);
				Если ЗначениеЗаполнено(СсылкаНоменклатуры) Тогда
					МассивНоменклатур.Добавить(СсылкаНоменклатуры);
					СтрокаУпаковки = ПараметрУпаковки[Индекс];
					СсылкаУпаковки = ГлЯдро_ПолучитьЗначениеСправочникаПоID(ИмяСправочникаЕИ, СтрокаУпаковки);
					Если ЗначениеЗаполнено(СсылкаУпаковки) Тогда
						МассивУпаковок.Добавить(СсылкаУпаковки);
					КонецЕсли;
				КонецЕсли;
			КонецЦикла;
			ПараметрНоменклатуры 	= МассивНоменклатур;
			ПараметрУпаковки 		= МассивУпаковок;
		ИначеЕсли ПараметрыОнлайн.Режим = "ПоискПоЧастиНаименования" Тогда
			СтрокаПоиска = "%" + ПараметрыОнлайн.ПараметрНоменклатуры + "%";
		Иначе
			МассивНоменклатур = Новый Массив;
			Если ПараметрыОнлайн.Свойство("СсылкаНоменклатуры") Тогда
				СсылкаНоменклатуры = ПараметрыОнлайн.СсылкаНоменклатуры;
			Иначе
				СсылкаНоменклатуры = ГлЯдро_ПолучитьЗначениеСправочникаПоID(ИмяСправочникаНоменклатуры, ПараметрыОнлайн.ПараметрНоменклатуры);
			КонецЕсли;
			МассивНоменклатур.Добавить(СсылкаНоменклатуры);
			ПараметрНоменклатуры = МассивНоменклатур;
			Если ПараметрыОнлайн.Режим = "СписокНоменклатуры"
				Или ПараметрыОнлайн.Режим = "СписокНоменклатурыДляГрупп"
				Или ПараметрыОнлайн.Режим = "СписокУпаковокДляНоменклатуры" Тогда
				Если СсылкаНоменклатуры.ЭтоГруппа ИЛИ НЕ ЗначениеЗаполнено(СсылкаНоменклатуры) Тогда // если заходим в корень справочника, то родитель будет пустой ссылкой
					РежимЗапроса = "СписокНоменклатурыДляГрупп";
					// Если в СКД настроен отбор по номенклатуре, то необходимо его добавить в "ПараметрНоменклатуры", 
					// т.к. иначе отборы пересекаются при компоновке макета и выводится всегда пустой список
					Если НЕ ЗначениеЗаполнено(СсылкаНоменклатуры) И ЗначениеЗаполнено(МетаданныеНСИ.Номенклатура) Тогда
						ПроверяемыйТип = "СправочникСсылка." + МетаданныеНСИ.Номенклатура.ИмяСправочника;                        						
						Для Каждого ЭлементОтбора Из КомпоновщикСКД.Настройки.Отбор.Элементы Цикл
							Если Не ЭлементОтбора.Использование Тогда
								Продолжить;
							КонецЕсли;      
							
							Если ЭлементОтбора.ВидСравнения = ВидСравненияКомпоновкиДанных.ВСпискеПоИерархии 
								Или ЭлементОтбора.ВидСравнения = ВидСравненияКомпоновкиДанных.ВСписке Тогда
								Для Каждого ЭлементПравогоЗначения Из ЭлементОтбора.ПравоеЗначение Цикл
									Если ТипЗнч(ЭлементПравогоЗначения.Значение) = Тип(ПроверяемыйТип) Тогда
										ПараметрНоменклатуры.Добавить(ЭлементПравогоЗначения.Значение);         				
									КонецЕсли;	
								КонецЦикла;
							ИначеЕсли ЭлементОтбора.ВидСравнения = ВидСравненияКомпоновкиДанных.ВИерархии 
								Или ЭлементОтбора.ВидСравнения = ВидСравненияКомпоновкиДанных.Равно Тогда							
								Если ТипЗнч(ЭлементОтбора.ПравоеЗначение) = Тип(ПроверяемыйТип) Тогда
									ПараметрНоменклатуры.Добавить(ЭлементОтбора.ПравоеЗначение);         				
								КонецЕсли;
							КонецЕсли;
						КонецЦикла;
					КонецЕсли;					
				Иначе
				    РежимЗапроса = "СписокУпаковокДляНоменклатуры";
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;		
	
	ГлЯдро_ЗаполнитьЗначениеПараметраКомпоновщикаНастроекСКД(КомпоновщикСКД, "ИспользоватьХарактеристикиНоменклатуры", ИспользоватьХарактеристикиНоменклатуры, АдресаПеременных);
	ГлЯдро_ЗаполнитьЗначениеПараметраКомпоновщикаНастроекСКД(КомпоновщикСКД, "РежимЗапроса", РежимЗапроса, АдресаПеременных);
	ГлЯдро_ЗаполнитьЗначениеПараметраКомпоновщикаНастроекСКД(КомпоновщикСКД, "ПараметрНоменклатуры", ПараметрНоменклатуры, АдресаПеременных);
	ГлЯдро_ЗаполнитьЗначениеПараметраКомпоновщикаНастроекСКД(КомпоновщикСКД, "ПараметрУпаковки", ПараметрУпаковки, АдресаПеременных);
	ГлЯдро_ЗаполнитьЗначениеПараметраКомпоновщикаНастроекСКД(КомпоновщикСКД, "СтрокаПоиска", СтрокаПоиска, АдресаПеременных);
	ГлЯдро_ЗаполнитьЗначениеПараметраКомпоновщикаНастроекСКД(КомпоновщикСКД, "ЧислоПоиска", ЧислоПоиска, АдресаПеременных);
	ГлЯдро_ЗаполнитьЗначениеПараметраКомпоновщикаНастроекСКД(КомпоновщикСКД, "ЭтоВесовойТовар", ЭтоВесовойТовар, АдресаПеременных);	
	
	ГлЯдро_ОбработатьПараметрыСКД("Номенклатура", ПараметрыОнлайн, КомпоновщикСКД, АдресаПеременных);
		
КонецПроцедуры

#КонецОбласти

#Область ГлобальныйКонтекст_СправочникиИТаблицы_ДополнительноДляОстальныхТаблиц

Процедура ГлЯдро_УстановитьОтборКомпоновщикаДляВыгрузкиТаблиц(ИмяТаблицы, ПараметрыОнлайн, ЭлементыОтбора, МетаданныеНСИ, ПараметрыДанных = Неопределено, АдресаПеременных)
	
	Если ПараметрыОнлайн.IsGroup Тогда
		ЭлементОтбора = ЭлементыОтбора.Добавить(Тип("ГруппаЭлементовОтбораКомпоновкиДанных"));
		ЭлементОтбора.ТипГруппы = ГлЯдро_ПолучитьТипГруппыОтбораПоСтроке(ПараметрыОнлайн.GroupTypeStr);  
		
		ТипИнтерфейса = ГлЯдро_ПолучитьДанныеИзХранилища1С("Cleverence_ТипИнтерфейса");
		
		Для Индекс = 0 По ПараметрыОнлайн.Elements.Count() - 1 Цикл
			Если ТипИнтерфейса = "REST_API" Тогда
				ПодчиненныеПараметрыОнлайн = ПараметрыОнлайн.Elements.Получить(Индекс);
			Иначе
				ПодчиненныеПараметрыОнлайн = ПараметрыОнлайн.Elements.Item(Индекс);
			КонецЕсли;
			ГлЯдро_УстановитьОтборКомпоновщикаДляВыгрузкиТаблиц(ИмяТаблицы, ПодчиненныеПараметрыОнлайн, ЭлементОтбора.Элементы, МетаданныеНСИ, ПараметрыДанных,АдресаПеременных);
		КонецЦикла;		
	Иначе
		// Если заходим в корень справочника, то родитель будет пустой ссылкой, но если есть отбор из СКД, то параметр из онлайна не надо включать
		ОтборРодителяСКД = Ложь;
		Если ИмяТаблицы = "Склады" Тогда
			Для Каждого пОтбор Из ЭлементыОтбора Цикл  
				ПостфиксИмениПоля = "_GUID";
				Если ПараметрыОнлайн.LeftValue = "ИдРодителя" 
					И (Строка(пОтбор.ЛевоеЗначение) = (ПараметрыОнлайн.LeftValue + ПостфиксИмениПоля + "_ДляОтбора"))
					И (Не ЗначениеЗаполнено(ПараметрыОнлайн.RightValue)) Тогда				
					ЭлементОтбора = пОтбор;     
					ОтборРодителяСКД = Истина;  
					Прервать;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;

		Если Не ОтборРодителяСКД Тогда
			ЭлементОтбора = ЭлементыОтбора.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
			ЭлементОтбора.ВидСравнения = ГлЯдро_ПолучитьВидСравненияПоСтроке(ПараметрыОнлайн.ComparisonTypeStr);
			Если ПараметрыОнлайн.LeftValue = "Ид" ИЛИ ПараметрыОнлайн.LeftValue = "ИдТовара" ИЛИ ПараметрыОнлайн.LeftValue = "ИдРодителя" ИЛИ ПараметрыОнлайн.LeftValue = "ИдСклада1С"
				ИЛИ ПараметрыОнлайн.LeftValue = "КлючХарактеристик" ИЛИ ПараметрыОнлайн.LeftValue = "КлючСерий" ИЛИ ПараметрыОнлайн.LeftValue = "ИдНоменклатуры" 
				ИЛИ ПараметрыОнлайн.LeftValue = "ИдСклада" ИЛИ ПараметрыОнлайн.LeftValue = "ИдЯчейки" ИЛИ ПараметрыОнлайн.LeftValue = "ИдХарактеристики"
				ИЛИ ПараметрыОнлайн.LeftValue = "ИдСерии" ИЛИ ПараметрыОнлайн.LeftValue = "ИдЕдиницыИзмерения" 	ИЛИ ПараметрыОнлайн.LeftValue = "Упаковка"
				ИЛИ ПараметрыОнлайн.LeftValue = "ИдТранспортнойУпаковки" Тогда
				ПостфиксИмениПоля = "_GUID";
			Иначе
				ПостфиксИмениПоля = "";
			КонецЕсли;
			ЭлементОтбора.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ПараметрыОнлайн.LeftValue + ПостфиксИмениПоля);
			
			ПараметрыОнлайнДляОтбора = Новый Структура("RightValue");
			Если ТипЗнч(ПараметрыОнлайн) = Тип("Структура")
				ИЛИ ТипЗнч(ПараметрыОнлайн) = Тип("COMОбъект") Тогда
				ЗаполнитьЗначенияСвойств(ПараметрыОнлайнДляОтбора, ПараметрыОнлайн);
			КонецЕсли;
			ПравоеУсловие = ?(ЗначениеЗаполнено(ПараметрыОнлайнДляОтбора["RightValue"]), ПараметрыОнлайнДляОтбора["RightValue"], "");
						
			ЭлементОтбора.ПравоеЗначение = ГлЯдро_ПолучитьЗначениеДляОтбора(ИмяТаблицы, ПараметрыОнлайн.LeftValue, ПравоеУсловие, МетаданныеНСИ,АдресаПеременных);
			
			Если ПараметрыДанных <> Неопределено Тогда
				Параметр = ПараметрыДанных.Найти(ПараметрыОнлайн.LeftValue);
				Если Параметр <> Неопределено Тогда
					Параметр.Значение =	ГлЯдро_ПолучитьЗначениеДляОтбора(ИмяТаблицы, ПараметрыОнлайн.LeftValue, ПравоеУсловие, МетаданныеНСИ,АдресаПеременных);
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		
		ГлЯдро_ОбработатьЭлементыОтбора(ИмяТаблицы, ПараметрыОнлайн, ЭлементыОтбора, ПостфиксИмениПоля,АдресаПеременных);		
		
	КонецЕсли;
	
КонецПроцедуры

Процедура ГлЯдро_УстановитьОтборКомпоновщикаДляВыгрузкиТаблицПроизвольнымЗапросом(ИмяТаблицы, ПараметрыОнлайн, ЭлементыОтбора, МетаданныеНСИ, ПараметрыДанных = Неопределено, АдресаПеременных)
	
	Если ПараметрыОнлайн.IsGroup Тогда
		ЭлементОтбора = ЭлементыОтбора.Добавить(Тип("ГруппаЭлементовОтбораКомпоновкиДанных"));
		ЭлементОтбора.ТипГруппы = ГлЯдро_ПолучитьТипГруппыОтбораПоСтроке(ПараметрыОнлайн.GroupTypeStr);  
		
		ТипИнтерфейса = ГлЯдро_ПолучитьДанныеИзХранилища1С("Cleverence_ТипИнтерфейса");
		
		Для Индекс = 0 По ПараметрыОнлайн.Elements.Count() - 1 Цикл
			Если ТипИнтерфейса = "REST_API" Тогда
				ПодчиненныеПараметрыОнлайн = ПараметрыОнлайн.Elements.Получить(Индекс);
			Иначе
				ПодчиненныеПараметрыОнлайн = ПараметрыОнлайн.Elements.Item(Индекс);
			КонецЕсли;
			ГлЯдро_УстановитьОтборКомпоновщикаДляВыгрузкиТаблицПроизвольнымЗапросом(ИмяТаблицы, ПодчиненныеПараметрыОнлайн, ЭлементОтбора.Элементы, МетаданныеНСИ, ПараметрыДанных, АдресаПеременных);
		КонецЦикла;		
	Иначе
		// Для произвольного запроса не делаем дополнительных преобразований для элементов отбора
		ЭлементОтбора = ЭлементыОтбора.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
		ЭлементОтбора.ВидСравнения 	= ГлЯдро_ПолучитьВидСравненияПоСтроке(ПараметрыОнлайн.ComparisonTypeStr);
		ЭлементОтбора.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ПараметрыОнлайн.LeftValue);
			
		ПараметрыОнлайнДляОтбора = Новый Структура("RightValue");
		Если ТипЗнч(ПараметрыОнлайн) = Тип("Структура")
			ИЛИ ТипЗнч(ПараметрыОнлайн) = Тип("COMОбъект") Тогда
			ЗаполнитьЗначенияСвойств(ПараметрыОнлайнДляОтбора, ПараметрыОнлайн);
		КонецЕсли;
		ПравоеУсловие = ?(ЗначениеЗаполнено(ПараметрыОнлайнДляОтбора["RightValue"]), ПараметрыОнлайнДляОтбора["RightValue"], "");
					
		ЭлементОтбора.ПравоеЗначение = ПравоеУсловие;
			
		Если ПараметрыДанных <> Неопределено Тогда
			Параметр = ПараметрыДанных.Найти(ПараметрыОнлайн.LeftValue);
			Если Параметр <> Неопределено Тогда
				Параметр.Значение =	ПравоеУсловие;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

Процедура ГлЯдро_УстановитьФлагПроверкиРодителейИерархическогоСправочника(ИмяТаблицы, ПараметрыОнлайн, ПараметрыВыгрузки, АдресаПеременных)

	Если ПараметрыОнлайн = ""
		ИЛИ ПараметрыВыгрузки = Неопределено Тогда	
		Возврат;
	КонецЕсли;
	
	Если ПараметрыОнлайн.IsGroup Тогда
		Для Индекс = 0 По ПараметрыОнлайн.Elements.Count() - 1 Цикл
			ТипИнтерфейса = ГлЯдро_ПолучитьДанныеИзХранилища1С("Cleverence_ТипИнтерфейса");
			Если ТипИнтерфейса = "REST_API" Тогда
				ПодчиненныеПараметрыОнлайн = ПараметрыОнлайн.Elements.Получить(Индекс);
			Иначе
				ПодчиненныеПараметрыОнлайн = ПараметрыОнлайн.Elements.Item(Индекс);
			КонецЕсли;
			ГлЯдро_УстановитьФлагПроверкиРодителейИерархическогоСправочника(ИмяТаблицы, ПодчиненныеПараметрыОнлайн, ПараметрыВыгрузки, АдресаПеременных);
		КонецЦикла;		
	Иначе
		ЛевоеУсловие 	= "";
		ПравоеУсловие 	= "";
		Если ТипЗнч(ПараметрыОнлайн) = Тип("Структура") Тогда
			Если ПараметрыОнлайн.Свойство("LeftValue") Тогда
				ЛевоеУсловие = ПараметрыОнлайн.LeftValue;			
			КонецЕсли;			
			Если ПараметрыОнлайн.Свойство("RightValue") Тогда
				ПравоеУсловие = ПараметрыОнлайн.RightValue;
			КонецЕсли;
		КонецЕсли;
			
		Если ЛевоеУсловие = "ИдРодителя" И ПравоеУсловие = "" Тогда
			ПараметрыВыгрузки.Вставить("флПроверятьРодителей", Истина);			
		КонецЕсли;			
	КонецЕсли;
	
КонецПроцедуры

Процедура ГлЯдро_ОбработатьЭлементыОтбора(ИмяТаблицы, ПараметрыОнлайн, ЭлементыОтбора, ПостфиксИмениПоля,АдресаПеременных)
	
	СтруктураИО = КомЯдро_ПолучитьЗначениеПеременной("ИнтеграционнаяОбработка",АдресаПеременных);
		
	Если (СтруктураИО = Неопределено
		ИЛИ НЕ ТипЗнч(СтруктураИО) = Тип("Структура")
		ИЛИ НЕ СтруктураИО.Свойство("ИнтеграционнаяОбработка")
		ИЛИ СтруктураИО.ИнтеграционнаяОбработка = Неопределено)
		И НЕ ГлЯдро_ПересоздатьИнтеграционнуюОбработку(АдресаПеременных) Тогда
		Возврат;
	КонецЕсли;
	СтруктураИО = КомЯдро_ПолучитьЗначениеПеременной("ИнтеграционнаяОбработка",АдресаПеременных);
	ИнтеграционнаяОбработка = СтруктураИО.ИнтеграционнаяОбработка;
	
	// в инт.обработке может не существовать данного метода
	Попытка
		ИнтеграционнаяОбработка.ОбработатьЭлементыОтбора(ИмяТаблицы, ПараметрыОнлайн, ЭлементыОтбора, ПостфиксИмениПоля);	
	Исключение	
	КонецПопытки; 	
	
КонецПроцедуры	

Процедура ГлЯдро_ОбработатьРезультатыВыгрузкиТаблицыДополнительно(ДанныеДляОбработки, ИмяТаблицы ,АдресаПеременных)
	
	СтруктураИО = КомЯдро_ПолучитьЗначениеПеременной("ИнтеграционнаяОбработка",АдресаПеременных);
		
	Если (СтруктураИО = Неопределено
		ИЛИ НЕ ТипЗнч(СтруктураИО) = Тип("Структура")
		ИЛИ НЕ СтруктураИО.Свойство("ИнтеграционнаяОбработка")
		ИЛИ СтруктураИО.ИнтеграционнаяОбработка = Неопределено)
		И НЕ ГлЯдро_ПересоздатьИнтеграционнуюОбработку(АдресаПеременных) Тогда
		Возврат;
	КонецЕсли;
	СтруктураИО = КомЯдро_ПолучитьЗначениеПеременной("ИнтеграционнаяОбработка",АдресаПеременных);
	ИнтеграционнаяОбработка = СтруктураИО.ИнтеграционнаяОбработка;
	
	// в инт.обработке может не существовать данного метода
	Попытка
		ИнтеграционнаяОбработка.ОбработатьРезультатыВыгрузкиТаблицы(ДанныеДляОбработки, ИмяТаблицы, АдресаПеременных);	
	Исключение	
	КонецПопытки; 	
	
КонецПроцедуры

Функция ГлЯдро_ЧисловойКодПоСсылке(Ссылка)
	ШестнадчатиричноеЧисло = СтрЗаменить(Строка(Ссылка.УникальныйИдентификатор()),"-","");
	Возврат ГлЯдро_ПреобразоватьИзШестнадцатиричнойСистемыСчисленияВДесятичноеЧисло(ШестнадчатиричноеЧисло);
КонецФункции

Функция ГлЯдро_ПреобразоватьИзШестнадцатиричнойСистемыСчисленияВДесятичноеЧисло(Знач Значение)
	
	Значение = НРег(Значение);
	ДлинаСтроки = СтрДлина(Значение);
	
	Результат = 0;
	Для НомерСимвола = 1 По ДлинаСтроки Цикл
		Результат = Результат * 16 + Найти("0123456789abcdef", Сред(Значение, НомерСимвола, 1)) - 1;
	КонецЦикла;
	
	Возврат Формат(Результат, "ЧГ=0");
	
КонецФункции

Процедура ГлЯдро_ОбработатьПараметрыСКД(ИмяТаблицы, ПараметрыОнлайн, КомпоновщикСКД, АдресаПеременных)
	
	СтруктураИО = КомЯдро_ПолучитьЗначениеПеременной("ИнтеграционнаяОбработка", АдресаПеременных);
		
	Если (СтруктураИО = Неопределено
		ИЛИ НЕ ТипЗнч(СтруктураИО) = Тип("Структура")
		ИЛИ НЕ СтруктураИО.Свойство("ИнтеграционнаяОбработка")
		ИЛИ СтруктураИО.ИнтеграционнаяОбработка = Неопределено)
		И НЕ ГлЯдро_ПересоздатьИнтеграционнуюОбработку(АдресаПеременных) Тогда
		Возврат;
	КонецЕсли;
	СтруктураИО = КомЯдро_ПолучитьЗначениеПеременной("ИнтеграционнаяОбработка", АдресаПеременных);
	ИнтеграционнаяОбработка = СтруктураИО.ИнтеграционнаяОбработка;
	
	// в инт.обработке может не существовать данного метода
	Попытка
		ИнтеграционнаяОбработка.ОбработатьПараметрыСКД(ИмяТаблицы, ПараметрыОнлайн, КомпоновщикСКД);	
	Исключение	
	КонецПопытки; 	
	
КонецПроцедуры

#КонецОбласти

// Вызывает в интеграционной обработке функцию получения списка имен справочников, участвующих в интеграции с Mobile Smarts
//
// Параметры:
//	АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
//
// Возвращаемое значение:
//	СписокЗначений - содержит имена справочников в базе 1С, участвующих в интеграции с Mobile Smarts
Функция ГлЯдро_ПолучитьСписокИспользуемыхСправочников(АдресаПеременных) Экспорт
	
	СписокИспользуемыхСправочников = Новый СписокЗначений;
	
	СтруктураИО = КомЯдро_ПолучитьЗначениеПеременной("ИнтеграционнаяОбработка",АдресаПеременных);
		
	Если (СтруктураИО = Неопределено
		ИЛИ НЕ ТипЗнч(СтруктураИО) = Тип("Структура")
		ИЛИ НЕ СтруктураИО.Свойство("ИнтеграционнаяОбработка")
		ИЛИ СтруктураИО.ИнтеграционнаяОбработка = Неопределено)
		И НЕ ГлЯдро_ПересоздатьИнтеграционнуюОбработку(АдресаПеременных) Тогда
		Возврат СписокИспользуемыхСправочников;
	КонецЕсли;
	СтруктураИО = КомЯдро_ПолучитьЗначениеПеременной("ИнтеграционнаяОбработка",АдресаПеременных);
	ИнтеграционнаяОбработка = СтруктураИО.ИнтеграционнаяОбработка;
	
	СписокИспользуемыхСправочников = ИнтеграционнаяОбработка.Конф_ПолучитьСписокИспользуемыхСправочников();
	
	Возврат СписокИспользуемыхСправочников;
	
КонецФункции

// Вызывает функцию очистки данных из таблицы на сервере Mobile Smarts
//
// Параметры:
//	ИмяТаблицы - Строка - имя выгружаемой таблицы	
//  ID_БазыSMARTS - Строка - идентификатор текущей базы Mobile Smarts
//  АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
//
// Возвращаемое значение:
//  Структура - содержит:
//		* Статус - Булево - признак успешности очистки таблицы
//		* Сообщение - Строка - информационное сообщение о результате очистки таблицы
Функция ГлЯдро_ОчиститьТаблицуНаСервереSMARTS(ИмяТаблицы, ТипБазы = "", АдресаПеременных) Экспорт
	
	ТипИнтерфейса = ГлЯдро_ПолучитьТипИнтерфейса(ТипБазы, АдресаПеременных); // ТипИнтерфейса = КомЯдро_ПолучитьЗначениеПеременной("ТипИнтерфейса",АдресаПеременных);
	Если ТипИнтерфейса = "REST_API" Тогда
		РезультатВыгрузки = REST_API_ОчиститьТаблицуНаСервереSMARTS(ИмяТаблицы, ТипБазы, АдресаПеременных);
	Иначе
		РезультатВыгрузки = КомЯдро_ОчиститьТаблицуНаСервереSMARTS(ИмяТаблицы, ТипБазы, АдресаПеременных);
	КонецЕсли;
	Сообщить(РезультатВыгрузки.Сообщение);
	
	Если НЕ РезультатВыгрузки.Статус Тогда
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации("ГлЯдро_ОчиститьТаблицуНаСервереSMARTS", "Ошибка", РезультатВыгрузки.Сообщение, , АдресаПеременных);
	КонецЕсли;
	
	Возврат РезультатВыгрузки;
	
КонецФункции

// Вызывает функцию получения имен справочников в конфигурации Mobile Smarts
//
// Параметры:
//	АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
//
// Возвращаемое значение:
//	Массив из Строка - содержит имена справочников в конфигурации Mobile Smarts
Функция ГлЯдро_ПолучитьСписокСправочниковВКонфигурацииSMARTS(АдресаПеременных) Экспорт
	Возврат КомЯдро_ПолучитьСписокСправочниковВКонфигурацииSMARTS(АдресаПеременных);		
КонецФункции

Функция ГлЯдро_ПолучитьТаблицуДляВыгрузкиСправочников(ИмяТаблицы, НастройкиКомпоновщика = "", ПараметрыКомпоновщика = Ложь, СхемаСКД = Неопределено, ПараметрыОнлайн = "", ОтборПоНоменклатуре = Неопределено, РаботаБезАлкоголя = Ложь, ПараметрыВыгрузки = Неопределено, АдресаПеременных)	
	
	ИмяСобытия = "ГлЯдро_ПолучитьТаблицуДляВыгрузкиСправочников";
	
	Если СхемаСКД = Неопределено Тогда
		ПараметрыПолученияМакета = Новый Структура("РаботаБезАлкоголя, ПараметрыОнлайн",РаботаБезАлкоголя, ПараметрыОнлайн);
		СхемаСКД = ГлЯдро_ПолучитьСхемуСКДДляВыгрузкиСправочников(ИмяТаблицы, ПараметрыКомпоновщика, ПараметрыПолученияМакета, ПараметрыВыгрузки, АдресаПеременных);
		Если СхемаСКД = Неопределено Тогда
			Возврат Новый ТаблицаЗначений;
		КонецЕсли;
	КонецЕсли;
	
	КомпоновщикСКД = Новый КомпоновщикНастроекКомпоновкиДанных;
	
	// Применяем настройки компоновки из параметров
	КомпоновщикСКД.Инициализировать(Новый ИсточникДоступныхНастроекКомпоновкиДанных(СхемаСКД));
		
	Если ЗначениеЗаполнено(НастройкиКомпоновщика) Тогда
		КомпоновщикСКД.ЗагрузитьНастройки(НастройкиКомпоновщика);
	Иначе
		КомпоновщикСКД.ЗагрузитьНастройки(СхемаСКД.НастройкиПоУмолчанию);
	КонецЕсли;
	
	// Установка типа значений для вычисляемых полей СКД, в которых содержится GUID,
	// т.к. иногда значение обрезается (например, макет скд "Склады")
	Для Каждого ВычисляемоеПоле Из СхемаСКД.ВычисляемыеПоля Цикл
		Если Найти(ВРег(ВычисляемоеПоле.ПутьКДанным), "GUID") > 0
			И Не ЗначениеЗаполнено(ВычисляемоеПоле.ТипЗначения) Тогда
			ВычисляемоеПоле.ТипЗначения = Новый ОписаниеТипов("Строка");
		КонецЕсли;
	КонецЦикла;
	
	// По параметрам онлайн определяем, нужно ли очищать ИдРодителя на верхнем уровне иерархического справочника
	Если ИмяТаблицы <> "Номенклатура" Тогда
		ГлЯдро_УстановитьФлагПроверкиРодителейИерархическогоСправочника(ИмяТаблицы, ПараметрыОнлайн, ПараметрыВыгрузки, АдресаПеременных);
	КонецЕсли;
	
	// Дополняем онлайн-таблицу (не номенклатура) допусловиями
	Если ИмяТаблицы <> "Номенклатура" И ПараметрыОнлайн <> "" И НЕ ПараметрыОнлайн.IsValueItem Тогда
		МетаданныеНСИ = ГлЯдро_ПолучитьМетаданныеНСИ(АдресаПеременных);
		
		СпособВыгрузки = "";
		Если ТипЗнч(ПараметрыВыгрузки) = Тип("Структура") Тогда
			Если ПараметрыВыгрузки.Свойство("СпособВыгрузки") Тогда
				СпособВыгрузки = ПараметрыВыгрузки.СпособВыгрузки;
			КонецЕсли;
		КонецЕсли;		
		Если СпособВыгрузки = "ПроизвольныйЗапрос" Тогда
			ГлЯдро_УстановитьОтборКомпоновщикаДляВыгрузкиТаблицПроизвольнымЗапросом(ИмяТаблицы, ПараметрыОнлайн, КомпоновщикСКД.Настройки.Отбор.Элементы, МетаданныеНСИ, КомпоновщикСКД.Настройки.ПараметрыДанных.Элементы, АдресаПеременных);
		Иначе
			ГлЯдро_УстановитьОтборКомпоновщикаДляВыгрузкиТаблиц(ИмяТаблицы, ПараметрыОнлайн, КомпоновщикСКД.Настройки.Отбор.Элементы, МетаданныеНСИ, КомпоновщикСКД.Настройки.ПараметрыДанных.Элементы, АдресаПеременных);
		КонецЕсли;
	КонецЕсли;
		
	Если ИмяТаблицы = "Номенклатура" Тогда
		ГлЯдро_УстановитьПараметрыСКДДляНоменклатуры(КомпоновщикСКД, ПараметрыОнлайн, АдресаПеременных);
	ИначеЕсли ИмяТаблицы = "Цены" Тогда
		ГлЯдро_ЗаполнитьЗначениеПараметраКомпоновщикаНастроекСКД(КомпоновщикСКД, "ОснованаяЦена", Конф_ПолучитьПустуюСсылкуСправочника("ОсновнаяЦена", АдресаПеременных), АдресаПеременных);
	КонецЕсли;
	
	// Вторым параметром передаем значения глобальных параметров (в отдельном методе для номенклатуры - передаем ПараметрыОнлайн)
	ГлЯдро_ОбработатьПараметрыСКД(ИмяТаблицы, ПараметрыКомпоновщика, КомпоновщикСКД, АдресаПеременных);
	
	РезультатНастройкиКомпоновки = КомпоновщикСКД.ПолучитьНастройки();
	
	// Добавляем все поля для макета компоновки
	ГруппировкаДокументов = РезультатНастройкиКомпоновки.Структура.Добавить(Тип("ГруппировкаКомпоновкиДанных"));
	Для Каждого ПолеЗапроса Из СхемаСКД.НастройкиПоУмолчанию.Выбор.Элементы Цикл
		ВыбранноеПоле = РезультатНастройкиКомпоновки.Выбор.Элементы.Добавить(Тип("ВыбранноеПолеКомпоновкиДанных"));
		ВыбранноеПоле.Заголовок = ПолеЗапроса.Поле;
		ВыбранноеПоле.Использование = Истина;
		ВыбранноеПоле.Поле = Новый ПолеКомпоновкиДанных(ПолеЗапроса.Поле);
		ПолеГруппировки = ГруппировкаДокументов.ПоляГруппировки.Элементы.Добавить(Тип("ПолеГруппировкиКомпоновкиДанных"));    
		ПолеГруппировки.Использование = Истина;
		ПолеГруппировки.Поле = Новый ПолеКомпоновкиДанных(ПолеЗапроса.Поле);
	КонецЦикла;
	
	Если ИмяТаблицы = "Номенклатура" И ОтборПоНоменклатуре <> Неопределено Тогда
		НовыйЭлементОтбора = РезультатНастройкиКомпоновки.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));		
		НовыйЭлементОтбора.ЛевоеЗначение = Новый ПолеКомпоновкиДанных("Номенклатура");
		НовыйЭлементОтбора.Использование = Истина;
		НовыйЭлементОтбора.ВидСравнения = ВидСравненияКомпоновкиДанных.ВСпискеПоИерархии;
		НовыйЭлементОтбора.ПравоеЗначение = ОтборПоНоменклатуре;
	КонецЕсли;	
	
	// Если это онлайн запрос списка справочника, ограничим его 196 строкой, для этого в макете СКД должны быть вставки для применения ограничения
	Если ПараметрыОнлайн <> ""
		И ((ИмяТаблицы = "Номенклатура" 
			И ((ПараметрыОнлайн.Режим = "СписокНоменклатуры") 
				ИЛИ (ПараметрыОнлайн.Режим = "ПоискПоЧастиНаименования") 
				ИЛИ (ПараметрыОнлайн.Режим = "СписокНоменклатурыДляГрупп") 
				ИЛИ (ПараметрыОнлайн.Режим = "СписокУпаковокДляНоменклатуры")) 
			Или ИмяТаблицы <> "Номенклатура")) Тогда
		ЗапросСКД = СхемаСКД.НаборыДанных[ИмяТаблицы].Запрос;
		ЗапросСКД = СтрЗаменить(ЗапросСКД,"//%ПЕРВЫЕ_N%", " ПЕРВЫЕ 196 ");
		ЗапросСКД = СтрЗаменить(ЗапросСКД,"//%УПОРЯДОЧИТЬ", "УПОРЯДОЧИТЬ");
		СхемаСКД.НаборыДанных[ИмяТаблицы].Запрос =  ЗапросСКД;
	КонецЕсли;
	
	// Выполняем компоновку макета
	КомпоновщикМакета = Новый КомпоновщикМакетаКомпоновкиДанных;
	Попытка
		МакетКомпоновки = КомпоновщикМакета.Выполнить(СхемаСКД, РезультатНастройкиКомпоновки,,,Тип("ГенераторМакетаКомпоновкиДанныхДляКоллекцииЗначений"),ЛОЖЬ);
	Исключение
		ИнфоОбОшибке = ИнформацияОбОшибке();
		ТекстСообщения = "Ошибка при получении таблицы данных " + ИмяТаблицы + "." + Символы.ПС;
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", ТекстСообщения + ПодробноеПредставлениеОшибки(ИнфоОбОшибке),, АдресаПеременных);
		Сообщить(ТекстСообщения + КраткоеПредставлениеОшибки(ИнфоОбОшибке));		
		Возврат Новый ТаблицаЗначений;
	КонецПопытки;
			
	ПроцессорКомпоновки = Новый ПроцессорКомпоновкиДанных;
	ПроцессорКомпоновки.Инициализировать(МакетКомпоновки,,, Истина);
	ПроцессорВывода = Новый ПроцессорВыводаРезультатаКомпоновкиДанныхВКоллекциюЗначений;
		 
	НачалоЗамера = ТекущаяУниверсальнаяДатаВМиллисекундах();
	
	ТаблицаЗначений = ПроцессорВывода.Вывести(ПроцессорКомпоновки);
	
	КонецЗамера = ТекущаяУниверсальнаяДатаВМиллисекундах();
	ВремяВыполнения = Строка((КонецЗамера-НачалоЗамера)/1000)+ " с.";
	
	ТекстСообщения = "Время вывода таблицы значений через ПроцессорВывода.Вывести(): "+ВремяВыполнения+"Конец"; // Слово "Конец" добавлено чтоб можно было удобно фильтровать ЖР по нему для замеров
	ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", ТекстСообщения,, АдресаПеременных);
	
	Возврат ТаблицаЗначений;
	
КонецФункции

Процедура ГлЯдро_ВыгрузитьТаблицуНаСерверSMARTSВФоне(Знач Параметры, Знач АдресРезультата) Экспорт

	ИмяСобытия = "ГлЯдро_ВыгрузитьТаблицуНаСерверSMARTSВФоне";
	
	// Вместо адресов переменных используем значения переменных, т.к. ФЗ выполняется в другом сеансе, 
	// поэтому временное хранилище родительского сеанса не доступно в сеансе ФЗ
	АдресаПеременных 				= Параметры.ЗначенияПеременных;
	МассивАдресовПустыхЗначений 	= Параметры.МассивАдресовПустыхЗначений;
	ИмяТаблицы						= Параметры.ИмяТаблицы;
	НастройкиКомпоновщика			= Параметры.НастройкиКомпоновщика;
	ПараметрыКомпоновщика			= Параметры.ПараметрыКомпоновщика;
	ТипБазы							= Параметры.ТипБазы;
	ОчищатьСправочникПередВыгрузкой = Параметры.ОчищатьСправочникПередВыгрузкой;
	РаботаБезАлкоголя				= Параметры.РаботаБезАлкоголя;
	ПараметрыВыгрузки				= Параметры.ПараметрыВыгрузки;
	
	АдресаПеременных.Вставить("ЭтоФоновоеЗадание", Истина);
	РезультатВыгрузки = ГлЯдро_ВыгрузитьТаблицуНаСерверSMARTS(ИмяТаблицы, НастройкиКомпоновщика, ПараметрыКомпоновщика, 
		ТипБазы, ОчищатьСправочникПередВыгрузкой, РаботаБезАлкоголя, ПараметрыВыгрузки, АдресаПеременных);
	АдресаПеременных.Удалить("ЭтоФоновоеЗадание");

    ГлЯдро_ПересохранитьЗначенияПеременныхВФЗ(АдресаПеременных, МассивАдресовПустыхЗначений);
	
	СтруктураРезультата = Новый Структура;
	СтруктураРезультата.Вставить("РезультатВыгрузки", 	РезультатВыгрузки);
	СтруктураРезультата.Вставить("АдресаПеременных", 	АдресаПеременных);
	
	ПоместитьВоВременноеХранилище(СтруктураРезультата, АдресРезультата);
	
КонецПроцедуры

Процедура ГлЯдро_ВыгрузитьТаблицуНаСерверSMARTSПорциямиВФоне(Знач Параметры, Знач АдресРезультата) Экспорт

	ИмяСобытия = "ГлЯдро_ВыгрузитьТаблицуНаСерверSMARTSПорциямиВФоне";
	
	// Вместо адресов переменных используем значения переменных, т.к. ФЗ выполняется в другом сеансе, 
	// поэтому временное хранилище родительского сеанса не доступно в сеансе ФЗ
	АдресаПеременных 				= Параметры.ЗначенияПеременных;
	МассивАдресовПустыхЗначений 	= Параметры.МассивАдресовПустыхЗначений;
	ИмяТаблицы						= Параметры.ИмяТаблицы;
	НастройкиКомпоновщика			= Параметры.НастройкиКомпоновщика;
	ПараметрыКомпоновщика			= Параметры.ПараметрыКомпоновщика;
	ТипБазы							= Параметры.ТипБазы;
	ОчищатьСправочникПередВыгрузкой = Параметры.ОчищатьСправочникПередВыгрузкой;
	РазмерПорцииНоменклатуры 		= Параметры.РазмерПорцииНоменклатуры;
	РаботаБезАлкоголя				= Параметры.РаботаБезАлкоголя;
	ПараметрыВыгрузки				= Параметры.ПараметрыВыгрузки;
	
	АдресаПеременных.Вставить("ЭтоФоновоеЗадание", Истина);
	РезультатВыгрузки = ГлЯдро_ВыгрузитьТаблицуНаСерверSMARTSПорциями(ИмяТаблицы, НастройкиКомпоновщика, ПараметрыКомпоновщика, 
		ТипБазы, ОчищатьСправочникПередВыгрузкой, РазмерПорцииНоменклатуры, РаботаБезАлкоголя, ПараметрыВыгрузки, АдресаПеременных);
	АдресаПеременных.Удалить("ЭтоФоновоеЗадание");

    ГлЯдро_ПересохранитьЗначенияПеременныхВФЗ(АдресаПеременных, МассивАдресовПустыхЗначений);
	
	СтруктураРезультата = Новый Структура;
	СтруктураРезультата.Вставить("РезультатВыгрузки", 	РезультатВыгрузки);
	СтруктураРезультата.Вставить("АдресаПеременных", 	АдресаПеременных);
	
	ПоместитьВоВременноеХранилище(СтруктураРезультата, АдресРезультата);
	
КонецПроцедуры

#КонецОбласти

#КонецОбласти

#КонецОбласти

#Область ГлобальныйКонтекст_СправочникиИТаблицы_ПечатьЭтикеток

Функция ГлЯдро_ПолучитьСписокПолейШаблона(СтруктураПараметров, АдресаПеременных) Экспорт
	
	СтруктураИО = КомЯдро_ПолучитьЗначениеПеременной("ИнтеграционнаяОбработка", АдресаПеременных);
		
	Если (СтруктураИО = Неопределено
		ИЛИ НЕ ТипЗнч(СтруктураИО) = Тип("Структура")
		ИЛИ НЕ СтруктураИО.Свойство("ИнтеграционнаяОбработка")
		ИЛИ СтруктураИО.ИнтеграционнаяОбработка = Неопределено)
		И НЕ ГлЯдро_ПересоздатьИнтеграционнуюОбработку(АдресаПеременных) Тогда
		Возврат Неопределено;
	КонецЕсли;
	СтруктураИО = КомЯдро_ПолучитьЗначениеПеременной("ИнтеграционнаяОбработка", АдресаПеременных);
	ИнтеграционнаяОбработка = СтруктураИО.ИнтеграционнаяОбработка;
	
	// в инт. обработке может не существовать данного метода
	Попытка
		СписокПолейШаблона = ИнтеграционнаяОбработка.ПолучитьСписокПолейШаблона(СтруктураПараметров);	
	Исключение
		ТекстОшибки = "Не удалось получить список полей шаблона в интеграционной обработке: " + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации("ГлЯдро_ПолучитьСписокПолейШаблона", "Предупреждение", ТекстОшибки, , АдресаПеременных);
		
		СписокПолейШаблона = Неопределено;		
	КонецПопытки;
	
	Возврат СписокПолейШаблона;
	
КонецФункции

Функция ГлЯдро_ПодготовитьСтруктуруМакетаШаблона(СтруктураПараметров, АдресаПеременных) Экспорт
	
	ШаблонЭтикетки 	= СтруктураПараметров.ШаблонЭтикетки;
	ИмяТаблицы 		= СтруктураПараметров.ИмяТаблицы;
	
	ВстроенныйМакет = ТипЗнч(ШаблонЭтикетки) = Тип("ТабличныйДокумент");
	
	ПолеТабличногоДокумента	= Неопределено;
	СтруктураМакетаШаблона 	= Неопределено;
	
	Если НЕ ВстроенныйМакет Тогда
		РеквизитыСправочника = ШаблонЭтикетки.Метаданные().Реквизиты;
		Если РеквизитыСправочника.Найти("Шаблон") <> Неопределено 
			И ТипЗнч(ШаблонЭтикетки.Шаблон) = Тип("ХранилищеЗначения") Тогда
			СтруктураМакетаШаблона = ШаблонЭтикетки.Шаблон.Получить();
		Иначе
		    Для каждого Реквизит ИЗ РеквизитыСправочника Цикл
				Если Реквизит.Тип.СодержитТип(Тип("ХранилищеЗначения")) Тогда
					СтруктураМакетаШаблона = ШаблонЭтикетки[Реквизит.Имя].Получить();
					Если СтруктураМакетаШаблона <> Неопределено Тогда
						Прервать;					
					КонецЕсли;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
	
		Если СтруктураМакетаШаблона <> Неопределено
			И ТипЗнч(СтруктураМакетаШаблона) = Тип("Структура") Тогда
			Если СтруктураМакетаШаблона.Свойство("РедакторТабличныйДокумент") Тогда
				ПолеТабличногоДокумента = СтруктураМакетаШаблона.РедакторТабличныйДокумент;	
			Иначе	
				Для каждого КлючЗначение ИЗ СтруктураМакетаШаблона Цикл
					Если ТипЗнч(КлючЗначение.Значение) = Тип("ТабличныйДокумент") Тогда
						ПолеТабличногоДокумента = КлючЗначение.Значение;
						Прервать;						
					КонецЕсли;					
				КонецЦикла;
			КонецЕсли;
		КонецЕсли;
		
		Если ПолеТабличногоДокумента = Неопределено Тогда
			Возврат Неопределено;		
		КонецЕсли;
	Иначе
		ПолеТабличногоДокумента = ШаблонЭтикетки;		
	КонецЕсли;
	
	Если СтруктураМакетаШаблона = Неопределено Тогда
		СтруктураМакетаШаблона = Новый Структура;
	КонецЕсли;
	
	ПараметрыШаблона       = Новый Соответствие;
	СчетчикПараметров      = 0;
	ПрефиксИмениПараметра  = "ПараметрМакета";
	
	Если НЕ СтруктураМакетаШаблона.Свойство("МакетЭтикетки") Тогда
		
		ИмяПараметраШтрихкод   = "Штрихкод";
		ИмяПараметраКодВалюты  = "ВидЦены.ВалютаЦены.Код";
		
		Если ПолеТабличногоДокумента <> Неопределено Тогда
			Если ПолеТабличногоДокумента.ОбластьПечати = Неопределено Тогда
				ПолеТабличногоДокумента.ОбластьПечати = ПолеТабличногоДокумента.Область("R1C1:"+"R"+ПолеТабличногоДокумента.ВысотаТаблицы+"C"+ПолеТабличногоДокумента.ШиринаТаблицы);
			КонецЕсли;	
			ОбластьМакетаЭтикетки = ПолеТабличногоДокумента.ПолучитьОбласть(ПолеТабличногоДокумента.ОбластьПечати.Имя);
			
			ОбластьМакетаЭтикетки.АвтоМасштаб 				= ПолеТабличногоДокумента.АвтоМасштаб;
			ОбластьМакетаЭтикетки.ВысотаСтраницы 			= ПолеТабличногоДокумента.ВысотаСтраницы;
			ОбластьМакетаЭтикетки.ИмяПараметровПечати 		= ПолеТабличногоДокумента.ИмяПараметровПечати;
			ОбластьМакетаЭтикетки.ИмяПринтера 				= ПолеТабличногоДокумента.ИмяПринтера;
			ОбластьМакетаЭтикетки.КлючПараметровПечати 		= ПолеТабличногоДокумента.КлючПараметровПечати;
			ОбластьМакетаЭтикетки.КоличествоЭкземпляров 	= ПолеТабличногоДокумента.КоличествоЭкземпляров;
			ОбластьМакетаЭтикетки.МасштабПечати 			= ПолеТабличногоДокумента.МасштабПечати;
			ОбластьМакетаЭтикетки.ОриентацияСтраницы 		= ПолеТабличногоДокумента.ОриентацияСтраницы;
			ОбластьМакетаЭтикетки.ПолеСверху 				= ПолеТабличногоДокумента.ПолеСверху;
			ОбластьМакетаЭтикетки.ПолеСлева 				= ПолеТабличногоДокумента.ПолеСлева;
			ОбластьМакетаЭтикетки.ПолеСнизу 				= ПолеТабличногоДокумента.ПолеСнизу;
			ОбластьМакетаЭтикетки.ПолеСправа 				= ПолеТабличногоДокумента.ПолеСправа;
			ОбластьМакетаЭтикетки.РазборПоКопиям 			= ПолеТабличногоДокумента.РазборПоКопиям;
			ОбластьМакетаЭтикетки.РазмерКолонтитулаСверху 	= ПолеТабличногоДокумента.РазмерКолонтитулаСверху;
			ОбластьМакетаЭтикетки.РазмерКолонтитулаСнизу 	= ПолеТабличногоДокумента.РазмерКолонтитулаСнизу;
			ОбластьМакетаЭтикетки.РазмерСтраницы 			= ПолеТабличногоДокумента.РазмерСтраницы;
			ОбластьМакетаЭтикетки.ТочностьПечати 			= ПолеТабличногоДокумента.ТочностьПечати;
			ОбластьМакетаЭтикетки.ЧерноБелаяПечать 			= ПолеТабличногоДокумента.ЧерноБелаяПечать;
			ОбластьМакетаЭтикетки.ШиринаСтраницы 			= ПолеТабличногоДокумента.ШиринаСтраницы;
			ОбластьМакетаЭтикетки.ЭкземпляровНаСтранице 	= ПолеТабличногоДокумента.ЭкземпляровНаСтранице;
			
			ОбластьМакетаЭтикетки.ОбластьПечати = ОбластьМакетаЭтикетки.Область("R1C1:"+"R"+ОбластьМакетаЭтикетки.ВысотаТаблицы+"C"+ОбластьМакетаЭтикетки.ШиринаТаблицы);
			
			Для НомерКолонки = 1 По ОбластьМакетаЭтикетки.ШиринаТаблицы Цикл
				Для НомерСтроки = 1 По ОбластьМакетаЭтикетки.ВысотаТаблицы Цикл
					Ячейка = ОбластьМакетаЭтикетки.Область(НомерСтроки, НомерКолонки);
					Если Ячейка.Заполнение = ТипЗаполненияОбластиТабличногоДокумента.Шаблон Тогда
						МассивПараметров = ГлЯдро_ПозицииПараметровШаблона(Ячейка.Текст);
						
						КоличествоПараметров = МассивПараметров.Количество();
						Для Индекс = 0 По КоличествоПараметров - 1 Цикл
							Структура = МассивПараметров[КоличествоПараметров - 1 - Индекс];
							
							ИмяПараметра = Сред(Ячейка.Текст, Структура.Начало + 1, Структура.Конец - Структура.Начало - 1);
							Если ГлЯдро_СтрНайти(ИмяПараметра, ПрефиксИмениПараметра) = 0 Тогда
								ЛеваяЧасть = Лев(Ячейка.Текст, Структура.Начало);
								ПраваяЧасть = Прав(Ячейка.Текст, СтрДлина(Ячейка.Текст) - Структура.Конец+1);
								
								СохраненноеИмяПараметраМакета = ПараметрыШаблона.Получить(ИмяПараметра);
								Если СохраненноеИмяПараметраМакета = Неопределено Тогда
									СчетчикПараметров = СчетчикПараметров + 1;
									Ячейка.Текст = ЛеваяЧасть + (ПрефиксИмениПараметра + СчетчикПараметров) + ПраваяЧасть;
									ПараметрыШаблона.Вставить(ИмяПараметра, ПрефиксИмениПараметра + СчетчикПараметров);
								Иначе
									Ячейка.Текст = ЛеваяЧасть + (СохраненноеИмяПараметраМакета) + ПраваяЧасть;
								КонецЕсли;
							КонецЕсли;
						КонецЦикла;
					ИначеЕсли Ячейка.Заполнение = ТипЗаполненияОбластиТабличногоДокумента.Параметр Тогда
						Если ГлЯдро_СтрНайти(Ячейка.Параметр, ПрефиксИмениПараметра) = 0 Тогда
							СохраненноеИмяПараметраМакета = ПараметрыШаблона.Получить(Ячейка.Параметр);
							Если СохраненноеИмяПараметраМакета = Неопределено Тогда
								СчетчикПараметров = СчетчикПараметров + 1;
								ПараметрыШаблона.Вставить(Ячейка.Параметр, ПрефиксИмениПараметра + СчетчикПараметров);
								Ячейка.Параметр = ПрефиксИмениПараметра + СчетчикПараметров;
							Иначе
								Ячейка.Параметр = СохраненноеИмяПараметраМакета;
							КонецЕсли;
						КонецЕсли;
					КонецЕсли;
				КонецЦикла;
			КонецЦикла;
			
			ТребуетсяПараметрШтрихкод = ПараметрыШаблона.Получить(ИмяПараметраШтрихкод) = Неопределено;
			ТребуетсяПараметрКодВалюты = ПараметрыШаблона.Получить(ИмяПараметраКодВалюты) = Неопределено;
			
			// Вставляем в параметры штрихкод
			Для Каждого Рисунок Из ОбластьМакетаЭтикетки.Рисунки Цикл
				Если ГлЯдро_СтрНайти(Рисунок.Имя, ИмяПараметраШтрихкод) = 1 Тогда
					Если ТребуетсяПараметрШтрихкод Тогда
						ПараметрыШаблона.Вставить(ИмяПараметраШтрихкод, ПрефиксИмениПараметра + (СчетчикПараметров+1));
					КонецЕсли;
					// Заменяем на пустую картинку.
					Рисунок.Картинка = Новый Картинка;
				КонецЕсли;
				Если ГлЯдро_СтрНайти(Рисунок.Имя, "ЗнакВалюты") = 1 Тогда
					Если ТребуетсяПараметрКодВалюты Тогда
						ПараметрыШаблона.Вставить(ИмяПараметраКодВалюты, ПрефиксИмениПараметра + (СчетчикПараметров+1));
					КонецЕсли;
					// Заменяем на пустую картинку.
					Рисунок.Картинка = Новый Картинка;
				КонецЕсли;
			КонецЦикла;
			
			СтруктураМакетаШаблона.Вставить("МакетЭтикетки",    ОбластьМакетаЭтикетки);
			СтруктураМакетаШаблона.Вставить("ИмяОбластиПечати", ОбластьМакетаЭтикетки.ОбластьПечати.Имя);
		Иначе
			СтруктураМакетаШаблона.Вставить("МакетЭтикетки");
			СтруктураМакетаШаблона.Вставить("ИмяОбластиПечати");
		КонецЕсли;
		
	КонецЕсли;
	
	Масштабировать = Истина;
	
	Если НЕ СтруктураМакетаШаблона.Свойство("ТипКода") Тогда
		
		Если ИмяТаблицы = "Ячейки"
			ИЛИ ИмяТаблицы = "Серии" Тогда
			ТипКода = 4;  // Code128
		ИначеЕсли ИмяТаблицы = "ТранспортныеУпаковки" Тогда
			ТипКода = 4;  // 17; // GS-1 Databar Expanded Stacked
			Масштабировать = Ложь;
		Иначе
			ТипКода = 1;  // EAN13
		КонецЕсли;
		
		//Если // ЭтикеткаДляАкцизныхМарок
		//	ТипКода = 6;  // PDF417
		//ИначеЕсли // ЭтикеткаКодМаркировкиИСМП
		//	ТипКода = 24;  // DataMatrix
		//	Масштабировать = Ложь;
		//КонецЕсли;
		
		СтруктураМакетаШаблона.Вставить("ТипКода", ТипКода);
		
	КонецЕсли;
	
	Если НЕ СтруктураМакетаШаблона.Свойство("ТипШтрихкода") Тогда
		СтруктураМакетаШаблона.Вставить("ТипШтрихкода", Неопределено);
	КонецЕсли;
	Если НЕ СтруктураМакетаШаблона.Свойство("РазмерШрифта") Тогда
		СтруктураМакетаШаблона.Вставить("РазмерШрифта", 12);
	КонецЕсли;
	Если НЕ СтруктураМакетаШаблона.Свойство("УровеньЧеткости") Тогда
		СтруктураМакетаШаблона.Вставить("УровеньЧеткости", 1);
	КонецЕсли;
	Если НЕ СтруктураМакетаШаблона.Свойство("МонохромныйШрифт") Тогда
		СтруктураМакетаШаблона.Вставить("МонохромныйШрифт", Истина);
	КонецЕсли;
	Если НЕ СтруктураМакетаШаблона.Свойство("GS1DatabarКоличествоСтрок") Тогда
		СтруктураМакетаШаблона.Вставить("GS1DatabarКоличествоСтрок", 102);
	КонецЕсли;
	Если НЕ СтруктураМакетаШаблона.Свойство("УголПоворота") Тогда
		СтруктураМакетаШаблона.Вставить("УголПоворота", 0);
	КонецЕсли;
	Если НЕ СтруктураМакетаШаблона.Свойство("Масштабировать") Тогда
		СтруктураМакетаШаблона.Вставить("Масштабировать", Масштабировать);
	КонецЕсли;
	Если НЕ СтруктураМакетаШаблона.Свойство("СохранятьПропорции") Тогда
		СтруктураМакетаШаблона.Вставить("СохранятьПропорции", Ложь);
	КонецЕсли;
	Если НЕ СтруктураМакетаШаблона.Свойство("ВертикальноеВыравнивание") Тогда
		СтруктураМакетаШаблона.Вставить("ВертикальноеВыравнивание", 1);
	КонецЕсли;
	
	Если НЕ СтруктураМакетаШаблона.Свойство("ОтображатьТекст") Тогда
		СтруктураМакетаШаблона.Вставить("ОтображатьТекст", Истина);
	КонецЕсли;
	Если НЕ СтруктураМакетаШаблона.Свойство("ПараметрыШаблона") Тогда
		СтруктураМакетаШаблона.Вставить("ПараметрыШаблона", ПараметрыШаблона);
	КонецЕсли;
	Если НЕ СтруктураМакетаШаблона.Свойство("РедакторТабличныйДокумент") Тогда
		СтруктураМакетаШаблона.Вставить("РедакторТабличныйДокумент", ПолеТабличногоДокумента);
	КонецЕсли;
	
	Если НЕ СтруктураМакетаШаблона.Свойство("КоличествоПоВертикали") Тогда
        СтруктураМакетаШаблона.Вставить("КоличествоПоВертикали", 1);
	КонецЕсли;
	Если НЕ СтруктураМакетаШаблона.Свойство("КоличествоПоГоризонтали") Тогда
		СтруктураМакетаШаблона.Вставить("КоличествоПоГоризонтали", 1);
	КонецЕсли;
	
	Возврат СтруктураМакетаШаблона;	
	
КонецФункции

Функция ГлЯдро_ПозицииПараметровШаблона(ТекстЯчейки) Экспорт
	
	Массив = Новый Массив;
	
	Начало = -1;
	Конец  = -1;
	СчетчикСкобокОткрывающих = 0;
	СчетчикСкобокЗакрывающих = 0;
	
	Для Индекс = 1 По СтрДлина(ТекстЯчейки) Цикл
		Символ = Сред(ТекстЯчейки, Индекс, 1);
		Если Символ = "[" Тогда
			СчетчикСкобокОткрывающих = СчетчикСкобокОткрывающих + 1;
			Если СчетчикСкобокОткрывающих = 1 Тогда
				Начало = Индекс;
			КонецЕсли;
		ИначеЕсли Символ = "]" Тогда
			СчетчикСкобокЗакрывающих = СчетчикСкобокЗакрывающих + 1;
			Если СчетчикСкобокЗакрывающих = СчетчикСкобокОткрывающих Тогда
				Конец = Индекс;
				
				Массив.Добавить(Новый Структура("Начало, Конец", Начало, Конец));
				
				Начало = -1;
				Конец  = -1;
				СчетчикСкобокОткрывающих = 0;
				СчетчикСкобокЗакрывающих = 0;
				
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Массив;
	
КонецФункции

Функция ГлЯдро_СформироватьПечатнуюФормуЭтикетки(СтруктураПараметров, АдресаПеременных) Экспорт
	
	СтруктураИО = КомЯдро_ПолучитьЗначениеПеременной("ИнтеграционнаяОбработка", АдресаПеременных);
		
	Если (СтруктураИО = Неопределено
		ИЛИ НЕ ТипЗнч(СтруктураИО) = Тип("Структура")
		ИЛИ НЕ СтруктураИО.Свойство("ИнтеграционнаяОбработка")
		ИЛИ СтруктураИО.ИнтеграционнаяОбработка = Неопределено)
		И НЕ ГлЯдро_ПересоздатьИнтеграционнуюОбработку(АдресаПеременных) Тогда
		Возврат Неопределено;
	КонецЕсли;
	СтруктураИО = КомЯдро_ПолучитьЗначениеПеременной("ИнтеграционнаяОбработка", АдресаПеременных);
	ИнтеграционнаяОбработка = СтруктураИО.ИнтеграционнаяОбработка;
	
	// в инт. обработке может не существовать данного метода
	Попытка
		ТабличныйДокумент = ИнтеграционнаяОбработка.СформироватьПечатнуюФормуЭтикетки(СтруктураПараметров);	
	Исключение
		ТекстОшибки = "Не удалось сформировать печатную форму этикетки в интеграционной обработке: " + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации("ГлЯдро_СформироватьПечатнуюФормуЭтикетки", "Предупреждение", ТекстОшибки, , АдресаПеременных);	
	КонецПопытки;
	
	Если ТабличныйДокумент <> Неопределено Тогда
		Возврат ТабличныйДокумент;	
	КонецЕсли;
	
	// Если табличный документ не сформирован в интеграционной обработке, формируем его общим методом
	
	СтруктураШаблона = СтруктураПараметров.СтруктураШаблона;
	ДанныеДляПечати = СтруктураПараметров.ДанныеДляПечати;	
	
	КоличествоЭкземпляров = 1;
	
	ТабличныйДокумент = Новый ТабличныйДокумент;
	
	НомерКолонки = 0;
	НомерРяда = 0;
	
	Область = СтруктураШаблона.МакетЭтикетки.ПолучитьОбласть(СтруктураШаблона.ИмяОбластиПечати);
	
	Для Каждого СтрокаТаблицы Из ДанныеДляПечати Цикл
		
		ЗаполнитьЗначенияСвойств(ТабличныйДокумент, СтруктураШаблона.МакетЭтикетки, , "ОбластьПечати");
		
		НомерСтрокиНачало = ТабличныйДокумент.ВысотаТаблицы + 1;
	
		Для каждого ПараметрШаблона Из СтруктураШаблона.ПараметрыШаблона Цикл
			КлючСтруктуры = ПараметрШаблона.Ключ;
			Пока Найти(КлючСтруктуры, ".") Цикл
				КлючСтруктуры = СтрЗаменить(КлючСтруктуры, ".", "_СимволТочки_");				
			КонецЦикла;
			Если НЕ КлючСтруктуры = "Штрихкод" Тогда
				Попытка	
					Область.Параметры[ПараметрШаблона.Значение] = ?(СтрокаТаблицы.Свойство(КлючСтруктуры), СтрокаТаблицы[КлючСтруктуры], "");
				Исключение                                                 
					ТекстОшибки = "При установке параметра макета возникла ошибка: " + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
					ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации("ГлЯдро_СформироватьПечатнуюФормуЭтикетки", "Ошибка", ТекстОшибки, , АдресаПеременных);	
				КонецПопытки;
			КонецЕсли;
		КонецЦикла;
		
		// Заполнить картинки штрихкодов
		Попытка
			ИнтеграционнаяОбработка.ЗаполнитьКартинкиШтрихкодов(Новый Структура("Область,СтруктураШаблона,СтрокаТаблицы", Область, СтруктураШаблона, СтрокаТаблицы));
		Исключение
			ТекстОшибки = "Не удалось заполнить картинки штрихкодов в интеграционной обработке: " + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
			ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации("ГлЯдро_СформироватьПечатнуюФормуЭтикетки", "Предупреждение", ТекстОшибки, , АдресаПеременных);		
		КонецПопытки;
		
		Для Инд = 1 По КоличествоЭкземпляров Цикл // Цикл по количеству экземпляров
			НомерКолонки = НомерКолонки + 1;
			Если НомерКолонки = 1 Тогда
				НомерРяда = НомерРяда + 1;
				ТабличныйДокумент.Вывести(Область);
			Иначе
				ТабличныйДокумент.Присоединить(Область);
			КонецЕсли;
			
			Если НомерКолонки = СтруктураШаблона.КоличествоПоГоризонтали
				И НомерРяда = СтруктураШаблона.КоличествоПоВертикали Тогда
				
				НомерРяда    = 0;
				НомерКолонки = 0;
				
				ТабличныйДокумент.ВывестиГоризонтальныйРазделительСтраниц();
				
			ИначеЕсли НомерКолонки = СтруктураШаблона.КоличествоПоГоризонтали Тогда
				НомерКолонки = 0;
			КонецЕсли;
		КонецЦикла; // Цикл по количеству экземпляров
		
	КонецЦикла;
	
	Возврат ТабличныйДокумент;
	
КонецФункции

Процедура ГлЯдро_ЗаполнитьКартинкиШтрихкодов(СтруктураПараметров, АдресаПеременных) Экспорт
	
	СтруктураИО = КомЯдро_ПолучитьЗначениеПеременной("ИнтеграционнаяОбработка", АдресаПеременных);
		
	Если (СтруктураИО = Неопределено
		ИЛИ НЕ ТипЗнч(СтруктураИО) = Тип("Структура")
		ИЛИ НЕ СтруктураИО.Свойство("ИнтеграционнаяОбработка")
		ИЛИ СтруктураИО.ИнтеграционнаяОбработка = Неопределено)
		И НЕ ГлЯдро_ПересоздатьИнтеграционнуюОбработку(АдресаПеременных) Тогда
		Возврат;
	КонецЕсли;
	СтруктураИО = КомЯдро_ПолучитьЗначениеПеременной("ИнтеграционнаяОбработка", АдресаПеременных);
	ИнтеграционнаяОбработка = СтруктураИО.ИнтеграционнаяОбработка;
	
	// в инт. обработке может не существовать данного метода
	Попытка
		ИнтеграционнаяОбработка.ЗаполнитьКартинкиШтрихкодов(СтруктураПараметров);	
	Исключение
		ТекстОшибки = "Не удалось заполнить картинки штрихкодов в интеграционной обработке: " + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации("ГлЯдро_ПолучитьСписокПолейШаблона", "Предупреждение", ТекстОшибки, , АдресаПеременных);	
	КонецПопытки;
	
КонецПроцедуры

#КонецОбласти

#Область ГлобальныйКонтекст_Документы

#Область ГлобальныйКонтекст_Документы_MobileSMARTS

#Область ГлобальныйКонтекст_Документы_MobileSMARTS_ЧтениеДанных

// Вызывает функцию получения таблицы документов из базы Mobile Smarts
//
// Параметры:
//	ТипБазы - Строка - "Частная", "Временная", "Основная"
//  АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
//
// Возвращаемое значение:
//	Массив из Структура - ключами являются имена колонок таблицы документов Mobile Smarts,
//						  значениями - значения соответствующих реквизитов документов Mobile Smarts
Функция ГлЯдро_ПолучитьСписокДокументовНаСервереSMARTS(ТипБазы, РазмерВыборки = 0, ОтборПоПериоду = Неопределено, ОтборПоУзлу = Неопределено, АдресаПеременных) Экспорт
	ПустаяТаблица = ГлЯдро_ПолучитьПустуюТаблицуДокументовSMARTS();
	
	ТипИнтерфейса = ГлЯдро_ПолучитьТипИнтерфейса(ТипБазы, АдресаПеременных); // ТипИнтерфейса = КомЯдро_ПолучитьЗначениеПеременной("ТипИнтерфейса",АдресаПеременных);
	Если ТипИнтерфейса = "REST_API" Тогда
		СписокДокументов = REST_API_ПолучитьСписокДокументовНаСервереSMARTS(ПустаяТаблица, ТипБазы, РазмерВыборки, ОтборПоПериоду, ОтборПоУзлу, АдресаПеременных);
	Иначе
		СписокДокументов = КомЯдро_ПолучитьСписокДокументовНаСервереSMARTS(ПустаяТаблица, ТипБазы, РазмерВыборки, ОтборПоПериоду, ОтборПоУзлу, АдресаПеременных);
	КонецЕсли;
	
	Возврат СписокДокументов;
КонецФункции

// Вызывает функцию получения данных документа на сервере Mobile Smarts и - при необходимости -
// преобразует табличные данные документа из таблиц значений в массивы структур
//
// Параметры:
//	ID_Документа - Строка - идентификатор документа в базе Mobile Smarts	
//	СтруктураДанныхДокументаMS - Структура - см. КомЯдро_ПолучитьМетаданныеДокументовMS.ДокументыMS или REST_API_ПолучитьМетаданныеДокументовMS.ДокументыMS
//  ТипБазы - Строка - "Частная", "Временная", "Основная"
//	КонвертироватьТаблицуЗначенийВМассивСтруктур - Булево - определяет необходимость преобразования табличных данных из таблиц значений в массивы структур
//  ФильтрТЧПоИдДокумента - Неопределено, Строка - фильтр получения табличной части для случая, когда она была объединена из нескольких документов
//  АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
//
// Возвращаемое значение:
//	- Структура	- содержит:
//		* ШапкаДокумента - Структура - содержит значения реквизитов шапки документа Mobile Smarts
//		* СтрокиПлан - ТаблицаЗначений, Массив из Структура - содержит таблицу плановых строк документа Mobile Smarts  	
//		* СтрокиФакт - ТаблицаЗначений, Массив из Структура - содержит таблицу фактических строк документа Mobile Smarts
//		* СовмещенныеСтроки - ТаблицаЗначений, Массив из Структура - содержит таблицу совмещенных строк документа Mobile Smarts
//		* [Имена дополнительных таблиц] - ТаблицаЗначений, Массив из Структура - содержит дополнительные таблицы документа Mobile Smarts
//		* [Имена таблиц Mobile Smarts] - ТаблицаЗначений, Массив из Структура - содержит дополнительные таблицы документа Mobile Smarts, не определенные в метаданных документа Mobile Smarts,
//																				но фактически присутствующие в экземпляре документа
//	- Неопределено - если получить данные документа не удалось
Функция ГлЯдро_ПолучитьДанныеДокументаMS(ID_Документа, СтруктураДанныхДокументаMS, ТипБазы, КонвертироватьТаблицуЗначенийВМассивСтруктур = Ложь, ФильтрТЧПоИдДокумента = Неопределено, ЗапрашиватьCombinedItems = Истина, АдресаПеременных) Экспорт
	
	НачалоСобытия = ТекущаяУниверсальнаяДатаВМиллисекундах();
	ИмяСобытия = "ГлЯдро_ПолучитьДанныеДокументаMS";
	
	ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Начало, Получение данных документа MS: " + Строка(ID_Документа), , АдресаПеременных);
	
	ТипИнтерфейса = ГлЯдро_ПолучитьТипИнтерфейса(ТипБазы, АдресаПеременных); // ТипИнтерфейса = КомЯдро_ПолучитьЗначениеПеременной("ТипИнтерфейса",АдресаПеременных);
	Если ТипИнтерфейса = "REST_API" Тогда
		ДанныеДокументаMS = REST_API_ПолучитьДанныеДокументаНаСервереSMARTS(ID_Документа, СтруктураДанныхДокументаMS, ТипБазы, ФильтрТЧПоИдДокумента, ЗапрашиватьCombinedItems, АдресаПеременных);
	Иначе
		ДанныеДокументаMS = КомЯдро_ПолучитьДанныеДокументаНаСервереSMARTS(ID_Документа, СтруктураДанныхДокументаMS, ТипБазы, ФильтрТЧПоИдДокумента,, АдресаПеременных);
	КонецЕсли;
		
	Если КонвертироватьТаблицуЗначенийВМассивСтруктур Тогда
		Для Каждого КЗ Из ДанныеДокументаMS Цикл
			Если ТипЗнч(КЗ.Значение) = Тип("ТаблицаЗначений") Тогда 
				ДанныеДокументаMS.Вставить(КЗ.Ключ,ГлЯдро_ТаблицуЗначенийВМассивСтруктур(КЗ.Значение));
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Конец, Получение данных документа MS: " + Строка(ID_Документа), НачалоСобытия, АдресаПеременных);
	
	Возврат ДанныеДокументаMS;
	
КонецФункции

#КонецОбласти

#Область ГлобальныйКонтекст_Документы_MobileSMARTS_ЗаписьДанных

// Вызывает функцию получения данных документа 1С для выгрузки и процедуру записи полученных данных в базу Mobile Smarts
//
// Параметры:
//	Документ1С - ДокументСсылка - документ в базе, выгружаемый на сервер Mobile Smarts
//  СписокПередаваемыхНастроек - Неопределено, Структура - содержит:
//		* СписокБизнесПроцессов - Неопределено, ТаблицаЗначений, Массив из Структура - содержит настройки отобранных бизнес-процессов
//		* ПроизвольныеКодыШапки - Неопределено, ТаблицаЗначений, Массив из Структура - содержит произвольные коды для выгрузки шапки документа
//		* ПроизвольныеКодыТабличнойЧасти - Неопределено, ТаблицаЗначений, Массив из Структура - содержит произвольные коды для выгрузки табличных частей документа
//		* ГлобальныеПараметры - Неопределено, ТаблицаЗначений, Массив из Структура - содержит значения глобальных параметров
//  ID_БизнесПроцесса - Строка - идентификатор бизнес-процесса
//  ТипБазы - Строка - "Частная", "Временная", "Основная"
//  НазначенныеПользователи - Неопределено
//							- Строка - идентификторы пользователей или устройств Mobile Smarts, которым назначается документ, разделенные "|"
//							- Массив из Структура - содержит:
//								* Ид - Строка - идентификатор пользователя или устройства Mobile Smarts, которому назначается документ
//                              * Имя - Строка - наименование пользователя или устройства Mobile Smarts, которому назначается документ
//  КопияДляКаждогоПользователя - Булево - признак необходимости создавать отдельную копию выгружаемого документа для каждого из назначенных пользователей
//  СпособНазначения - Строка - "", "Устройству", "Пользователям"
//  АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
Процедура ГлЯдро_СформироватьИЗаписатьДокументВБазуSMARTS(Документ1С, СписокПередаваемыхНастроек, ID_БизнесПроцесса = "", ТипБазы,НазначенныеПользователи,КопияДляКаждогоПользователя = Ложь, СпособНазначения = "", АдресаПеременных) Экспорт
	
	НачалоСобытия = ТекущаяУниверсальнаяДатаВМиллисекундах();
	ИмяСобытия = "ГлЯдро_СформироватьИЗаписатьДокументВБазуSMARTS";
	
	ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Начало, Выгрузка документа в базу SMARTS", , АдресаПеременных);
	
	Если ТипЗнч(Документ1С) = Тип("Массив") Тогда
		МассивДанныхДокументовКОбъединению = Новый Массив;
		СтрокаИдИсходныхДокументов = "";
		Для Каждого ДокументКОбъединению Из Документ1С Цикл
			ДанныеДокумента = ГлЯдро_ПолучитьДанныеДокумента1СДляВыгрузки(ДокументКОбъединению, СписокПередаваемыхНастроек, ID_БизнесПроцесса, АдресаПеременных);
			
			Если ДанныеДокумента = Неопределено Тогда
				Продолжить;
			КонецЕсли;     
			
			МассивДанныхДокументовКОбъединению.Добавить(ДанныеДокумента);
			СтрокаИдИсходныхДокументов = СтрокаИдИсходныхДокументов +?(СтрокаИдИсходныхДокументов="","",";")+ ДанныеДокумента.ШапкаДокумента.Ид;
		КонецЦикла;
		
		// Если во всех документах были критические ошибки - завершаем процесс
		Если Не МассивДанныхДокументовКОбъединению.Количество() Тогда
			ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Конец, Выгрузка документа в базу SMARTS", НачалоСобытия, АдресаПеременных);
			Возврат;
		КонецЕсли;                                             
		
		// В шапке будет информация из первого выбранного документа+ список Ид объединенных документов
		ШапкаДокумента = МассивДанныхДокументовКОбъединению[0].ШапкаДокумента;
		ШапкаДокумента.Вставить("ИдИсходныхДокументов",СтрокаИдИсходныхДокументов);
		
		// добавим ключи всех выгружаемых ТЧ по полученной структуре из первого документа
		ТабличныеЧастиОбъединенные = Новый Структура;			
		Для Каждого ТабличнаяЧасть Из МассивДанныхДокументовКОбъединению[0].ТабличныеЧасти Цикл
			ТабличныеЧастиОбъединенные.Вставить(ТабличнаяЧасть.Ключ, Новый Массив);	
		КонецЦикла;
		
		Для Каждого ДокументКОбъединению Из МассивДанныхДокументовКОбъединению Цикл
			Для Каждого ТабличнаяЧасть Из ДокументКОбъединению.ТабличныеЧасти Цикл 
				Для Каждого СтрокаТЧ Из  ТабличнаяЧасть.Значение Цикл
					СтрокаСтруктурой = СтрокаТЧ;
					СтрокаСтруктурой.Вставить("ИдДокумента",ДокументКОбъединению.ШапкаДокумента.Ид);
					ТабличныеЧастиОбъединенные[ТабличнаяЧасть.Ключ].Добавить(СтрокаСтруктурой);
				КонецЦикла;
			КонецЦикла;
		КонецЦикла;
		
		ДанныеОбъединенногоДокумента = Новый Структура;			
		ДанныеОбъединенногоДокумента.Вставить("ШапкаДокумента",ШапкаДокумента);
		ДанныеОбъединенногоДокумента.Вставить("ТабличныеЧасти", ТабличныеЧастиОбъединенные);
		ДанныеДокумента = ДанныеОбъединенногоДокумента;
	Иначе
				
		ДанныеДокумента = ГлЯдро_ПолучитьДанныеДокумента1СДляВыгрузки(Документ1С, СписокПередаваемыхНастроек, ID_БизнесПроцесса,АдресаПеременных);				
		// Если в документе были критические ошибки, завершаем процесс
		Если ДанныеДокумента = Неопределено Тогда
			ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Конец, Выгрузка документа в базу SMARTS", НачалоСобытия, АдресаПеременных);
			Возврат;
		КонецЕсли;     
		
	КонецЕсли;
	
	ТипИнтерфейса = ГлЯдро_ПолучитьТипИнтерфейса(ТипБазы, АдресаПеременных); // ТипИнтерфейса = КомЯдро_ПолучитьЗначениеПеременной("ТипИнтерфейса",АдресаПеременных);
	
	Если ТипЗнч(НазначенныеПользователи) = Тип("Массив")
		И НазначенныеПользователи.Количество() > 0 Тогда
		НазначенныеПользователиМассив = НазначенныеПользователи;
		НазначенныеПользователиСтрокой = "";
		Для Каждого НазначенныйПользователь ИЗ НазначенныеПользователи Цикл
			НазначенныеПользователиСтрокой = НазначенныеПользователиСтрокой+?(НазначенныеПользователиСтрокой = "","","|")+НазначенныйПользователь.Ид;
		КонецЦикла;
	ИначеЕсли ТипЗнч(НазначенныеПользователи) = Тип("Строка")
		И ЗначениеЗаполнено(НазначенныеПользователи) Тогда
		НазначенныеПользователиМассив = ГлЯдро_РазложитьСтрокуВМассивПодстрок(НазначенныеПользователи, "|");
		НазначенныеПользователиСтрокой = НазначенныеПользователи;
	Иначе
		НазначенныеПользователиМассив = Неопределено;
		НазначенныеПользователиСтрокой = Неопределено;
	КонецЕсли;
	
	Если НазначенныеПользователиМассив <> Неопределено 
		И НазначенныеПользователиСтрокой <> Неопределено Тогда
		Если КопияДляКаждогоПользователя Тогда
			Если ТипИнтерфейса = "REST_API" Тогда
				Для Каждого НазначенныйПользователь ИЗ НазначенныеПользователиМассив Цикл
					ДокументSMARTS  = REST_API_СформироватьНовыйДокументSMARTS(ДанныеДокумента,НазначенныйПользователь.Ид,АдресаПеременных,,СпособНазначения);
					REST_API_ЗаписатьДокументВБазуSMARTS(ДокументSMARTS, ТипБазы, АдресаПеременных);
				КонецЦикла;
			Иначе
				Для Каждого НазначенныйПользователь ИЗ НазначенныеПользователиМассив Цикл
					ДокументSMARTS  = КомЯдро_СформироватьНовыйДокументSMARTS(ДанныеДокумента,НазначенныйПользователь.Ид, СпособНазначения);		
					КомЯдро_ЗаписатьДокументВБазуSMARTS(ДокументSMARTS, ТипБазы,АдресаПеременных);
				КонецЦикла;
			КонецЕсли;
		Иначе
			Если ТипИнтерфейса = "REST_API" Тогда
				ДокументSMARTS  = REST_API_СформироватьНовыйДокументSMARTS(ДанныеДокумента,НазначенныеПользователиСтрокой,АдресаПеременных,,СпособНазначения);
				REST_API_ЗаписатьДокументВБазуSMARTS(ДокументSMARTS, ТипБазы,АдресаПеременных);
			Иначе
				ДокументSMARTS  = КомЯдро_СформироватьНовыйДокументSMARTS(ДанныеДокумента,НазначенныеПользователиСтрокой, СпособНазначения);		
				КомЯдро_ЗаписатьДокументВБазуSMARTS(ДокументSMARTS, ТипБазы,АдресаПеременных);	
			КонецЕсли;
		КонецЕсли;
		
	Иначе
		Если ТипИнтерфейса = "REST_API" Тогда
			ДокументSMARTS  = REST_API_СформироватьНовыйДокументSMARTS(ДанныеДокумента,"",АдресаПеременных);		
			REST_API_ЗаписатьДокументВБазуSMARTS(ДокументSMARTS, ТипБазы,АдресаПеременных);
		Иначе
			ДокументSMARTS  = КомЯдро_СформироватьНовыйДокументSMARTS(ДанныеДокумента);		
			КомЯдро_ЗаписатьДокументВБазуSMARTS(ДокументSMARTS, ТипБазы,АдресаПеременных);	
		КонецЕсли;
	КонецЕсли;
	      	
	ГлЯдро_ОбработатьДокумент1СПослеВыгрузкиНаСерверSMARTS(Документ1С, ДанныеДокумента, СписокПередаваемыхНастроек, ID_БизнесПроцесса, АдресаПеременных);
	
	ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Конец, Выгрузка документа в базу SMARTS", НачалоСобытия, АдресаПеременных);
	
КонецПроцедуры

// Вызывает процедуру удаления документа на сервере Mobile Smarts
//
// Параметры:
//	ID_Документа - Строка - идентификатор документа, который требуется удалить	
//  ТипБазы - Строка - "Частная", "Временная", "Основная"
//	АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
//
// Возвращаемое значение:
//	Структура - содержит:
//		* Статус - Булево - признак успешности операции удаления
//		* Сообщение - Строка - информационное сообщение о результате удаления документа
Функция ГлЯдро_УдалитьДокументНаСервереSMARTS(ID_Документа, ТипБазы, ДополнительныеПараметры = Неопределено, АдресаПеременных) Экспорт
	ТипИнтерфейса = ГлЯдро_ПолучитьТипИнтерфейса(ТипБазы, АдресаПеременных); // ТипИнтерфейса = КомЯдро_ПолучитьЗначениеПеременной("ТипИнтерфейса",АдресаПеременных);
		
	Если ТипИнтерфейса = "REST_API" Тогда
		ДокументУдален = REST_API_УдалитьДокументНаСервереSMARTS(ID_Документа, ТипБазы,АдресаПеременных);
	Иначе
		ДокументУдален = КомЯдро_УдалитьДокументНаСервереSMARTS(ID_Документа, ТипБазы,АдресаПеременных);
	КонецЕсли;
	
	ИмяДокумента = "";
	Если ТипЗнч(ДополнительныеПараметры) = Тип("Структура")	И ДополнительныеПараметры.Свойство("ИмяДокумента") Тогда
		ИмяДокумента = СокрЛП(ДополнительныеПараметры.ИмяДокумента);
		Если ЗначениеЗаполнено(ИмяДокумента) Тогда
			ИмяДокумента = """" + ИмяДокумента + """ ";
		КонецЕсли;
	КонецЕсли;
	
	Если ДокументУдален Тогда
		РезультатУдаления = Новый Структура("Сообщение,Статус", "Документ " + ИмяДокумента + "удален с ТСД!", Истина);
	Иначе
		РезультатУдаления = Новый Структура("Сообщение,Статус", "Не удалось удалить документ " + ИмяДокумента + "с ТСД!", Ложь);
	КонецЕсли;
	
	Возврат РезультатУдаления;
	
КонецФункции

Функция ГлЯдро_УстановитьСтатусДокументаНаСервереSMARTS(ID_Документа, ТипБазы, Статус,АдресаПеременных)
	
	ТипИнтерфейса = ГлЯдро_ПолучитьТипИнтерфейса(ТипБазы, АдресаПеременных); // ТипИнтерфейса = КомЯдро_ПолучитьЗначениеПеременной("ТипИнтерфейса",АдресаПеременных);
	Если ТипИнтерфейса = "REST_API" Тогда
		СтатусУстановлен = REST_API_УстановитьСтатусДокументаНаСервереSMARTS(ID_Документа, ТипБазы, Статус,АдресаПеременных);
	Иначе
		СтатусУстановлен = КомЯдро_УстановитьСтатусДокументаНаСервереSMARTS(ID_Документа, ТипБазы, Статус,АдресаПеременных);
	КонецЕсли;
	
	Если СтатусУстановлен = Истина Тогда
		РезультатУстановкиСтатуса = Новый Структура("Сообщение,Статус", "Успешно установлен статус [" + Статус + "]!", Истина);
	Иначе
		РезультатУстановкиСтатуса = Новый Структура("Сообщение,Статус", "Не удалось установить статус [" + Статус + "]!", Ложь);
	КонецЕсли;
	
	Возврат РезультатУстановкиСтатуса;
	
КонецФункции

#КонецОбласти

#Область ГлобальныйКонтекст_Документы_MobileSMARTS_ВспомогательныеМеханизмы

// Возвращает массив, содержащий структуру, ключами которой являются имена колонок таблицы документов Mobile Smarts
//
// Возващаемое значение:
//	Массив из Структура - содержит имена колонок таблицы документов Mobile Smarts	
Функция ГлЯдро_ПолучитьПустуюТаблицуДокументовSMARTS() Экспорт
		
	ТаблицаДокументов = Новый Массив;
	ТаблицаДокументов.Добавить(Новый Структура("КолонкиТаблицыЗначений,ЭтоТаблицаЗначений","ДатаСоздания,Имя,Ид,ИмяТипаДокумента,СтрокиПланКоличество,СтрокиФактКоличество,ИмяПользователя,ВОбработке,Завершен,НастройкаБизнесПроцесса,ИдИсходныхДокументов,ИдУзла",Истина));
	
	Возврат ТаблицаДокументов;
КонецФункции

Функция ГлЯдро_ПолучениеУстройстваПоПинкодуДляВыгрузкиДокумента(ПинКод, ТипБазы, АдресаПеременных) Экспорт
	
	ИмяСобытия = "ГлЯдро_ПолучениеУстройстваПоПинкодуДляВыгрузкиДокумента";
	
	МассивУстройств = Новый Массив;
	
	// Получаем настройки подключения
	Если ТипБазы = "Частная" Тогда
		КлючПеременной = "REST_API_СтруктураПодключенияЧастнойБазыMS";
	ИначеЕсли ТипБазы = "Временная" Тогда
		КлючПеременной = "REST_API_СтруктураПодключенияВременнойБазыMS";
	Иначе
		КлючПеременной = "REST_API_СтруктураПодключенияБазыMS";
	КонецЕсли;
	
	СтруктураПодключения = КомЯдро_ПолучитьЗначениеПеременной(КлючПеременной,АдресаПеременных); 
	
	Если СтруктураПодключения = Неопределено Тогда
		Возврат МассивУстройств;
	КонецЕсли;
	
	// Посылаем запрос на сервер
	СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключения, Новый Структура("HTTPМетод,Метод,ТипЗапроса", "GET", "Devices", "ПолучениеМетаданных"),, АдресаПеременных);	
	
	// Обрабатываем ответ сервера
	Если СтруктураОтвета.КодСостояния <> 200 Тогда
		
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(
			ИмяСобытия, 
			"Ошибка", 
			"Запрос: GET, Devices. Получен некорректный ответ от сервера, Код состояния: " + Строка(СтруктураОтвета.КодСостояния)+ ". Содержание ошибки: " + Строка(СтруктураОтвета.ТекстОшибки),
			,
			АдресаПеременных);	
			
		Возврат МассивУстройств;
		
	Иначе
		
		Devices = СтруктураОтвета.ОтветСервера.Получить("value");	
		
	КонецЕсли;		
	
	// Ищем по введенному пин-коду устройство
	Для Каждого Устройство Из Devices Цикл
		Если Устройство.Получить("pincode") = ПинКод Тогда
			ИдУстройства = Устройство.Получить("deviceId");
			МассивУстройств.Добавить(Новый Структура("Ид,Имя", ИдУстройства, ИдУстройства));			
			Прервать;
		КонецЕсли;
	КонецЦикла;    	
	
	Возврат МассивУстройств;
	
КонецФункции

Функция ГлЯдро_ПолучениеАрхивныхДокументовSMARTS(ПараметрыЗапроса, ФильтрыЗапроса, ТипБазы, АдресаПеременных) Экспорт
	
	ИмяСобытия = "ГлЯдро_ПолучениеАрхивныхДокументовSMARTS";
	
	МассивДокументов = Новый Массив;
	
	// Получаем настройки подключения
	Если ТипБазы = "Частная" Тогда
		КлючПеременной = "REST_API_СтруктураПодключенияЧастнойБазыMS";
	ИначеЕсли ТипБазы = "Временная" Тогда
		КлючПеременной = "REST_API_СтруктураПодключенияВременнойБазыMS";
	Иначе
		КлючПеременной = "REST_API_СтруктураПодключенияБазыMS";
	КонецЕсли;
	
	СтруктураПодключения = КомЯдро_ПолучитьЗначениеПеременной(КлючПеременной, АдресаПеременных); 
	
	Если СтруктураПодключения = Неопределено Тогда
		Возврат МассивДокументов;
	КонецЕсли;
	
	ОтправляемыеДанные = Новый Соответствие;	
	Для Каждого СтрПараметра Из ПараметрыЗапроса Цикл
		ОтправляемыеДанные.Вставить(СтрПараметра.Ключ, СтрПараметра.Значение);				
	КонецЦикла;                                                               	
	
	ТекстМетода = "Operations('ПолучитьАрхДокументы')";
	
	Если ЗначениеЗаполнено(ФильтрыЗапроса) Тогда
		ТекстМетода = ТекстМетода + "?$filter=";
		Для Каждого СтрФильтра Из ФильтрыЗапроса Цикл
			Если (СтрФильтра.Ключ = "id")Тогда                                   
				ТекстФильтра = СтрФильтра.Ключ + " eq '" + СтрФильтра.Значение + "' and ";				
			Иначе
				ТекстФильтра = "contains(" + СтрФильтра.Ключ + ",'" + СтрФильтра.Значение + "') and ";
			КонецЕсли;
			ТекстМетода = ТекстМетода + ТекстФильтра;
		КонецЦикла;
		ТекстМетода = Лев(ТекстМетода, СтрДлина(ТекстМетода) - 5);
	КонецЕсли;                                              
	
	СтруктураОтвета = REST_API_ВыполнитьМетод(
		СтруктураПодключения, 
		Новый Структура("HTTPМетод,Метод,ТипЗапроса", "POST", ТекстМетода, "ПолучениеСпискаДокументов"), 
		ОтправляемыеДанные, 
		АдресаПеременных);
		
	// Обрабатываем ответ сервера
	Если СтруктураОтвета.КодСостояния <> 200 Тогда
		
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(
			ИмяСобытия, 
			"Ошибка", 
			"Запрос: POST, Operations('ПолучитьАрхДокументы'). Получен некорректный ответ от сервера, Код состояния: " + Строка(СтруктураОтвета.КодСостояния)+ ". Содержание ошибки: " + Строка(СтруктураОтвета.ТекстОшибки),
			,
			АдресаПеременных);	
			
		Возврат МассивДокументов;
		
	Иначе
		
		Documets = СтруктураОтвета.ОтветСервера.Получить("documentList");	
		Если Documets = Неопределено Тогда
			Возврат МассивДокументов;
		КонецЕсли;
		
	КонецЕсли;		
			
	// Обходим выборку, заполняем массив данных для возврата на форму
	Для Каждого Document Из Documets Цикл
		
		СтруктураДокумента = Новый Структура("Синоним,УИД,ИДУстройства,ИмяФайла,Тип,ВремяБэкапа", "", "", "", "", "", "");
		
		СтруктураДокумента.Синоним 			= Document["name"];
		СтруктураДокумента.УИД 				= Document["id"];
		СтруктураДокумента.ИДУстройства 	= Document["deviceId"];
		
		СтруктураДокумента.ИмяФайла 		= Document["fileName"];		
		СтруктураДокумента.Тип 				= Document["documentTypeName"];
		СтруктураДокумента.ВремяБэкапа		= REST_API_ПреобразоватьКДате(Document["backupTime"]);
		
		МассивДокументов.Добавить(СтруктураДокумента);
		
	КонецЦикла;    	
	
	Возврат МассивДокументов;
	
КонецФункции

Функция ГлЯдро_ВосстановитьДокументыSMARTS(МассивДокументов, ТипБазы, АдресаПеременных) Экспорт
	
	ИмяСобытия = "ГлЯдро_ВосстановитьДокументыSMARTS";
	
	// Получаем настройки подключения
	Если ТипБазы = "Частная" Тогда
		КлючПеременной = "REST_API_СтруктураПодключенияЧастнойБазыMS";
	ИначеЕсли ТипБазы = "Временная" Тогда
		КлючПеременной = "REST_API_СтруктураПодключенияВременнойБазыMS";
	Иначе
		КлючПеременной = "REST_API_СтруктураПодключенияБазыMS";
	КонецЕсли;
	
	СтруктураПодключения = КомЯдро_ПолучитьЗначениеПеременной(КлючПеременной, АдресаПеременных); 
	
	Если СтруктураПодключения = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;
	
	МассивДокументовНаВосстановление = Новый Массив;
	
	Для Каждого СтруктураДокумента Из МассивДокументов Цикл
		МассивДокументовНаВосстановление.Добавить(СтруктураДокумента.УИД);		
	КонецЦикла;
	
	ОтправляемыеДанные = Новый Соответствие;
	ОтправляемыеДанные.Вставить("FilesInfo@odata.type", "#Collection(Guid)");
	ОтправляемыеДанные.Вставить("FilesInfo", 			МассивДокументовНаВосстановление);
	
	// Посылаем запрос на сервер
	СтруктураОтвета = REST_API_ВыполнитьМетод(
		СтруктураПодключения, 
		Новый Структура("HTTPМетод,Метод,ТипЗапроса", "POST", "Operations('ВосстановитьДокументы')", "ПолучениеМетаданных"),
		ОтправляемыеДанные,
		АдресаПеременных);	
	
	// Обрабатываем ответ сервера
	Если СтруктураОтвета.КодСостояния < 200 или СтруктураОтвета.КодСостояния >= 300 Тогда
		Результат =  Ложь;
	Иначе
		Результат = СтруктураОтвета.ОтветСервера.Получить("result");			
	КонецЕсли;

	Возврат Результат;
	
КонецФункции

Функция ГлЯдро_ПроверитьНаличиеСовмещенныхСтрокВНастройкеБП(НастройкаБП)

	ЗапрашиватьCombinedItems = Истина; // По умолчанию запрашиваем CombinedItems
	
	Если ТипЗнч(НастройкаБП) <> Тип("Структура") Тогда
		Возврат ЗапрашиватьCombinedItems;	
	КонецЕсли;		
		
	СовмещенныеСтрокиЗагрузка = Ложь;
	СовмещенныеСтрокаВыгрузка = Ложь;
	
	НастройкаЗагрузкиТЧ = Неопределено;
	НастройкаВыгрузкиТЧ = Неопределено;
	Если НастройкаБП.Свойство("НастройкаЗагрузкиТЧ", НастройкаЗагрузкиТЧ)
		И ТипЗнч(НастройкаЗагрузкиТЧ) = Тип("Массив") Тогда
		СовмещенныеСтрокиЗагрузка = ГлЯдро_НайтиВМассивеСтруктурПоОтбору(НастройкаЗагрузкиТЧ, Новый Структура("ТабличнаяЧастьДокументаMS", "СовмещенныеСтроки"));
	КонецЕсли;
	Если НастройкаБП.Свойство("НастройкаВыгрузкиТЧ", НастройкаВыгрузкиТЧ)
		И ТипЗнч(НастройкаВыгрузкиТЧ) = Тип("Массив") Тогда
		СовмещенныеСтрокиВыгрузка = ГлЯдро_НайтиВМассивеСтруктурПоОтбору(НастройкаВыгрузкиТЧ, Новый Структура("ТабличнаяЧастьДокументаMS", "СовмещенныеСтроки"));
	КонецЕсли;
		
	Если СовмещенныеСтрокиЗагрузка = Неопределено
		И СовмещенныеСтрокиВыгрузка = Неопределено Тогда
		ЗапрашиватьCombinedItems = Ложь;				
	КонецЕсли;		
	
    Возврат ЗапрашиватьCombinedItems;
	
КонецФункции

#КонецОбласти

#КонецОбласти

#Область ГлобальныйКонтекст_Документы_1С

#Область ГлобальныйКонтекст_Документы_1С_ЧтениеДанных

// Получает настройки отборов бизнес-процессов, соответствующих переданному типу документа Mobile Smarts (если не указан - то всех бизнес-процессов), выполняет отбор документов по полученным
// настройкам и возвращает полученный результат отбора, преобразованный в массив структур.
//
// Параметры:
//	СтруктураНастроек - Структура - содержит:
//		* БизнесПроцессы - Массив из Структура - см. ГлЯдро_СформироватьМетаданныеНастроекMS
//      * НастройкиОтборов - Массив из Структура - см. ГлЯдро_СформироватьМетаданныеНастроекMS
//		* РежимОбмена - Строка - "Интерактивный", "Онлайн", "Автообмен"
//		* ПараметрыУзлов - Массив из Структура - содержит значения глобальных параметров для текущего узла в сессии Mobile Smarts
//		* РазмерВыборки - Число - если отличен от нуля, ограничивать выборку этим числом документов
//  ТипДокумента - Строка - тип документа Mobile Smarts
//  РежимОбмена - Неопределено, Строка - режим обмена - "Интерактивный", "Онлайн", "Автообмен"
//  АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
//
// Возвращаемое значение:
//	- Массив из Структура - содержит:	
//		* Ссылка - ДокументСсылка - отобранный документ
//      * НастройкаБизнесПроцесса - Строка - идентификатор бизнес-процесса
//		* БизнесПроцесс - Строка - название бизнес-процесса
//		* ТипДокумента1С - Строка - тип исходного документа 1С
//		* ИмяБП - Строка - имя бизнес-процесса (?)
//      * ИмяКонтрагента - Неопределено, СправочникСсылка.Контрагенты - контрагент документа
//		* ИмяСклада - Неопределено, СправочникСсылка.Склады - склад/склад-отправитель документа
//		* ИмяСкладаКуда - Неопределено, СправочникСсылка.Склады - склад-получатель документа
//		* Дата - Дата - дата документа - при онлайн-обмене и автообмене
//		* Номер - Строка - номер документа - при онлайн-обмене и автообмене
//		* Количество - Число - количество строк в документе - при онлайн-обмене и автообмене
//		* [ИменаРеквизитов] - Произвольный - значения реквизитов документа, выбранных для отображения на форме обмена документами в интерактивном режиме
//  - Неопределено - если не удалось получить список документов
Функция ГлЯдро_ПолучитьСписокДокументов1С(СтруктураНастроек, ТипДокумента = Неопределено, РежимОбмена = Неопределено, АдресаПеременных) Экспорт
	
	Если ТипЗнч(СтруктураНастроек.БизнесПроцессы) <> Тип("Массив") ИЛИ СтруктураНастроек.БизнесПроцессы.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	Если ТипЗнч(СтруктураНастроек.НастройкиОтборов) <> Тип("Массив") ИЛИ СтруктураНастроек.НастройкиОтборов.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ПараметрыУзлов = Неопределено;
	
	Если РежимОбмена = Неопределено 
		И СтруктураНастроек.Свойство("РежимОбмена")
		И ЗначениеЗаполнено(СтруктураНастроек.РежимОбмена)   Тогда
		РежимОбмена = СтруктураНастроек.РежимОбмена
	КонецЕсли;
	
	НастройкиОтборов = СтруктураНастроек.НастройкиОтборов;
	Если НастройкиОтборов[0].Свойство("КолонкиТаблицыЗначений") Тогда
		НастройкиОтборовКолонки = ГлЯдро_РазложитьСтрокуВМассивПодстрок(НастройкиОтборов[0].КолонкиТаблицыЗначений);
	Иначе
		НастройкиОтборовКолонки = Новый Массив;
		Для Каждого КлючЗначение Из НастройкиОтборов[0] Цикл
			НастройкиОтборовКолонки.Добавить(КлючЗначение.Ключ);		
		КонецЦикла;
	КонецЕсли;
	НастройкиБП = СтруктураНастроек.БизнесПроцессы;
	Если НастройкиБП[0].Свойство("КолонкиТаблицыЗначений") Тогда
		НастройкиБПКолонки = ГлЯдро_РазложитьСтрокуВМассивПодстрок(НастройкиБП[0].КолонкиТаблицыЗначений);
	Иначе
		НастройкиБПКолонки = Новый Массив;
		Для Каждого КлючЗначение Из НастройкиБП[0] Цикл
			НастройкиБПКолонки.Добавить(КлючЗначение.Ключ);		
		КонецЦикла;
	КонецЕсли;
	ЕстьНастройкаВыбранныхРеквизитов 	= (НастройкиБПКолонки.Найти("НастройкаПредставленийРеквизитовДокумента")<>Неопределено);
	ПодходящиеНастройкиБП = Новый Массив;
	Если ТипДокумента <> Неопределено Тогда
		Для каждого Строка Из НастройкиБП Цикл
			Если НЕ Строка.Свойство("ТипДокументаMS") 
				ИЛИ Строка.ТипДокументаMS <> ТипДокумента Тогда
				Продолжить;
			КонецЕсли;
			ПодходящиеНастройкиБП.Добавить(Строка);
		КонецЦикла;
		НастройкиБП = ПодходящиеНастройкиБП;
	КонецЕсли;
	
	ПодходящиеНастройкиБП = Новый Массив;
	Для каждого Строка Из НастройкиБП Цикл
		Если Строка.Свойство("Используется") И НЕ Строка.Используется = Истина Тогда
			Продолжить;
		КонецЕсли;
		ПодходящиеНастройкиБП.Добавить(Строка);
	КонецЦикла;
	НастройкиБП = ПодходящиеНастройкиБП;
	
	Если НастройкиБП.Количество() <= 0 Тогда
		Возврат Неопределено;                                      
	КонецЕсли;                                                           
	
	РазмерВыборки = Неопределено;
	СтруктураНастроек.Свойство("РазмерВыборки", РазмерВыборки);
	ОграничениеВыборки 			= ЗначениеЗаполнено(РазмерВыборки);
	КоличествоДокументовЦикл 	= РазмерВыборки;
	
	ОтборПоПериоду = Неопределено;
	СтруктураНастроек.Свойство("ОтборПоПериоду", ОтборПоПериоду);
	
	ОтобранныеДокументы = Новый ТаблицаЗначений;
	ОтобранныеДокументы.Колонки.Добавить("Ссылка");
	ОтобранныеДокументы.Колонки.Добавить("НастройкаБизнесПроцесса");
	ОтобранныеДокументы.Колонки.Добавить("БизнесПроцесс");
	ОтобранныеДокументы.Колонки.Добавить("ТипДокумента1С");
	ОтобранныеДокументы.Колонки.Добавить("ИмяБП");
	
	ТекущиеНастройкиMS = КомЯдро_ПолучитьЗначениеПеременной("ТекущиеНастройкиMS",АдресаПеременных);
	
	Если РежимОбмена = "Интерактивный" И ТекущиеНастройкиMS.Свойство("ФормаОбменаВыбранныеКолонки")
		И ТекущиеНастройкиMS.ФормаОбменаВыбранныеКолонки <> Ложь
		И ТекущиеНастройкиMS.ФормаОбменаВыбранныеКолонки.Количество() > 1 Тогда
		ВключенныеКолонки = Новый Массив;
		Для Каждого СтрокаМассива из ТекущиеНастройкиMS.ФормаОбменаВыбранныеКолонки Цикл
			Если НЕ СтрокаМассива.Свойство("Использование")
				ИЛИ НЕ СтрокаМассива.Использование Тогда
				Продолжить;
			КонецЕсли;
			ВключенныеКолонки.Добавить(СтрокаМассива);
		КонецЦикла;
	
		Для Каждого ВключеннаяКолонка Из ВключенныеКолонки Цикл
			Если ОтобранныеДокументы.Колонки.Найти(ВключеннаяКолонка.Название) = Неопределено Тогда
				ОтобранныеДокументы.Колонки.Добавить(ВключеннаяКолонка.Название);
			КонецЕсли;
		КонецЦикла;
	Иначе	
		ОтобранныеДокументы.Колонки.Добавить("Дата");
		ОтобранныеДокументы.Колонки.Добавить("Номер");
		ОтобранныеДокументы.Колонки.Добавить("Количество");		
	КонецЕсли;
	
	Если ОтобранныеДокументы.Колонки.Найти("ИмяКонтрагента") = Неопределено Тогда
		ОтобранныеДокументы.Колонки.Добавить("ИмяКонтрагента");
	КонецЕсли;		
	Если ОтобранныеДокументы.Колонки.Найти("ИмяСклада") = Неопределено Тогда
		ОтобранныеДокументы.Колонки.Добавить("ИмяСклада");
	КонецЕсли;		
	Если ОтобранныеДокументы.Колонки.Найти("ИмяСкладаКуда") = Неопределено Тогда
		ОтобранныеДокументы.Колонки.Добавить("ИмяСкладаКуда");
	КонецЕсли;				
	
	// для обратной совместимости, т.к. в старых версиях обработки еще не было этого поля
	ЕстьРеквизитИспользуется 				= (НастройкиОтборовКолонки.Найти("Используется") <> Неопределено);
	ЕстьРеквизитВариантОтбора 			= (НастройкиОтборовКолонки.Найти("ВариантОтбора") <> Неопределено);			
	
	СтруктураМетаданных = КомЯдро_ПолучитьЗначениеПеременной("СтруктураМетаданных",АдресаПеременных);
			
	Для Каждого СтрокаБП из НастройкиБП Цикл
		Если СтрокаБП.Свойство("ЭтоТаблицаЗначений") Тогда
			Продолжить; // Возможно тут надо обратно вернуть Прервать, но так не срабатывают автотесты
		КонецЕсли;
		// В автотестах не нужно отбирать документы по бизнес-процессам, которые не принадлежат текущему программному продукту
		Если ТекущиеНастройкиMS.Свойство("СторонниеБизнесПроцессы") 
			И ТекущиеНастройкиMS.СторонниеБизнесПроцессы.Найти(СтрокаБП.ID_БизнесПроцесса) <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		// Если выбрано ограничение количества выбранных документов, то заканчиваем обход бизнес-процессов
		Если ОграничениеВыборки И КоличествоДокументовЦикл <= 0 Тогда
			Прервать;
		КонецЕсли;
		
		Если ЗначениеЗаполнено(СтрокаБП.ТипИсходногоДокумента1С) Тогда
			Для Каждого Настройка из НастройкиОтборов Цикл
				Если НЕ Настройка.Свойство("ID_БизнесПроцесса")
						ИЛИ НЕ Настройка.ID_БизнесПроцесса = СтрокаБП.ID_БизнесПроцесса Тогда
					Продолжить;
				КонецЕсли;
				Если НЕ ЕстьРеквизитИспользуется ИЛИ (ЕстьРеквизитИспользуется
						И Настройка.Используется) Тогда
					Если НЕ ГлЯдро_ТипДокументаЕстьВ1С(СтрокаБП.ТипИсходногоДокумента1С,АдресаПеременных) Тогда
						Прервать;
					КонецЕсли;
					Если НЕ ЕстьРеквизитВариантОтбора ИЛИ ЕстьРеквизитВариантОтбора
							И Найти(ВРег(СокрЛП(Настройка.ВариантОтбора)), ВРег(СокрЛП("Конструктор")))
							И ЗначениеЗаполнено(Настройка.НастройкаКомпоновщикаСтрокой) Тогда
						НастройкиКомпоновки = ГлЯдро_ЗначениеИзСтрокиXML(СтрЗаменить(Настройка.НастройкаКомпоновщикаСтрокой, Символы.ВК, ""));

						ВыбранныеРеквизиты = Новый СписокЗначений;   
						Если ЕстьНастройкаВыбранныхРеквизитов
								И СтрокаБП.НастройкаПредставленийРеквизитовДокумента <> Неопределено
								И СтрокаБП.НастройкаПредставленийРеквизитовДокумента.Количество() > 1 Тогда
							Для Каждого ОтобраннаяКолонка Из ОтобранныеДокументы.Колонки Цикл
								Для Каждого СтрокаМассива из СтрокаБП.НастройкаПредставленийРеквизитовДокумента Цикл
									Если СтрокаМассива.Свойство("Использование")
											И СтрокаМассива.Использование
											И СтрокаМассива.Свойство("ПредставлениеРеквизита")
											И СтрокаМассива.ПредставлениеРеквизита = ОтобраннаяКолонка.Имя Тогда

										Если (СтрокаМассива.НазваниеРеквизита = "Количество"
												ИЛИ СтруктураМетаданных.Документы1С[строкаБП.ТипИсходногоДокумента1С].Реквизиты.НайтиПоЗначению(СтрокаМассива.НазваниеРеквизита) <> Неопределено) Тогда
											ВыбранныеРеквизиты.Добавить(СтрокаМассива.НазваниеРеквизита, СтрокаМассива.ПредставлениеРеквизита);
										КонецЕсли;

										Прервать;
									КонецЕсли;
								КонецЦикла;
							КонецЦикла;
						КонецЕсли;

						ДокументыОтбор = ГлЯдро_ОтобратьДокументы1СЧерезСКД(
							НастройкиКомпоновки, 
							СтрокаБП.ТипИсходногоДокумента1С,
							СтрокаБП.Название, 
							СтруктураНастроек.ПараметрыУзлов, 
							ОтборПоПериоду,
							КоличествоДокументовЦикл,
							ВыбранныеРеквизиты,
							АдресаПеременных);
						Для Каждого СтрокаДокумента Из ДокументыОтбор Цикл
							Если СтрокаДокумента.Свойство("ЭтоТаблицаЗначений") Тогда
								Продолжить;
							КонецЕсли;
							Если ОтобранныеДокументы.Найти(СтрокаДокумента.Ссылка, "Ссылка") = Неопределено Тогда
								НоваяСтрока = ОтобранныеДокументы.Добавить();
								// т.к. компоновщик не хочет заменять заголовки, придется сделать так
								Если ЕстьНастройкаВыбранныхРеквизитов
										И ВыбранныеРеквизиты.Количество() > 0 Тогда
									Для Каждого ВыбранныйРеквизит Из ВыбранныеРеквизиты Цикл
									// по каким-то причинам СКД при отборе может отсеивать некоторые реквизиты документа и они пропадают из данных
										Попытка
											НоваяСтрока[ВыбранныйРеквизит.Представление] = СтрокаДокумента[ВыбранныйРеквизит.Значение];
										Исключение
										КонецПопытки;
									КонецЦикла;
								Иначе
									ЗаполнитьЗначенияСвойств(НоваяСтрока, СтрокаДокумента);
								КонецЕсли;
								НоваяСтрока.НастройкаБизнесПроцесса = СтрокаБП.ID_БизнесПроцесса;
								НоваяСтрока.БизнесПроцесс = СтрокаБП.Название;
								НоваяСтрока.ТипДокумента1С = СтрокаБП.ТипИсходногоДокумента1С;
							Иначе
								ОтобранныеДокументы.Найти(СтрокаДокумента.Ссылка, "Ссылка").НастройкаБизнесПроцесса = "";
								ОтобранныеДокументы.Найти(СтрокаДокумента.Ссылка, "Ссылка").БизнесПроцесс = "";
								ОтобранныеДокументы.Найти(СтрокаДокумента.Ссылка, "Ссылка").ИмяБП = "";
							КонецЕсли;
						КонецЦикла;
					КонецЕсли;
					Если ЕстьРеквизитВариантОтбора
							И Найти(ВРег(СокрЛП(Настройка.ВариантОтбора)), ВРег(СокрЛП("Запрос")))
							И ЗначениеЗаполнено(Настройка.ID_ПроизвольногоОтбора) Тогда
						НастройкиКомпоновки = ГлЯдро_ЗначениеИзСтрокиXML(СтрЗаменить(Настройка.НастройкаКомпоновщикаСтрокой, Символы.ВК, ""));	
							
						Если СтруктураНастроек.Свойство("ПараметрыУзлов") Тогда
							ПараметрыУзлов = СтруктураНастроек.ПараметрыУзлов;
						КонецЕсли;														
						ДокументыПроизвольныйОтбор = ГлЯдро_ОтобратьДокументы1СЧерезПроизвольныйОтбор(Настройка.ID_ПроизвольногоОтбора, Истина, Неопределено, ПараметрыУзлов, НастройкиКомпоновки, АдресаПеременных);
						Если ДокументыПроизвольныйОтбор = Неопределено Тогда
							Продолжить;
						КонецЕсли;
						Для Каждого СтрокаДокумента Из ДокументыПроизвольныйОтбор Цикл
							Если СтрокаДокумента.Свойство("ЭтоТаблицаЗначений") Тогда
								Продолжить;
							КонецЕсли;
							Если ОтобранныеДокументы.Найти(СтрокаДокумента.Ссылка, "Ссылка") = Неопределено Тогда
								НоваяСтрока = ОтобранныеДокументы.Добавить();
								ЗаполнитьЗначенияСвойств(НоваяСтрока, СтрокаДокумента);
								НоваяСтрока.НастройкаБизнесПроцесса = СтрокаБП.ID_БизнесПроцесса;
								НоваяСтрока.БизнесПроцесс = СтрокаБП.Название;
								НоваяСтрока.ТипДокумента1С = СтрокаБП.ТипИсходногоДокумента1С;
							Иначе
								ОтобранныеДокументы.Найти(СтрокаДокумента.Ссылка, "Ссылка").НастройкаБизнесПроцесса = "";
								ОтобранныеДокументы.Найти(СтрокаДокумента.Ссылка, "Ссылка").БизнесПроцесс = "";
								ОтобранныеДокументы.Найти(СтрокаДокумента.Ссылка, "Ссылка").ИмяБП = "";
							КонецЕсли;
						КонецЦикла;
					КонецЕсли;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли; 
		
		Если ОграничениеВыборки Тогда
			КоличествоДокументовЦикл = РазмерВыборки - ОтобранныеДокументы.Количество();
		КонецЕсли;
	КонецЦикла;	
	
	Для каждого СтрокаДок Из ОтобранныеДокументы Цикл
		
		ИменаРеквизитовШапки = СтруктураМетаданных.Документы1С[СтрокаДок.ТипДокумента1С].ИменаРеквизитовШапки;
		
		Для каждого Реквизит Из ИменаРеквизитовШапки Цикл
			Попытка
				СтрокаДок[Реквизит.Ключ] = СтрокаДок.Ссылка[Реквизит.Значение];										
			Исключение			
			КонецПопытки; 		    
		КонецЦикла; 		
		
	КонецЦикла; 
	
	Возврат ГлЯдро_ТаблицуЗначенийВМассивСтруктур(ОтобранныеДокументы);
	
КонецФункции

// Получает список бизнес-процессов для переданных документов 1С, согласно отборам документов по полученным настройкам
//
// Параметры:
//	СтруктураНастроек 	- Структура 			- содержит:
//		* СписокДокументов	- Массив из Структура 	- список ссылок на выгружаемые документы 1С
//		* БизнесПроцессы 	- Массив из Структура 	- см. ГлЯдро_СформироватьМетаданныеНастроекMS
//      * НастройкиОтборов 	- Массив из Структура 	- см. ГлЯдро_СформироватьМетаданныеНастроекMS
//		* РежимОбмена 		- Строка 				- "Интерактивный", "Онлайн", "Автообмен"
//		* ТипДокумента1С 	- Строка 				- тип исходящего документа 1С
//		* ПараметрыУзлов 	- Массив из Структура 	- содержит значения глобальных параметров для текущего узла в сессии Mobile Smarts
//  РежимОбмена 		- Неопределено, Строка 	- режим обмена - "Интерактивный", "Онлайн", "Автообмен"
//  АдресаПеременных 	- Структура 			- см. КомЯдро_СоздатьСтруктуруАдресаПеременных
//
// Возвращаемое значение:
//	- Массив из Структура 	- содержит:	
//      	* ID_БизнесПроцесса - Строка - идентификатор бизнес-процесса
//			* Название 			- Строка - название бизнес-процесса
//  - Неопределено 			- если не удалось получить список бизнес-процессов
//
Функция ГлЯдро_ПолучитьБизнесПроцессДляТекущихДокументов(СтруктураНастроек, РежимОбмена = Неопределено, АдресаПеременных) Экспорт
	
	Если Не СтруктураНастроек.СписокДокументов.Количество() Тогда
		Возврат Неопределено;
	КонецЕсли;
	Если ТипЗнч(СтруктураНастроек.БизнесПроцессы) <> Тип("Массив") ИЛИ СтруктураНастроек.БизнесПроцессы.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	Если ТипЗнч(СтруктураНастроек.НастройкиОтборов) <> Тип("Массив") ИЛИ СтруктураНастроек.НастройкиОтборов.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ПараметрыУзлов = Неопределено;
	
	Если РежимОбмена = Неопределено 
		И СтруктураНастроек.Свойство("РежимОбмена")
		И ЗначениеЗаполнено(СтруктураНастроек.РежимОбмена)   Тогда
		РежимОбмена = СтруктураНастроек.РежимОбмена
	КонецЕсли;
	
	НастройкиОтборов = СтруктураНастроек.НастройкиОтборов;
	Если НастройкиОтборов[0].Свойство("КолонкиТаблицыЗначений") Тогда
		НастройкиОтборовКолонки = ГлЯдро_РазложитьСтрокуВМассивПодстрок(НастройкиОтборов[0].КолонкиТаблицыЗначений);
	Иначе
		НастройкиОтборовКолонки = Новый Массив;
		Для Каждого КлючЗначение Из НастройкиОтборов[0] Цикл
			НастройкиОтборовКолонки.Добавить(КлючЗначение.Ключ);		
		КонецЦикла;
	КонецЕсли;
	НастройкиБП = СтруктураНастроек.БизнесПроцессы;
	Если НастройкиБП[0].Свойство("КолонкиТаблицыЗначений") Тогда
		НастройкиБПКолонки = ГлЯдро_РазложитьСтрокуВМассивПодстрок(НастройкиБП[0].КолонкиТаблицыЗначений);
	Иначе
		НастройкиБПКолонки = Новый Массив;
		Для Каждого КлючЗначение Из НастройкиБП[0] Цикл
			НастройкиБПКолонки.Добавить(КлючЗначение.Ключ);		
		КонецЦикла;
	КонецЕсли;
	ЕстьНастройкаВыбранныхРеквизитов 	= (НастройкиБПКолонки.Найти("НастройкаПредставленийРеквизитовДокумента")<>Неопределено);
	ПодходящиеНастройкиБП = Новый Массив;
	Если СтруктураНастроек.ТипДокумента1С <> Неопределено Тогда
		Для каждого Строка Из НастройкиБП Цикл
			Если НЕ Строка.Свойство("ТипИсходногоДокумента1С") 
				ИЛИ Строка.ТипИсходногоДокумента1С <> СтруктураНастроек.ТипДокумента1С Тогда
				Продолжить;
			КонецЕсли;
			ПодходящиеНастройкиБП.Добавить(Строка);
		КонецЦикла;
		НастройкиБП = ПодходящиеНастройкиБП;
	КонецЕсли;
	
	ПодходящиеНастройкиБП = Новый Массив;
	Для каждого Строка Из НастройкиБП Цикл
		Если Строка.Свойство("Используется") И НЕ Строка.Используется = Истина Тогда
			Продолжить;
		КонецЕсли;
		ПодходящиеНастройкиБП.Добавить(Строка);
	КонецЦикла;
	НастройкиБП = ПодходящиеНастройкиБП;
	
	Если НастройкиБП.Количество() <= 0 Тогда
		Возврат Неопределено;                                      
	КонецЕсли;                                                           
	
	// для обратной совместимости, т.к. в старых версиях обработки еще не было этого поля
	ЕстьРеквизитИспользуется 	= (НастройкиОтборовКолонки.Найти("Используется") <> Неопределено);
	ЕстьРеквизитВариантОтбора 	= (НастройкиОтборовКолонки.Найти("ВариантОтбора") <> Неопределено);			
	
	СтруктураМетаданных = КомЯдро_ПолучитьЗначениеПеременной("СтруктураМетаданных",АдресаПеременных);
	
	СписокБизнесПроцессов = Новый Массив;
	
	Для Каждого СтрокаБП из НастройкиБП Цикл
		Если СтрокаБП.Свойство("ЭтоТаблицаЗначений") Тогда
			Продолжить;
		КонецЕсли;
		
		Если ЗначениеЗаполнено(СтрокаБП.ТипИсходногоДокумента1С) Тогда
			Для Каждого Настройка из НастройкиОтборов Цикл
				Если НЕ Настройка.Свойство("ID_БизнесПроцесса")
						ИЛИ НЕ Настройка.ID_БизнесПроцесса = СтрокаБП.ID_БизнесПроцесса Тогда
					Продолжить;
				КонецЕсли;
				Если НЕ ЕстьРеквизитИспользуется ИЛИ (ЕстьРеквизитИспользуется И Настройка.Используется) Тогда
						
					Если НЕ ГлЯдро_ТипДокументаЕстьВ1С(СтрокаБП.ТипИсходногоДокумента1С,АдресаПеременных) Тогда
						Прервать;
					КонецЕсли;
					
					Если НЕ ЕстьРеквизитВариантОтбора ИЛИ ЕстьРеквизитВариантОтбора
						И Найти(ВРег(СокрЛП(Настройка.ВариантОтбора)), ВРег(СокрЛП("Конструктор")))
						И ЗначениеЗаполнено(Настройка.НастройкаКомпоновщикаСтрокой) Тогда
						
						НастройкиКомпоновки = ГлЯдро_ЗначениеИзСтрокиXML(СтрЗаменить(Настройка.НастройкаКомпоновщикаСтрокой, Символы.ВК, ""));				

						ДокументыОтбор = ГлЯдро_ОтобратьДокументы1СЧерезСКД(НастройкиКомпоновки, СтрокаБП.ТипИсходногоДокумента1С,строкаБП.Название, СтруктураНастроек.ПараметрыУзлов,,,,АдресаПеременных);
						
						// Проверяем, есть ли выгружаемые документы в полученном списке ссылок, если да, то выбираем текущий БП
						Для Каждого СтрокаДокумента Из СтруктураНастроек.СписокДокументов Цикл
							Если ГлЯдро_НайтиВМассивеСтруктурПоОтбору(ДокументыОтбор, Новый Структура("Ссылка", СтрокаДокумента)) <> Неопределено Тогда								
								
								Если ГлЯдро_НайтиВМассивеСтруктурПоОтбору(СписокБизнесПроцессов, Новый Структура("ID_БизнесПроцесса", СтрокаБП.ID_БизнесПроцесса)) = Неопределено Тогда
									СписокБизнесПроцессов.Добавить(Новый Структура("ID_БизнесПроцесса,Название", СтрокаБП.ID_БизнесПроцесса, СтрокаБП.Название));
								КонецЕсли;								
								
							КонецЕсли;
						КонецЦикла;												
						
					КонецЕсли;
					
					Если ЕстьРеквизитВариантОтбора
						И Найти(ВРег(СокрЛП(Настройка.ВариантОтбора)), ВРег(СокрЛП("Запрос")))
						И ЗначениеЗаполнено(Настройка.ID_ПроизвольногоОтбора) Тогда
							
						НастройкиКомпоновки = ГлЯдро_ЗначениеИзСтрокиXML(СтрЗаменить(Настройка.НастройкаКомпоновщикаСтрокой, Символы.ВК, ""));	
							
						Если СтруктураНастроек.Свойство("ПараметрыУзлов") Тогда
							ПараметрыУзлов = СтруктураНастроек.ПараметрыУзлов;
						КонецЕсли;														
						
						ДокументыПроизвольныйОтбор = ГлЯдро_ОтобратьДокументы1СЧерезПроизвольныйОтбор(Настройка.ID_ПроизвольногоОтбора, Истина, Неопределено, ПараметрыУзлов, НастройкиКомпоновки, АдресаПеременных);
						Если ДокументыПроизвольныйОтбор = Неопределено Тогда
							Продолжить;
						КонецЕсли;
						
						// Проверяем, есть ли выгружаемые документы в полученном списке ссылок, если да, то выбираем текущий БП
						Для Каждого СтрокаДокумента Из СтруктураНастроек.СписокДокументов Цикл
							Если ГлЯдро_НайтиВМассивеСтруктурПоОтбору(ДокументыПроизвольныйОтбор, Новый Структура("Ссылка", СтрокаДокумента)) <> Неопределено Тогда								
								
								Если ГлЯдро_НайтиВМассивеСтруктурПоОтбору(СписокБизнесПроцессов, Новый Структура("ID_БизнесПроцесса", СтрокаБП.ID_БизнесПроцесса)) = Неопределено Тогда
									СписокБизнесПроцессов.Добавить(Новый Структура("ID_БизнесПроцесса,Название", СтрокаБП.ID_БизнесПроцесса, СтрокаБП.Название));
								КонецЕсли;								
								
							КонецЕсли;
						КонецЦикла;	
																		
					КонецЕсли;
					
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
	КонецЦикла;	
	
	Возврат СписокБизнесПроцессов;
	
КонецФункции

// Вызывает в интеграционной обработке функцию СписокДополнительныхОбработчиковПолученияТЧ и возвращает результат ее выполнения
//
// Параметры:
//	ТипДокумента - Неопределено, Строка - имя типа документа 1С, для которого требуется получить список дополнительных обработчиков получения табличных частей
//  АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
//
// Возвращаемое значение:
//	- Соответствие - содержит список дополнительных обработчиков получения табличных частей
//	- Неопределено - если список дополнительных обработчиков получить не удалось
Функция ГлЯдро_ПолучитьСписокДополнительныхОбработчиковПолученияТЧ(ТипДокумента = Неопределено,АдресаПеременных) Экспорт
	
	СтруктураИО = КомЯдро_ПолучитьЗначениеПеременной("ИнтеграционнаяОбработка",АдресаПеременных);
		
	Если (СтруктураИО = Неопределено
		ИЛИ НЕ ТипЗнч(СтруктураИО) = Тип("Структура")
		ИЛИ НЕ СтруктураИО.Свойство("ИнтеграционнаяОбработка")
		ИЛИ СтруктураИО.ИнтеграционнаяОбработка = Неопределено)
		И НЕ ГлЯдро_ПересоздатьИнтеграционнуюОбработку(АдресаПеременных) Тогда
		Возврат Неопределено;
	КонецЕсли;
	СтруктураИО = КомЯдро_ПолучитьЗначениеПеременной("ИнтеграционнаяОбработка",АдресаПеременных);
	ИнтеграционнаяОбработка = СтруктураИО.ИнтеграционнаяОбработка;
	
	Попытка
		Результат = ИнтеграционнаяОбработка.СписокДополнительныхОбработчиковПолученияТЧ(ТипДокумента);
	Исключение
		ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		Результат = Новый Соответствие();
	КонецПопытки;
	
	Если Результат = Неопределено Тогда
		Результат = Новый Соответствие();
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Формирует структуру данных документа для выгрузки на сервер Mobile Smarts
//
// Параметры:
//	Документ1С - ДокументСсылка - документ в базе, выгружаемый на сервер Mobile Smarts
//  ДанныеНастроекИзКэша - Неопределено, Структура - содержит:
//		* СписокБизнесПроцессов - Неопределено, ТаблицаЗначений, Массив из Структура - содержит настройки отобранных бизнес-процессов
//		* ПроизвольныеКодыШапки - Неопределено, ТаблицаЗначений, Массив из Структура - содержит произвольные коды для выгрузки шапки документа
//		* ПроизвольныеКодыТабличнойЧасти - Неопределено, ТаблицаЗначений, Массив из Структура - содержит произвольные коды для выгрузки табличных частей документа
//		* ГлобальныеПараметры - Неопределено, ТаблицаЗначений, Массив из Структура - содержит значения глобальных параметров
//  ID_БизнесПроцесса - Строка - идентификатор бизнес-процесса
//  АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
//
// Возвращаемое значение:
//	- Структура - содержит:	
//		* ШапкаДокумента - Структура - ключами являются имена реквизитов Mobile Smarts шапки выгружаемого документа,
//									   значениями - значения соответствующих реквизитов
//      * ТабличныеЧасти - Структура - ключами являются имена табличных частей Mobile Smarts выгружаемого документа,
//									   значениями - массивы данных строк соответствующих табличных частей
//	- Неопределено - если данные документа для выгрузки получить не удалось
Функция ГлЯдро_ПолучитьДанныеДокумента1СДляВыгрузки(Документ1С, ДанныеНастроекИзКэша = Неопределено, ID_БизнесПроцесса = "",АдресаПеременных) Экспорт
	
	НачалоСобытия = ТекущаяУниверсальнаяДатаВМиллисекундах();
	ИмяСобытия = "ГлЯдро_ПолучитьДанныеДокумента1СДляВыгрузки";
	
	СтруктураИО = КомЯдро_ПолучитьЗначениеПеременной("ИнтеграционнаяОбработка",АдресаПеременных);
		
	Если (СтруктураИО = Неопределено
		ИЛИ НЕ ТипЗнч(СтруктураИО) = Тип("Структура")
		ИЛИ НЕ СтруктураИО.Свойство("ИнтеграционнаяОбработка")
		ИЛИ СтруктураИО.ИнтеграционнаяОбработка = Неопределено)
		И НЕ ГлЯдро_ПересоздатьИнтеграционнуюОбработку(АдресаПеременных) Тогда
		Возврат Неопределено;
	КонецЕсли;
	СтруктураИО = КомЯдро_ПолучитьЗначениеПеременной("ИнтеграционнаяОбработка",АдресаПеременных);
	ИнтеграционнаяОбработка = СтруктураИО.ИнтеграционнаяОбработка;
	
	СписокБизнесПроцессов = Неопределено;
	Если ДанныеНастроекИзКэша = Неопределено ИЛИ НЕ ДанныеНастроекИзКэша.Свойство("СписокБизнесПроцессов") ИЛИ ДанныеНастроекИзКэша.СписокБизнесПроцессов = Неопределено Тогда
		Отбор = Новый Структура("Используется,ТипИсходногоДокумента1С", Истина, ГлЯдро_ПолучитьТипДокументаПоСсылке(Документ1С));
		Если ID_БизнесПроцесса <> "" Тогда
			Отбор.Вставить("ID_БизнесПроцесса", ID_БизнесПроцесса);
		КонецЕсли;
		СписокБизнесПроцессов = ГлЯдро_ПолучитьИзКэшаЗначениеТабличнойНастройкиSMARTS("НастройкиБизнесПроцессов", Отбор, "",АдресаПеременных);
	Иначе
		СписокБизнесПроцессов = ДанныеНастроекИзКэша.СписокБизнесПроцессов;
	КонецЕсли;
	Если СписокБизнесПроцессов = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	// даже если БП несколько, то выберем первый
	Если СписокБизнесПроцессов[0].Свойство("ТаблицаЗначений") Тогда
		НастройкаБП = СписокБизнесПроцессов[1];
	Иначе
		НастройкаБП = СписокБизнесПроцессов[0];	
	КонецЕсли;
	
	ПроизвольныеКодыДокумента = ГлЯдро_ПолучитьПроизвольныеКоды("ПроизвольныеКодыДокумента", ДанныеНастроекИзКэша, "Выгрузка", "Документ", АдресаПеременных);	
	
	ДанныеДокумента = Новый Структура;
	
	// Произвольная обработка выгрузки документа
	Если НастройкаБП.Свойство("ВыполнитьТолькоПроизвольныйКодВыгрузка")
		И НастройкаБП.ВыполнитьТолькоПроизвольныйКодВыгрузка = Истина Тогда
		
		// Произвольный код
		Если НастройкаБП.ТипОбработчикаВыгрузки = 0 И ЗначениеЗаполнено(НастройкаБП.ID_ПроизвольногоКода_Выгрузка_Документ) Тогда
			
			Если ТипЗнч(ПроизвольныеКодыДокумента) = Тип("ТаблицаЗначений") Тогда
				НайденныйПК = ПроизвольныеКодыДокумента.Найти(НастройкаБП.ID_ПроизвольногоКода_Выгрузка_Документ, "ID_ПроизвольногоКода");	
			ИначеЕсли ТипЗнч(ПроизвольныеКодыДокумента) = Тип("Массив") Тогда
				НайденныйПК = ГлЯдро_НайтиСтруктуруВМассивеПоЭлементу(ПроизвольныеКодыДокумента, "ID_ПроизвольногоКода", НастройкаБП.ID_ПроизвольногоКода_Выгрузка_Документ);
			Иначе
				НайденныйПК = Неопределено;
			КонецЕсли;

			Если НайденныйПК <> Неопределено И ЗначениеЗаполнено(НайденныйПК.ТекстПроизвольногоКода) Тогда
				
				СтруктураПеременных = Новый Структура;
				СтруктураПеременных.Вставить("ДанныеДокумента", 		ДанныеДокумента);
				СтруктураПеременных.Вставить("СсылкаДокумент1С", 		Документ1С);
				СтруктураПеременных.Вставить("НастройкаБП", 			НастройкаБП);
				СтруктураПеременных.Вставить("ДанныеНастроекИзКэша", 	ДанныеНастроекИзКэша);
				СтруктураПеременных.Вставить("МодульОбработки", 		ИнтеграционнаяОбработка);
				СтруктураПеременных.Вставить("АдресаПеременных", 		АдресаПеременных);
				
				РезультатВыполненияКода = ГлЯдро_ВыполнитьПроизвольныйКод(НайденныйПК.ТекстПроизвольногоКода, СтруктураПеременных,НастройкаБП.ID_ПроизвольногоКода_Выгрузка_Документ,НайденныйПК.Наименование,АдресаПеременных);
				
				Если НЕ РезультатВыполненияКода.Статус Тогда
					Сообщить("Ошибка! Не удалось выполнить произвольный код выгрузки документа """ + НайденныйПК.Наименование + """");
				КонецЕсли; 
				
			КонецЕсли; 
			
		// Произвольный обработчик
		ИначеЕсли НастройкаБП.ТипОбработчикаВыгрузки = 1 И ЗначениеЗаполнено(НастройкаБП.ОбработчикВыгрузкиДокумента) Тогда	
			
			СтруктураПараметров = ГлЯдро_ПолучитьСтруктуруПараметровВыполненияОбработчикаВыгрузки();
			СтруктураПараметров.СсылкаДокумент1С 		= Документ1С;
			СтруктураПараметров.НастройкаБП 			= НастройкаБП;
			СтруктураПараметров.ДанныеНастроекИзКэша 	= ДанныеНастроекИзКэша;
			СтруктураПараметров.ИнтеграционнаяОбработка = ИнтеграционнаяОбработка;
			СтруктураПараметров.ДанныеДокумента 		= ДанныеДокумента;
			
			ГлЯдро_ВыполнитьОбработчикВыгрузкиДокумента1С("ОбработчикВыгрузкиДокумента", СтруктураПараметров, АдресаПеременных);
			
			Если ДанныеДокумента.Свойство("КритическаяОшибка") И ДанныеДокумента.КритическаяОшибка = Истина Тогда
				ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Конец, Выгрузка документа 1С", НачалоСобытия, АдресаПеременных);
				Возврат Неопределено;
			КонецЕсли;
			
		КонецЕсли;
		
		Возврат ДанныеДокумента;
		
	КонецЕсли;	
	
	ПроизвольныеКодыШапки 			= ГлЯдро_ПолучитьПроизвольныеКоды("ПроизвольныеКодыШапки", ДанныеНастроекИзКэша, "Выгрузка", "Шапка", АдресаПеременных);	
	ПроизвольныеКодыТабличнойЧасти 	= ГлЯдро_ПолучитьПроизвольныеКоды("ПроизвольныеКодыТабличнойЧасти", ДанныеНастроекИзКэша, "Выгрузка", "ТабличнаяЧасть", АдресаПеременных);	
			
	МассивТиповОбъектов = Новый Массив;
	МассивТиповОбъектов.Добавить("ПередВыгрузкойДокумента");
	МассивТиповОбъектов.Добавить("ПослеВыгрузкиДокумента");
	МассивТиповОбъектов.Добавить("ПослеОтправкиДокумента");
	
	ПроизвольныеКодыОбработчикаВыгрузки = ГлЯдро_ПолучитьПроизвольныеКоды("ПроизвольныеКодыОбработчикаВыгрузки", ДанныеНастроекИзКэша, "Выгрузка", МассивТиповОбъектов, АдресаПеременных);		
	
	МассивТиповОбъектов.Очистить();
	МассивТиповОбъектов.Добавить("ПередВыгрузкойТЧ");
	МассивТиповОбъектов.Добавить("ПослеВыгрузкиТЧ");
	МассивТиповОбъектов.Добавить("ПослеОбъединенияТЧ");
	
	ПроизвольныеКодыОбработчикаТЧ = ГлЯдро_ПолучитьПроизвольныеКоды("ПроизвольныеКодыОбработчикаТЧ", ДанныеНастроекИзКэша, "Выгрузка", МассивТиповОбъектов, АдресаПеременных);		
	
	МассивТиповОбъектов.Очистить();
	МассивТиповОбъектов.Добавить("ПередВыгрузкойСтрокиТЧ");
	МассивТиповОбъектов.Добавить("ПослеВыгрузкиСтрокиТЧ");
	МассивТиповОбъектов.Добавить("ПослеОбъединенияСтрокиТЧ");

	ПроизвольныеКодыОбработчикаСтрокиТЧ = ГлЯдро_ПолучитьПроизвольныеКоды("ПроизвольныеКодыОбработчикаСтрокиТЧ", ДанныеНастроекИзКэша, "Выгрузка", МассивТиповОбъектов, АдресаПеременных);
		
	ЗначенияПараметров = Неопределено;
	Если ДанныеНастроекИзКэша = Неопределено
		ИЛИ НЕ ДанныеНастроекИзКэша.Свойство("ЗначенияПараметров")
		ИЛИ ТипЗнч(ДанныеНастроекИзКэша.ЗначенияПараметров) <> Тип("Массив") Тогда
		ЗначенияПараметров = ГлЯдро_ПолучитьЗначенияГлобальныхПараметров(,,,АдресаПеременных);
	Иначе
		ЗначенияПараметров = ДанныеНастроекИзКэша.ЗначенияПараметров;
    КонецЕсли;
	
	// Шапка документа
	ДанныеДляВыгрузки_Шапка = Новый Структура;
		
	НастройкаВыгрузкиПолей = НастройкаБП.НастройкаВыгрузкиПолей;
	
	// Реквизиты 1С
	ОтобранныеПравила = ГлЯдро_СкопироватьМассив(НастройкаВыгрузкиПолей,Новый Структура("Выгружать,ТипИсточника",Истина,"Реквизит1С"));
	ГлЯдро_ЗаполнитьДанныеДляВыгрузкиРеквизитами1С(Документ1С, ОтобранныеПравила, ДанныеДляВыгрузки_Шапка, АдресаПеременных);
	
	// Произвольные значения
	ОтобранныеПравила = ГлЯдро_СкопироватьМассив(НастройкаВыгрузкиПолей,Новый Структура("Выгружать,ТипИсточника",Истина,"ПроизвольноеЗначение"));
	ГлЯдро_ЗаполнитьДанныеДляВыгрузкиПроизвольнымиЗначениями(ОтобранныеПравила, ДанныеДляВыгрузки_Шапка);
	
	// Глобальные параметры
	ОтобранныеПравила = ГлЯдро_СкопироватьМассив(НастройкаВыгрузкиПолей,Новый Структура("Выгружать,ТипИсточника",Истина,"ГлобальныйПараметр"));
	ГлЯдро_ЗаполнитьДанныеДляВыгрузкиГлобальныйПараметр(Документ1С, Неопределено, ОтобранныеПравила, ДанныеДляВыгрузки_Шапка, Неопределено, "Шапка", ЗначенияПараметров);
	
	// Произвольные коды
	ОтобранныеПравила = ГлЯдро_СкопироватьМассив(НастройкаВыгрузкиПолей,Новый Структура("Выгружать,ТипИсточника",Истина,"ПроизвольныйКод"));
	ГлЯдро_ЗаполнитьДанныеДляВыгрузкиПроизвольнымиКодами(Документ1С, Неопределено, ОтобранныеПравила, ДанныеДляВыгрузки_Шапка, Неопределено, "Шапка", ПроизвольныеКодыШапки,АдресаПеременных);
	
	ДанныеШапки = ГлЯдро_ПолучитьДанныеДокумента1СПоПравиламОбмена(ДанныеДляВыгрузки_Шапка, НастройкаВыгрузкиПолей);
	
	ЕстьРеквизитЗаменыПредставления = НастройкаБП.Свойство("ЗаменитьПредставлениеДокументаПриВыгрузке");
	
	Если ЕстьРеквизитЗаменыПредставления
		И НастройкаБП.ЗаменитьПредставлениеДокументаПриВыгрузке = Истина Тогда
		ПредставлениеДокумента = ГлЯдро_ПолучитьПредставлениеДокументаПоНастройкам(Документ1С, НастройкаБП.НастройкаПредставленийРеквизитовДокумента);		
		Если ПредставлениеДокумента <> "" Тогда		
			ДанныеШапки.Вставить("ПредставлениеИмениДокумента", ПредставлениеДокумента);
		КонецЕсли;
	КонецЕсли;

	ДанныеШапки.Вставить("Name",                    Строка(Документ1С));
	ДанныеШапки.Вставить("ИмяТипаДокумента",        НастройкаБП.ТипДокументаMS);
	ДанныеШапки.Вставить("НастройкаБизнесПроцесса", НастройкаБП.ID_БизнесПроцесса);
	ДанныеШапки.Вставить("ИмяБП", 					НастройкаБП.Название);
	
	Если НастройкаБП.КонтрольКоличества Тогда
		ДанныеШапки.Вставить("КонтрольКолва", НастройкаБП.КонтрольКоличества);			
	КонецЕсли;	
	Если НастройкаБП.КоллективнаяРабота Тогда
		ДанныеШапки.Вставить("ServerHosted", НастройкаБП.КоллективнаяРабота);		
	КонецЕсли;	
	
	ДанныеТекущегоУзла = КомЯдро_ПолучитьЗначениеПеременной("ДанныеТекущегоУзла",АдресаПеременных);
	
	Если ТипЗнч(ДанныеТекущегоУзла) = Тип("Структура") Тогда
		ID_Узла = ДанныеТекущегоУзла.ID_Узла;		
	КонецЕсли;
	ДанныеШапки.Вставить("ИдУзла", ID_Узла);
	
	ДанныеДокумента.Вставить("ШапкаДокумента", ДанныеШапки);
	
	СтруктураПараметров = ГлЯдро_ПолучитьСтруктуруПараметровВыполненияОбработчикаВыгрузки();
	СтруктураПараметров.СсылкаДокумент1С 		= Документ1С;
	СтруктураПараметров.ДанныеДокумента 		= ДанныеДокумента;
	СтруктураПараметров.НастройкаБП 			= НастройкаБП;
	СтруктураПараметров.ДанныеНастроекИзКэша 	= ДанныеНастроекИзКэша;
	СтруктураПараметров.ИнтеграционнаяОбработка = ИнтеграционнаяОбработка;
	СтруктураПараметров.ИмяПриемникаДанных 		= "ДанныеДляВыгрузки_Шапка";
	
	ГлЯдро_ВыполнитьОбработчикВыгрузкиДокумента1С("Обработчик_ПередВыгрузкойДокумента", СтруктураПараметров, АдресаПеременных);	
	
	Если ДанныеДокумента.Свойство("КритическаяОшибка") И ДанныеДокумента.КритическаяОшибка = Истина Тогда
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Конец, Выгрузка документа 1С", НачалоСобытия, АдресаПеременных);
		Возврат Неопределено;
	КонецЕсли;
	
	// ************************************ +++ алгоритм выгрузки из нескольких ТЧ 1С в несколько ТЧ Mobile SMARTS ************************************
	
	ТаблицыДанныхТЧ = Новый Структура;
	
	// переносим все данные строки настроек БП в структуру
	СтруктураНастроекБП = НастройкаБП;
			
	НастройкаВыгрузкиТЧ = ГлЯдро_МассивСтруктурВТаблицуЗначений(СтруктураНастроекБП.НастройкаВыгрузкиТЧ);
	
	// проверяем возможность обращение к ТЧ, запросим данные ТЧ до начала соединения.
	// +++
	СписокДополнительныхОбработчиков = ГлЯдро_ПолучитьСписокДополнительныхОбработчиковПолученияТЧ(СтруктураНастроекБП.ТипИсходногоДокумента1С,АдресаПеременных);
	СвязиТабличныхЧастей = Новый ТаблицаЗначений;
	Если ЗначениеЗаполнено(СтруктураНастроекБП.СвязиТабличныхЧастей) 
		И СтруктураНастроекБП.СвязиТабличныхЧастей.Количество() Тогда
		СвязиТабличныхЧастей = ГлЯдро_МассивСтруктурВТаблицуЗначений(СтруктураНастроекБП.СвязиТабличныхЧастей);
	КонецЕсли;
	
	МассивИменТЧКУдалению = Новый Массив;
	СтруктураРезультатовДопТЧиЗапросов = Новый Структура();
	
	Если НастройкаВыгрузкиТЧ <> Неопределено Тогда // В некоторых случаях может выгружаться только шапка документа 
		Для Каждого НастройкаТЧ Из НастройкаВыгрузкиТЧ Цикл
			
			ИмяТаблицыДокумента = НастройкаТЧ.НастройкаТЧСтрокой;
			Если СписокДополнительныхОбработчиков.Получить(ИмяТаблицыДокумента) <> Неопределено Тогда
				
				РезультатОбработчика = ГлЯдро_ВыполнитьОбработчикПолученияДанныхТЧ(СписокДополнительныхОбработчиков[ИмяТаблицыДокумента].ФункцияПолучения, Документ1С, ДанныеНастроекИзКэша, АдресаПеременных);
				Если РезультатОбработчика.Колонки.Найти("Ссылка") = Неопределено Тогда
					МассивТипов = Новый Массив;
					МассивТипов.Добавить(Тип("ДокументСсылка."+СтруктураНастроекБП.ТипИсходногоДокумента1С));
					РезультатОбработчика.Колонки.Добавить("Ссылка",Новый ОписаниеТипов(МассивТипов));
					РезультатОбработчика.ЗаполнитьЗначения(Документ1С,"Ссылка");
				КонецЕсли;
				Если РезультатОбработчика.Количество() = 0 Тогда
					МассивИменТЧКУдалению.Добавить(ИмяТаблицыДокумента);				
				Иначе
					СтруктураРезультатовДопТЧиЗапросов.Вставить(ИмяТаблицыДокумента,РезультатОбработчика);	
				КонецЕсли;
			ИначеЕсли Найти(ВРег(СокрЛП(ИмяТаблицыДокумента)), ВРег(СокрЛП("Запрос"))) Тогда
				
				ТекстЗапросаВыгрузкиНаТСД = НастройкаТЧ.ТекстЗапросаВыгрузкиНаТСД;
			    Запрос = Новый Запрос(СтрЗаменить(ТекстЗапросаВыгрузкиНаТСД, "¶", ""));
				Запрос.УстановитьПараметр("Ссылка", Документ1С);
				ПараметрыЗапроса = Новый Структура;
				Попытка
					Если НастройкаВыгрузкиТЧ.Колонки.найти("ТекстКодаПолучениеПараметров") <> Неопределено
						И ЗначениеЗаполнено(НастройкаТЧ.ТекстКодаПолучениеПараметров) Тогда
						//Выполнить(СтрЗаменить(НастройкаТЧ.ТекстКодаПолучениеПараметров, "ДокументДляВыгрузки", "Документ1С"));
						СтрокаВызова = СтрЗаменить(НастройкаТЧ.ТекстКодаПолучениеПараметров, "ДокументДляВыгрузки", "Документ1С");
						ПараметрыАлгоритма = Новый Структура;
						ПараметрыАлгоритма.Вставить("Документ1С", 		Документ1С);
						ПараметрыАлгоритма.Вставить("ПараметрыЗапроса", ПараметрыЗапроса);
						//ГлЯдро_ВыполнитьПроизвольныйКод(СтрокаВызова, ПараметрыАлгоритма,, "ТекстКодаПолученияПараметров", АдресаПеременных);
						//ПараметрыЗапроса = ПараметрыАлгоритма.ПараметрыЗапроса;
						ПараметрыЗапроса = ГлЯдро_ВыполнитьКодПолученияПараметровЗапроса(СтрокаВызова, ПараметрыАлгоритма, АдресаПеременных);
						
						Если ПараметрыЗапроса.Количество() Тогда
							Для Каждого ПараметрЗапроса Из ПараметрыЗапроса Цикл
								Запрос.УстановитьПараметр(ПараметрЗапроса.Ключ, ПараметрЗапроса.Значение);	
							КонецЦикла;
						КонецЕсли;
					КонецЕсли;
				Исключение
					//Сообщить("Ошибка получения параметров запроса табличной части." + Символы.ПС + ОписаниеОшибки());					
				КонецПопытки;
				Попытка
					РезультатЗапроса = Запрос.Выполнить();
					СтруктураРезультатовДопТЧиЗапросов.Вставить("Запрос_" + НастройкаТЧ.ТабличнаяЧастьДокументаMS, РезультатЗапроса);
				Исключение
					МассивИменТЧКУдалению.Добавить(ИмяТаблицыДокумента);	
				КонецПопытки;
			ИначеЕсли Документ1С.Метаданные().ТабличныеЧасти.Найти(ИмяТаблицыДокумента) = Неопределено Тогда
				МассивИменТЧКУдалению.Добавить(ИмяТаблицыДокумента);	
			КонецЕсли;
			
		КонецЦикла;
	КонецЕсли;
	
	Если МассивИменТЧКУдалению.Количество() > 0 Тогда
		МассивСтрокНастроекТЧКУдалению = Новый Массив;
		МассивСтрокСвязейТЧКУдалению = Новый Массив;
		Для Каждого ИмяТЧ Из МассивИменТЧКУдалению Цикл				
			Для Каждого СтрокаНастройки Из НастройкаВыгрузкиТЧ Цикл
				Если Найти(ВРег(СокрЛП(СтрокаНастройки.НастройкаТЧСтрокой)), ВРег(СокрЛП(ИмяТЧ))) Тогда
					МассивСтрокНастроекТЧКУдалению.Добавить(СтрокаНастройки);	
				КонецЕсли;
			КонецЦикла;
			Для Каждого СтрокаСвязи Из СвязиТабличныхЧастей Цикл
				Если Найти(ВРег(СокрЛП(СтрокаСвязи.ГлавнаяТаблица)), ВРег(СокрЛП(ИмяТЧ))) 
					Или Найти(ВРег(СокрЛП(СтрокаСвязи.ПодчиненнаяТаблица)), ВРег(СокрЛП(ИмяТЧ))) Тогда
					Если МассивСтрокСвязейТЧКУдалению.Найти(СтрокаСвязи) = Неопределено Тогда
						МассивСтрокСвязейТЧКУдалению.Добавить(СтрокаСвязи);
					КонецЕсли;
				КонецЕсли;
			КонецЦикла;
		КонецЦикла;
		Для Каждого Настройка Из МассивСтрокНастроекТЧКУдалению Цикл
			НастройкаВыгрузкиТЧ.Удалить(Настройка);	
		КонецЦикла;
		Для Каждого Настройка Из МассивСтрокСвязейТЧКУдалению Цикл
			СвязиТабличныхЧастей.Удалить(Настройка);	
		КонецЦикла;
	КонецЕсли;
	// ---
	
	Если НЕ ЗначениеЗаполнено(СтруктураНастроекБП.СвязиТабличныхЧастей) 
		ИЛИ НЕ СвязиТабличныхЧастей.Количество() Тогда
		Перейти ~ЦиклПоТабличнымЧастям;
	КонецЕсли;
	
	ИменаРеквизитовТЧ = Новый Соответствие;
	
	Если НастройкаВыгрузкиТЧ <> Неопределено Тогда
		Для каждого СтрокаНастройкиВыгрузкиТЧ Из НастройкаВыгрузкиТЧ Цикл
			СоответствиеИменРеквизитовТЧ = Новый Соответствие;
			Для каждого СтрокаТЧ ИЗ СтрокаНастройкиВыгрузкиТЧ.ТабличнаяЧастьДокумента1С Цикл
				//Если НЕ СтрокаТЧ.ТипИсточника = "Реквизит1С" Тогда
				//	Продолжить;
				//КонецЕсли;
				
				МассивИменРеквизитов = СоответствиеИменРеквизитовТЧ.Получить(СтрокаТЧ.ИмяИсточника);
				Если МассивИменРеквизитов = Неопределено Тогда
					МассивИменРеквизитов = Новый Массив;
				КонецЕсли;
				
				ПсевдонимКолонки = СтрокаТЧ.ИмяИсточника + "_" + СтрокаТЧ.ИмяПриемника;
				Если МассивИменРеквизитов.Найти(ПсевдонимКолонки) = Неопределено Тогда
					МассивИменРеквизитов.Добавить(ПсевдонимКолонки);
				КонецЕсли;
				
				СоответствиеИменРеквизитовТЧ.Вставить(СтрокаТЧ.ИмяИсточника, МассивИменРеквизитов);
			КонецЦикла;
			ИменаРеквизитовТЧ.Вставить(СтрокаНастройкиВыгрузкиТЧ.НастройкаТЧСтрокой, СоответствиеИменРеквизитовТЧ);
		КонецЦикла;
	КонецЕсли;
		
	// массив уникальных имен таблиц MS из таблицы связей
	МассивТаблицMS = Новый Массив;
	
	Для каждого Строка Из СтруктураНастроекБП.СвязиТабличныхЧастей Цикл
		Если Строка.Свойство("ЭтоТаблицаЗначений") Тогда
			Продолжить;
		КонецЕсли;
		Если МассивТаблицMS.Найти(Строка.ТабличнаяЧастьДокументаMS) = Неопределено Тогда
			МассивТаблицMS.Добавить(Строка.ТабличнаяЧастьДокументаMS);
		КонецЕсли;	
	КонецЦикла;		

	// копируем настройки из подчиненных таблиц в главную
	Для каждого Элемент Из МассивТаблицMS Цикл
		НайденныеСтроки = НастройкаВыгрузкиТЧ.НайтиСтроки(Новый Структура("ТабличнаяЧастьДокументаMS", Элемент));
		Если НайденныеСтроки.Количество() > 1 Тогда					
									
			ТаблицаКуда = НайденныеСтроки[0];
			
			КоличествоСтрок = НайденныеСтроки.Количество();
			Для Сч = -(КоличествоСтрок - 1) По -1 Цикл
				
				ТекущаяСтрока = НайденныеСтроки[-Сч];
				
				Для каждого Строка Из ТекущаяСтрока.ТабличнаяЧастьДокумента1С Цикл									
					ЗаполнитьЗначенияСвойств(ТаблицаКуда.ТабличнаяЧастьДокумента1С.Добавить(), Строка);
				КонецЦикла; 
				
				НайденныеСтроки.Удалить(-Сч);
				НастройкаВыгрузкиТЧ.Удалить(ТекущаяСтрока);
				
			КонецЦикла; 
		КонецЕсли; 			
	КонецЦикла; 			
				
	СвязиТабличныхЧастей.Сортировать("ТабличнаяЧастьДокументаMS ВОЗР, ГлавнаяТаблица ВОЗР, ПодчиненнаяТаблица ВОЗР");
	
	ТабличныеЧасти = СвязиТабличныхЧастей.Скопировать();
	ТабличныеЧасти.Свернуть("ТабличнаяЧастьДокументаMS, ГлавнаяТаблица, ПодчиненнаяТаблица");		
	
	Для каждого Элемент Из МассивТаблицMS Цикл
		
		СписокКолонок = Новый Массив;
		
		ОтобранныеТабличныеЧасти 		= ТабличныеЧасти.НайтиСтроки(Новый Структура("ТабличнаяЧастьДокументаMS", Элемент));		
		ОтобранныеСвязиТабличныхЧастей 	= СвязиТабличныхЧастей.НайтиСтроки(Новый Структура("ТабличнаяЧастьДокументаMS", Элемент));			
		
		ПсевдонимДокумента = "Документ" + СтруктураНастроекБП.ТипИсходногоДокумента1С;
		
		ТекстЗапроса = "ВЫБРАТЬ &ВыбираемыеПоля ИЗ Документ." + СтруктураНастроекБП.ТипИсходногоДокумента1С + " КАК " + ПсевдонимДокумента + "
		| &СтрокаСоединения
		| ГДЕ 
		|	" + ПсевдонимДокумента + ".Ссылка = &Ссылка";
			
		ТекущаяСтрока = ОтобранныеСвязиТабличныхЧастей[0];
		ПраваяТаблица = ТекущаяСтрока.ГлавнаяТаблица;
		ВыбираемыеПоля = "";
		ПараметрыЗапроса = Новый СписокЗначений;
		ПерваяСтрока = Истина;
		СтрокаСоединения = "";
		
	
		Если СписокДополнительныхОбработчиков.Получить(ПраваяТаблица) <> Неопределено Тогда
			
			РезультатОбработчика = СтруктураРезультатовДопТЧиЗапросов[ПраваяТаблица];
			ПсевдонимПравойТаблицы = СтруктураНастроекБП.ТипИсходногоДокумента1С + ПраваяТаблица;		
			
			МетаданныеСтроки = СписокДополнительныхОбработчиков[ПраваяТаблица].СписокКолонок;
			пПерваяСтрока = Истина;
			пВыбираемыеПоля = "";
			Для Каждого Колонка Из МетаданныеСтроки Цикл
				Если СписокКолонок.Найти(Колонка.Значение) = Неопределено Тогда
					ВыбираемыеПоля = ВыбираемыеПоля + Символы.ПС + ?(ПерваяСтрока, "", ", ") + "ЕСТЬNULL(" + ПсевдонимПравойТаблицы + "." + Колонка.Значение + ", """") КАК " + Колонка.Значение;
					СписокКолонок.Добавить(Колонка.Значение);
					ПерваяСтрока = Ложь;
				КонецЕсли;
				пВыбираемыеПоля = пВыбираемыеПоля + Символы.ПС + ?(пПерваяСтрока, "", ", ") + ПсевдонимПравойТаблицы + "." + Колонка.Значение + " КАК " + Колонка.Значение;
				пПерваяСтрока = Ложь;
			КонецЦИкла;
			пВыбираемыеПоля = пВыбираемыеПоля + Символы.ПС + "," + "ЕСТЬNULL(" + ПсевдонимПравойТаблицы + ".Ссылка, """") КАК Ссылка";
				
			ТекстЗапроса = "ВЫБРАТЬ " + пВыбираемыеПоля + " 
			| ПОМЕСТИТЬ ВложенныйЗапрос"+ПсевдонимПравойТаблицы+"
			|ИЗ &" + ПсевдонимПравойТаблицы + " КАК " + ПсевдонимПравойТаблицы + "
			|;
			|///////////////////////////////////////////////////////////////
			|"+ТекстЗапроса;
			
			ПараметрыЗапроса.Добавить(РезультатОбработчика,ПсевдонимПравойТаблицы);
			
			СтрокаСоединения = СтрокаСоединения + Символы.ПС + " ЛЕВОЕ СОЕДИНЕНИЕ ВложенныйЗапрос"+ПсевдонимПравойТаблицы+" КАК " + ПсевдонимПравойТаблицы + "  
			|	ПО 
			|	1=1";
			
		ИначеЕсли Найти(ВРег(СокрЛП(ПраваяТаблица)), ВРег(СокрЛП("Запрос"))) Тогда
			
			РезультатЗапроса = СтруктураРезультатовДопТЧиЗапросов["Запрос_" + Элемент];
			ПсевдонимПравойТаблицы = "ВложенныйЗапрос";
			Для каждого Колонка Из РезультатЗапроса.Колонки Цикл							
				Если СписокКолонок.Найти(Колонка.Имя) = Неопределено Тогда
					ВыбираемыеПоля = ВыбираемыеПоля + Символы.ПС + ?(ПерваяСтрока, "", ", ") + "ЕСТЬNULL(" + ПсевдонимПравойТаблицы + "." + Колонка.Имя + ", """") КАК " + Колонка.Имя;
					СписокКолонок.Добавить(Колонка.Имя);
					ПерваяСтрока = Ложь;
				КонецЕсли;	
			КонецЦикла; 						
			
			СтрокаСоединения = " ВНУТРЕННЕЕ СОЕДИНЕНИЕ (" + ТекстЗапросаВыгрузкиНаТСД +") КАК " + ПсевдонимПравойТаблицы + "  
			|	ПО 
			|	" + ПсевдонимДокумента + ".Ссылка = " + ПсевдонимПравойТаблицы + ".Ссылка";					
			
		Иначе	
			
			РеквизитыТЧ = ИменаРеквизитовТЧ.Получить(ПраваяТаблица);
			
			ПсевдонимПравойТаблицы = СтруктураНастроекБП.ТипИсходногоДокумента1С + ПраваяТаблица;		
			
			СтрокаСоединения = " ВНУТРЕННЕЕ СОЕДИНЕНИЕ Документ." + СтруктураНастроекБП.ТипИсходногоДокумента1С + "." + ПраваяТаблица + " КАК " + ПсевдонимПравойТаблицы + "  
			|	ПО 
			|	" + ПсевдонимДокумента + ".Ссылка = " + ПсевдонимПравойТаблицы + ".Ссылка";					
			
			МетаданныеСтроки = Документ1С.Метаданные().ТабличныеЧасти[ПраваяТаблица].Реквизиты;
			Для Каждого Колонка Из МетаданныеСтроки Цикл
				ПсевдонимыКолонок = Новый Массив;
				//ПсевдонимыКолонок.Добавить(Колонка.Имя); // Раскомментировать, если понадобится выбирать все поля
				Если РеквизитыТЧ <> Неопределено Тогда
					ПсевдонимыКолонокТЧ = РеквизитыТЧ.Получить(Колонка.Имя);
					Если ПсевдонимыКолонокТЧ <> Неопределено Тогда
						ПсевдонимыКолонок.Очистить();
						Для каждого ПсевдонимКолонки ИЗ ПсевдонимыКолонокТЧ Цикл
							ПсевдонимыКолонок.Добавить(ПсевдонимКолонки);
						КонецЦикла;
					КонецЕсли;
				КонецЕсли;
				Для каждого ПсевдонимКолонки ИЗ ПсевдонимыКолонок Цикл
					Если СписокКолонок.Найти(ПсевдонимКолонки) = Неопределено Тогда
						ВыбираемыеПоля = ВыбираемыеПоля + Символы.ПС + ?(ПерваяСтрока, "", ", ") + "ЕСТЬNULL(" + ПсевдонимПравойТаблицы + "." + Колонка.Имя + ", """") КАК " + ПсевдонимКолонки;
						СписокКолонок.Добавить(ПсевдонимКолонки);
						ПерваяСтрока = Ложь;
					КонецЕсли;
				КонецЦикла;
			КонецЦИкла;			
			
		КонецЕсли; 
			
		Для каждого ТекущаяСтрока Из ОтобранныеТабличныеЧасти Цикл
			
			ЛеваяТаблица = ТекущаяСтрока.ГлавнаяТаблица;
			ПсевдонимЛевойТаблицы = ?(Найти(ВРег(СокрЛП(ЛеваяТаблица)), ВРег(СокрЛП("Запрос"))),"ВложенныйЗапрос",СтруктураНастроекБП.ТипИсходногоДокумента1С + ЛеваяТаблица);
			
			ПраваяТаблица = ТекущаяСтрока.ПодчиненнаяТаблица;
			ПсевдонимПравойТаблицы = СтруктураНастроекБП.ТипИсходногоДокумента1С + ПраваяТаблица;
			ЕстьСоединение = Истина;
			Если СписокДополнительныхОбработчиков.Получить(ПраваяТаблица) <> Неопределено Тогда
				
				РезультатОбработчика = ГлЯдро_ВыполнитьОбработчикПолученияДанныхТЧ(СписокДополнительныхОбработчиков[ПраваяТаблица].ФункцияПолучения, Документ1С, ДанныеНастроекИзКэша, АдресаПеременных);
				
				Если РезультатОбработчика = Неопределено 
					ИЛИ РезультатОбработчика.Количество() = 0 Тогда
					ЕстьСоединение = Ложь;
				КонецЕсли;
				
				ПсевдонимПравойТаблицы = СтруктураНастроекБП.ТипИсходногоДокумента1С + ПраваяТаблица;		
				
				МетаданныеСтроки = СписокДополнительныхОбработчиков[ПраваяТаблица].СписокКолонок;
				пПерваяСтрока = Истина;
				пВыбираемыеПоля = "";
				Для Каждого Колонка Из МетаданныеСтроки Цикл
					Если СписокКолонок.Найти(Колонка.Значение) = Неопределено Тогда
						Если ЕстьСоединение = Истина Тогда
							ВыбираемыеПоля = ВыбираемыеПоля + Символы.ПС + ?(ПерваяСтрока, "", ", ") + "ЕСТЬNULL(" + ПсевдонимПравойТаблицы + "." + Колонка.Значение + ", """") КАК " + Колонка.Значение;
						Иначе
							ВыбираемыеПоля = ВыбираемыеПоля + Символы.ПС + ?(ПерваяСтрока, "", ", ") + """"" КАК " + Колонка.Значение;
						КонецЕсли;
						СписокКолонок.Добавить(Колонка.Значение);
						ПерваяСтрока = Ложь;
					КонецЕсли;
					пВыбираемыеПоля = пВыбираемыеПоля + Символы.ПС + ?(пПерваяСтрока, "", ", ") + ПсевдонимПравойТаблицы + "." + Колонка.Значение + " КАК " + Колонка.Значение;
					пПерваяСтрока = Ложь;
				КонецЦИкла;
				Если ЕстьСоединение = Истина Тогда
					ТекстЗапроса = "ВЫБРАТЬ " + пВыбираемыеПоля + " 
					| ПОМЕСТИТЬ ВложенныйЗапрос"+ПсевдонимПравойТаблицы+"
					|ИЗ &" + ПсевдонимПравойТаблицы + " КАК " + ПсевдонимПравойТаблицы + "
					|;
					|///////////////////////////////////////////////////////////////
					|"+ТекстЗапроса;
					
					ПараметрыЗапроса.Добавить(РезультатОбработчика,ПсевдонимПравойТаблицы);
					
					СтрокаСоединения = СтрокаСоединения + Символы.ПС + " ЛЕВОЕ СОЕДИНЕНИЕ ВложенныйЗапрос"+ПсевдонимПравойТаблицы+" КАК " + ПсевдонимПравойТаблицы + "  
					|	ПО 
					|	1=1";
				КонецЕсли;
				
			ИначеЕсли Найти(ВРег(СокрЛП(ПраваяТаблица)), ВРег(СокрЛП("Запрос"))) Тогда
				ТекстЗапросаВыгрузкиНаТСД = НастройкаВыгрузкиТЧ.НайтиСтроки(Новый Структура("ТабличнаяЧастьДокументаMS, НастройкаТЧСтрокой", Элемент, ПраваяТаблица))[0].ТекстЗапросаВыгрузкиНаТСД;
			    Запрос = Новый Запрос(СтрЗаменить(ТекстЗапросаВыгрузкиНаТСД, "¶", ""));
				Запрос.УстановитьПараметр("Ссылка", Документ1С);
				РезультатЗапроса = Запрос.Выполнить();
				Для каждого Колонка Из РезультатЗапроса.Колонки Цикл							
					Если СписокКолонок.Найти(Колонка.Имя) = Неопределено Тогда
						ВыбираемыеПоля = ВыбираемыеПоля + Символы.ПС + ?(ПерваяСтрока, "", ", ") + "ЕСТЬNULL(" + ПсевдонимПравойТаблицы + "." + Колонка.Имя + ", """") КАК " + Колонка.Имя;
						СписокКолонок.Добавить(Колонка.Имя);
						ПерваяСтрока = Ложь;
					КонецЕсли;	
				КонецЦикла; 
				
				ПсевдонимПравойТаблицы = "ВложенныйЗапрос";
				
				СтрокаСоединения = СтрокаСоединения + Символы.ПС + " ЛЕВОЕ СОЕДИНЕНИЕ (" + ТекстЗапросаВыгрузкиНаТСД +") КАК " + ПсевдонимПравойТаблицы + "  
				|	ПО 
				|	" + ПсевдонимЛевойТаблицы + ".Ссылка = " + ПсевдонимПравойТаблицы + ".Ссылка";					
				
			Иначе	
				
				РеквизитыТЧ = ИменаРеквизитовТЧ.Получить(ПраваяТаблица);
				
				ПсевдонимПравойТаблицы = СтруктураНастроекБП.ТипИсходногоДокумента1С + ПраваяТаблица;		
				
				СтрокаСоединения = СтрокаСоединения + Символы.ПС + " ЛЕВОЕ СОЕДИНЕНИЕ Документ." + СтруктураНастроекБП.ТипИсходногоДокумента1С + "." + ПраваяТаблица + " КАК " + ПсевдонимПравойТаблицы + "  
				|	ПО 
				|	" + ПсевдонимЛевойТаблицы + ".Ссылка = " + ПсевдонимПравойТаблицы + ".Ссылка";					
				
				МетаданныеСтроки = Документ1С.Метаданные().ТабличныеЧасти[ПраваяТаблица].Реквизиты;
				Для Каждого Колонка Из МетаданныеСтроки Цикл
					ПсевдонимыКолонок = Новый Массив;
					//ПсевдонимыКолонок.Добавить(Колонка.Имя); // Раскомментировать, если понадобится выбирать все поля
					Если РеквизитыТЧ <> Неопределено Тогда
						ПсевдонимыКолонокТЧ = РеквизитыТЧ.Получить(Колонка.Имя);
						Если ПсевдонимыКолонокТЧ <> Неопределено Тогда
							ПсевдонимыКолонок.Очистить();
							Для каждого ПсевдонимКолонки ИЗ ПсевдонимыКолонокТЧ Цикл
								ПсевдонимыКолонок.Добавить(ПсевдонимКолонки);
							КонецЦикла;
						КонецЕсли;
					КонецЕсли;
					Для каждого ПсевдонимКолонки ИЗ ПсевдонимыКолонок Цикл
						Если СписокКолонок.Найти(ПсевдонимКолонки) = Неопределено Тогда
							ВыбираемыеПоля = ВыбираемыеПоля + Символы.ПС + ?(ПерваяСтрока, "", ", ") + "ЕСТЬNULL(" + ПсевдонимПравойТаблицы + "." + Колонка.Имя + ", """") КАК " + ПсевдонимКолонки;
							СписокКолонок.Добавить(ПсевдонимКолонки);
							ПерваяСтрока = Ложь;
						КонецЕсли;
					КонецЦикла;
				КонецЦИкла;			
				
			КонецЕсли;
			
			Если ЕстьСоединение = Истина Тогда			
				НайденныеСтроки = СвязиТабличныхЧастей.НайтиСтроки(Новый Структура("ГлавнаяТаблица, ПодчиненнаяТаблица, ТабличнаяЧастьДокументаMS", ЛеваяТаблица, ПраваяТаблица, Элемент));			
				Для каждого НайденнаяСтрока Из НайденныеСтроки Цикл
					СтрокаСоединения = СтрокаСоединения + Символы.ПС + " И " + ПсевдонимЛевойТаблицы + "." + НайденнаяСтрока.ПолеГлавнойТаблицы + " = " + ПсевдонимПравойТаблицы + "." + НайденнаяСтрока.ПолеПодчиненнойТаблицы;			
				КонецЦикла;
			КонецЕсли;
			
		КонецЦикла; 		
		
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&СтрокаСоединения", 	СтрокаСоединения);
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ВыбираемыеПоля", 	ВыбираемыеПоля);
		
		Запрос = Новый Запрос(ТекстЗапроса);
		Запрос.УстановитьПараметр("Ссылка", Документ1С);
		
		Для каждого ДопПараметр Из ПараметрыЗапроса Цикл
			Запрос.УстановитьПараметр(ДопПараметр.Представление,ДопПараметр.Значение);			
		КонецЦикла;
		
		ИмяТекОбработчика = "Обработчик_ПослеОбъединенияТабличнойЧасти";
		ОбъединеннаяТаблицаДанныхТЧ = Запрос.Выполнить().Выгрузить();	
		
		СтруктураПараметров = ГлЯдро_ПолучитьСтруктуруПараметровВыполненияОбработчикаВыгрузки();
		СтруктураПараметров.СсылкаДокумент1С 		= Документ1С;
		СтруктураПараметров.ДанныеДокумента 		= ДанныеДокумента;
		СтруктураПараметров.НастройкаБП 			= СтруктураНастроекБП;
		СтруктураПараметров.ДанныеНастроекИзКэша 	= ДанныеНастроекИзКэша;
		СтруктураПараметров.ИнтеграционнаяОбработка = ИнтеграционнаяОбработка;
		СтруктураПараметров.ИмяПриемникаДанных 		= "ДанныеДляВыгрузки_Строка";
		СтруктураПараметров.ТЧ 						= ОбъединеннаяТаблицаДанныхТЧ;
				
		ГлЯдро_ВыполнитьОбработчикВыгрузкиДокумента1С(ИмяТекОбработчика, СтруктураПараметров, АдресаПеременных);	
		
		Если ДанныеДокумента.Свойство("КритическаяОшибка") И ДанныеДокумента.КритическаяОшибка = Истина Тогда
			ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Конец, Выгрузка документа 1С", НачалоСобытия, АдресаПеременных);
			Возврат Неопределено;
		КонецЕсли;  		
		
		Структура = Новый Структура;
		Структура.Вставить("ТаблицаДанныхТЧ", 	ОбъединеннаяТаблицаДанныхТЧ);
		Структура.Вставить("СписокКолонок", 	СписокКолонок);
		
		ТаблицыДанныхТЧ.Вставить(Элемент, Структура);
		
	КонецЦикла; 
	
	// ************************************ --- алгоритм выгрузки из нескольких ТЧ 1С в несколько ТЧ Mobile SMARTS ************************************		
	
	~ЦиклПоТабличнымЧастям:
	
	пТабличныеЧасти = Новый Структура;
	
	Если НастройкаВыгрузкиТЧ <> Неопределено Тогда
		Для каждого СтрокаНастройкиВыгрузкиТЧ Из НастройкаВыгрузкиТЧ Цикл		
			// Табличная часть		
			Если ТаблицыДанныхТЧ.Свойство(СтрокаНастройкиВыгрузкиТЧ.ТабличнаяЧастьДокументаMS) Тогда
				ТаблицаДанныхТЧ = ТаблицыДанныхТЧ[СтрокаНастройкиВыгрузкиТЧ.ТабличнаяЧастьДокументаMS]["ТаблицаДанныхТЧ"];
				СписокКолонок 	= ТаблицыДанныхТЧ[СтрокаНастройкиВыгрузкиТЧ.ТабличнаяЧастьДокументаMS]["СписокКолонок"];
			Иначе	
				СписокКолонок = Новый Массив;
				
				СписокДополнительныхОбработчиков = ГлЯдро_ПолучитьСписокДополнительныхОбработчиковПолученияТЧ(СтруктураНастроекБП.ТипИсходногоДокумента1С,АдресаПеременных);
				Если СписокДополнительныхОбработчиков.Получить(СтрокаНастройкиВыгрузкиТЧ.НастройкаТЧСтрокой) <> Неопределено Тогда
					Если ПраваяТаблица = Неопределено Тогда
						ПраваяТаблица = СтрокаНастройкиВыгрузкиТЧ.НастройкаТЧСтрокой;
					КонецЕсли;
					ТаблицаДанныхТЧ = СтруктураРезультатовДопТЧиЗапросов[ПраваяТаблица];
					Для Каждого Колонка Из ТаблицаДанныхТЧ.Колонки Цикл
						СписокКолонок.Добавить(Колонка.Имя);
					КонецЦИкла;
				ИначеЕсли Найти(СтрокаНастройкиВыгрузкиТЧ.НастройкаТЧСтрокой, "Запрос") Тогда
					ТаблицаДанныхТЧ = СтруктураРезультатовДопТЧиЗапросов["Запрос_" + СтрокаНастройкиВыгрузкиТЧ.ТабличнаяЧастьДокументаMS].Выгрузить();
					Для Каждого Колонка Из ТаблицаДанныхТЧ.Колонки Цикл
						СписокКолонок.Добавить(Колонка.Имя);
					КонецЦИкла;
				Иначе 
					ТаблицаДанныхТЧ = Документ1С[СтрокаНастройкиВыгрузкиТЧ.НастройкаТЧСтрокой];
					МетаданныеСтроки = Документ1С.Метаданные().ТабличныеЧасти[СтрокаНастройкиВыгрузкиТЧ.НастройкаТЧСтрокой].Реквизиты;
					Для Каждого Колонка Из МетаданныеСтроки Цикл
						СписокКолонок.Добавить(Колонка.Имя);
					КонецЦИкла;
				КонецЕсли;
			КонецЕсли;
			
			МетаданныеНСИ 			= Конф_ПолучитьМетаданныеНСИ(АдресаПеременных); 
			Номенклатура 			= МетаданныеНСИ.Номенклатура.ИмяСправочника;
			БазоваяЕдиницаИзмерения = МетаданныеНСИ.Номенклатура.БазоваяЕдиницаИзмерения;
			
			ЕстьКолонкаНоменклатура = Ложь;
			Если СписокКолонок.Найти(Номенклатура) <> Неопределено Тогда
				ИмяРеквизитаНоменклатура = Номенклатура;
				ЕстьКолонкаНоменклатура  = Истина;
			КонецЕсли;
			
			Для каждого ИмяКолонки ИЗ СписокКолонок Цикл
				Если ГлЯдро_СтрНайти(ИмяКолонки, "Номенклатура_") > 0 Тогда
					ИмяРеквизитаНоменклатураВторичн = ИмяКолонки;
					ЕстьКолонкаНоменклатура  = Истина;
					Прервать;
				КонецЕсли;
			КонецЦикла;		
			
			Если ЕстьКолонкаНоменклатура И Метаданные.Справочники.Найти(Номенклатура) <> Неопределено 
				И Метаданные.Справочники[Номенклатура].Реквизиты.Найти(БазоваяЕдиницаИзмерения.ИмяРеквизита) <> Неопределено Тогда 
				ЕстьРеквизитБазоваяЕдиницаИзмерения = Истина;
			Иначе
				ЕстьРеквизитБазоваяЕдиницаИзмерения = Ложь;
			КонецЕсли;		
			
			МассивДанныхСтрок = Новый Массив;
			
			ИмяТекОбработчика = "Обработчик_ПередВыгрузкойТабличнойЧасти";
			// Если настройки бизнес-процесса давно не обновлялись и данного свойства нет, пропускаем выполнение обработчика
			Если НастройкаВыгрузкиТЧ.Колонки.Найти(ИмяТекОбработчика) <> Неопределено Тогда						
				
				СтруктураПараметров = ГлЯдро_ПолучитьСтруктуруПараметровВыполненияОбработчикаВыгрузки();
				СтруктураПараметров.СсылкаДокумент1С 		= Документ1С;
				СтруктураПараметров.ДанныеДокумента 		= ДанныеДокумента;
				СтруктураПараметров.НастройкаБП 			= СтрокаНастройкиВыгрузкиТЧ;
				СтруктураПараметров.ДанныеНастроекИзКэша 	= ДанныеНастроекИзКэша;
				СтруктураПараметров.ИнтеграционнаяОбработка = ИнтеграционнаяОбработка;
				СтруктураПараметров.ИмяПриемникаДанных 		= "ДанныеДляВыгрузки_Строка";
				СтруктураПараметров.ТЧ 						= ТаблицаДанныхТЧ;
				
				ГлЯдро_ВыполнитьОбработчикВыгрузкиДокумента1С(ИмяТекОбработчика, СтруктураПараметров, АдресаПеременных);	
				
				Если ДанныеДокумента.Свойство("КритическаяОшибка") И ДанныеДокумента.КритическаяОшибка = Истина Тогда
					ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Конец, Выгрузка документа 1С", НачалоСобытия, АдресаПеременных);
					Возврат Неопределено;
				КонецЕсли;
				
			КонецЕсли;
			
			Для Каждого СтрокаТЧ Из ТаблицаДанныхТЧ Цикл
				
				// Строка документа
				ДанныеДляВыгрузки_Строка = Новый Структура;
				
				ТабличнаяЧастьДокумента1С = СтрокаНастройкиВыгрузкиТЧ.ТабличнаяЧастьДокумента1С;
				Если ТипЗнч(ТабличнаяЧастьДокумента1С) = Тип("ТаблицаЗначений") И ТабличнаяЧастьДокумента1С.Колонки.Найти("ТипИсточника") <> Неопределено Тогда
					// Реквизиты 1С
					ОтобранныеПравила = ТабличнаяЧастьДокумента1С.Скопировать(Новый Структура("Выгружать,ТипИсточника",Истина,"Реквизит1С"));
					ГлЯдро_ЗаполнитьДанныеДляВыгрузкиРеквизитами1С(СтрокаТЧ, ОтобранныеПравила, ДанныеДляВыгрузки_Строка, АдресаПеременных);

					// Произвольные значения
					ОтобранныеПравила = ТабличнаяЧастьДокумента1С.Скопировать(Новый Структура("Выгружать,ТипИсточника",Истина,"ПроизвольноеЗначение"));
					ГлЯдро_ЗаполнитьДанныеДляВыгрузкиПроизвольнымиЗначениями(ОтобранныеПравила, ДанныеДляВыгрузки_Строка);
					
					// Глобальные параметры
					ОтобранныеПравила = ГлЯдро_СкопироватьМассив(НастройкаВыгрузкиПолей,Новый Структура("Выгружать,ТипИсточника",Истина,"ГлобальныйПараметр"));
					ГлЯдро_ЗаполнитьДанныеДляВыгрузкиГлобальныйПараметр(Документ1С, Неопределено, ОтобранныеПравила, ДанныеДляВыгрузки_Шапка, Неопределено, "Строка", ЗначенияПараметров);
		            				
					// Произвольные коды
					ОтобранныеПравила = ТабличнаяЧастьДокумента1С.Скопировать(Новый Структура("Выгружать,ТипИсточника",Истина,"ПроизвольныйКод"));
					ГлЯдро_ЗаполнитьДанныеДляВыгрузкиПроизвольнымиКодами(Документ1С, СтрокаТЧ, ОтобранныеПравила, ДанныеДляВыгрузки_Шапка, ДанныеДляВыгрузки_Строка, "Строка", ПроизвольныеКодыТабличнойЧасти,АдресаПеременных);
					
					Если НЕ ДанныеДляВыгрузки_Строка.Свойство("ИдТовара") ИЛИ НЕ ЗначениеЗаполнено(ДанныеДляВыгрузки_Строка.ИдТовара) Тогда
						ДанныеДляВыгрузки_Строка.Вставить("ИдТовара", "*");
					КонецЕсли;
					
					Если НЕ ДанныеДляВыгрузки_Строка.Свойство("ИдУпаковки") 
						ИЛИ НЕ ЗначениеЗаполнено(ДанныеДляВыгрузки_Строка.ИдУпаковки) Тогда
						Если ДанныеДляВыгрузки_Строка.ИдТовара <> "*"
							И ЕстьРеквизитБазоваяЕдиницаИзмерения Тогда
							ИдУпаковки = "";
							Если ЗначениеЗаполнено(ИмяРеквизитаНоменклатура) Тогда
								ИдУпаковки = XMLСтрока(ГлЯдро_ПолучитьЕдиницуИзмеренияПоУмолчанию(СтрокаТЧ[ИмяРеквизитаНоменклатура],АдресаПеременных));
							КонецЕсли;
							Если НЕ ЗначениеЗаполнено(ИдУпаковки) И ЗначениеЗаполнено(ИмяРеквизитаНоменклатураВторичн) Тогда
								ИдУпаковки = XMLСтрока(ГлЯдро_ПолучитьЕдиницуИзмеренияПоУмолчанию(СтрокаТЧ[ИмяРеквизитаНоменклатураВторичн],АдресаПеременных));
							КонецЕсли;
							Если НЕ ЗначениеЗаполнено(ИдУпаковки) Тогда
								ИдУпаковки = "шт";
							КонецЕсли;
						Иначе
							ИдУпаковки = "шт";
						КонецЕсли;
						ДанныеДляВыгрузки_Строка.Вставить("ИдУпаковки", ИдУпаковки);
						ДанныеДляВыгрузки_Строка.Вставить("ИдЕдиницыИзмерения", ИдУпаковки);
					КонецЕсли;
													
				КонецЕсли;
				
				ИмяТекОбработчика = "Обработчик_ПередВыгрузкойСтрокиТабличнойЧасти";
				// Если настройки бизнес-процесса давно не обновлялись и данного свойства нет, пропускаем выполнение обработчика
				Если НастройкаВыгрузкиТЧ.Колонки.Найти(ИмяТекОбработчика) <> Неопределено Тогда
					
					СтруктураПараметров = ГлЯдро_ПолучитьСтруктуруПараметровВыполненияОбработчикаВыгрузки();
					СтруктураПараметров.СсылкаДокумент1С 		= Документ1С;
					СтруктураПараметров.ДанныеДокумента 		= ДанныеДокумента;
					СтруктураПараметров.НастройкаБП 			= СтрокаНастройкиВыгрузкиТЧ;
					СтруктураПараметров.ДанныеНастроекИзКэша 	= ДанныеНастроекИзКэша;
					СтруктураПараметров.ИнтеграционнаяОбработка = ИнтеграционнаяОбработка;
					СтруктураПараметров.ИмяПриемникаДанных 		= "ДанныеДляВыгрузки_Строка";
					СтруктураПараметров.ТЧ 						= ТаблицаДанныхТЧ;
					СтруктураПараметров.СтрокаДокумента			= ДанныеДляВыгрузки_Строка;
					
					ГлЯдро_ВыполнитьОбработчикВыгрузкиДокумента1С(ИмяТекОбработчика, СтруктураПараметров, АдресаПеременных);	
					
					Если ДанныеДокумента.Свойство("КритическаяОшибка") И ДанныеДокумента.КритическаяОшибка = Истина Тогда
						ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Конец, Выгрузка документа 1С", НачалоСобытия, АдресаПеременных);
						Возврат Неопределено;
					КонецЕсли;
					
				КонецЕсли;          
				
				ДанныеСтроки = ГлЯдро_ПолучитьДанныеДокумента1СПоПравиламОбмена(ДанныеДляВыгрузки_Строка, ТабличнаяЧастьДокумента1С);
				МассивДанныхСтрок.Добавить(ДанныеСтроки);
				
				ИмяТекОбработчика = "Обработчик_ПослеВыгрузкиСтрокиТабличнойЧасти";
				// Если настройки бизнес-процесса давно не обновлялись и данного свойства нет, пропускаем выполнение обработчика
				Если НастройкаВыгрузкиТЧ.Колонки.Найти(ИмяТекОбработчика) <> Неопределено Тогда
					
					СтруктураПараметров = ГлЯдро_ПолучитьСтруктуруПараметровВыполненияОбработчикаВыгрузки();
					СтруктураПараметров.СсылкаДокумент1С 		= Документ1С;
					СтруктураПараметров.ДанныеДокумента 		= ДанныеДокумента;
					СтруктураПараметров.НастройкаБП 			= СтрокаНастройкиВыгрузкиТЧ;
					СтруктураПараметров.ДанныеНастроекИзКэша 	= ДанныеНастроекИзКэша;
					СтруктураПараметров.ИнтеграционнаяОбработка = ИнтеграционнаяОбработка;
					СтруктураПараметров.ИмяПриемникаДанных 		= "ДанныеДляВыгрузки_Строка";
					СтруктураПараметров.ТЧ 						= ТаблицаДанныхТЧ;
					СтруктураПараметров.СтрокаДокумента			= ДанныеСтроки;
					
					ГлЯдро_ВыполнитьОбработчикВыгрузкиДокумента1С(ИмяТекОбработчика, СтруктураПараметров, АдресаПеременных);	
					
					Если ДанныеДокумента.Свойство("КритическаяОшибка") И ДанныеДокумента.КритическаяОшибка = Истина Тогда
						ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Конец, Выгрузка документа 1С", НачалоСобытия, АдресаПеременных);
						Возврат Неопределено;
					КонецЕсли;
					
				КонецЕсли;

				
			КонецЦикла;
			
			пТабличныеЧасти.Вставить(СтрокаНастройкиВыгрузкиТЧ.ТабличнаяЧастьДокументаMS, МассивДанныхСтрок);	
			
			ИмяТекОбработчика = "Обработчик_ПослеВыгрузкиТабличнойЧасти";
			// Если настройки бизнес-процесса давно не обновлялись и данного свойства нет, пропускаем выполнение обработчика
			Если НастройкаВыгрузкиТЧ.Колонки.Найти(ИмяТекОбработчика) <> Неопределено Тогда						
				
				СтруктураПараметров = ГлЯдро_ПолучитьСтруктуруПараметровВыполненияОбработчикаВыгрузки();
				СтруктураПараметров.СсылкаДокумент1С 		= Документ1С;
				СтруктураПараметров.ДанныеДокумента 		= ДанныеДокумента;
				СтруктураПараметров.НастройкаБП 			= СтрокаНастройкиВыгрузкиТЧ;
				СтруктураПараметров.ДанныеНастроекИзКэша 	= ДанныеНастроекИзКэша;
				СтруктураПараметров.ИнтеграционнаяОбработка = ИнтеграционнаяОбработка;
				СтруктураПараметров.ИмяПриемникаДанных 		= "ДанныеДляВыгрузки_Строка";
				СтруктураПараметров.ТЧ 						= МассивДанныхСтрок;
				
				ГлЯдро_ВыполнитьОбработчикВыгрузкиДокумента1С(ИмяТекОбработчика, СтруктураПараметров, АдресаПеременных);	
				
				Если ДанныеДокумента.Свойство("КритическаяОшибка") И ДанныеДокумента.КритическаяОшибка = Истина Тогда
					ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Конец, Выгрузка документа 1С", НачалоСобытия, АдресаПеременных);
					Возврат Неопределено;
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЦикла; 
		
	КонецЕсли;
	
	ДанныеДокумента.Вставить("ТабличныеЧасти", пТабличныеЧасти);
	
	СтруктураПараметров = ГлЯдро_ПолучитьСтруктуруПараметровВыполненияОбработчикаВыгрузки();
	СтруктураПараметров.СсылкаДокумент1С 		= Документ1С;
	СтруктураПараметров.ДанныеДокумента 		= ДанныеДокумента;
	СтруктураПараметров.НастройкаБП 			= НастройкаБП;
	СтруктураПараметров.ДанныеНастроекИзКэша 	= ДанныеНастроекИзКэша;
	СтруктураПараметров.ИнтеграционнаяОбработка = ИнтеграционнаяОбработка;
	СтруктураПараметров.ИмяПриемникаДанных 		= "ДанныеДляВыгрузки_Шапка";
	
	ГлЯдро_ВыполнитьОбработчикВыгрузкиДокумента1С("Обработчик_ПослеВыгрузкиДокумента", СтруктураПараметров, АдресаПеременных);	
	
	Если ДанныеДокумента.Свойство("КритическаяОшибка") И ДанныеДокумента.КритическаяОшибка = Истина Тогда
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Конец, Выгрузка документа 1С", НачалоСобытия, АдресаПеременных);
		Возврат Неопределено;
	КонецЕсли;
	
	// Закончили
	Возврат ДанныеДокумента;
	
КонецФункции

Функция ГлЯдро_ПолучитьДокумент1СДляВыгрузкиОнлайн(ID_Документа, ТипДокументаSMARTS, ID_БизнесПроцесса, ТипИнтерфейса="", АдресаПеременных)
	
	// Определяем БП по типу документа SMARTS и ID_БизнесПроцесса
	Отбор = Новый Структура("Используется, ТипДокументаMS, ID_БизнесПроцесса", Истина, ТипДокументаSMARTS, ID_БизнесПроцесса);
	НастройкиБП = ГлЯдро_ПолучитьИзКэшаЗначениеТабличнойНастройкиSMARTS("НастройкиБизнесПроцессов", Отбор,, АдресаПеременных);
	Если НастройкиБП = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	// Возможно каждому пользователю должна выгружаться отдельная копия
	НазначенныйПользователь = "";
	Если Найти(ID_Документа,"#")>0  Тогда
		КодДокумента =   ID_Документа;
		ID_Документа = Лев(ID_Документа, Найти(ID_Документа,"#")-1 );
		НазначенныйПользователь =   СтрЗаменить(КодДокумента, ID_Документа+"#","");
	КонецЕсли;

	// Пытаемся найти документ в базе по GUID
	Документ1С = Неопределено;
	Для Каждого СтрокаБП из НастройкиБП Цикл
		Если СтрокаБП.Свойство("ЭтоТаблицаЗначений")
			ИЛИ (СтрокаБП.Свойство("ТипИсходногоДокумента1С") И НЕ ЗначениеЗаполнено(СтрокаБП.ТипИсходногоДокумента1С)) Тогда
			Продолжить;
		КонецЕсли;
		
		Документ1С_Попытка = Документы[СтрокаБП.ТипИсходногоДокумента1С].ПолучитьСсылку(Новый УникальныйИдентификатор(ID_Документа));
		Если ГлЯдро_СсылкаСуществует(Документ1С_Попытка) Тогда
			Документ1с = Документ1С_Попытка;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	Если НЕ ЗначениеЗаполнено(Документ1С) Тогда
		Возврат Неопределено;
	КонецЕсли;

	ЭтоВнешнееСоединение = Ложь;
	#Если ВнешнееСоединение Тогда
		ЭтоВнешнееСоединение = Истина;
	#КонецЕсли
	
	Если ЭтоВнешнееСоединение ИЛИ ЭтоWebСервис Тогда
		НастройкаОтбора = ГлЯдро_ПолучитьНастройкуОтбораБизнесПроцесса(ID_БизнесПроцесса, "Онлайн", АдресаПеременных);
		Если НастройкаОтбора = Неопределено Тогда
			Возврат "#Не удалось определить настройку отбора для выбранного бизнес-процесса";
		КонецЕсли;
		
		ПараметрыУзлов = ГлЯдро_ПолучитьЗначенияГлобальныхПараметров(,,, АдресаПеременных);
		
		ДокументПопадаетВОтбор = ГлЯдро_ПроверитьПопаданиеСсылкиВОтборДокументов(НастройкаОтбора, Документ1С, ПараметрыУзлов, АдресаПеременных);
		Если НЕ ДокументПопадаетВОтбор Тогда		
			Возврат "#Документ не попадает в отбор по выбранному бизнес-процессу";
		КонецЕсли;
	КонецЕсли;
	
	ДанныеДокумента = ГлЯдро_ПолучитьДанныеДокумента1СДляВыгрузки(Документ1С, , ID_БизнесПроцесса,АдресаПеременных);
	Если ДанныеДокумента = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	//Если ТипИнтерфейса = "REST_API" Тогда
	ИспJSON_mXmlDoc = КомЯдро_ПолучитьЗначениеПеременной("ИспJSON_mXmlDoc",АдресаПеременных);
	Если ИспJSON_mXmlDoc = Истина
			ИЛИ (ИспJSON_mXmlDoc = Неопределено И ТипИнтерфейса = "REST_API") Тогда
		Результат = REST_API_СформироватьНовыйДокументSMARTS(ДанныеДокумента, НазначенныйПользователь, АдресаПеременных,Истина,Истина);
		Результат = ГлЯдро_ПолучитьJSON(Результат); //, "Cleverence.Warehouse.Document, Cleverence.MobileSMARTS");
	Иначе
		ДокументSMARTS = КомЯдро_СформироватьНовыйДокументSMARTS(ДанныеДокумента,НазначенныйПользователь);
	
		пCOMБазыMS = КомЯдро_ПолучитьЗначениеПеременной("COMБазыMS",АдресаПеременных);
		
		СтруктураПодключенияБазыMS = пCOMБазыMS;
		
		Результат = СтруктураПодключенияБазыMS.StorageConnector.СохранитьОбъектВ_XML(ДокументSMARTS);
	КонецЕсли;
	
	ГлЯдро_ОбработатьДокумент1СПослеВыгрузкиНаСерверSMARTS(Документ1С, ДанныеДокумента, , ID_БизнесПроцесса, АдресаПеременных);
	
	Отбор = Новый Структура("Используется,ТипИсходногоДокумента1С,ID_БизнесПроцесса", Истина, ГлЯдро_ПолучитьТипДокументаПоСсылке(Документ1С), ID_БизнесПроцесса);
	ОтобранныеБизнесПроцессы = ГлЯдро_ПолучитьИзКэшаЗначениеТабличнойНастройкиSMARTS("НастройкиБизнесПроцессов", Отбор, "", АдресаПеременных);	
	
	ЕстьЧастнаяБаза = КомЯдро_ПолучитьЗначениеПеременной("ЕстьЧастнаяБаза",АдресаПеременных);
	ТипБазы = ?(ЕстьЧастнаяБаза=Истина,"Частная","Основная");
		
	// Выгрузка номенклатуры из документа перед выгрузкой 	
	//флВыгрузитьНоменклатуруДокумента = ГлЯдро_ПолучитьИзКэшаНастройкуSMARTS("ВыгружатьНоменклатуруДокументаПередВыгрузкойДокумента",,АдресаПеременных);
	флВыгрузитьНоменклатуруДокумента = Ложь; // Не выгружаем номенклатуру в онлайне
	Если флВыгрузитьНоменклатуруДокумента Тогда
		ГлЯдро_ВыгрузитьНоменклатуруИзДокумента(Документ1С, ОтобранныеБизнесПроцессы[0],ТипБазы, АдресаПеременных);	
	КонецЕсли;	
	
	Возврат Результат;
	
КонецФункции

Процедура ГлЯдро_ЗаполнитьДанныеДляВыгрузкиРеквизитами1С(ИсточникДанных, ПравилаОбмена, Результат, АдресаПеременных = Неопределено)
	
	Если ПравилаОбмена = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Для Каждого Правило Из ПравилаОбмена Цикл
		ЗначениеРеквизитаДляВыгрузки = "";
		
		ИмяИсточника = Правило.ИмяИсточника;
		Если ТипЗнч(ИсточникДанных) = Тип("СтрокаТаблицыЗначений") Тогда
			ПсевдонимКолонки = Правило.ИмяИсточника + "_" + Правило.ИмяПриемника;
			
			УИД = Новый УникальныйИдентификатор();
			СтруктураДляПроверки = Новый Структура(ПсевдонимКолонки, УИД);
			ЗаполнитьЗначенияСвойств(СтруктураДляПроверки, ИсточникДанных);
			Если СтруктураДляПроверки[ПсевдонимКолонки] <> УИД Тогда 
				ИмяИсточника = ПсевдонимКолонки;
			КонецЕсли;
		КонецЕсли;
		
		Попытка
			ЗначениеЗаполненоВИсточнике = ЗначениеЗаполнено(ИсточникДанных[ИмяИсточника]);			
		Исключение
			Если АдресаПеременных <> Неопределено Тогда
				ИмяСобытия = "ГлЯдро_ЗаполнитьДанныеДляВыгрузкиРеквизитами1С";
				ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
				ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", ТекстОшибки, , АдресаПеременных);				
			КонецЕсли;
			Продолжить;
		КонецПопытки;
		
		Если ЗначениеЗаполненоВИсточнике Тогда
			Попытка
				Если Правило.СпособСопоставления = "СтрокаGUID" Тогда
					ЗначениеРеквизитаДляВыгрузки = XMLСтрока(ИсточникДанных[ИмяИсточника].УникальныйИдентификатор());
				ИначеЕсли Правило.СпособСопоставления = "Наименование" Тогда
					ЗначениеРеквизитаДляВыгрузки = ИсточникДанных[ИмяИсточника].Наименование;
				ИначеЕсли Правило.СпособСопоставления = "Код" Тогда
					ЗначениеРеквизитаДляВыгрузки = ИсточникДанных[ИмяИсточника].Код;
				ИначеЕсли Правило.СпособСопоставления = "КакЕсть" Тогда
					ЗначениеРеквизитаДляВыгрузки = ИсточникДанных[ИмяИсточника];
				КонецЕсли;
			Исключение	
			КонецПопытки;
		КонецЕсли;
		// +++ Условие нужно для случая, когда данные получены из соединения нескольких таблиц и заполнение реквизита настроено в нескольких из них.
		//     Без условия остаются данные только последней таблицы
		Если Не ЗначениеЗаполнено(ЗначениеРеквизитаДляВыгрузки) Тогда
			Если Результат.Свойство(Правило.ИмяПриемника)
				И ЗначениеЗаполнено(Результат[Правило.ИмяПриемника]) Тогда
				Продолжить;
			КонецЕсли;						
		КонецЕсли;
		// ---
		Результат.Вставить(Правило.ИмяПриемника, ЗначениеРеквизитаДляВыгрузки);
		
	КонецЦикла;
	
КонецПроцедуры

Процедура ГлЯдро_ЗаполнитьДанныеДляВыгрузкиПроизвольнымиЗначениями(ПравилаОбмена, Результат)
	
	Если ПравилаОбмена = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Для Каждого Правило Из ПравилаОбмена Цикл
		ЗначениеРеквизитаДляВыгрузки = "";
		Если ЗначениеЗаполнено(Правило.ИмяПриемника) И ЗначениеЗаполнено(Правило.ЗначениеИсточника) Тогда
			Попытка
				Если Правило.СпособСопоставления = "СтрокаGUID" Тогда
					ЗначениеРеквизитаДляВыгрузки = XMLСтрока(Правило.ЗначениеИсточника.УникальныйИдентификатор());
				ИначеЕсли Правило.СпособСопоставления = "Наименование" Тогда
					ЗначениеРеквизитаДляВыгрузки = Правило.ЗначениеИсточника.Наименование;
				ИначеЕсли Правило.СпособСопоставления = "Код" Тогда
					ЗначениеРеквизитаДляВыгрузки = Правило.ЗначениеИсточника.Код;
				Иначе
					ЗначениеРеквизитаДляВыгрузки = Правило.ЗначениеИсточника;
				КонецЕсли;
			Исключение	
			КонецПопытки;
			Результат.Вставить(Правило.ИмяПриемника, ЗначениеРеквизитаДляВыгрузки);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

Процедура ГлЯдро_ЗаполнитьДанныеДляВыгрузкиПроизвольнымиКодами(Документ1С, СтрокаДокумента1С, ПравилаОбмена, ДанныеДляВыгрузки_Шапка, ДанныеДляВыгрузки_Строка, ТипВыгрузки, ПроизвольныеКоды,АдресаПеременных)
	
	Если ПравилаОбмена = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	СтруктураИО = КомЯдро_ПолучитьЗначениеПеременной("ИнтеграционнаяОбработка",АдресаПеременных);
		
	Если (НЕ СтруктураИО = Неопределено
		И ТипЗнч(СтруктураИО) = Тип("Структура")
		И СтруктураИО.Свойство("ИнтеграционнаяОбработка")) Тогда
		Если СтруктураИО.ИнтеграционнаяОбработка = Неопределено Тогда
			ГлЯдро_ПересоздатьИнтеграционнуюОбработку(АдресаПеременных);
			СтруктураИО = КомЯдро_ПолучитьЗначениеПеременной("ИнтеграционнаяОбработка",АдресаПеременных);
		КонецЕсли;
		ИнтеграционнаяОбработка = СтруктураИО.ИнтеграционнаяОбработка;
	Иначе	
		ИнтеграционнаяОбработка = Неопределено;
	КонецЕсли;	
	
	Для Каждого Правило Из ПравилаОбмена Цикл
		ЗначениеРеквизитаДляВыгрузки = "";
		// Временное решение. ИмяИсточника начинает хранить ID кода только после перевыбора его в форме сопоставления полей выгрузки
		ID_ПроизвольногоКода = ?(ЗначениеЗаполнено(Правило.ИмяИсточника), Правило.ИмяИсточника, Правило.ЗначениеИсточника);
		Если ЗначениеЗаполнено(ID_ПроизвольногоКода) И ЗначениеЗаполнено(Правило.ИмяПриемника) Тогда
			Если ТипЗнч(ПроизвольныеКоды) = Тип("ТаблицаЗначений") Тогда
				НайденныйПК = ПроизвольныеКоды.Найти(ID_ПроизвольногоКода);	
			ИначеЕсли ТипЗнч(ПроизвольныеКоды) = Тип("Массив") Тогда
				НайденныйПК = ГлЯдро_СкопироватьМассив(ПроизвольныеКоды,Новый Структура("ID_ПроизвольногоКода",ID_ПроизвольногоКода));
				Если НайденныйПК.Количество()>0 Тогда
					НайденныйПК = НайденныйПК[0];
				Иначе 
					НайденныйПК = Неопределено;
				КонецЕсли;
			Иначе
				Продолжить;
			КонецЕсли;
			
			Если НайденныйПК <> Неопределено Тогда
				СтруктураПеременных = Новый Структура;
				СтруктураПеременных.Вставить("СсылкаДокумент1С", Документ1С);
				СтруктураПеременных.Вставить("ДанныеДляВыгрузки_Шапка", ДанныеДляВыгрузки_Шапка);
				СтруктураПеременных.Вставить("МодульОбработки", ИнтеграционнаяОбработка);
				Если ТипВыгрузки = "Строка" Тогда
					СтруктураПеременных.Вставить("СтрокаТЧДокумента1С", СтрокаДокумента1С);
					СтруктураПеременных.Вставить("ДанныеДляВыгрузки_Строка", ДанныеДляВыгрузки_Строка);
				КонецЕсли;
				РезультатВыполненияКода = ГлЯдро_ВыполнитьПроизвольныйКод(НайденныйПК.ТекстПроизвольногоКода, СтруктураПеременных,ID_ПроизвольногоКода,НайденныйПК.Наименование,АдресаПеременных);
				Если РезультатВыполненияКода.Статус Тогда
					ЗначениеРеквизитаДляВыгрузки = РезультатВыполненияКода.Данные;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		Если ТипВыгрузки = "Шапка" Тогда
			ДанныеДляВыгрузки_Шапка.Вставить(Правило.ИмяПриемника, ЗначениеРеквизитаДляВыгрузки);
		ИначеЕсли ТипВыгрузки = "Строка" Тогда
			ДанныеДляВыгрузки_Строка.Вставить(Правило.ИмяПриемника, ЗначениеРеквизитаДляВыгрузки);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

Процедура ГлЯдро_ЗаполнитьДанныеДляВыгрузкиГлобальныйПараметр(Документ1С, СтрокаДокумента1С, ПравилаОбмена, ДанныеДляВыгрузки_Шапка, ДанныеДляВыгрузки_Строка, ТипВыгрузки, ГлобальныеПараметры)
	
	Если ТипЗнч(ПравилаОбмена) <> Тип("Массив") 
		ИЛИ ПравилаОбмена.Количество() = 0
		ИЛИ ТипЗнч(ГлобальныеПараметры) <> Тип("Массив")
		ИЛИ (ТипВыгрузки = "Шапка" И ТипЗнч(ДанныеДляВыгрузки_Шапка) <> Тип("Структура"))
		ИЛИ (ТипВыгрузки = "Строка" И ТипЗнч(ДанныеДляВыгрузки_Строка) <> Тип("Структура")) Тогда
		Возврат;
	КонецЕсли;
	
	Для Каждого Правило Из ПравилаОбмена Цикл
		
		ЗначениеРеквизитаДляЗагрузки = "";
		Если ЗначениеЗаполнено(Правило.ИмяИсточника)
				И ЗначениеЗаполнено(Правило.ИмяПриемника) Тогда
			НайденныйГП = ГлЯдро_НайтиСтруктуруВМассивеПоЭлементу(ГлобальныеПараметры, "ID_Параметра", Правило.ИмяИсточника);
			Если НайденныйГП <> Неопределено Тогда
				ЗначениеРеквизитаДляЗагрузки = НайденныйГП.Значение;
			КонецЕсли;
			
			Если ТипВыгрузки = "Шапка" Тогда
				ДанныеДляВыгрузки_Шапка.Вставить(Правило.ИмяПриемника, ЗначениеРеквизитаДляЗагрузки);
			ИначеЕсли ТипВыгрузки = "Строка" Тогда
				ДанныеДляВыгрузки_Строка.Вставить(Правило.ИмяПриемника, ЗначениеРеквизитаДляЗагрузки);
			КонецЕсли;
			
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

Функция ГлЯдро_ПолучитьДанныеДокумента1СПоПравиламОбмена(Источник, ПравилаОбмена)
	
	Результат = Новый Структура;
	
	Если ПравилаОбмена = Неопределено Тогда
		Возврат Результат;
	КонецЕсли;
	
	Если ТипЗнч(ПравилаОбмена) = Тип("ТаблицаЗначений") Тогда
		ОтобранныеПравила = ПравилаОбмена.НайтиСтроки(Новый Структура("Выгружать", Истина));
	ИначеЕсли ТипЗнч(ПравилаОбмена) = Тип("Массив") Тогда
		ОтобранныеПравила = ГлЯдро_СкопироватьМассив(ПравилаОбмена,Новый Структура("Выгружать", Истина));		
	КонецЕсли;
	
	Для Каждого Правило Из ОтобранныеПравила Цикл
		Попытка
			ЗначениеРеквизитаВИсточнике = Источник[Правило.ИмяПриемника];			
		Исключение
			Продолжить;
		КонецПопытки;
		
		Результат.Вставить(Правило.ИмяПриемника, ЗначениеРеквизитаВИсточнике);
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Функция ГлЯдро_ВыполнитьОбработчикПолученияДанныхТЧ(ФункцияПолучения, Документ1С, ДанныеНастроекИзКэша = Неопределено, АдресаПеременных)
	
	Результат = Новый ТаблицаЗначений;	
	
	Если ЗначениеЗаполнено(ФункцияПолучения) Тогда
		СтруктураИО = КомЯдро_ПолучитьЗначениеПеременной("ИнтеграционнаяОбработка",АдресаПеременных);
		
		Если (СтруктураИО = Неопределено
			ИЛИ НЕ ТипЗнч(СтруктураИО) = Тип("Структура")
			ИЛИ НЕ СтруктураИО.Свойство("ИнтеграционнаяОбработка")
			ИЛИ СтруктураИО.ИнтеграционнаяОбработка = Неопределено)
			И НЕ ГлЯдро_ПересоздатьИнтеграционнуюОбработку(АдресаПеременных) Тогда
			ИнтеграционнаяОбработка = Неопределено;
		Иначе
			СтруктураИО = КомЯдро_ПолучитьЗначениеПеременной("ИнтеграционнаяОбработка",АдресаПеременных);
			ИнтеграционнаяОбработка = СтруктураИО.ИнтеграционнаяОбработка;
		КонецЕсли;
		
		ТекущиеНастройкиMS = КомЯдро_ПолучитьЗначениеПеременной("ТекущиеНастройкиMS",АдресаПеременных);		
		
		ЗначенияПараметров = Неопределено;
		Если ДанныеНастроекИзКэша = Неопределено
			ИЛИ НЕ ДанныеНастроекИзКэша.Свойство("ЗначенияПараметров")
			ИЛИ ТипЗнч(ДанныеНастроекИзКэша.ЗначенияПараметров) <> Тип("Массив") Тогда
			ЗначенияПараметров = ГлЯдро_ПолучитьЗначенияГлобальныхПараметров(,,,АдресаПеременных);
		Иначе
			ЗначенияПараметров = ДанныеНастроекИзКэша.ЗначенияПараметров;
		КонецЕсли;
		
		СтруктураПараметров = Новый Структура;
		СтруктураПараметров.Вставить("Документ1С", 			Документ1С);
		СтруктураПараметров.Вставить("ТекущиеНастройкиMS", 	ТекущиеНастройкиMS);
		СтруктураПараметров.Вставить("ЗначенияПараметров",	ЗначенияПараметров);

		Попытка
			//Выполнить("Результат = ИнтеграционнаяОбработка." + ФункцияПолучения
			//	+ "(СтруктураПараметров)");
			ПараметрыАлгоритма = Новый Структура;
			ПараметрыАлгоритма.Вставить("Результат", Результат);
			ПараметрыАлгоритма.Вставить("ИнтеграционнаяОбработка", ИнтеграционнаяОбработка);
			ПараметрыАлгоритма.Вставить("СтруктураПараметров", СтруктураПараметров);
			ГлЯдро_ВыполнитьВБезопасномРежиме("Параметры.Результат = Параметры.ИнтеграционнаяОбработка." + ФункцияПолучения
				+ "(Параметры.СтруктураПараметров)", ПараметрыАлгоритма, АдресаПеременных);
			Результат = ПараметрыАлгоритма.Результат;
		Исключение
			ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
			ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации("ГлЯдро_ВыполнитьОбработчикПолученияДанныхТЧ", "Ошибка", "Не удалось выполнить обработчик """ + ФункцияПолучения + """. Причина: " + ТекстОшибки,,АдресаПеременных);			
		КонецПопытки;

		Если СтруктураПараметров.Свойство("КритическаяОшибка")
			И СтруктураПараметров.КритическаяОшибка Тогда
			Если СтруктураПараметров.Свойство("КритическаяОшибкаОписание") Тогда
				КритическаяОшибкаОписание = СтруктураПараметров.КритическаяОшибкаОписание;	
			Иначе	
				КритическаяОшибкаОписание = "(Пусто)";
			КонецЕсли;
			ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации("ГлЯдро_ВыполнитьОбработчикПолученияДанныхТЧ", "Ошибка", "Критическая ошибка при выполнении обработчика """ + ФункцияПолучения + """. Причина: " + КритическаяОшибкаОписание,,АдресаПеременных);
			ВызватьИсключение "Критическая ошибка при выполнении обработчика """ + ФункцияПолучения + """. Причина: " + КритическаяОшибкаОписание;
		КонецЕсли;

	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

Процедура ГлЯдро_ВыгрузитьНоменклатуруИзДокумента(Документ1С, НастройкаБП,ТипБазы, АдресаПеременных)
			
	МетаданныеНСИ = ГлЯдро_ПолучитьМетаданныеНСИ(АдресаПеременных);
	НазваниеРеквизитаНоменклатуры = МетаданныеНСИ.Номенклатура.ИмяСправочника;
	СтруктураМетаданных = КомЯдро_ПолучитьЗначениеПеременной("СтруктураМетаданных",АдресаПеременных);
	
	//Найдем настройку выгрузки ТЧ с номенклатурой и название ТЧ с номенклатурой
	ИмяТЧДокумента = "";
	НастройкиВыгрузкиТЧ = НастройкаБП.НастройкаВыгрузкиТЧ;
	
	Если НастройкиВыгрузкиТЧ = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Для Каждого НастройкаВыгрузкиТЧ из НастройкиВыгрузкиТЧ Цикл
		Если НастройкаВыгрузкиТЧ.Свойство("ЭтоТаблицаЗначений") Тогда
			Продолжить;
		КонецЕсли;
		тчСопоставленияРеквизитов = НастройкаВыгрузкиТЧ.ТабличнаяЧастьДокумента1С;
		НайденныеСтрокиНастройки = ГлЯдро_НайтиВМассивеСтруктурПоОтбору(тчСопоставленияРеквизитов,Новый Структура("ИмяПриемника","ИдТовара"));
		Если НайденныеСтрокиНастройки <> Неопределено И НайденныеСтрокиНастройки.Количество() > 0 Тогда
			ИмяТЧДокумента = НастройкаВыгрузкиТЧ.НастройкаТЧСтрокой;
			ИмяРеквизитаИсточника = НайденныеСтрокиНастройки[0].ИмяИсточника;
			СписокДополнительныхОбработчиков = ГлЯдро_ПолучитьСписокДополнительныхОбработчиковПолученияТЧ(НастройкаБП.ТипИсходногоДокумента1С, АдресаПеременных);
			Если ГлЯдро_СтрНайти(ВРЕГ(ИмяТЧДокумента), "ЗАПРОС") = 0
				И НЕ (СписокДополнительныхОбработчиков <> Неопределено И СписокДополнительныхОбработчиков.Получить(ИмяТЧДокумента) <> Неопределено)
				И СтруктураМетаданных.Документы1С[НастройкаБП.ТипИсходногоДокумента1С].ТабличныеЧасти[ИмяТЧДокумента].Реквизиты.НайтиПоЗначению(НазваниеРеквизитаНоменклатуры) <> Неопределено Тогда
				Прервать;
			Иначе
				ИмяТЧДокумента = "";
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Если ИмяТЧДокумента <> "" Тогда

		МассивНоменклатуры = ГлЯдро_ВыгрузитьКолонкуИзТЧДокумента(Документ1С,НастройкаВыгрузкиТЧ,НазваниеРеквизитаНоменклатуры,ИмяРеквизитаИсточника, АдресаПеременных);
		
		Если НЕ МассивНоменклатуры.Количество() Тогда
			Возврат;
		КонецЕсли;
		
		НастройкиКомпоновщика = "";
		Отбор = Новый Структура("ИмяТаблицы", "Номенклатура");
		НастройкаКомпоновщикаСтрокой = ГлЯдро_ПолучитьИзКэшаЗначениеТабличнойНастройкиSMARTS("НастройкиОбменаСправочников", Отбор, "НастройкаКомпоновщикаСтрокой", АдресаПеременных);
		Если ЗначениеЗаполнено(НастройкаКомпоновщикаСтрокой) Тогда
			НастройкиКомпоновщика = ГлЯдро_ЗначениеИзСтрокиXML(НастройкаКомпоновщикаСтрокой);
		КонецЕслИ;
		
		РаботаБезАлкоголя 					= ГлЯдро_ПолучитьИзКэшаНастройкуSMARTS("РаботаБезАлкоголя", , АдресаПеременных);		
		
		ПараметрыВыгрузки = ГлЯдро_ПолучитьЗаполнитьСтруктуруПараметровВыгрузкиСправочника("Номенклатура", АдресаПеременных);
		
		ДанныеДляВыгрузки = ГлЯдро_ПолучитьПорциюДанныхДляВыгрузки("Номенклатура", НастройкиКомпоновщика,"", ТипБазы,МассивНоменклатуры,РаботаБезАлкоголя, ПараметрыВыгрузки,, АдресаПеременных);
		
		флОчищатьСправочникПередВыгрузкой = Ложь;
		
		РезультатВыгрузки = ГлЯдро_ВыгрузитьПодготовленныйМассивНаСерверSMARTS("Номенклатура", ДанныеДляВыгрузки, ТипБазы, флОчищатьСправочникПередВыгрузкой, АдресаПеременных);		
		
		Если НЕ РезультатВыгрузки.Свойство("Статус") ИЛИ НЕ РезультатВыгрузки.Статус = Истина Тогда	
			ТипИнтерфейса = ГлЯдро_ПолучитьТипИнтерфейса(ТипБазы, АдресаПеременных); // ТипИнтерфейса = КомЯдро_ПолучитьЗначениеПеременной("ТипИнтерфейса", АдресаПеременных);
			Если ТипИнтерфейса = "REST_API" Тогда
				Сообщение = РезультатВыгрузки.Сообщение;
			Иначе	
				ОписаниеОшибки = КомЯдро_ПолучитьОшибку(ТипБазы, АдресаПеременных);		
				Сообщение = "Ошибка выгрузки таблицы [Номеклатура]." + Символы.ВК + ОписаниеОшибки;
			КонецЕсли;
			Сообщение = "Ошибка выгрузки таблицы [Номеклатура]." + Символы.ВК + ОписаниеОшибки;
			Сообщить(Сообщение);							
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры

Функция ГлЯдро_ВыгрузитьКолонкуИзТЧДокумента(Документ1С,НастройкаВыгрузкиТЧ,НазваниеРеквизита,ИмяРеквизитаИсточника, АдресаПеременных)
	ИмяТЧДокумента = НастройкаВыгрузкиТЧ.НастройкаТЧСтрокой;
	
	Если ИмяТЧДокумента = "(Запрос)"  Или ИмяТЧДокумента = "Запрос"Тогда
			
		МассивНоменклатуры = Новый Массив;
		
		Запрос = Новый Запрос(СтрЗаменить(НастройкаВыгрузкиТЧ.ТекстЗапросаВыгрузкиНаТСД, "¶", ""));		
		Запрос.УстановитьПараметр("Ссылка", Документ1С);
			
		ПараметрыЗапроса = Новый Структура;    
		Попытка					
			//Выполнить(СтрЗаменить(НастройкаВыгрузкиТЧ.ТекстКодаПолучениеПараметров, "ДокументДляВыгрузки", "Документ1С"));
			ТекстКодаПолучениеПараметров = СтрЗаменить(НастройкаВыгрузкиТЧ.ТекстКодаПолучениеПараметров, "ДокументДляВыгрузки", "Документ1С");
			СтрокаВызова = СтрЗаменить(ТекстКодаПолучениеПараметров, "ПараметрыЗапроса", "Параметры.ПараметрыЗапроса");
			ПараметрыАлгоритма = Новый Структура;
			ПараметрыАлгоритма.Вставить("ПараметрыЗапроса", ПараметрыЗапроса);
			ГлЯдро_ВыполнитьВБезопасномРежиме(СтрокаВызова, ПараметрыАлгоритма, АдресаПеременных);
			ПараметрыЗапроса = ПараметрыАлгоритма.ПараметрыЗапроса;
			
			Если ПараметрыЗапроса.Количество() Тогда
				Для Каждого ПараметрЗапроса Из ПараметрыЗапроса Цикл
					Запрос.УстановитьПараметр(ПараметрЗапроса.Ключ, ПараметрЗапроса.Значение);	
				КонецЦикла;
			КонецЕсли;
		Исключение
			Сообщить("Ошибка получения параметров запроса табличной части. Номенклатура документа не выгружена" + Символы.ПС + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		КонецПопытки;				
		
		ТаблицаДанныхТЧ = Запрос.Выполнить().Выгрузить();
		МассивНоменклатуры = ТаблицаДанныхТЧ.ВыгрузитьКолонку(ИмяРеквизитаИсточника);
	Иначе
		Если ТипЗнч(Документ1С) = Тип("Массив") Тогда
			ОбщийМассив = Новый Массив;
			Для каждого СтрокаМассива Из Документ1С Цикл
				
				Док = СтрокаМассива;
				ТЧДокумента =  Док[ИмяТЧДокумента];
				
				Для каждого СтрокаТЧ Из ТЧДокумента Цикл
					ОбщийМассив.Добавить(СтрокаТЧ[НазваниеРеквизита]);	
				КонецЦикла;
				
			КонецЦикла;
			
			МассивНоменклатуры =  ОбщийМассив;
				
		Иначе 
			МассивНоменклатуры = Документ1С[ИмяТЧДокумента].ВыгрузитьКолонку(НазваниеРеквизита);
		КонецЕсли;
	КонецЕсли;
	
	// Из массива надо убрать пустые ссылки, иначе "захватится" вся номенклатура
	Если МассивНоменклатуры.Количество()>0 Тогда												
		КолвоЭлементовКоллекции = МассивНоменклатуры.Количество(); 
		Для ОбратныйИндекс = 1 По КолвоЭлементовКоллекции Цикл 
			ЭлементМассива = МассивНоменклатуры[КолвоЭлементовКоллекции - ОбратныйИндекс]; 
			Если ЭлементМассива.Пустая() Тогда 
				МассивНоменклатуры.Удалить(КолвоЭлементовКоллекции - ОбратныйИндекс); 
			КонецЕсли; 
		КонецЦикла;
	КонецЕсли;
	
	Возврат МассивНоменклатуры;

КонецФункции

Процедура ГлЯдро_ОбработатьДокумент1СПослеВыгрузкиНаСерверSMARTS(Документ1С, ДанныеДокумента, ДанныеНастроекИзКэша = Неопределено, ID_БизнесПроцесса = "",АдресаПеременных) Экспорт
	
	НачалоСобытия = ТекущаяУниверсальнаяДатаВМиллисекундах();
	ИмяСобытия = "ГлЯдро_ОбработатьДокумент1СПослеВыгрузкиНаСерверSMARTS";
	
	СтруктураИО = КомЯдро_ПолучитьЗначениеПеременной("ИнтеграционнаяОбработка", АдресаПеременных);
		
	Если (СтруктураИО = Неопределено
		ИЛИ НЕ ТипЗнч(СтруктураИО) = Тип("Структура")
		ИЛИ НЕ СтруктураИО.Свойство("ИнтеграционнаяОбработка")
		ИЛИ СтруктураИО.ИнтеграционнаяОбработка = Неопределено)
		И НЕ ГлЯдро_ПересоздатьИнтеграционнуюОбработку(АдресаПеременных) Тогда
		Возврат;
	КонецЕсли;
	
	ИнтеграционнаяОбработка = СтруктураИО.ИнтеграционнаяОбработка;
	
	СписокБизнесПроцессов = Неопределено;
	
	Если ДанныеНастроекИзКэша = Неопределено ИЛИ НЕ ДанныеНастроекИзКэша.Свойство("СписокБизнесПроцессов") ИЛИ ДанныеНастроекИзКэша.СписокБизнесПроцессов = Неопределено Тогда
		Отбор = Новый Структура("Используется,ТипИсходногоДокумента1С", Истина, ГлЯдро_ПолучитьТипДокументаПоСсылке(Документ1С));
		Если ID_БизнесПроцесса <> "" Тогда
			Отбор.Вставить("ID_БизнесПроцесса", ID_БизнесПроцесса);
		КонецЕсли;
		СписокБизнесПроцессов = ГлЯдро_ПолучитьИзКэшаЗначениеТабличнойНастройкиSMARTS("НастройкиБизнесПроцессов", Отбор, "",АдресаПеременных);
	Иначе
		СписокБизнесПроцессов = ДанныеНастроекИзКэша.СписокБизнесПроцессов;
	КонецЕсли;
	
	Если СписокБизнесПроцессов = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	// В онлайне у нас нет данных из кэша, поэтому сформируем и поместим в них обработчики после загрузки документа на ТСД
	Если ДанныеНастроекИзКэша = Неопределено Тогда
		
		ДанныеНастроекИзКэша = Новый Структура();
		
		Отбор = Новый Структура("Направление,ТипОбъекта", "Выгрузка", "ПослеОтправкиДокумента");
		ПроизвольныеКодыОбработчикаЗагрузки = ГлЯдро_ПолучитьИзКэшаЗначениеТабличнойНастройкиSMARTS("ПроизвольныеКоды", Отбор, "", АдресаПеременных);
		ДанныеНастроекИзКэша.Вставить("ПроизвольныеКодыОбработчикаВыгрузки", ПроизвольныеКодыОбработчикаЗагрузки);		
		
    КонецЕсли;
	
	// даже если БП несколько, то выберем первый
	Если СписокБизнесПроцессов[0].Свойство("ТаблицаЗначений") Тогда
		НастройкаБП = СписокБизнесПроцессов[1];
	Иначе
		НастройкаБП = СписокБизнесПроцессов[0];	
	КонецЕсли;
	
	СтруктураПараметров = ГлЯдро_ПолучитьСтруктуруПараметровВыполненияОбработчикаВыгрузки();
	СтруктураПараметров.СсылкаДокумент1С 		= Документ1С;
	СтруктураПараметров.ДанныеДокумента 		= ДанныеДокумента;
	СтруктураПараметров.НастройкаБП 			= НастройкаБП;
	СтруктураПараметров.ДанныеНастроекИзКэша 	= ДанныеНастроекИзКэша;
	СтруктураПараметров.ИнтеграционнаяОбработка = ИнтеграционнаяОбработка;
	СтруктураПараметров.ИмяПриемникаДанных 		= "ДанныеДляВыгрузки_Шапка";
		
	ГлЯдро_ВыполнитьОбработчикВыгрузкиДокумента1С("Обработчик_ПослеОтправкиДокумента", СтруктураПараметров, АдресаПеременных);	
	
	Если ТипЗнч(ДанныеДокумента) = Тип("Структура")
		И ДанныеДокумента.Свойство("КритическаяОшибка")
		И ДанныеДокумента.КритическаяОшибка = Истина Тогда
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Конец, После отправки документа 1С на сервер", НачалоСобытия, АдресаПеременных);
		Возврат;
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти

#Область ГлобальныйКонтекст_Документы_1С_ЗаписьДанных

// Вызывает функцию получения данных документа Mobile Smarts, при необходимости подбирает настройку бизнес-процесса для загрузки документа
// и вызывает функцию формирования и записи документа 1С на основании данных документа Mobile Smarts
//
// Параметры:
//	ID_Документа - Строка, Массив из Строка - идентификаторы загружаемых документов
//  СтруктураДокументаMS - Структура - структура данных документа Mobile Smarts - см. КомЯдро_ПолучитьМетаданныеДокументовMS 
//									   или REST_API_ПолучитьМетаданныеДокументовMS (в зависимости от типа интерфейса)
//  ID_БизнесПроцесса - Строка - идентификатор бизнес-процесса
//  ДанныеНастроекИзКэша - Неопределено, Структура - содержит:
//		* НастройкиБизнесПроцессов - Неопределено, ТаблицаЗначений, Массив из Структура - содержит настройки бизнес-процессов
//		* ПроизвольныеКодыШапки - Неопределено, ТаблицаЗначений, Массив из Структура - содержит произвольные коды загрузки шапки документа
//		* ПроизвольныеКодыТабличнойЧасти - Неопределено, ТаблицаЗначений, Массив из Структура - содержит произвольные коды загрузки табличных частей документа
//		* ЗначенияПараметров - Неопределено, ТаблицаЗначений, Массив из Структура - содержит значения глобальных параметров
//  ТипБазы - Строка - "Частная", "Временная", "Основная"
//  НастройкаБП - Неопределено, Структура - содержит настройку бизнес-процесса, используемую при загрузке - см. ГлЯдро_ПолучитьНастройкуБизнесПроцесса
//	ДокументДляЗаполнения - ДокументОбъект - содержит объект документа, который будет перезаписан
//                        - Структура - содержит:
//								* Данные - Строка, ДокументОбъект, ДанныеФормыСтруктура - данные объекта документа, который будет перезаписан, или его адрес во временном хранилище		  												  или их адрес во временном хранилище
//                        - Неопределено
//	Онлайн - Булево - признак того, что обмен выполняется в режиме "Онлайн"
//	ФильтрТЧПоИдДокумента - Неопределено, Строка - идентификатор исходного документа для случая, когда документ Mobile Smarts был сформирован из нескольких документов 1С
//	ВсеВОдин - Булево - признак того, что загружаемые документы Mobile Smarts должны быть загружены в один документ 1С
//  АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
//
// Возвращаемое значение:
//	Структура - содержит:
//		* Сообщение - Строка - информационное сообщение о результате формирования и записи документа
//		* Статус - Булево - признак успешности формирования и записи документа
//      * Данные - ДокументОбъект - объект сформированного документа - при работе в онлайн-режиме
//				 - ДокументСсылка - ссылка на сформированный документ в случае, если он записан
//				 - Строка - адрес во временном хранилище, куда помещен объект сформированного документа
//		* Ссылка - ДокументСсылка - ссылка на существующий документ, который был перезаписан при загрузке
//      * ДокументЗаписанВОбработчике - Булево - признак того, что документ записан в обработчике интеграционной обработки
//		* ЕстьОшибкиПриВыполненииОбработчиков - Булево - признак того, что при выполнении обработчиков интеграционной обработки возникли ошибки     	
//		* ДокументЗаписан - Булево - признак того, что документ записан в функции - не для онлайн-обмена
//		* ДокументПроведен - Булево - признак того, что документ проведен в функции - не для онлайн-обмена
//      * МетаданныеИмя - Строка - имя объекта метаданных записанного документа	
//      * Дополнение - Строка - идентификатор пользователя документа Mobile Smarts
Функция ГлЯдро_СформироватьИЗаписатьДокументВБазу1С_ПоID(ID_Документа, СтруктураДокументаMS, ID_БизнесПроцесса = "", ДанныеНастроекИзКэша = Неопределено, ТипБазы, НастройкаБП = Неопределено, ДокументДляЗаполнения = Неопределено, Онлайн = Ложь, ФильтрТЧПоИдДокумента = Неопределено, ВсеВОдин = Ложь, АдресаПеременных) Экспорт
	
	НастройкиДляОбмена = Неопределено;	
	Если ДанныеНастроекИзКэша = Неопределено ИЛИ НЕ ДанныеНастроекИзКэша.Свойство("НастройкиДляОбмена") ИЛИ ДанныеНастроекИзКэша.НастройкиДляОбмена = Неопределено Тогда
		 НастройкиДляОбмена = ГлЯдро_ПолучитьИзКэшаНастройкуSMARTS("НастройкиБизнесПроцессов",,АдресаПеременных)
	Иначе
		НастройкиДляОбмена = ДанныеНастроекИзКэша.НастройкиДляОбмена;
	КонецЕсли;
	
	// Попробуем получить настройку бизнес-процесса до получения данных документа MS
	Если НастройкаБП = Неопределено И ЗначениеЗаполнено(ID_БизнесПроцесса) Тогда
		РезультатПодбораБП = ГлЯдро_ПолучитьНастройкуБизнесПроцесса(ID_БизнесПроцесса, "", НастройкиДляОбмена, , АдресаПеременных);										
		Если ТипЗнч(РезультатПодбораБП) = Тип("Структура") И РезультатПодбораБП.Статус = Истина Тогда
			НастройкаБП = РезультатПодбораБП.Данные;
		Иначе
			НастройкаБП = Неопределено;
		КонецЕсли;
	КонецЕсли;
	
	// Проверяем, нужно ли получать CombinedItems
	ЗапрашиватьCombinedItems = ГлЯдро_ПроверитьНаличиеСовмещенныхСтрокВНастройкеБП(НастройкаБП);
	
	Если ВсеВОдин = Истина И ТипЗнч(ID_Документа) = Тип("Массив") Тогда
		ДанныеДокументаMS = Неопределено;
		Для каждого ДокументКЗагрузке ИЗ ID_Документа Цикл
			пДанныеДокументаMS = ГлЯдро_ПолучитьДанныеДокументаMS(ДокументКЗагрузке.Ид, СтруктураДокументаMS, ТипБазы, Истина, ФильтрТЧПоИдДокумента, ЗапрашиватьCombinedItems, АдресаПеременных);
			Если ДанныеДокументаMS = Неопределено Тогда
				ДанныеДокументаMS = пДанныеДокументаMS;
				Если НЕ ДанныеДокументаMS.Свойство("СовмещенныеСтроки") 
					ИЛИ НЕ ТипЗнч(ДанныеДокументаMS.СовмещенныеСтроки) = Тип("Массив") Тогда
					ДанныеДокументаMS.Вставить("СовмещенныеСтроки",Новый Массив());
				КонецЕсли;
				Если НЕ ДанныеДокументаMS.Свойство("СтрокиПлан") 
					ИЛИ НЕ ТипЗнч(ДанныеДокументаMS.СтрокиПлан) = Тип("Массив") Тогда
					ДанныеДокументаMS.Вставить("СтрокиПлан",Новый Массив());
				КонецЕсли;
				Если НЕ ДанныеДокументаMS.Свойство("СтрокиФакт") 
					ИЛИ НЕ ТипЗнч(ДанныеДокументаMS.СтрокиФакт) = Тип("Массив") Тогда
					ДанныеДокументаMS.Вставить("СтрокиФакт",Новый Массив());
				КонецЕсли;
			Иначе
				Если пДанныеДокументаMS.Свойство("СовмещенныеСтроки") 
					И ТипЗнч(пДанныеДокументаMS.СовмещенныеСтроки) = Тип("Массив") Тогда
					Для каждого СтрокаТЧ ИЗ пДанныеДокументаMS.СовмещенныеСтроки Цикл
						ДанныеДокументаMS.СовмещенныеСтроки.Добавить(СтрокаТЧ);
					КонецЦикла;
				КонецЕсли;
				Если пДанныеДокументаMS.Свойство("СтрокиПлан") 
					И ТипЗнч(пДанныеДокументаMS.СтрокиПлан) = Тип("Массив") Тогда
					Для каждого СтрокаТЧ ИЗ пДанныеДокументаMS.СтрокиПлан Цикл
						ДанныеДокументаMS.СтрокиПлан.Добавить(СтрокаТЧ);
					КонецЦикла;
				КонецЕсли;
				Если пДанныеДокументаMS.Свойство("СтрокиФакт") 
					И ТипЗнч(пДанныеДокументаMS.СтрокиФакт) = Тип("Массив") Тогда
					Для каждого СтрокаТЧ ИЗ пДанныеДокументаMS.СтрокиФакт Цикл
						ДанныеДокументаMS.СтрокиФакт.Добавить(СтрокаТЧ);
					КонецЦикла;
				КонецЕсли;
				// У второго и последующего документа обходим доп. таблицы и дозаполняем их
				Если СтруктураДокументаMS.Свойство("ДополнительныеТаблицы") Тогда
					Для Каждого ДопТаблица Из СтруктураДокументаMS.ДополнительныеТаблицы Цикл
						МассивДопТаблицы = Неопределено;														
						Если пДанныеДокументаMS.Свойство(ДопТаблица.Представление) 
							И ТипЗнч(пДанныеДокументаMS[ДопТаблица.Представление]) = Тип("Массив") Тогда								
							// Выгружаем уже имеющие строки таблицы в служебную переменную...
							ДанныеДокументаMS.Свойство(ДопТаблица.Представление, МассивДопТаблицы);
							Для каждого СтрокаТЧ ИЗ пДанныеДокументаMS[ДопТаблица.Представление] Цикл
								Если СтрокаТЧ.Свойство("ЭтоТаблицаЗначений") Тогда
									Продолжить;
								КонецЕсли;
								// ... и дозаполняем ее строками таблицы текущего документа
								МассивДопТаблицы.Добавить(СтрокаТЧ);
							КонецЦикла;								
							ДанныеДокументаMS.Вставить(ДопТаблица.Представление, МассивДопТаблицы);
						КонецЕсли;
					КонецЦикла;						
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
	Иначе
		ДанныеДокументаMS = ГлЯдро_ПолучитьДанныеДокументаMS(ID_Документа, СтруктураДокументаMS, ТипБазы, Истина, ФильтрТЧПоИдДокумента, ЗапрашиватьCombinedItems, АдресаПеременных);
	КонецЕсли;
	
	Если ID_БизнесПроцесса = "" Тогда
		Если ДанныеДокументаMS.ШапкаДокумента.Свойство("НастройкаБизнесПроцесса") Тогда
			ID_БизнесПроцесса = ДанныеДокументаMS.ШапкаДокумента.НастройкаБизнесПроцесса;
		КонецЕсли;
	КонецЕсли;
	
	Если ДокументДляЗаполнения <> Неопределено И НастройкаБП <> Неопределено Тогда
		
		Если НЕ ЗначениеЗаполнено(СокрЛП(НастройкаБП.ТипРезультирующегоДокумента1С)) ИЛИ (НастройкаБП.ЗагружатьВТотЖе И НЕ ЗначениеЗаполнено(СокрЛП(НастройкаБП.ТипИсходногоДокумента1С))) Тогда
			РезультатЗаписи = Новый Структура;
			РезультатЗаписи.Вставить("Сообщение", 	"Данный бизнес-процесс не подразумевает загрузку документа в 1С, т.к. у него не заполнен результирующий документ 1С");			
			РезультатЗаписи.Вставить("Статус", 		Ложь); 
			РезультатЗаписи.Вставить("Данные",		Неопределено); 
		ИначеЕсли Онлайн = Истина 
			И НЕ НастройкаБП.ЗаписыватьДокументПослеЗагрузки = Истина
			И НЕ НастройкаБП.ЗаписыватьДокументПослеЗагрузки = "Всегда"
			И НЕ НастройкаБП.ЗаписыватьДокументПослеЗагрузки = "ПриОнлайн" Тогда
			РезультатЗаписи = Новый Структура;
			РезультатЗаписи.Вставить("Сообщение", 	"Данный бизнес-процесс не подразумевает загрузку документа в 1С в режиме Онлайн");			
			РезультатЗаписи.Вставить("Статус", 		Ложь); 
			РезультатЗаписи.Вставить("Данные",		Неопределено);	
		Иначе
			РезультатЗаписи = ГлЯдро_СформироватьИЗаписатьДокументВБазу1С(ДанныеДокументаMS, НастройкаБП, ДанныеНастроекИзКэша, ДокументДляЗаполнения, Онлайн, ФильтрТЧПоИдДокумента,,, АдресаПеременных);	
		КонецЕсли;		
				
	Иначе
				
		РезультатПодбораБП = ГлЯдро_ПолучитьНастройкуБизнесПроцесса(ID_БизнесПроцесса, ДанныеДокументаMS.ШапкаДокумента.ИмяТипаДокумента, НастройкиДляОбмена,,АдресаПеременных);										
		Если РезультатПодбораБП = Неопределено ИЛИ (ТипЗнч(РезультатПодбораБП) = Тип("Структура") И РезультатПодбораБП.Статус = Ложь) Тогда
			Сообщение = "Номер ошибки #ONLEX001. Загрузка данного документа в учетную систему - не произведена по причине отсутствия бизнес-процесса для него. Проверьте настройки бизнес-процессов в обработке для 1С общие или для выбранного торгового объекта - если используется. Подробнее - https://www.cleverence.ru/support/97289/";
			РезультатЗаписи = Новый Структура("Сообщение,Статус", Сообщение, Ложь);
			Если ТипЗнч(РезультатПодбораБП) = Тип("Структура") Тогда
				РезультатЗаписи.Вставить("Данные", РезультатПодбораБП.Данные);
			КонецЕсли;
		Иначе
			НастройкаБП = РезультатПодбораБП.Данные;
			Если НЕ ЗначениеЗаполнено(СокрЛП(НастройкаБП.ТипРезультирующегоДокумента1С)) ИЛИ (НастройкаБП.ЗагружатьВТотЖе И НЕ ЗначениеЗаполнено(СокрЛП(НастройкаБП.ТипИсходногоДокумента1С))) Тогда
				РезультатЗаписи = Новый Структура;
				РезультатЗаписи.Вставить("Сообщение", 	"Данный бизнес-процесс не подразумевает загрузку документа в 1С, т.к. у него не заполнен результирующий документ 1С");			
				РезультатЗаписи.Вставить("Статус", 		Ложь); 
				РезультатЗаписи.Вставить("Данные",		Неопределено); 
			ИначеЕсли Онлайн = Истина 
				И НЕ НастройкаБП.ЗаписыватьДокументПослеЗагрузки = Истина
				И НЕ НастройкаБП.ЗаписыватьДокументПослеЗагрузки = "Всегда"
				И НЕ НастройкаБП.ЗаписыватьДокументПослеЗагрузки = "ПриОнлайн" Тогда
				РезультатЗаписи = Новый Структура;
				РезультатЗаписи.Вставить("Сообщение", 	"Данный бизнес-процесс не подразумевает загрузку документа в 1С в режиме Онлайн");			
				РезультатЗаписи.Вставить("Статус", 		Ложь); 
				РезультатЗаписи.Вставить("Данные",		Неопределено);
			Иначе
				РезультатЗаписи = ГлЯдро_СформироватьИЗаписатьДокументВБазу1С(ДанныеДокументаMS, РезультатПодбораБП.Данные, ДанныеНастроекИзКэша, ДокументДляЗаполнения, Онлайн, ФильтрТЧПоИдДокумента,,, АдресаПеременных);
			КонецЕсли;
		КонецЕсли;
		
	КонецЕсли;
	
	Если ДанныеДокументаMS.ШапкаДокумента.Свойство("ИдПользователя") Тогда
		РезультатЗаписи.Вставить("Дополнение", ДанныеДокументаMS.ШапкаДокумента.ИдПользователя);
	КонецЕсли;		
	
	// В веб-клиенте сообщения, сформированные методом "Сообщить()" на сервере, теряются
	// Получим невыведенные пользователю сообщения, и передадим на клиент для вывода этих сообщений в форме сформированного документа
	СообщенияПользователю = ПолучитьСообщенияПользователю();
	Если СообщенияПользователю.Количество() Тогда
		РезультатЗаписи.Вставить("СообщенияПользователю", СообщенияПользователю);
	КонецЕсли;
	
	Возврат РезультатЗаписи;
	
КонецФункции

// Вызывает функцию заполнения документа 1С данными документа Mobile Smarts в соответствии с переданной настройкой бизнес-процесса,
// при необходимости - записывает и проводит документ.
//
// Параметры:
//	ДанныеДокументаMS -	Структура - содержит данные документа Mobile Smarts - см. ГлЯдро_ПолучитьДанныеДокументаMS
//  НастройкаБП - Структура - содержит настройку бизнес-процесса, используемую при загрузке - см. ГлЯдро_ПолучитьНастройкуБизнесПроцесса
//  ДанныеНастроекИзКэша - Неопределено, Структура - содержит:
//		* НастройкиБизнесПроцессов - Неопределено, ТаблицаЗначений, Массив из Структура - содержит настройки бизнес-процессов
//		* ПроизвольныеКодыШапки - Неопределено, ТаблицаЗначений, Массив из Структура - содержит произвольные коды загрузки шапки документа
//		* ПроизвольныеКодыТабличнойЧасти - Неопределено, ТаблицаЗначений, Массив из Структура - содержит произвольные коды загрузки табличных частей документа
//		* ЗначенияПараметров - Неопределено, ТаблицаЗначений, Массив из Структура - содержит значения глобальных параметров
//  ДокументДляЗаполнения - ДокументОбъект - содержит объект документа, который будет перезаписан
//                        - Структура - содержит:
//								* Данные - Строка, ДокументОбъект, ДанныеФормыСтруктура - данные объекта документа, который будет перезаписан, или его адрес во временном хранилище		  												  или их адрес во временном хранилище
//                        - Неопределено
//  Онлайн - Булево - признак того, что обмен выполняется в режиме "Онлайн"
//  ФильтрТЧПоИдДокумента - Неопределено, Строка - идентификатор исходного документа для случая, когда документ Mobile Smarts был сформирован из нескольких документов 1С
//  АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
//
// Возвращаемое значение:
//	Структура - содержит:
//		* Сообщение - Строка - информационное сообщение о результате формирования и записи документа
//		* Статус - Булево - признак успешности формирования и записи документа
//      * Данные - ДокументОбъект - объект сформированного документа - при работе в онлайн-режиме
//				 - ДокументСсылка - ссылка на сформированный документ в случае, если он записан
//				 - Строка - адрес во временном хранилище, куда помещен объект сформированного документа
//		* Ссылка - ДокументСсылка - ссылка на существующий документ, который был перезаписан при загрузке
//      * ДокументЗаписанВОбработчике - Булево - признак того, что документ записан в обработчике интеграционной обработки
//		* ЕстьОшибкиПриВыполненииОбработчиков - Булево - признак того, что при выполнении обработчиков интеграционной обработки возникли ошибки     	
//		* ДокументЗаписан - Булево - признак того, что документ записан в функции - не для онлайн-обмена
//		* ДокументПроведен - Булево - признак того, что документ проведен в функции - не для онлайн-обмена
//      * МетаданныеИмя - Строка - имя объекта метаданных записанного документа
Функция ГлЯдро_СформироватьИЗаписатьДокументВБазу1С(ДанныеДокументаMS, НастройкаБП, ДанныеНастроекИзКэша = Неопределено, ДокументДляЗаполнения = Неопределено, Онлайн = Ложь, ФильтрТЧПоИдДокумента = Неопределено, ДокументОснование = Неопределено, РезультатыВыполненияПоследовательныхБП = Неопределено, АдресаПеременных) Экспорт
	
	// +++ Последовательность БП
	Если РезультатыВыполненияПоследовательныхБП <> Неопределено 
		И ТипЗнч(РезультатыВыполненияПоследовательныхБП) = Тип("ТаблицаЗначений") Тогда		
		Если РезультатыВыполненияПоследовательныхБП.Найти(НастройкаБП.ID_БизнесПроцесса,"ID_БизнесПроцесса") <> Неопределено Тогда
			Возврат "Повтор";
		КонецЕсли;
	КонецЕсли;		
	// ---
	
	КэшПроверенныхСсылок = Новый Соответствие;
	
	СтруктураДанных = ГлЯдро_ЗаполнитьДокумент1С(ДанныеДокументаMS, НастройкаБП, ДанныеНастроекИзКэша, ДокументДляЗаполнения, Онлайн, ФильтрТЧПоИдДокумента,ДокументОснование,АдресаПеременных);
	
	// Очищаем кэш проверенных ссылок после заполнения документа
	КэшПроверенныхСсылок.Очистить();
	
	Если НастройкаБП.ВыполнитьТолькоПроизвольныйКод = Истина Тогда
		РезультатЗаписи = Новый Структура("Сообщение,Статус,Данные,Ссылка,ДанныеДокументаMS", СтруктураДанных.СообщениеПользователю, Истина, Неопределено, Неопределено, Неопределено);
		Возврат РезультатЗаписи;
	КонецЕсли;
	
	ДокументДляЗаписи = СтруктураДанных.ДокументДляЗаписи;
	
	РезультатЗаписи = Новый Структура("Сообщение,Статус,Данные,Ссылка,ДанныеДокументаMS", "", Истина, ДокументДляЗаписи, ДокументДляЗаписи.Ссылка, ДанныеДокументаMS);
	
	Если СтруктураДанных.Свойство("КритическаяОшибка")
		И СтруктураДанных.КритическаяОшибка = Истина Тогда
		РезультатЗаписи.Вставить("Статус",Ложь);
	КонецЕсли;
	
	Если СтруктураДанных.Свойство("ДокументЗаписанВОбработчике")
		И СтруктураДанных.ДокументЗаписанВОбработчике = Истина Тогда
		РезультатЗаписи.Вставить("ДокументЗаписанВОбработчике",Истина);
	Иначе
		РезультатЗаписи.Вставить("ДокументЗаписанВОбработчике",Ложь);
	КонецЕсли;
	
	Если СтруктураДанных.Свойство("ПараметрыОткрытияФормы") Тогда
		РезультатЗаписи.Вставить("ПараметрыОткрытияФормы", СтруктураДанных.ПараметрыОткрытияФормы);
	КонецЕсли;
	
	Если ДокументДляЗаписи.ДополнительныеСвойства.Свойство("ЕстьОшибкиПриВыполненииОбработчиков") И ДокументДляЗаписи.ДополнительныеСвойства.ЕстьОшибкиПриВыполненииОбработчиков Тогда
		РезультатЗаписи.Вставить("ЕстьОшибкиПриВыполненииОбработчиков", ДокументДляЗаписи.ДополнительныеСвойства.ЕстьОшибкиПриВыполненииОбработчиков);
	КонецЕсли;	
	
	Если НЕ Онлайн И РезультатЗаписи.Статус = Истина Тогда
		
		ЗаписыватьДокументПослеЗагрузки = ГлЯдро_ПолучитьЗначениеРеквизитаНастройкиБизнесПроцесса(НастройкаБП, "ЗаписыватьДокументПослеЗагрузки");
		
		Если ЗаписыватьДокументПослеЗагрузки = Истина 
			ИЛИ ЗаписыватьДокументПослеЗагрузки = "Всегда"
			ИЛИ ЗаписыватьДокументПослеЗагрузки = "ПриРучном" Тогда
			Попытка
				
				Если ДокументДляЗаписи.ЭтоНовый() И НЕ ЗначениеЗаполнено(ДокументДляЗаписи.Номер) Тогда
					ДокументДляЗаписи.УстановитьНовыйНомер();
				КонецЕсли;				
				
				Если Не РезультатЗаписи.ДокументЗаписанВОбработчике Тогда
					ДокументДляЗаписи.Записать(РежимЗаписиДокумента.Запись);	
				КонецЕсли;
				
				ДокументЗаписан = Истина;
			Исключение
				Сообщить("Произошла ошибка при записи документа. Причина: " + КраткоеПредставлениеОшибки(ИнформацияОбОшибке()));
				ДокументЗаписан = Ложь;
			КонецПопытки; 
		Иначе
			ДокументЗаписан = РезультатЗаписи.ДокументЗаписанВОбработчике;
		КонецЕсли;		
		
		РезультатЗаписи.Вставить("ДокументЗаписан", ДокументЗаписан);
		
		ПроводитьДокументПослеЗагрузки = ГлЯдро_ПолучитьЗначениеРеквизитаНастройкиБизнесПроцесса(НастройкаБП, "ПроводитьДокументПослеЗагрузки");
		
		Если ПроводитьДокументПослеЗагрузки = Истина
			И (ЗаписыватьДокументПослеЗагрузки = Истина 
			ИЛИ ЗаписыватьДокументПослеЗагрузки = "Всегда"
			ИЛИ ЗаписыватьДокументПослеЗагрузки = "ПриРучном") Тогда
			Попытка				
				РежимПроведения = ?(ДокументДляЗаписи.Метаданные().ОперативноеПроведение = Метаданные.СвойстваОбъектов.ОперативноеПроведение.Разрешить, 
					РежимПроведенияДокумента.Оперативный, РежимПроведенияДокумента.Неоперативный);
					
				Если (РежимПроведения = РежимПроведенияДокумента.Оперативный) И (ДокументДляЗаписи.Дата < НачалоДня(ТекущаяДата())) Тогда
					РежимПроведения = РежимПроведенияДокумента.Неоперативный;
				КонецЕсли;						
				
				ДокументДляЗаписи.Записать(РежимЗаписиДокумента.Проведение, РежимПроведения);	
				ДокументПроведен = Истина;
			Исключение
				Сообщить("Произошла ошибка при проведении документа. Причина: " + КраткоеПредставлениеОшибки(ИнформацияОбОшибке()));
				ДокументПроведен = Ложь;
			КонецПопытки; 
		Иначе
			ДокументПроведен = Ложь;
		КонецЕсли;						
		
		РезультатЗаписи.Вставить("ДокументПроведен", ДокументПроведен);		
		
	КонецЕсли;			
	
	// Возможно в предыдущем условии был записан новый документ, 
	// обновим на всякий случай его ссылку в структуре результата
	РезультатЗаписи.Вставить("Ссылка", ДокументДляЗаписи.Ссылка);
	
	Если СтруктураДанных.Свойство("СообщениеОбОшибках") И СтруктураДанных.СообщениеОбОшибках <> "" Тогда
		РезультатЗаписи.Вставить("Сообщение", "ОШИБКИ:" + Символы.ВК + СтруктураДанных.СообщениеОбОшибках);
	КонецЕсли;
	
	Если Не Онлайн Тогда
		РезультатЗаписи.Вставить("МетаданныеИмя",РезультатЗаписи.Данные.Метаданные().Имя);
		РезультатЗаписи.Данные = ?(ДокументЗаписан = Истина,РезультатЗаписи.Данные.Ссылка,ПоместитьВоВременноеХранилище(Новый Структура("Объект",РезультатЗаписи.Данные),новый УникальныйИдентификатор()));
	КонецЕсли;
	
	Если Онлайн И РезультатЗаписи.Статус = Истина Тогда
		РезультатЗаписи.Вставить("ДокументОснование", СтруктураДанных.ДокументОснование);
	КонецЕсли;
	
	// +++ Последовательность БП
	Если НастройкаБП.Свойство("НастройкаПоследовательностиБПМассивСтруктур")
		И ЗначениеЗаполнено(НастройкаБП.НастройкаПоследовательностиБПМассивСтруктур) Тогда
		
		ПрерыватьПриКритическойОшибке = Ложь;
		Если НастройкаБП.Свойство("ПрерыватьПоследовательностьПриКритическойОшибке") Тогда
			ПрерыватьПриКритическойОшибке = НастройкаБП.ПрерыватьПоследовательностьПриКритическойОшибке;
		КонецЕсли;
		
		ПрерватьПоследовательность = Ложь;
		Если ПрерыватьПриКритическойОшибке
			И РезультатЗаписи.Статус = Ложь Тогда
			ПрерватьПоследовательность = Истина;
		КонецЕсли;
		
		ПоследовательностьБП = ГлЯдро_МассивСтруктурВТаблицуЗначений(НастройкаБП.НастройкаПоследовательностиБПМассивСтруктур);
		Если ПоследовательностьБП.Количество() > 0 Тогда
			Если РезультатыВыполненияПоследовательныхБП = Неопределено Тогда
				РезультатыВыполненияПоследовательныхБП = Новый ТаблицаЗначений;
				РезультатыВыполненияПоследовательныхБП.Колонки.Добавить("ID_БизнесПроцесса");
				РезультатыВыполненияПоследовательныхБП.Колонки.Добавить("Результат");
			КонецЕсли;
			
			Для Каждого СледующийБП Из ПоследовательностьБП Цикл
				
				Если ПрерватьПоследовательность Тогда
					Прервать;
				КонецЕсли;
				
				Если СледующийБП.Использование = Ложь Тогда
					Продолжить;
				КонецЕсли;
				
				Если СледующийБП.ИсточникДокументаОснования = "РезультирующийДокумент" Тогда
					ИсточникДокументаОснования = ДокументДляЗаписи.Ссылка;
				ИначеЕсли СледующийБП.ИсточникДокументаОснования = "ИсходныйДокумент" Тогда
					Если НастройкаБП.ЗагружатьВТотЖе
						Или ДокументОснование = Неопределено Тогда
						ИсточникДокументаОснования = ДокументДляЗаписи.Ссылка;
					Иначе
						ИсточникДокументаОснования = ДокументОснование;
					КонецЕсли;
				Иначе
					ИсточникДокументаОснования = Неопределено;	
				КонецЕсли;
				
				Если ДанныеНастроекИзКэша = Неопределено ИЛИ НЕ ДанныеНастроекИзКэша.Свойство("НастройкиДляОбмена") ИЛИ ДанныеНастроекИзКэша.НастройкиДляОбмена = Неопределено Тогда
					НастройкиДляОбмена = ГлЯдро_ПолучитьИзКэшаНастройкуSMARTS("НастройкиБизнесПроцессов",,АдресаПеременных)
				Иначе
					НастройкиДляОбмена = ДанныеНастроекИзКэша.НастройкиДляОбмена;
				КонецЕсли;				
				НастройкаСледующегоБП = ГлЯдро_ПолучитьНастройкуБизнесПроцесса(СледующийБП.ID_БизнесПроцесса, НастройкаБП.ТипДокументаMS,НастройкиДляОбмена,Истина,АдресаПеременных);
				Если НастройкаСледующегоБП.Статус = Ложь Тогда
					Продолжить;
				КонецЕсли;					
				
				РезультатВыполнения = ГлЯдро_СформироватьИЗаписатьДокументВБазу1С(
					ДанныеДокументаMS,
					НастройкаСледующегоБП.Данные,
					ДанныеНастроекИзКэша,
					,
					Ложь,
					ФильтрТЧПоИдДокумента,
					ИсточникДокументаОснования,
					РезультатыВыполненияПоследовательныхБП, 
					АдресаПеременных);												
				
				Если Не РезультатВыполнения = "Повтор" Тогда
					НС = РезультатыВыполненияПоследовательныхБП.Добавить();
					НС.ID_БизнесПроцесса = НастройкаБП.ID_БизнесПроцесса;
					НС.Результат = РезультатВыполнения;
				КонецЕсли;
				Если РезультатВыполнения.Статус = Ложь 
					И ПрерыватьПриКритическойОшибке Тогда
					ПрерватьПоследовательность = Истина;	
				КонецЕсли;
				
			КонецЦикла;			
		КонецЕсли;
	КонецЕсли;
	// ---
	
	Возврат РезультатЗаписи;
	
КонецФункции

Функция ГлЯдро_ЗаполнитьДокумент1С(ДанныеДокументаMS, НастройкаБП, ДанныеНастроекИзКэша = Неопределено, ДокументДляЗаполнения = Неопределено, Онлайн = Ложь, ФильтрТЧПоИдДокумента = Неопределено, ДокументОснование = Неопределено ,АдресаПеременных)
	
	НачалоСобытия = ТекущаяУниверсальнаяДатаВМиллисекундах();
	ИмяСобытия = "ГлЯдро_ЗаполнитьДокумент1С";
	
	ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Начало, Заполнение документа 1С", , АдресаПеременных);
		
	ПроизвольныеКодыДокумента = Неопределено;
	Если ДанныеНастроекИзКэша = Неопределено ИЛИ НЕ ДанныеНастроекИзКэша.Свойство("ПроизвольныеКодыДокумента") ИЛИ ДанныеНастроекИзКэша.ПроизвольныеКодыДокумента = Неопределено Тогда
		Отбор = Новый Структура("Направление,ТипОбъекта", "Загрузка", "Документ");
		ПроизвольныеКодыДокумента = ГлЯдро_ПолучитьИзКэшаЗначениеТабличнойНастройкиSMARTS("ПроизвольныеКоды", Отбор,,АдресаПеременных);
	Иначе
		Если ТипЗнч(ДанныеНастроекИзКэша.ПроизвольныеКодыДокумента) = Тип("ТаблицаЗначений")
			ИЛИ ТипЗнч(ДанныеНастроекИзКэша.ПроизвольныеКодыДокумента) = Тип("Массив") Тогда
			ПроизвольныеКодыДокумента = ДанныеНастроекИзКэша.ПроизвольныеКодыДокумента;
		КонецЕсли;
	КонецЕсли;	
	
	ПроизвольныеКодыШапки 				= ГлЯдро_ПолучитьПроизвольныеКоды("ПроизвольныеКодыШапки", ДанныеНастроекИзКэша, "Загрузка", "Шапка", АдресаПеременных);	
	ПроизвольныеКодыТабличнойЧасти 		= ГлЯдро_ПолучитьПроизвольныеКоды("ПроизвольныеКодыТабличнойЧасти", ДанныеНастроекИзКэша, "Загрузка", "ТабличнаяЧасть", АдресаПеременных);	
	
	МассивТиповОбъектов = Новый Массив;
	МассивТиповОбъектов.Добавить("ПередЗагрузкойДокумента");
	МассивТиповОбъектов.Добавить("ПослеЗагрузкиДокумента");
	
	ПроизвольныеКодыОбработчикаЗагрузки = ГлЯдро_ПолучитьПроизвольныеКоды("ПроизвольныеКодыОбработчикаЗагрузки", ДанныеНастроекИзКэша, "Загрузка", МассивТиповОбъектов, АдресаПеременных);
	
	МассивТиповОбъектов.Очистить();
	МассивТиповОбъектов.Добавить("ПередЗаполнениемТЧ");
	МассивТиповОбъектов.Добавить("ПослеЗаполненияТЧ");
	
	ПроизвольныеКодыОбработчикаТЧ 		= ГлЯдро_ПолучитьПроизвольныеКоды("ПроизвольныеКодыОбработчикаТЧ", ДанныеНастроекИзКэша, "Загрузка", МассивТиповОбъектов, АдресаПеременных);
	
	МассивТиповОбъектов.Очистить();
	МассивТиповОбъектов.Добавить("ПередЗаполнениемСтрокиТЧ");
	МассивТиповОбъектов.Добавить("ПослеЗаполненияСтрокиТЧ");
	
	ПроизвольныеКодыОбработчикаСтрокиТЧ = ГлЯдро_ПолучитьПроизвольныеКоды("ПроизвольныеКодыОбработчикаСтрокиТЧ", ДанныеНастроекИзКэша, "Загрузка", МассивТиповОбъектов, АдресаПеременных);
	
	Если ДанныеНастроекИзКэша = Неопределено 
		ИЛИ НЕ ДанныеНастроекИзКэша.Свойство("ЗначенияПараметров") 
		ИЛИ ТипЗнч(ДанныеНастроекИзКэша.ЗначенияПараметров) <> Тип("Массив") Тогда
		ЗначенияПараметров = ГлЯдро_ПолучитьЗначенияГлобальныхПараметров(,,,АдресаПеременных);
	Иначе
		ЗначенияПараметров = ДанныеНастроекИзКэша.ЗначенияПараметров;
    КонецЕсли;
	
	// Определяем обший модуль для выполнения кода в безопасном режиме (для передачи в ИО)
	СтруктураИО = КомЯдро_ПолучитьЗначениеПеременной("ИнтеграционнаяОбработка", АдресаПеременных);	
	ИмяМодуляБезопасногоРежима = Неопределено;
	
	Если (СтруктураИО = Неопределено
		ИЛИ НЕ ТипЗнч(СтруктураИО) = Тип("Структура")
		ИЛИ НЕ СтруктураИО.Свойство("ИнтеграционнаяОбработка")
		ИЛИ СтруктураИО.ИнтеграционнаяОбработка = Неопределено)
		И НЕ ГлЯдро_ПересоздатьИнтеграционнуюОбработку(АдресаПеременных) Тогда                       		
		ИнтеграционнаяОбработка = Неопределено;
	Иначе
		СтруктураИО = КомЯдро_ПолучитьЗначениеПеременной("ИнтеграционнаяОбработка",АдресаПеременных);		
		Попытка
			ПараметрыАлгоритма = Новый Структура;
			ПараметрыАлгоритма.Вставить("ИнтеграционнаяОбработка", СтруктураИО.ИнтеграционнаяОбработка);
			ИмяМодуляБезопасногоРежима = ГлЯдро_ВычислитьВБезопасномРежиме("Параметры.ИнтеграционнаяОбработка.ПолучитьОбщийМодульВыполненияВБезопасномРежиме()", ПараметрыАлгоритма);				
		Исключение
			ИмяМодуляБезопасногоРежима = "";
		КонецПопытки;
	КонецЕсли;     
	
	// Поиск существующего документа
	ДокументДляЗаписи = Неопределено;
	//ДокументОснование = Неопределено;
	Если НастройкаБП.ВыполнитьТолькоПроизвольныйКод = Истина Тогда
		Если ЗначениеЗаполнено(НастройкаБП.ТипИсходногоДокумента1С) Тогда
			Если ДокументОснование = Неопределено Тогда
				ДокументОснование = ГлЯдро_ПолучитьСсылкуНаДокументПоИд(НастройкаБП.ТипИсходногоДокумента1С,?(ЗначениеЗаполнено(ФильтрТЧПоИдДокумента),ФильтрТЧПоИдДокумента,ДанныеДокументаMS.ШапкаДокумента.Ид));
			КонецЕсли;
		КонецЕсли;
	ИначеЕсли НастройкаБП.ЗагружатьВТотЖе Тогда
		Если ТипЗнч(ДокументДляЗаполнения) = Тип("Структура") Тогда
			Если ЭтоАдресВременногоХранилища(ДокументДляЗаполнения.Данные) Тогда
				ДокументДляЗаписи = ПолучитьИзВременногоХранилища(ДокументДляЗаполнения.Данные).Объект;
			Иначе
				ДокументДляЗаписи = ДокументДляЗаполнения.Данные;
				Если ТипЗнч(ДокументДляЗаписи) = Тип("ДанныеФормыСтруктура") Тогда
					ДокументДляЗаписи = ДанныеФормыВЗначение(ДокументДляЗаписи,Тип("ДокументОбъект."+НастройкаБП.ТипИсходногоДокумента1С));
				КонецЕсли;
			КонецЕсли;				
		Иначе
			Попытка				
				ДокументДляЗаписи = ГлЯдро_ПолучитьСсылкуНаДокументПоИд(НастройкаБП.ТипИсходногоДокумента1С,?(ЗначениеЗаполнено(ФильтрТЧПоИдДокумента),ФильтрТЧПоИдДокумента,ДанныеДокументаMS.ШапкаДокумента.Ид));
				ДокументДляЗаписи = ДокументДляЗаписи.ПолучитьОбъект();
				Если ДокументДляЗаписи.Метаданные().Реквизиты.Найти("ДокументОснование") <> Неопределено
					И ДокументОснование = Неопределено Тогда
						ДокументОснование = ДокументДляЗаписи.ДокументОснование;					
				КонецЕсли;
			Исключение
				ИмяСобытия = "ГлЯдро_ЗаполнитьДокумент1С";
				ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());				
				ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Ошибка при получении объекта документа для записи: " + ТекстОшибки + ", Документ: " + Строка(ДокументДляЗаписи),, АдресаПеременных);				
			КонецПопытки;
			Если ДокументДляЗаписи = Неопределено Тогда
				// документ не нашелся, возможно его удалили, создаем новый
				ДокументДляЗаписи = Документы[НастройкаБП.ТипРезультирующегоДокумента1С].СоздатьДокумент();
			КонецЕсли;
		КонецЕсли;
	Иначе
		Если ТипЗнч(ДокументДляЗаполнения) = Тип("Структура") Тогда
			Если ЭтоАдресВременногоХранилища(ДокументДляЗаполнения.Данные) Тогда
				ДокументДляЗаписи = ПолучитьИзВременногоХранилища(ДокументДляЗаполнения.Данные).Объект;
			Иначе
				ДокументДляЗаписи = ДокументДляЗаполнения.Данные;
				Если ТипЗнч(ДокументДляЗаписи) = Тип("ДанныеФормыСтруктура") Тогда
					ДокументДляЗаписи = ДанныеФормыВЗначение(ДокументДляЗаписи,Тип("ДокументОбъект."+НастройкаБП.ТипРезультирующегоДокумента1С));
				КонецЕсли;
			КонецЕсли;
		Иначе
			Если НастройкаБП.СоздаватьНовыйДокументПриЗагрузке = Истина ИЛИ НЕ ЗначениеЗаполнено(ДокументДляЗаполнения) ИЛИ ДокументДляЗаполнения = Ложь Тогда
				ДокументДляЗаписи = Документы[НастройкаБП.ТипРезультирующегоДокумента1С].СоздатьДокумент();
				Если ЗначениеЗаполнено(НастройкаБП.ТипИсходногоДокумента1С) И НастройкаБП.ТипИсходногоДокумента1С <> НастройкаБП.ТипРезультирующегоДокумента1С Тогда
					Попытка
						Если ДокументОснование = Неопределено Тогда
							ДокументОснование = ГлЯдро_ПолучитьСсылкуНаДокументПоИд(НастройкаБП.ТипИсходногоДокумента1С,?(ЗначениеЗаполнено(ФильтрТЧПоИдДокумента),ФильтрТЧПоИдДокумента,ДанныеДокументаMS.ШапкаДокумента.Ид));
						КонецЕсли;
						Если ДокументДляЗаписи.Метаданные().Реквизиты.Найти("ДокументОснование") <> Неопределено Тогда
							ДокументДляЗаписи.ДокументОснование = ДокументОснование;
						КонецЕсли;
					Исключение
						ИмяСобытия = "ГлЯдро_ЗаполнитьДокумент1С";
						ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
						ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Ошибка при получении объекта документа - основания: " + ТекстОшибки + ", Документ: " + Строка(ДокументДляЗаписи),, АдресаПеременных);						
					КонецПопытки;
				КонецЕсли;
			Иначе			
				Попытка 
					ДокументДляЗаписи = ДокументДляЗаполнения.ПолучитьОбъект();	
				Исключение
					ИмяСобытия = "ГлЯдро_ЗаполнитьДокумент1С";
					ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
					ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Ошибка при получении объекта документа для записи: " + ТекстОшибки + ", Документ: " + Строка(ДокументДляЗаписи),, АдресаПеременных);					
				КонецПопытки;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	ДанныеДляЗагрузкиПоКлючам = Новый ТаблицаЗначений;
	ДанныеДляЗагрузкиПоКлючам.Колонки.Добавить("Таблица1СИсточник");
	ДанныеДляЗагрузкиПоКлючам.Колонки.Добавить("Таблица1СПриемник");
	ДанныеДляЗагрузкиПоКлючам.Колонки.Добавить("ИндексСтрокиMS");
	ДанныеДляЗагрузкиПоКлючам.Колонки.Добавить("ИндексСтроки1С");
	ДанныеДляЗагрузкиПоКлючам.Колонки.Добавить("ЗначениеКлюча");
	
	СтруктураДанных = Новый Структура;
	СтруктураДанных.Вставить("СообщениеОбОшибках", 								""); 
	СтруктураДанных.Вставить("СообщениеПользователю",							"Данные документа обработаны!");
	СтруктураДанных.Вставить("МетаданныеПриемника", 							?(ДокументДляЗаписи = Неопределено,"",ДокументДляЗаписи.Метаданные())); 
	СтруктураДанных.Вставить("ПравилаЗагрузки", 								НастройкаБП.НастройкаЗагрузкиПолей); 
	СтруктураДанных.Вставить("ДокументДляЗаписи", 								ДокументДляЗаписи); 
	СтруктураДанных.Вставить("ДокументОснование", 								ДокументОснование); 
	СтруктураДанных.Вставить("ДанныеДокументаMS", 								ДанныеДокументаMS); 
	СтруктураДанных.Вставить("ПроизвольныеКодыШапки", 							ПроизвольныеКодыШапки); 
	СтруктураДанных.Вставить("ПроизвольныеКодыТабличнойЧасти", 					ПроизвольныеКодыТабличнойЧасти); 	
	СтруктураДанных.Вставить("ПроизвольныеКодыОбработчикаЗагрузки", 			ПроизвольныеКодыОбработчикаЗагрузки); 	
	СтруктураДанных.Вставить("ПроизвольныеКодыОбработчикаТЧ", 					ПроизвольныеКодыОбработчикаТЧ); 	
	СтруктураДанных.Вставить("ПроизвольныеКодыОбработчикаСтрокиТЧ", 			ПроизвольныеКодыОбработчикаСтрокиТЧ); 	
	СтруктураДанных.Вставить("ЗначенияПараметров", 								ЗначенияПараметров); 
	СтруктураДанных.Вставить("ДанныеДляЗагрузки_Шапка", 						Новый Структура); 
	СтруктураДанных.Вставить("ИмяПриемникаДанных", 								"ДанныеДляЗагрузки_Шапка"); 
	СтруктураДанных.Вставить("ШапкаДокументаMS", 								СтруктураДанных.ДанныеДокументаMS.ШапкаДокумента); 
	СтруктураДанных.Вставить("ИмяИсточникаДанных", 								"ШапкаДокументаMS");
	СтруктураДанных.Вставить("ДанныеДляЗагрузкиПоКлючам", 						ДанныеДляЗагрузкиПоКлючам); // ZHKN 03.10.2017
	СтруктураДанных.Вставить("ПоследнийИндексСтрокиДанныхДляЗагрузкиПоКлючам", 	-1);   // ZHKN 03.10.2017
	СтруктураДанных.Вставить("ИмяМодуляБезопасногоРежима", 						ИмяМодуляБезопасногоРежима);   // ZHKN 03.10.2017	
		
	Если НастройкаБП.ВыполнитьТолькоПроизвольныйКод = Истина Тогда
		
		Если НастройкаБП.ТипОбработчикаЗагрузки = 0 И ЗначениеЗаполнено(НастройкаБП.ID_ПроизвольногоКода_Загрузка_Документ) Тогда
			
			Если ТипЗнч(ПроизвольныеКодыДокумента) = Тип("ТаблицаЗначений") Тогда
				НайденныйПК = ПроизвольныеКодыДокумента.Найти(НастройкаБП.ID_ПроизвольногоКода_Загрузка_Документ, "ID_ПроизвольногоКода");	
			ИначеЕсли ТипЗнч(ПроизвольныеКодыДокумента) = Тип("Массив") Тогда
				НайденныйПК = ГлЯдро_НайтиСтруктуруВМассивеПоЭлементу(ПроизвольныеКодыДокумента, "ID_ПроизвольногоКода", НастройкаБП.ID_ПроизвольногоКода_Загрузка_Документ);
			Иначе
				НайденныйПК = Неопределено;	
			КонецЕсли;

			Если НайденныйПК <> Неопределено И ЗначениеЗаполнено(НайденныйПК.ТекстПроизвольногоКода) Тогда
				
				СтруктураИО = КомЯдро_ПолучитьЗначениеПеременной("ИнтеграционнаяОбработка",АдресаПеременных);
				
				Если (СтруктураИО = Неопределено
					ИЛИ НЕ ТипЗнч(СтруктураИО) = Тип("Структура")
					ИЛИ НЕ СтруктураИО.Свойство("ИнтеграционнаяОбработка")
					ИЛИ СтруктураИО.ИнтеграционнаяОбработка = Неопределено)
					И НЕ ГлЯдро_ПересоздатьИнтеграционнуюОбработку(АдресаПеременных) Тогда
					ИнтеграционнаяОбработка = Неопределено;
				Иначе
					СтруктураИО = КомЯдро_ПолучитьЗначениеПеременной("ИнтеграционнаяОбработка",АдресаПеременных);
					ИнтеграционнаяОбработка = СтруктураИО.ИнтеграционнаяОбработка;
				КонецЕсли;				
				
				СтруктураПеременных = Новый Структура;
				СтруктураПеременных.Вставить("СсылкаДокументОснование1С", 	ДокументОснование);
				СтруктураПеременных.Вставить("ДокументТСД", 				ДанныеДокументаMS);
				СтруктураПеременных.Вставить("МодульОбработки", 			ИнтеграционнаяОбработка);
				СтруктураПеременных.Вставить("НастройкаБП", 				НастройкаБП);
				СтруктураПеременных.Вставить("ДанныеНастроекИзКэша", 		ДанныеНастроекИзКэша);
				СтруктураПеременных.Вставить("АдресаПеременных", 			АдресаПеременных);
				
				РезультатВыполненияКода = ГлЯдро_ВыполнитьПроизвольныйКод(НайденныйПК.ТекстПроизвольногоКода, СтруктураПеременных, НайденныйПК.ID_ПроизвольногоКода, НайденныйПК.Наименование, АдресаПеременных);
				
				
				Если НЕ РезультатВыполненияКода.Статус Тогда
					Сообщить("Ошибка! Не удалось выполнить произвольный код загрузки документа """ + НайденныйПК.Наименование + """");
				КонецЕсли; 
				//++кс #2014 Павлюков М.С. 31.05.2021
				Если НЕ ПустаяСтрока(РезультатВыполненияКода.СообщениеПользователю) Тогда
					СтруктураДанных.СообщениеПользователю = РезультатВыполненияКода.СообщениеПользователю;
				КонецЕсли;
				//--кс #2014 Павлюков М.С. 31.05.2021
			КонецЕсли; 
			
		ИначеЕсли НастройкаБП.ТипОбработчикаЗагрузки = 1 И ЗначениеЗаполнено(НастройкаБП.Обработчик_ПередЗаполнениемДокумента) Тогда
			
			ГлЯдро_ВыполнитьОбработчикЗагрузкиДокумента1С("Обработчик_ПередЗаполнениемДокумента", ДокументДляЗаписи, ДокументОснование, НастройкаБП,,,, ДанныеДокументаMS,,СтруктураДанных,АдресаПеременных);
			
		КонецЕсли;
		
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Конец, Заполнение документа 1С", НачалоСобытия, АдресаПеременных);
		Возврат СтруктураДанных;
	КонецЕсли;
	// Шапка документа
	// Реквизиты MS
	ГлЯдро_ЗаполнитьДанныеДляЗагрузкиРеквизитамиMS(СтруктураДанных);
	// Произвольные значения
	ГлЯдро_ЗаполнитьДанныеДляЗагрузкиПроизвольнымиЗначениями(СтруктураДанных);
	// Глобальные параметры
	ГлЯдро_ЗаполнитьДанныеДляЗагрузкиГлобальнымиПараметрами(СтруктураДанных);
	// Произвольные коды
	ГлЯдро_ЗаполнитьДанныеДляЗагрузкиПроизвольнымиКодами(СтруктураДанных,АдресаПеременных);	
	
	ГлЯдро_ВыполнитьОбработчикЗагрузкиДокумента1С("Обработчик_ПередЗаполнениемДокумента", ДокументДляЗаписи, ДокументОснование, НастройкаБП,,,, ДанныеДокументаMS,,СтруктураДанных,АдресаПеременных);	
		
	Если СтруктураДанных.Свойство("КритическаяОшибка")
		И СтруктураДанных.КритическаяОшибка = Истина Тогда
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Конец, Заполнение документа 1С", НачалоСобытия, АдресаПеременных);
		Возврат СтруктураДанных;
	КонецЕсли;
	
	// Заполняем шапку документа только если в новый документ
	Если ДокументДляЗаписи.ЭтоНовый() Тогда
		// Перед заполнением документа		
		Если НЕ ЗначениеЗаполнено(ДокументДляЗаписи.Дата) Тогда
			ДокументДляЗаписи.Дата = ТекущаяДата();
		КонецЕсли;
	КонецЕсли;
		
	// Загружаем
	Если ТипЗнч(НастройкаБП.НастройкаЗагрузкиПолей) = Тип("Массив") Тогда
		Для Каждого НастройкаРеквизита из НастройкаБП.НастройкаЗагрузкиПолей Цикл
			Если НастройкаРеквизита.Свойство("ТипПриемника") И НастройкаРеквизита.ТипПриемника = "Реквизит1С"
				И НастройкаРеквизита.Свойство("Загружать") И НастройкаРеквизита.Загружать = Истина Тогда
				
				Если СтруктураДанных.ДанныеДляЗагрузки_Шапка.Свойство(НастройкаРеквизита.ИмяПриемника) 
					И ЗначениеЗаполнено(СтруктураДанных.ДанныеДляЗагрузки_Шапка[НастройкаРеквизита.ИмяПриемника]) Тогда
					Попытка
						//ДокументДляЗаписи[НастройкаРеквизита.ИмяПриемника] = СтруктураДанных.ДанныеДляЗагрузки_Шапка[НастройкаРеквизита.ИмяПриемника];
						ЗначениеДляЗагрузки = REST_API_ПреобразованиеЗначенияРеквизитаИсточникаВТип1С(
							СтруктураДанных.ДанныеДляЗагрузки_Шапка[НастройкаРеквизита.ИмяПриемника],
							ДокументДляЗаписи[НастройкаРеквизита.ИмяПриемника]);	
						ДокументДляЗаписи[НастройкаРеквизита.ИмяПриемника] = ЗначениеДляЗагрузки;
					Исключение
						ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
						ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Ошибка при заполнении реквизита документа: " + ТекстОшибки + ", Документ: " + Строка(ДокументДляЗаписи), , АдресаПеременных);						
					КонецПопытки;
				КонецЕсли;
				
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	// Табличные части
	СтруктураДанных.Вставить("КонтрольКоличества", НастройкаБП.КонтрольКоличества);
	СтруктураДанных.Вставить("ДанныеДляЗагрузки_Строка", Новый Структура); 
	СтруктураДанных.Вставить("ИмяПриемникаДанных", "ДанныеДляЗагрузки_Строка"); 
	СтруктураДанных.Вставить("ИмяИсточникаДанных", "ТаблицаMS"); 
	
	//Найдем основную ТЧ и поставим её на первое место т.к. она должна обработаться первой
	НастройкиТЧ = НастройкаБП.НастройкаЗагрузкиТЧ;Индекс=0;
	Для Каждого СтрокаНастройкиТЧ Из НастройкиТЧ Цикл
		Если СтрокаНастройкиТЧ.Свойство("ОсновнаяТабличнаяЧасть") и СтрокаНастройкиТЧ.ОсновнаяТабличнаяЧасть = Истина Тогда
			СтруктураДанных.Вставить("ИмяОсновнойТЧ",СтрокаНастройкиТЧ.НастройкаТЧСтрокой);
			НастройкиТЧ.Удалить(Индекс);
			Если НастройкиТЧ[0].Свойство("ЭтоТаблицаЗначений") Тогда
				НастройкиТЧ.Вставить(1,СтрокаНастройкиТЧ);
			Иначе
				НастройкиТЧ.Вставить(0,СтрокаНастройкиТЧ);
			КонецЕсли;
			Прервать;
		КонецЕсли;
		Индекс=Индекс+1;
	КонецЦикла;
	
	
	Для Каждого СтрокаНастройкиТЧ Из НастройкиТЧ Цикл
		Если СтрокаНастройкиТЧ.Свойство("ЭтоТаблицаЗначений") Тогда
			Продолжить;
		КонецЕсли;
		СтруктураДанных.Вставить("СтрокаНастройкиТЧ", СтрокаНастройкиТЧ); 
		ГлЯдро_ЗагрузитьСтрокиТабличнойЧасти(СтруктураДанных,АдресаПеременных);
		Если СтруктураДанных.Свойство("КритическаяОшибка")
			И СтруктураДанных.КритическаяОшибка = Истина Тогда
			ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Конец, Заполнение документа 1С", НачалоСобытия, АдресаПеременных);
			Возврат СтруктураДанных;
	КонецЕсли;
	КонецЦикла;
	
	СтруктураДанных.Вставить("ИмяИсточникаДанных", "ДанныеДляЗагрузки_Шапка");
	СтруктураДанных.Вставить("ИмяПриемникаДанных", "ДанныеДляЗагрузки_Шапка"); 
	
	// После заполнения документа
	ГлЯдро_ВыполнитьОбработчикЗагрузкиДокумента1С("Обработчик_ПослеЗаполненияДокумента", ДокументДляЗаписи, ДокументОснование, НастройкаБП,,,, ДанныеДокументаMS,,СтруктураДанных,АдресаПеременных);
	
	Если СтруктураДанных.Свойство("КритическаяОшибка")
		И СтруктураДанных.КритическаяОшибка = Истина Тогда
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Конец, Заполнение документа 1С", НачалоСобытия, АдресаПеременных);
		Возврат СтруктураДанных;
	КонецЕсли;
		
	Если ГлЯдро_УдалитьСтрокиПоУсловию(ДокументДляЗаписи, НастройкаБП) Тогда
		//// если выполнено удаление строк по условию, необходимо сбросить флаг ДокументЗаписанВОбработчике, иначе изменения пропадут
		//СтруктураДанных.Вставить("ДокументЗаписанВОбработчике", Ложь);
		
		// Если удалены какие-то строки в документе, и при этом он был записан в обработчике, то необходимо еще раз записать документ,
		// чтобы сохранились эти изменения (флаг не трогаем)
		Если СтруктураДанных.Свойство("ДокументЗаписанВОбработчике") 
			И СтруктураДанных.ДокументЗаписанВОбработчике = Истина Тогда
			
			Попытка
				ДокументДляЗаписи.Записать();
			Исключение
				ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
				ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(
					ИмяСобытия, 
					"Ошибка", 
					"Ошибка при записи документа по удаления строк по условию: " + ТекстОшибки + ", Документ: " + Строка(ДокументДляЗаписи),, 
					АдресаПеременных);					
			КонецПопытки;                 				
			
		КонецЕсли;
	КонецЕсли;	
		
	ДокументДляЗаписи.ДополнительныеСвойства.Вставить("ПроводитьДокумент", НастройкаБП.ПроводитьДокументПослеЗагрузки);
	
	ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Конец, Заполнение документа 1С", НачалоСобытия, АдресаПеременных);
	
	Возврат СтруктураДанных;
	
КонецФункции

Функция ГлЯдро_ЗаписатьИПровестиДокумент1С(Знач РезультатЗаписи, НастройкаБизнесПроцесса, ИмяТипаДокумента, ИмяДокумента,АдресаПеременных)
	
	ИмяСобытия = "ГлЯдро_ЗаписатьИПровестиДокумент1С";
	НачалоСобытия = ТекущаяУниверсальнаяДатаВМиллисекундах();
	
	Если РезультатЗаписи.Статус = Истина Тогда
		
		// Результат выполнения произвольного кода загрузки
		Если РезультатЗаписи.Данные = Неопределено Тогда
			Возврат РезультатЗаписи;
		КонецЕсли;
		
		// ******************************************* +++ Алгоритм записи и проведения документов *******************************************
		
		НастройкиДляОбмена 	= ГлЯдро_ПолучитьИзКэшаНастройкуSMARTS("НастройкиБизнесПроцессов",,АдресаПеременных);
		// т.к. для документа уже был правильно подобран БП в методе "ГлЯдро_СформироватьИЗаписатьДокументВБазу1С_ПоID", то и здесь БП будет правильно подобран
		РезультатПодбораБП 	= ГлЯдро_ПолучитьНастройкуБизнесПроцесса(НастройкаБизнесПроцесса, ИмяТипаДокумента, НастройкиДляОбмена,,АдресаПеременных);										
		НастройкаБП 		= РезультатПодбораБП.Данные;
				
		ДокументДляЗаписи 	= РезультатЗаписи.Данные;
		ЭтоНовыйДокумент 	= ДокументДляЗаписи.ЭтоНовый();				
		СтрокаДокумента 	= "";
		#Область НесовместимыйКодFresh
		ДокументДляЗаписи.ОбменДанными.Загрузка = Ложь;
		#КонецОбласти //НесовместимыйКодFresh
		
		Если ДокументДляЗаписи.ЭтоНовый() И НЕ ЗначениеЗаполнено(ДокументДляЗаписи.Номер) Тогда
			ДокументДляЗаписи.УстановитьНовыйНомер();
		КонецЕсли;	
		
		Попытка
			Если ДокументДляЗаписи.Проведен Тогда
				Если Не РезультатЗаписи.ДокументЗаписанВОбработчике Тогда					
					РежимПроведения = ?(ДокументДляЗаписи.Метаданные().ОперативноеПроведение = Метаданные.СвойстваОбъектов.ОперативноеПроведение.Разрешить, 
						РежимПроведенияДокумента.Оперативный, РежимПроведенияДокумента.Неоперативный);
						
					Если (РежимПроведения = РежимПроведенияДокумента.Оперативный) И (ДокументДляЗаписи.Дата < НачалоДня(ТекущаяДата())) Тогда
						РежимПроведения = РежимПроведенияДокумента.Неоперативный;
					КонецЕсли;						
					
					ДокументДляЗаписи.Записать(РежимЗаписиДокумента.Проведение, РежимПроведения);
				КонецЕсли;	
				СтрокаДокумента = Строка(ДокументДляЗаписи.Ссылка);	
				РезультатЗаписи.Вставить("Сообщение", "Документ " + СтрокаДокумента + " записан и перепроведен!");
				ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Документ перепроведен: "+ СтрокаДокумента,НачалоСобытия,АдресаПеременных);
			Иначе	
				// Из-за странностей в некоторых релизах УТ 11, ЕРП 2.4 добавим попытку
				Попытка
					Если Не РезультатЗаписи.ДокументЗаписанВОбработчике Тогда
						ДокументДляЗаписи.Записать(РежимЗаписиДокумента.Запись);						
					КонецЕсли;						
				Исключение
					ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
					ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Ошибка при записи документа без режима ОбменДаннымиЗагрузка=Истина: " + ТекстОшибки + ", Документ: " + Строка(РежимЗаписиДокумента),, АдресаПеременных);					
					#Область НесовместимыйКодFresh
					ДокументДляЗаписи.ОбменДанными.Загрузка = Истина;					
					ДокументДляЗаписи.Записать(РежимЗаписиДокумента.Запись);
					ДокументДляЗаписи.ОбменДанными.Загрузка = Ложь;
					#КонецОбласти //НесовместимыйКодFresh
				КонецПопытки;						
				СтрокаДокумента = Строка(ДокументДляЗаписи.Ссылка);
				РезультатЗаписи.Вставить("Сообщение", "Документ " + СтрокаДокумента + " записан!"); 
			КонецЕсли;
		Исключение						
			РезультатЗаписи.Вставить("Сообщение", "Документ " + ИмяДокумента + " НЕ записан в базу 1С! Загрузите документ вручную через обработку."); 
			РезультатЗаписи.Вставить("Статус", Ложь);
			ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
			ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Ошибка при записи документа: " + ТекстОшибки + ", Документ: " + СтрокаДокумента,,АдресаПеременных);			
		КонецПопытки; 										
		
		Если РезультатЗаписи.Статус = Истина 
			И НЕ ДокументДляЗаписи.Проведен 
			И НастройкаБП.ПроводитьДокументПослеЗагрузки Тогда
			
			Попытка
				ДокументДляЗаписи.Записать(РежимЗаписиДокумента.Проведение);	
				СтрокаДокумента = Строка(ДокументДляЗаписи.Ссылка);
				РезультатЗаписи.Вставить("Сообщение", "Документ " + СтрокаДокумента + " записан и проведен!");
				ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Документ проведен: "+ СтрокаДокумента,НачалоСобытия,АдресаПеременных);
			Исключение
				РезультатЗаписи.Статус = Ложь;
				РезультатЗаписи.Вставить("Сообщение", "Документ " + СтрокаДокумента + " записан, но не проведен, проведите или загрузите документ вручную!");
				ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
				ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Ошибка при проведении: " + ТекстОшибки + ", Документ: " + СтрокаДокумента,НачалоСобытия,АдресаПеременных);				
			КонецПопытки; 
			
		КонецЕсли;
		
		Если РезультатЗаписи.Статус = Истина 
			И РезультатЗаписи.Свойство("ДокументОснование")
			И ЗначениеЗаполнено(РезультатЗаписи.ДокументОснование)
			И ДокументДляЗаписи.Ссылка <> РезультатЗаписи.ДокументОснование Тогда
			
			Попытка
				ДокументОснование = РезультатЗаписи.ДокументОснование.ПолучитьОбъект();
				Если ДокументОснование.Метаданные().Реквизиты.Найти("Комментарий") <> Неопределено Тогда
					ТекстКомментария = "Документ обработан на ТСД и создан " + Строка(ДокументДляЗаписи.Ссылка);
					Если ГлЯдро_СтрНайти(ДокументОснование.Комментарий, ТекстКомментария) = 0 Тогда
						ДокументОснование.Комментарий = ДокументОснование.Комментарий + ?(ПустаяСтрока(ДокументОснование.Комментарий), ТекстКомментария, "," + Символы.ПС + ТекстКомментария);
						
						РежимЗаписи = РежимЗаписиДокумента.Запись;
						Если ДокументОснование.Метаданные().Проведение = Метаданные.СвойстваОбъектов.Проведение.Разрешить
							И ДокументОснование.Проведен Тогда
							РежимЗаписи = РежимЗаписиДокумента.Проведение;
						КонецЕсли;
						ДокументОснование.Записать(РежимЗаписи);
					КонецЕсли;
				КонецЕсли;
			Исключение
				ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
				ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Ошибка при записи документа-основания: " + ТекстОшибки + ", Документ: " + Строка(ДокументОснование.Ссылка), НачалоСобытия, АдресаПеременных);				
			КонецПопытки;
			
		КонецЕсли;
		
		// ******************************************* --- Алгоритм записи и проведения документов *******************************************
		
	КонецЕсли;
	
	Возврат РезультатЗаписи;
	
КонецФункции

Функция ГлЯдро_УдалитьСтрокиПоУсловию(ДокументДляЗаписи, НастройкаБП)	
	
	УдалениеСтрокВыполнено = Ложь;
	
	Для каждого Строка Из НастройкаБП.НастройкаЗагрузкиТЧ Цикл
		Если Строка.Свойство("ЭтоТаблицаЗначений") 
			ИЛИ НЕ Строка.Свойство("УдалятьСтрокиПоУсловиюСтрокой")
			ИЛИ НЕ ЗначениеЗаполнено(Строка.УдалятьСтрокиПоУсловиюСтрокой)
			ИЛИ ДокументДляЗаписи.Метаданные().ТабличныеЧасти.Найти(Строка.НастройкаТЧСтрокой) = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		УдалятьСтрокиПоУсловиюФлаг = Строка.Свойство("УдалятьСтрокиПоУсловиюФлаг") И Строка.УдалятьСтрокиПоУсловиюФлаг = Истина;
		Если УдалятьСтрокиПоУсловиюФлаг <> Истина Тогда
			Продолжить;
		КонецЕсли;
		
		пНастройкиКомпоновки = ГлЯдро_ЗначениеИзСтрокиXML(СтрЗаменить(Строка.УдалятьСтрокиПоУсловиюСтрокой, Символы.ВК, "")); 	
		
		Если пНастройкиКомпоновки = Неопределено
			ИЛИ пНастройкиКомпоновки.Отбор.Элементы.Количество() = 0 Тогда
			Продолжить;
		КонецЕсли;
				
		ТаблицаДляУдаленияСтрок = ДокументДляЗаписи[Строка.НастройкаТЧСтрокой].Выгрузить();				
		
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//Загрузим ТЧ в СКД с настроенным отбором
		СКД = Новый СхемаКомпоновкиДанных;
		
		// Заполнение основных данных схемы
		ИсточникДанных = СКД.ИсточникиДанных.Добавить();
		ИсточникДанных.Имя = "ИсточникДанных";
		ИсточникДанных.ТипИсточникаДанных = "Local";
		
		ТекущийНаборДанных = СКД.НаборыДанных.Добавить(Тип("НаборДанныхОбъектСхемыКомпоновкиДанных"));
		ТекущийНаборДанных.Имя = "ОсновнойНабор";
		ТекущийНаборДанных.ИмяОбъекта = "ТаблицаИсточник";	
		ТекущийНаборДанных.ИсточникДанных = "ИсточникДанных";			
		ТипНабора = "Объект";
		
		НастройкиПоУмолчанию = пНастройкиКомпоновки;
		
		// Создание структуры.
		// Группировка, детальные записи и автовыбранное поле
		Группировка = НастройкиПоУмолчанию.Структура.Добавить(Тип("ГруппировкаКомпоновкиДанных"));
		Группировка.Использование = Истина;			
		АвтоПоле = Группировка.Выбор.Элементы.Добавить(Тип("АвтоВыбранноеПолеКомпоновкиДанных"));
		АвтоПоле.Использование = Истина;
		
		КоллекцияКолонок = Новый ТаблицаЗначений;
		КоллекцияКолонок.Колонки.Добавить("Имя");
		КоллекцияКолонок.Колонки.Добавить("ТипЗначения");
		КоллекцияКолонок.Колонки.Добавить("Заголовок");
		
		Для каждого Колонка Из ТаблицаДляУдаленияСтрок.Колонки Цикл			
			НоваяКолонка = КоллекцияКолонок.Добавить();
			НоваяКолонка.Имя = Колонка.Имя;
			НоваяКолонка.ТипЗначения = Колонка.ТипЗначения;
			НоваяКолонка.Заголовок = Колонка.Имя;									
		КонецЦикла;
		
		// Добавление полей в набор		
		Для каждого НоваяКолонка Из КоллекцияКолонок Цикл			
			ПолеНабора = ТекущийНаборДанных.Поля.Добавить(Тип("ПолеНабораДанныхСхемыКомпоновкиДанных"));
			ПолеНабора.Заголовок = СокрЛП(НоваяКолонка.Заголовок);
			ПолеНабора.Поле = СокрЛП(НоваяКолонка.Имя);
			ПолеНабора.ПутьКДанным = СокрЛП(НоваяКолонка.Имя);
			
			// Удалим неопределено и NULL
			Массив = Новый Массив;
			Для каждого ТекущийТип Из НоваяКолонка.ТипЗначения.Типы() Цикл
				Если ТекущийТип = Тип("Неопределено") или ТекущийТип = Тип("NULL") или ТекущийТип = Неопределено или ТекущийТип = Null Тогда 
					Продолжить; 
				КонецЕсли;
				Массив.Добавить(ТекущийТип);
			КонецЦикла;
			ПолеНабора.ТипЗначения = Новый ОписаниеТипов(Массив,НоваяКолонка.ТипЗначения.КвалификаторыЧисла,НоваяКолонка.ТипЗначения.КвалификаторыСтроки,НоваяКолонка.ТипЗначения.КвалификаторыДаты);
			
			ВыбранноеПолеКомпоновкиДанных = НастройкиПоУмолчанию.Выбор.Элементы.Добавить(Тип("ВыбранноеПолеКомпоновкиДанных"));			
			ВыбранноеПолеКомпоновкиДанных.Поле = Новый ПолеКомпоновкиДанных(ПолеНабора.ПутьКДанным);
			ВыбранноеПолеКомпоновкиДанных.Использование = Истина;
		КонецЦикла;		
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			
		ВнешниеНаборыДанных = Новый Структура;
	    ВнешниеНаборыДанных.Вставить("ТаблицаИсточник", ТаблицаДляУдаленияСтрок);
		
		КомпоновщикМакета = Новый КомпоновщикМакетаКомпоновкиДанных;
		МакетКомпоновки = КомпоновщикМакета.Выполнить(СКД, НастройкиПоУмолчанию,,,Тип("ГенераторМакетаКомпоновкиДанныхДляКоллекцииЗначений"),Ложь);
		
		ПроцессорКомпоновки = Новый ПроцессорКомпоновкиДанных;
		ПроцессорКомпоновки.Инициализировать(МакетКомпоновки,ВнешниеНаборыДанных);
		ПроцессорВывода = Новый ПроцессорВыводаРезультатаКомпоновкиДанныхВКоллекциюЗначений;
		Результат = ПроцессорВывода.Вывести(ПроцессорКомпоновки);
		
		Результат.Сортировать("НомерСтроки Убыв");
		
		ТЧДОкумента = ДокументДляЗаписи[Строка.НастройкаТЧСтрокой];
		Для каждого СтрокаДляУдаления ИЗ Результат Цикл
			СтрокаТЧ = ТЧДОкумента.Найти(СтрокаДляУдаления.НомерСтроки,"НомерСтроки");			
			ТЧДОкумента.Удалить(СтрокаТЧ);
			УдалениеСтрокВыполнено = Истина;
		КонецЦикла;
					
	КонецЦикла; 		
	
	Возврат УдалениеСтрокВыполнено;
			
КонецФункции

Процедура ГлЯдро_ЗагрузитьСтрокиТабличнойЧасти(СтруктураДанных,АдресаПеременных)
	
	//Заплатка. Нужно будет найти причину
	Если НЕ СтруктураДанных.СтрокаНастройкиТЧ.Свойство("ТабличнаяЧастьДокумента1С")
		И СтруктураДанных.СтрокаНастройкиТЧ.Свойство("ТабличнаяЧастьДокумента1ССтрокой")
		И ТипЗнч(СтруктураДанных.СтрокаНастройкиТЧ.ТабличнаяЧастьДокумента1ССтрокой) = Тип("Строка") Тогда
		СтруктураДанных.СтрокаНастройкиТЧ.Вставить("ТабличнаяЧастьДокумента1С",ГлЯдро_ЗначениеИзСтрокиXML(СтруктураДанных.СтрокаНастройкиТЧ.ТабличнаяЧастьДокумента1ССтрокой));
	КонецЕсли;
	
	Если ТипЗнч(СтруктураДанных.СтрокаНастройкиТЧ.ТабличнаяЧастьДокумента1С) <> Тип("Массив") Тогда
		Возврат;
	КонецЕсли;
	
	ИмяТЧ_1С = СтруктураДанных.СтрокаНастройкиТЧ.НастройкаТЧСтрокой;
	ИмяТЧ_MS = СтруктураДанных.СтрокаНастройкиТЧ.ТабличнаяЧастьДокументаMS;
	
	СтруктураДанных.Вставить("ПравилаЗагрузки", СтруктураДанных.СтрокаНастройкиТЧ.ТабличнаяЧастьДокумента1С); 
	СтруктураДанных.Вставить("МетаданныеПриемника", СтруктураДанных.ДокументДляЗаписи.Метаданные().ТабличныеЧасти[ИмяТЧ_1С]);
	СтруктураДанных.Вставить("МетаданныеДокументаПриемника", СтруктураДанных.ДокументДляЗаписи.Метаданные()); // ZHKN 03.10.2017
	СтруктураДанных.Вставить("Таблица1С", СтруктураДанных.ДокументДляЗаписи[ИмяТЧ_1С].Выгрузить()); 
	Если ИмяТЧ_MS = "СерииФакт" ИЛИ ИмяТЧ_MS = "СерийныеНомераФакт" Тогда
		СтруктураДанных.Вставить("ЭтоСерии", Истина); 
		СтруктураДанных.Вставить("ТаблицаТоваровMS", СтруктураДанных.ДанныеДокументаMS.СтрокиФакт); 
	ИначеЕсли ИмяТЧ_MS = "СерииПлан" ИЛИ ИмяТЧ_MS = "СерийныеНомераПлан" Тогда
		СтруктураДанных.Вставить("ЭтоСерии", Истина); 
		СтруктураДанных.Вставить("ТаблицаТоваровMS", СтруктураДанных.ДанныеДокументаMS.СтрокиПлан); 
	Иначе
		Если СтруктураДанных.ДанныеДокументаMS.Свойство(ИмяТЧ_MS) = Ложь Тогда
			Возврат;
		КонецЕсли;
		СтруктураДанных.Вставить("ЭтоСерии", Ложь); 
		СтруктураДанных.Вставить("ТаблицаMS", СтруктураДанных.ДанныеДокументаMS[ИмяТЧ_MS]); 
	КонецЕсли;
	
	
	ПравилаПоиска = Новый Массив;
	Для Каждого Правило Из СтруктураДанных.ПравилаЗагрузки Цикл
		Если Правило.Свойство("ПравилоПоиска")
			И Правило.Загружать = Истина
			И ЗначениеЗаполнено(Правило.ПравилоПоиска) Тогда
			ПравилаПоиска.Добавить(ГлЯдро_СкопироватьСтруктуру(Правило));
		КонецЕсли;
	КонецЦикла;
	СтруктураДанных.Вставить("ПравилаПоиска",ПравилаПоиска);
	
	Если СтруктураДанных.СтрокаНастройкиТЧ.ОчищатьТабличнуюЧасть Тогда
		СтруктураДанных.Таблица1С.Очистить();
	Иначе
		Для Каждого Правило Из СтруктураДанных.ПравилаЗагрузки Цикл
			Если Правило.Свойство("ОчищатьПередЗагрузкой")
				И Правило.Загружать = Истина
				И Правило.ОчищатьПередЗагрузкой 
				И СтруктураДанных.Таблица1С.Количество() > 0 Тогда
				ГлЯдро_ОчиститьКолонкуТаблицыЗначений(СтруктураДанных.Таблица1С, Правило.ИмяПриемника);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	// Перед заполнением ТЧ
	ГлЯдро_ВыполнитьОбработчикЗагрузкиДокумента1С("Обработчик_ПередЗаполнениемТабличнойЧасти", СтруктураДанных.ДокументДляЗаписи, СтруктураДанных.ДокументОснование, СтруктураДанных.СтрокаНастройкиТЧ, СтруктураДанных.Таблица1С,,,СтруктураДанных.ДанныеДокументаMS,,СтруктураДанных,АдресаПеременных);
	Если СтруктураДанных.Свойство("КритическаяОшибка")
		И СтруктураДанных.КритическаяОшибка = Истина Тогда
		Возврат;
	КонецЕсли;
	
	// Заполнение ТЧ
	Если  СтруктураДанных.СтрокаНастройкиТЧ.Свойство("ОсновнаяТабличнаяЧасть")
		И СтруктураДанных.СтрокаНастройкиТЧ.ОсновнаяТабличнаяЧасть Тогда
		//Заполним КлючСвязи
		СтруктураДанных.Вставить("НазваниеРеквизитаКлюча","КлючСвязи");
		ОтобранныеПравила = ГлЯдро_СкопироватьМассив(СтруктураДанных.ПравилаЗагрузки,Новый Структура("Загружать,ТипИсточника",Истина,"РеквизитMS"));
		Для Каждого Правило Из ОтобранныеПравила Цикл
			Если Найти(Правило.СинонимИсточника, "Ключ связи для """) > 0 И 
				СтруктураДанных.МетаданныеДокументаПриемника.ТабличныеЧасти[Правило.ИмяИсточника].Реквизиты.Найти(Правило.ИмяПриемника) <> Неопределено Тогда
				СтруктураДанных.НазваниеРеквизитаКлюча = Правило.ИмяПриемника;
				Прервать;
			КонецЕсли;
		КонецЦикла;
		
		
		ОписаниеТипаКлючаСвязи = СтруктураДанных.Таблица1С.Колонки[СтруктураДанных.НазваниеРеквизитаКлюча].ТипЗначения;
		СтруктураДанных.Вставить("СтроковыйТипКлючаСвязи",ОписаниеТипаКлючаСвязи.СодержитТип(Тип("Строка")));
		СтруктураДанных.Вставить("ЧисловойТипКлючаСвязи",ОписаниеТипаКлючаСвязи.СодержитТип(Тип("Число")));
		МаксКлючСвязи=0;
		Если СтруктураДанных.ЧисловойТипКлючаСвязи Тогда		
			Для Каждого СтрокаТЧ Из СтруктураДанных.Таблица1С Цикл
				РеквизитКлючаСвязи = Число(СтрокаТЧ[СтруктураДанных.НазваниеРеквизитаКлюча]);
				МаксКлючСвязи = Макс(МаксКлючСвязи, РеквизитКлючаСвязи);
			КонецЦикла;
			
			Для Каждого СтрокаТЧ Из СтруктураДанных.Таблица1С Цикл
				Если НЕ ЗначениеЗаполнено(СтрокаТЧ[СтруктураДанных.НазваниеРеквизитаКлюча]) Тогда
					МаксКлючСвязи=МаксКлючСвязи+1;
					СтрокаТЧ[СтруктураДанных.НазваниеРеквизитаКлюча] = МаксКлючСвязи;
				КонецЕсли;
			КонецЦикла;
		ИначеЕсли СтруктураДанных.СтроковыйТипКлючаСвязи Тогда
		    МаксКлючСвязи=0;			
			Для Каждого СтрокаТЧ Из СтруктураДанных.Таблица1С Цикл
				Если НЕ ЗначениеЗаполнено(СтрокаТЧ[СтруктураДанных.НазваниеРеквизитаКлюча]) Тогда
					Пока СтруктураДанных.Таблица1С.Найти(Строка(Формат(МаксКлючСвязи,"ЧГ=")),СтруктураДанных.НазваниеРеквизитаКлюча) <> Неопределено Цикл
						МаксКлючСвязи = МаксКлючСвязи + 1;
					КонецЦикла;
					СтрокаТЧ[СтруктураДанных.НазваниеРеквизитаКлюча] = Строка(Формат(МаксКлючСвязи,"ЧГ="));
				КонецЕсли;
			КонецЦикла;
			
		КонецЕсли;
		СтруктураДанных.Вставить("МаксКлючСвязи",МаксКлючСвязи);
	КонецЕсли;

	ОтобранныеПравилаДляЗагрузкиРеквизитамиMS 			= ГлЯдро_СкопироватьМассив(СтруктураДанных.ПравилаЗагрузки, Новый Структура("Загружать,ТипИсточника", Истина, "РеквизитMS"));
	ОтобранныеПравилаДляЗагрузкиПроизвольнымиЗначениями = ГлЯдро_СкопироватьМассив(СтруктураДанных.ПравилаЗагрузки, Новый Структура("Загружать,ТипИсточника", Истина, "ПроизвольноеЗначение"));
	ОтобранныеПравилаДляЗагрузкиГлобальнымиПараметрами 	= ГлЯдро_СкопироватьМассив(СтруктураДанных.ПравилаЗагрузки, Новый Структура("Загружать,ТипИсточника", Истина, "ГлобальныйПараметр"));
	ОтобранныеПравилаДляЗагрузкиПроизвольнымиКодами 	= ГлЯдро_СкопироватьМассив(СтруктураДанных.ПравилаЗагрузки, Новый Структура("Загружать,ТипИсточника", Истина, "ПроизвольныйКод"));
	
	ПравилаПодбораКоличества = ГлЯдро_СкопироватьМассив(СтруктураДанных.ПравилаЗагрузки, Новый Структура("Загружать,СпособСопоставления", Истина, "ПодборКоличества"));
	РеквизитыКЗагрузке 		 = ГлЯдро_СкопироватьМассив(СтруктураДанных.ПравилаЗагрузки, Новый Структура("Загружать,ТипПриемника", Истина, "Реквизит1С"));
	
	СтруктураДанных.Вставить("ОтобранныеПравилаДляЗагрузкиРеквизитамиMS", 			ОтобранныеПравилаДляЗагрузкиРеквизитамиMS);
	СтруктураДанных.Вставить("ОтобранныеПравилаДляЗагрузкиПроизвольнымиЗначениями", ОтобранныеПравилаДляЗагрузкиПроизвольнымиЗначениями);
	СтруктураДанных.Вставить("ОтобранныеПравилаДляЗагрузкиГлобальнымиПараметрами", 	ОтобранныеПравилаДляЗагрузкиГлобальнымиПараметрами);
	СтруктураДанных.Вставить("ОтобранныеПравилаДляЗагрузкиПроизвольнымиКодами", 	ОтобранныеПравилаДляЗагрузкиПроизвольнымиКодами);
	
	Для ИндексСтрокиMS = 0 По СтруктураДанных.ТаблицаMS.Количество() - 1 Цикл
		
		Если ТипЗнч(СтруктураДанных.ТаблицаMS) = Тип("Массив") И СтруктураДанных.ТаблицаMS[ИндексСтрокиMS].Свойство("ЭтоТаблицаЗначений") Тогда
			Продолжить;
		КонецЕсли;	
		
		СтруктураДанных.Вставить("ИндексСтрокиMS", ИндексСтрокиMS); 
		СтруктураДанных.Вставить("ДанныеДляЗагрузки_Строка", Новый Структура); 
		
		// Реквизиты MS
		ГлЯдро_ЗаполнитьДанныеДляЗагрузкиРеквизитамиMS(СтруктураДанных);
				
		// Произвольные значения
		ГлЯдро_ЗаполнитьДанныеДляЗагрузкиПроизвольнымиЗначениями(СтруктураДанных);
		
		// Глобальные параметры
		ГлЯдро_ЗаполнитьДанныеДляЗагрузкиГлобальнымиПараметрами(СтруктураДанных);
		
		// Произвольные коды
		//Будем выполнять только при сборе данных для загрузки и в момент выполнения произвольного кода мы не знаем, в какую/какие строки ТЧ 1С будет идти загрузка 
		ГлЯдро_ЗаполнитьДанныеДляЗагрузкиПроизвольнымиКодами(СтруктураДанных,АдресаПеременных);
			
		СтруктураДанных.Вставить("СтрокаMSРазнесена", Ложь);
		СтруктураДанных.Вставить("ЭтоНоваяСтрока1С", Ложь);
		СтруктураДанных.Вставить("ИндексСтроки1С", 0);
		СтруктураДанных.Вставить("ИндексСтрокиДляПоиска", 0);
		Пока НЕ СтруктураДанных.СтрокаMSРазнесена Цикл
			
			// Поиск подходящей строки
			СтруктураДанных.Вставить("ИмяТаблицыДляПоиска", "Таблица1С");
			ГлЯдро_НайтиПодходящуюСтрокуТаблицы1СПоКлючам(СтруктураДанных);
			ТекущаяСтрока1С = СтруктураДанных.Таблица1С.Получить(СтруктураДанных.ИндексСтроки1С);
			Если  СтруктураДанных.СтрокаНастройкиТЧ.Свойство("ОсновнаяТабличнаяЧасть")
				И СтруктураДанных.СтрокаНастройкиТЧ.ОсновнаяТабличнаяЧасть 
				И СтруктураДанных.ДанныеДляЗагрузкиПоКлючам.Количество() > 0 
				И СтруктураДанных.ПоследнийИндексСтрокиДанныхДляЗагрузкиПоКлючам >= 0 Тогда
				    СтрокаТЧ = СтруктураДанных.ДанныеДляЗагрузкиПоКлючам.Получить(СтруктураДанных.ПоследнийИндексСтрокиДанныхДляЗагрузкиПоКлючам);
					СтрокаТЧ.ИндексСтроки1С = СтруктураДанных.ИндексСтроки1С;
					Если Не СтруктураДанных.ЭтоНоваяСтрока1С И ЗначениеЗаполнено(ТекущаяСтрока1С[СтруктураДанных.НазваниеРеквизитаКлюча]) Тогда
						СтрокаТЧ.ЗначениеКлюча = ТекущаяСтрока1С[СтруктураДанных.НазваниеРеквизитаКлюча];
					Иначе
						СтруктураДанных.МаксКлючСвязи = СтруктураДанных.МаксКлючСвязи+1;
						СтрокаТЧ.ЗначениеКлюча = ?(СтруктураДанных.СтроковыйТипКлючаСвязи = Истина,Строка(Формат(СтруктураДанных.МаксКлючСвязи,"ЧГ=")),СтруктураДанных.МаксКлючСвязи);
						ТекущаяСтрока1С[СтруктураДанных.НазваниеРеквизитаКлюча] = СтрокаТЧ.ЗначениеКлюча;
					КонецЕсли;
			КонецЕсли;
			СтруктураДанных.Вставить("СтрокаДокумента1С", ТекущаяСтрока1С);
			
			// Подбор количества
			// ПравилаПодбораКоличества = ГлЯдро_СкопироватьМассив(СтруктураДанных.ПравилаЗагрузки,Новый Структура("Загружать,СпособСопоставления",Истина,"ПодборКоличества"));
			Если ПравилаПодбораКоличества.Количество() = 0 Тогда
				СтруктураДанных.Вставить("СтрокаMSРазнесена", Истина);
			Иначе
				Для Каждого СтрокаПравила Из ПравилаПодбораКоличества Цикл
					
					СтруктураДанных.Вставить("ПодборКоличества_Колонка1С", СтрокаПравила.ИмяПриемника);
					СтруктураДанных.Вставить("ПодборКоличества_КолонкаMS", СтрокаПравила.ИмяИсточника);
					
					СтруктураВызова = Новый Структура;
					СтруктураВызова.Вставить("ИмяМетода", СтрокаПравила.ОбработчикПодбораКоличества);
					СтруктураВызова.Вставить("ТипМетода", "Процедура");
					ПараметрыМетода = Новый Структура("СтруктураДанных", СтруктураДанных);
					СтруктураВызова.Вставить("ПараметрыМетода", ПараметрыМетода);
					
					ГлЯдро_ВыполнитьПроизвольныйОбработчик(СтруктураВызова,АдресаПеременных);
					
				КонецЦикла;
			КонецЕсли;
			
			// Перед заполнением строки
			ГлЯдро_ВыполнитьОбработчикЗагрузкиДокумента1С("Обработчик_ПередЗаполнениемСтрокиТабличнойЧасти", СтруктураДанных.ДокументДляЗаписи, СтруктураДанных.ДокументОснование, СтруктураДанных.СтрокаНастройкиТЧ,СтруктураДанных.Таблица1С, ТекущаяСтрока1С, СтруктураДанных, СтруктураДанных.ДанныеДокументаMS,СтруктураДанных.ДанныеДляЗагрузки_Строка,СтруктураДанных,АдресаПеременных);
			Если СтруктураДанных.Свойство("КритическаяОшибка")
				И СтруктураДанных.КритическаяОшибка = Истина Тогда
				Возврат;
			КонецЕсли;
			
			// Заполнение строки
			//Если СтруктураДанных.ЭтоНоваяСтрока1С Тогда
			//	РеквизитыКЗагрузке = ГлЯдро_СкопироватьМассив(СтруктураДанных.ПравилаЗагрузки,Новый Структура("Загружать,ТипПриемника",Истина,"Реквизит1С"));
			//Иначе
			//	РеквизитыКЗагрузке = ГлЯдро_СкопироватьМассив(СтруктураДанных.ПравилаЗагрузки,Новый Структура("Загружать,ТипПриемника", Истина, "Реквизит1С"));
			//КонецЕсли;
			
			КлючСвязиПроставлен = Ложь;
			Для Каждого НастройкаРеквизита Из РеквизитыКЗагрузке Цикл 
				
				Если НастройкаРеквизита.СпособСопоставления = "ПодборКоличества" Тогда
					Продолжить;
				ИначеЕсли НастройкаРеквизита.Группировать = Истина Тогда
					Если ЗначениеЗаполнено(СтруктураДанных.ДанныеДляЗагрузки_Строка[НастройкаРеквизита.ИмяПриемника]) 
							И (СтруктураДанных.ЭтоНоваяСтрока1С Или Не ЗначениеЗаполнено(ТекущаяСтрока1С[НастройкаРеквизита.ИмяПриемника])) Тогда						
							
						//ТекущаяСтрока1С[НастройкаРеквизита.ИмяПриемника] = СтруктураДанных.ДанныеДляЗагрузки_Строка[НастройкаРеквизита.ИмяПриемника];
						ЗначениеПриемника = REST_API_ПреобразованиеЗначенияРеквизитаИсточникаВТип1С(
							СтруктураДанных.ДанныеДляЗагрузки_Строка[НастройкаРеквизита.ИмяПриемника],
							ТекущаяСтрока1С[НастройкаРеквизита.ИмяПриемника]);	
						ТекущаяСтрока1С[НастройкаРеквизита.ИмяПриемника] = ЗначениеПриемника;
					КонецЕсли;
				ИначеЕсли НЕ НастройкаРеквизита.Группировать = Истина Тогда
					СтруктураДанных.Вставить("Агрегирование_Колонка1С", НастройкаРеквизита.ИмяПриемника);
					СтруктураДанных.Вставить("Агрегирование_ЭтоКлючСвязи", НастройкаРеквизита.ИмяИсточника = "КлючСвязиСерий");
					ГлЯдро_ЗаполнитьАгрегатноеЗначение(СтруктураДанных);
				КонецЕсли;
				
				Если НастройкаРеквизита.ИмяИсточника = "КлючСвязи" Тогда
					КлючСвязиПроставлен = Истина;
				КонецЕсли;	
				
			КонецЦикла;
			
			// Если в БП забыли указать ключ связи в подчиненной ТЧ, то можно попытаться попытаться заполнить связь по названию реквизита основной ТЧ 
			Если  СтруктураДанных.СтрокаНастройкиТЧ.Свойство("СопоставлятьСОсновнойТЧ")
				И СтруктураДанных.СтрокаНастройкиТЧ.СопоставлятьСОсновнойТЧ 
				И КлючСвязиПроставлен = Ложь 
				И СтруктураДанных.Свойство("НазваниеРеквизитаКлюча") Тогда
				Попытка
					ТекущаяСтрока1С[СтруктураДанных.НазваниеРеквизитаКлюча] = СтруктураДанных.ДанныеДляЗагрузки_Строка[СтруктураДанных.НазваниеРеквизитаКлюча];
				Исключение
				КонецПопытки;
			КонецЕсли;
			
			// После заполнения строки
			ГлЯдро_ВыполнитьОбработчикЗагрузкиДокумента1С("Обработчик_ПослеЗаполненияСтрокиТабличнойЧасти", СтруктураДанных.ДокументДляЗаписи, СтруктураДанных.ДокументОснование, СтруктураДанных.СтрокаНастройкиТЧ,СтруктураДанных.Таблица1С, ТекущаяСтрока1С, СтруктураДанных, СтруктураДанных.ДанныеДокументаMS,,СтруктураДанных,АдресаПеременных);//СтруктураДанных.СтрокаНастройкиТЧ);
			Если СтруктураДанных.Свойство("КритическаяОшибка")
				И СтруктураДанных.КритическаяОшибка = Истина Тогда
				Возврат;
			КонецЕсли;
		КонецЦикла;
		
	КонецЦикла;
	
	// После заполнения ТЧ
	ГлЯдро_ВыполнитьОбработчикЗагрузкиДокумента1С("Обработчик_ПослеЗаполненияТабличнойЧасти", СтруктураДанных.ДокументДляЗаписи, СтруктураДанных.ДокументОснование, СтруктураДанных.СтрокаНастройкиТЧ, СтруктураДанных.Таблица1С,,, СтруктураДанных.ДанныеДокументаMS,,СтруктураДанных,АдресаПеременных);
	Если СтруктураДанных.Свойство("КритическаяОшибка")
		И СтруктураДанных.КритическаяОшибка = Истина Тогда
		Возврат;
	КонецЕсли;
	
	// Возвращаем на место товары для серий.
	Если СтруктураДанных.ЭтоСерии Тогда
		Если ИмяТЧ_MS = "СерииФакт" ИЛИ ИмяТЧ_MS = "СерийныеНомераФакт" Тогда
			СтруктураДанных.ДанныеДокументаMS.Вставить("СтрокиФакт", СтруктураДанных.ТаблицаТоваровMS.Скопировать()); 
		КонецЕсли;
		Если ИмяТЧ_MS = "СерииПлан" ИЛИ ИмяТЧ_MS = "СерийныеНомераПлан" Тогда
			СтруктураДанных.ДанныеДокументаMS.Вставить("СтрокиПлан", СтруктураДанных.ТаблицаТоваровMS.Скопировать()); 
		КонецЕсли;
		СтруктураДанных.ТаблицаТоваровMS.Очистить();
	КонецЕсли;
	
	СтруктураДанных.ДокументДляЗаписи[ИмяТЧ_1С].Загрузить(СтруктураДанных.Таблица1С); 
	
КонецПроцедуры

Процедура ГлЯдро_ВыполнитьОбработчикЗагрузкиДокумента1С(ИмяОбработчика,
		Док1СРезультат, Док1СОснование, СтрокаНастройки, ТЧ = Неопределено,
		СтрокаДокумента = Неопределено, СтруктураПоискаКлючаСвязи = Неопределено,
		ДанныеДокументаMS = Неопределено, ДанныеДляЗагрузки_Строка = Неопределено,СтруктураДанных = Неопределено,АдресаПеременных)

	НачалоСобытия = ТекущаяУниверсальнаяДатаВМиллисекундах();
	ИмяСобытия = "ГлЯдро_ВыполнитьОбработчикЗагрузкиДокумента1С";	
	
	ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Начало, Выполнение обработчика загрузки документа 1С: " + Строка(ИмяОбработчика), , АдресаПеременных);	
		
	Если ЗначениеЗаполнено(СтрокаНастройки[ИмяОбработчика]) Тогда
		СтруктураИО = КомЯдро_ПолучитьЗначениеПеременной("ИнтеграционнаяОбработка",АдресаПеременных);
		
		Если (СтруктураИО = Неопределено
			ИЛИ НЕ ТипЗнч(СтруктураИО) = Тип("Структура")
			ИЛИ НЕ СтруктураИО.Свойство("ИнтеграционнаяОбработка")
			ИЛИ СтруктураИО.ИнтеграционнаяОбработка = Неопределено)
			И НЕ ГлЯдро_ПересоздатьИнтеграционнуюОбработку(АдресаПеременных) Тогда
			ИнтеграционнаяОбработка = Неопределено;
		Иначе
			СтруктураИО = КомЯдро_ПолучитьЗначениеПеременной("ИнтеграционнаяОбработка",АдресаПеременных);
			ИнтеграционнаяОбработка = СтруктураИО.ИнтеграционнаяОбработка;
		КонецЕсли;
		
		// Проверяем, является ли обработчик заполнения произвольным кодом
		ПроизвольныеКоды = Неопределено;
		Если СтруктураДанных.ИмяИсточникаДанных = "ДанныеДляЗагрузки_Шапка" Тогда
			ПроизвольныеКоды = СтруктураДанных.ПроизвольныеКодыОбработчикаЗагрузки;
		ИначеЕсли СтруктураДанных.ИмяПриемникаДанных = "ДанныеДляЗагрузки_Строка" Тогда
			Если СтрокаДокумента = Неопределено Тогда
				ПроизвольныеКоды = СтруктураДанных.ПроизвольныеКодыОбработчикаТЧ;
			Иначе
				ПроизвольныеКоды = СтруктураДанных.ПроизвольныеКодыОбработчикаСтрокиТЧ;
			КонецЕсли;
		КонецЕсли;
		
		Если ТипЗнч(ПроизвольныеКоды) = Тип("ТаблицаЗначений") Тогда
			НайденныйПК = ПроизвольныеКоды.Найти(СтрокаНастройки[ИмяОбработчика]);	
		ИначеЕсли ТипЗнч(ПроизвольныеКоды) = Тип("Массив") Тогда
			НайденныйПК = ГлЯдро_НайтиСтруктуруВМассивеПоЭлементу(ПроизвольныеКоды, "ID_ПроизвольногоКода", СтрокаНастройки[ИмяОбработчика]);			
		Иначе
			НайденныйПК = Неопределено;
		КонецЕсли;
		
		ЗначенияПараметров = ?(СтруктураДанных.Свойство("ЗначенияПараметров"), СтруктураДанных.ЗначенияПараметров, Неопределено);
		
		ТекущиеНастройкиMS = КомЯдро_ПолучитьЗначениеПеременной("ТекущиеНастройкиMS",АдресаПеременных);		
		
		Если Не НайденныйПК = Неопределено Тогда
			
			СтруктураПеременных = Новый Структура;
			
			Если СтруктураДанных.ИмяПриемникаДанных = "ДанныеДляЗагрузки_Шапка" Тогда					
				
				СтруктураПеременных.Вставить("Док1СРезультат", 			Док1СРезультат);
				СтруктураПеременных.Вставить("Док1СОснование", 			Док1СОснование);
				СтруктураПеременных.Вставить("ДанныеДокументаMS", 		ДанныеДокументаMS);
				СтруктураПеременных.Вставить("ДокументТСД", 			ДанныеДокументаMS);
				Если СтрокаНастройки.Свойство("НастройкаТЧСтрокой") Тогда
					СтруктураПеременных.Вставить("ИмяТабличнойЧасти", 	СтрокаНастройки.НастройкаТЧСтрокой);
				КонецЕсли;
				СтруктураПеременных.Вставить("СтрокаНастройки", 		СтрокаНастройки);
				СтруктураПеременных.Вставить("ТЧ", 						ТЧ);
				СтруктураПеременных.Вставить("ТекущиеНастройкиMS", 		ТекущиеНастройкиMS);
				СтруктураПеременных.Вставить("ЗначенияПараметров",		ЗначенияПараметров);
				СтруктураПеременных.Вставить("АдресаПеременных", 		АдресаПеременных);
				СтруктураПеременных.Вставить("МодульОбработки", 		ИнтеграционнаяОбработка);
				
			ИначеЕсли СтруктураДанных.ИмяПриемникаДанных = "ДанныеДляЗагрузки_Строка" Тогда
				
				Если СтрокаДокумента = Неопределено Тогда
					
					СтруктураПеременных.Вставить("Док1СРезультат", 			Док1СРезультат);
					СтруктураПеременных.Вставить("Док1СОснование", 			Док1СОснование);
					СтруктураПеременных.Вставить("ДанныеДокументаMS", 		ДанныеДокументаMS);
					СтруктураПеременных.Вставить("ДокументТСД", 			ДанныеДокументаMS);
					Если СтрокаНастройки.Свойство("НастройкаТЧСтрокой") Тогда
						СтруктураПеременных.Вставить("ИмяТабличнойЧасти", 	СтрокаНастройки.НастройкаТЧСтрокой);
					КонецЕсли;
					СтруктураПеременных.Вставить("СтрокаНастройки", 		СтрокаНастройки);
					СтруктураПеременных.Вставить("ТЧ", 						ТЧ);
					СтруктураПеременных.Вставить("ТекущиеНастройкиMS", 		ТекущиеНастройкиMS);
					СтруктураПеременных.Вставить("ЗначенияПараметров",		ЗначенияПараметров);
					СтруктураПеременных.Вставить("АдресаПеременных", 		АдресаПеременных);
					СтруктураПеременных.Вставить("МодульОбработки", 		ИнтеграционнаяОбработка);
					
				Иначе
					
					СтруктураПеременных.Вставить("Док1СРезультат", 						Док1СРезультат);
					СтруктураПеременных.Вставить("Док1СОснование", 						Док1СОснование);
					СтруктураПеременных.Вставить("ДанныеДокументаMS", 					ДанныеДокументаMS);
					СтруктураПеременных.Вставить("ДокументТСД", 						ДанныеДокументаMS);
					Если СтрокаНастройки.Свойство("НастройкаТЧСтрокой") Тогда
						СтруктураПеременных.Вставить("ИмяТабличнойЧасти", 				СтрокаНастройки.НастройкаТЧСтрокой);
					КонецЕсли;
					СтруктураПеременных.Вставить("СтрокаНастройки", 					СтрокаНастройки);
					СтруктураПеременных.Вставить("СтрокаДокумента", 					СтрокаДокумента);
					СтруктураПеременных.Вставить("СтруктураПоискаКлючаСвязи", 			СтруктураПоискаКлючаСвязи);
					Если СтруктураПоискаКлючаСвязи <> Неопределено Тогда
						СтруктураПеременных.Вставить("СтрокаТабличнойЧастиДокументаТСД", СтруктураПоискаКлючаСвязи.ТаблицаMS[СтруктураПоискаКлючаСвязи.ИндексСтрокиMS]);
					КонецЕсли;                                                          					
					СтруктураПеременных.Вставить("ТЧ", 									ТЧ);
					СтруктураПеременных.Вставить("ТекущиеНастройкиMS", 					ТекущиеНастройкиMS);
					СтруктураПеременных.Вставить("ЗначенияПараметров",					ЗначенияПараметров);
					СтруктураПеременных.Вставить("АдресаПеременных", 					АдресаПеременных);
					СтруктураПеременных.Вставить("МодульОбработки", 					ИнтеграционнаяОбработка);
					
				КонецЕсли;
				
			КонецЕсли;	
			
			РезультатВыполненияКода = ГлЯдро_ВыполнитьПроизвольныйКод(
				НайденныйПК.ТекстПроизвольногоКода, 
				СтруктураПеременных,
				НайденныйПК.ID_ПроизвольногоКода,
				НайденныйПК.Наименование,
				АдресаПеременных);
			
			Если Не РезультатВыполненияКода.Статус Тогда
				СообщениеОбОшибках = СтруктураДанных.СообщениеОбОшибках + Символы.ВК + "Не удалось выполнить произвольный код [" + НайденныйПК.Наименование + "]";
				СтруктураДанных.Вставить("СообщениеОбОшибках", СообщениеОбОшибках);				
			КонецЕсли;
			
		Иначе
			
			СтруктураПараметров = Новый Структура;
			СтруктураПараметров.Вставить("СтрокаНастройки", 			СтрокаНастройки);
			СтруктураПараметров.Вставить("Док1СРезультат", 				Док1СРезультат);
			СтруктураПараметров.Вставить("Док1СОснование", 				Док1СОснование);
			СтруктураПараметров.Вставить("ТЧ", 							ТЧ);
			СтруктураПараметров.Вставить("СтрокаДокумента", 			СтрокаДокумента);
			СтруктураПараметров.Вставить("СтруктураПоискаКлючаСвязи", 	СтруктураПоискаКлючаСвязи);
			СтруктураПараметров.Вставить("ДанныеДокументаMS", 			ДанныеДокументаMS);
			СтруктураПараметров.Вставить("ДокументТСД", 				ДанныеДокументаMS);
			СтруктураПараметров.Вставить("ТекущиеНастройкиMS", 			ТекущиеНастройкиMS);
			СтруктураПараметров.Вставить("ЗначенияПараметров",			ЗначенияПараметров);
			СтруктураПараметров.Вставить("ДанныеДляЗагрузки_Строка", 	ДанныеДляЗагрузки_Строка);
			Если СтруктураДанных.Свойство("ДанныеДляЗагрузки_Шапка") Тогда
				СтруктураПараметров.Вставить("ДанныеДляЗагрузки_Шапка", СтруктураДанных.ДанныеДляЗагрузки_Шапка);
			КонецЕсли;          
			Если ЗначениеЗаполнено(СтруктураДанных.ИмяМодуляБезопасногоРежима) Тогда
				СтруктураПараметров.Вставить("ИмяМодуляБезопасногоРежима", СтруктураДанных.ИмяМодуляБезопасногоРежима);
			КонецЕсли;
			
			СтруктураПараметров.Вставить("АдресаПеременных", АдресаПеременных);
			Если СтруктураПоискаКлючаСвязи <> Неопределено Тогда
				СтруктураПараметров.Вставить("СтрокаТабличнойЧастиДокументаТСД", СтруктураПоискаКлючаСвязи.ТаблицаMS[СтруктураПоискаКлючаСвязи.ИндексСтрокиMS]);
			КонецЕсли;
			Если СтрокаНастройки.Свойство("НастройкаТЧСтрокой") Тогда
				СтруктураПараметров.Вставить("ИмяТабличнойЧасти", СтрокаНастройки.НастройкаТЧСтрокой);
			КонецЕсли;
			Попытка
				//Выполнить ("ИнтеграционнаяОбработка." + СтрокаНастройки[ИмяОбработчика]
				//+ "(СтруктураПараметров)");
				ПараметрыАлгоритма = Новый Структура;
				ПараметрыАлгоритма.Вставить("ИнтеграционнаяОбработка", ИнтеграционнаяОбработка);
				ПараметрыАлгоритма.Вставить("СтруктураПараметров", СтруктураПараметров);
				ГлЯдро_ВыполнитьВБезопасномРежиме("Параметры.ИнтеграционнаяОбработка." + СтрокаНастройки[ИмяОбработчика]
				+ "(Параметры.СтруктураПараметров)", ПараметрыАлгоритма, АдресаПеременных);
				Если Док1СРезультат <> СтруктураПараметров.Док1СРезультат Тогда // При выполнении обработчика документ результат может быть заменен на уже существующий, или созданный в обработчике. Чтоб документы не задваивались, надо забрать его из структуры
					Док1СРезультат =  СтруктураПараметров.Док1СРезультат;
					Если СтруктураДанных<> Неопределено 
						И СтруктураДанных.ДокументДляЗаписи <> Док1СРезультат Тогда
						СтруктураДанных.Вставить("ДокументДляЗаписи",Док1СРезультат);
					КонецЕсли;
				КонецЕсли;
			Исключение
				ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
				ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации("ГлЯдро_ВыполнитьОбработчикЗагрузкиДокумента1С", "Ошибка", "Не удалось выполнить обработчик """ + СтрокаНастройки[ИмяОбработчика] + """. Причина: " + ТекстОшибки,, АдресаПеременных);				
			КонецПопытки;
			Если СтруктураПараметров.Свойство("ЕстьОшибкиПриВыполненииОбработчиков")
				И СтруктураПараметров.ЕстьОшибкиПриВыполненииОбработчиков Тогда
				Док1СРезультат.ДополнительныеСвойства.Вставить("ЕстьОшибкиПриВыполненииОбработчиков", СтруктураПараметров.ЕстьОшибкиПриВыполненииОбработчиков);
			КонецЕсли;
			Если СтруктураПараметров.Свойство("КритическаяОшибка")
				И СтруктураПараметров.КритическаяОшибка Тогда
				Если СтруктураПараметров.Свойство("КритическаяОшибкаОписание") Тогда
					КритическаяОшибкаОписание = СтруктураПараметров.КритическаяОшибкаОписание;	
				Иначе	
					КритическаяОшибкаОписание = "(Пусто)";
				КонецЕсли;
				ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации("ГлЯдро_ВыполнитьОбработчикЗагрузкиДокумента1С", "Ошибка", "Критическая ошибка при выполнении обработчика """ + СтрокаНастройки[ИмяОбработчика] + """. Причина: " + КритическаяОшибкаОписание,,АдресаПеременных);
				ТекстОшибки = "Критическая ошибка при выполнении обработчика """ + СтрокаНастройки[ИмяОбработчика] + """. Причина: " + КритическаяОшибкаОписание;
				Если СтруктураДанных.Свойство("СообщениеОбОшибках") И СтруктураДанных.СообщениеОбОшибках <> "" Тогда
					ТекстОшибки = СтруктураДанных.СообщениеОбОшибках + "
					|" + ТекстОшибки;
				КонецЕсли;
				СтруктураДанных.Вставить("СообщениеОбОшибках",ТекстОшибки);
				СтруктураДанных.Вставить("КритическаяОшибка",Истина);
			КонецЕсли;
			Если СтруктураПараметров.Свойство("ДокументЗаписанВОбработчике") Тогда
				СтруктураДанных.Вставить("ДокументЗаписанВОбработчике",СтруктураПараметров.ДокументЗаписанВОбработчике);
			КонецЕсли;
			Если СтруктураПараметров.Свойство("ПараметрыОткрытияФормы") Тогда
				СтруктураДанных.Вставить("ПараметрыОткрытияФормы",СтруктураПараметров.ПараметрыОткрытияФормы);
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЕсли;
	
	ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Конец, Выполнение обработчика загрузки документа 1С: " + Строка(ИмяОбработчика), НачалоСобытия, АдресаПеременных);

КонецПроцедуры

Процедура ГлЯдро_ЗаполнитьДанныеДляЗагрузкиРеквизитамиMS(СтруктураДанных)
	
	Если ТипЗнч(СтруктураДанных.ПравилаЗагрузки) <> Тип("Массив") ИЛИ СтруктураДанных.ПравилаЗагрузки.Количество() <= 1 Тогда
		Возврат;
	КонецЕсли;
	
	Если СтруктураДанных.Свойство("ОтобранныеПравилаДляЗагрузкиРеквизитамиMS") Тогда
		ОтобранныеПравила = СтруктураДанных.ОтобранныеПравилаДляЗагрузкиРеквизитамиMS;
	Иначе	
		ОтобранныеПравила = ГлЯдро_СкопироватьМассив(СтруктураДанных.ПравилаЗагрузки,Новый Структура("Загружать,ТипИсточника",Истина,"РеквизитMS"));
	КонецЕсли;
	
	ИсточникДанных = СтруктураДанных[СтруктураДанных.ИмяИсточникаДанных];
	Если СтруктураДанных.ИмяПриемникаДанных = "ДанныеДляЗагрузки_Строка" Тогда
		ИсточникДанных 	= ИсточникДанных.Получить(СтруктураДанных.ИндексСтрокиMS);
		ТаблицаMS 		= СтруктураДанных[СтруктураДанных.ИмяИсточникаДанных];
	Иначе
		ТаблицаMS = Неопределено;
	КонецЕсли;		
	
	ИмяКлючаСвязи = "КлючСвязи";
	
	Для Каждого Правило Из ОтобранныеПравила Цикл
		Если Правило.СпособСопоставления = "ПодборКоличества" Тогда
			Продолжить;
		КонецЕсли;
		ЗначениеРеквизитаДляЗагрузки = Неопределено;
		Если ЗначениеЗаполнено(Правило.ИмяПриемника) И ЗначениеЗаполнено(Правило.ИмяИсточника) Тогда
			Если Найти(Правило.СинонимИсточника, "Ключ связи для """) > 0 И 
				СтруктураДанных.МетаданныеДокументаПриемника.ТабличныеЧасти[Правило.ИмяИсточника].Реквизиты.Найти(Правило.ИмяПриемника) <> Неопределено И
				СтруктураДанных.СтрокаНастройкиТЧ.Свойство("ОсновнаяТабличнаяЧасть") И СтруктураДанных.СтрокаНастройкиТЧ.ОсновнаяТабличнаяЧасть = Истина Тогда 
				
				СтрокаТЧ = СтруктураДанных.ДанныеДляЗагрузкиПоКлючам.Добавить();
				СтрокаТЧ.Таблица1СИсточник = СтруктураДанных.МетаданныеПриемника.Имя;
				СтрокаТЧ.Таблица1СПриемник = Правило.ИмяИсточника;
				СтрокаТЧ.ИндексСтрокиMS = СтруктураДанных.ИндексСтрокиMS;
				СтрокаТЧ.ИндексСтроки1С = 0;

				СтруктураДанных.ПоследнийИндексСтрокиДанныхДляЗагрузкиПоКлючам = СтруктураДанных.ДанныеДляЗагрузкиПоКлючам.Индекс(СтрокаТЧ);
				ЗначениеРеквизитаДляЗагрузки = Неопределено; //Заполним в другом месте
			ИначеЕсли Правило.СпособСопоставления = "КакЕсть" Тогда 
				ИмяИсточника = Правило.ИмяИсточника;
				Если ИмяИсточника = "КлючСвязи" Тогда
					ИмяИсточника = Правило.ИмяПриемника;
					ИмяКлючаСвязи = ИмяИсточника;
				КонецЕсли;
				ЗначениеРеквизитаДляЗагрузки = ИсточникДанных[ИмяИсточника];
			Иначе
				Попытка
					ЗначениеРеквизита = ИсточникДанных[Правило.ИмяИсточника];
					Если НЕ ЗначениеЗаполнено(ЗначениеРеквизита) Тогда
						ЗначениеРеквизитаДляЗагрузки = Неопределено;
					Иначе
						ТипВсеСправочники = Справочники.ТипВсеСсылки();
						ТипВсеДокументы = Документы.ТипВсеСсылки();
						ТипВсеПВХ = ПланыВидовХарактеристик.ТипВсеСсылки();
						ТипВсеПеречисление = Перечисления.ТипВсеСсылки();
						ОбъектМетаданных = СтруктураДанных.МетаданныеПриемника.Реквизиты[Правило.ИмяПриемника];
						Для Каждого ТипРеквизитаПриемника Из ОбъектМетаданных.Тип.Типы() Цикл
							ЭтоСправочник = ТипВсеСправочники.СодержитТип(ТипРеквизитаПриемника);
							ЭтоДокумент = ТипВсеДокументы.СодержитТип(ТипРеквизитаПриемника);
							ЭтоПВХ = ТипВсеПВХ.СодержитТип(ТипРеквизитаПриемника);
							ЭтоПеречисление = ТипВсеПеречисление.СодержитТип(ТипРеквизитаПриемника);
							пОбъектМетаданных = Метаданные.НайтиПоТипу(ТипРеквизитаПриемника);
							Если пОбъектМетаданных = Неопределено Тогда
								Продолжить;
							КонецЕсли;
							ИмяОбъекта = пОбъектМетаданных.Имя;
							Если Правило.СпособСопоставления = "СтрокаGUID" Тогда
								Если ЭтоСправочник Тогда
									ЗначениеРеквизитаДляЗагрузки = Справочники[ИмяОбъекта].ПолучитьСсылку(Новый УникальныйИдентификатор(ЗначениеРеквизита));
								ИначеЕсли ЭтоДокумент Тогда
									ЗначениеРеквизитаДляЗагрузки = Документы[ИмяОбъекта].ПолучитьСсылку(Новый УникальныйИдентификатор(ЗначениеРеквизита));
								ИначеЕсли ЭтоПВХ Тогда
									ЗначениеРеквизитаДляЗагрузки = ПланыВидовХарактеристик[ИмяОбъекта].ПолучитьСсылку(Новый УникальныйИдентификатор(ЗначениеРеквизита));
								ИначеЕсли ЭтоПеречисление Тогда
									ЗначениеРеквизитаДляЗагрузки = Перечисления[ИмяОбъекта].ПолучитьСсылку(Новый УникальныйИдентификатор(ЗначениеРеквизита));
								КонецЕсли;
							ИначеЕсли Правило.СпособСопоставления = "Наименование" Тогда							
								Если ЭтоСправочник Тогда
									ЗначениеРеквизитаДляЗагрузки = Справочники[ИмяОбъекта].НайтиПоНаименованию(ЗначениеРеквизита, Истина);
								ИначеЕсли ЭтоПВХ Тогда
									ЗначениеРеквизитаДляЗагрузки = ПланыВидовХарактеристик[ИмяОбъекта].НайтиПоНаименованию(ЗначениеРеквизита, Истина);
								ИначеЕсли ЭтоПеречисление Тогда
									ЗначениеРеквизитаДляЗагрузки = ПредопределенноеЗначение("Перечисление." + ИмяОбъекта + "." + ЗначениеРеквизита);	
								КонецЕсли;
							ИначеЕсли Правило.СпособСопоставления = "Код" Тогда
								Если ЭтоСправочник Тогда
									ЗначениеРеквизитаДляЗагрузки = Справочники[ИмяОбъекта].НайтиПоКоду(ЗначениеРеквизита);
								ИначеЕсли ЭтоПВХ Тогда
									ЗначениеРеквизитаДляЗагрузки = ПланыВидовХарактеристик[ИмяОбъекта].НайтиПоКоду(ЗначениеРеквизита);	
								КонецЕсли;
							КонецЕсли;
							Если ТипЗнч(ЗначениеРеквизитаДляЗагрузки) = ТипРеквизитаПриемника
								И НЕ ЗначениеРеквизитаДляЗагрузки.Пустая() Тогда
								
								СсылкиПроверяемогоТипа = КэшПроверенныхСсылок.Получить(ТипРеквизитаПриемника);
								Если СсылкиПроверяемогоТипа = Неопределено Тогда
									СсылкаСуществует = ГлЯдро_СсылкаСуществует(ЗначениеРеквизитаДляЗагрузки);
									
									ЗначениеКэша = Новый Соответствие;
									ЗначениеКэша.Вставить(ЗначениеРеквизитаДляЗагрузки, СсылкаСуществует);
									КэшПроверенныхСсылок.Вставить(ТипРеквизитаПриемника, ЗначениеКэша);
								Иначе
									СсылкаСуществует = СсылкиПроверяемогоТипа.Получить(ЗначениеРеквизитаДляЗагрузки);
									Если СсылкаСуществует = Неопределено Тогда
										СсылкаСуществует = ГлЯдро_СсылкаСуществует(ЗначениеРеквизитаДляЗагрузки);	
										
										СсылкиПроверяемогоТипа.Вставить(ЗначениеРеквизитаДляЗагрузки, СсылкаСуществует);
									КонецЕсли;
								КонецЕсли;
								
								Если СсылкаСуществует Тогда
									Прервать;
								КонецЕсли;	
									
							КонецЕсли;
						КонецЦикла;
					КонецЕсли;
				Исключение
					СообщениеОбОшибках = СтруктураДанных.СообщениеОбОшибках + Символы.ВК + "Не удалось получить значение реквизита Mobile SMARTS [" + Правило.СинонимИсточника + "]";
					СтруктураДанных.Вставить("СообщениеОбОшибках", СообщениеОбОшибках);
				КонецПопытки;
			КонецЕсли;		
			
		КонецЕсли;	
		СтруктураДанных[СтруктураДанных.ИмяПриемникаДанных].Вставить(Правило.ИмяПриемника, ЗначениеРеквизитаДляЗагрузки);

		Если ТаблицаMS <> Неопределено Тогда			
			Если НЕ Найти(ВРег(СокрЛП(ТаблицаMS[0].КолонкиТаблицыЗначений)), ВРег(СокрЛП(Правило.ИмяПриемника))) Тогда
				ТаблицаMS[0].КолонкиТаблицыЗначений = ТаблицаMS[0].КолонкиТаблицыЗначений + "," + Правило.ИмяПриемника;
			КонецЕсли;
			ИсточникДанных.Вставить(Правило.ИмяПриемника, ЗначениеРеквизитаДляЗагрузки);
		КонецЕсли;
		  		
	КонецЦикла;
	
	Если СтруктураДанных.Свойство("СтрокаНастройкиТЧ") И СтруктураДанных.СтрокаНастройкиТЧ.Свойство("СопоставлятьСОсновнойТЧ") И СтруктураДанных.СтрокаНастройкиТЧ.СопоставлятьСОсновнойТЧ = Истина Тогда
		ИмяОсновнойТЧ = ?(СтруктураДанных.Свойство("ИмяОсновнойТЧ"),СтруктураДанных.ИмяОсновнойТЧ,Неопределено);
		Если ЗначениеЗаполнено(ИмяОсновнойТЧ) Тогда
			Отбор = Новый Структура();
			Отбор.Вставить("Таблица1СПриемник", СтруктураДанных.МетаданныеПриемника.Имя);
			Отбор.Вставить("ИндексСтрокиMS", СтруктураДанных.ИндексСтрокиMS);
			
			СтрокиТЧ = СтруктураДанных.ДанныеДляЗагрузкиПоКлючам.НайтиСтроки(Отбор);
			Если СтрокиТЧ.Количество() > 0  Тогда
				СтрокаТЧ = СтрокиТЧ[0];
				СтрокаОсновнойТЧ = СтруктураДанных.ДокументДляЗаписи[ИмяОсновнойТЧ].Получить(СтрокаТЧ.ИндексСтроки1С);
				Попытка
					СтруктураДанных[СтруктураДанных.ИмяПриемникаДанных].Вставить(ИмяКлючаСвязи,СтрокаОсновнойТЧ[ИмяКлючаСвязи]);
				Исключение
					// Если в БП забыли указать ключ связи в подчиненной ТЧ, то можно попытаться попытаться заполнить связь по названию реквизита основной ТЧ
					Если СтруктураДанных.Свойство("НазваниеРеквизитаКлюча") 
						И ЗначениеЗаполнено(СтруктураДанных.НазваниеРеквизитаКлюча) 
						И ИмяКлючаСвязи <> СтруктураДанных.НазваниеРеквизитаКлюча Тогда
						
						ИмяКлючаСвязи = СтруктураДанных.НазваниеРеквизитаКлюча;
						Попытка
							СтруктураДанных[СтруктураДанных.ИмяПриемникаДанных].Вставить(ИмяКлючаСвязи,СтрокаОсновнойТЧ[ИмяКлючаСвязи]);
						Исключение
						КонецПопытки;
						
					КонецЕсли;
				КонецПопытки;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

Процедура ГлЯдро_ЗаполнитьДанныеДляЗагрузкиПроизвольнымиЗначениями(СтруктураДанных)
	
	Если ТипЗнч(СтруктураДанных.ПравилаЗагрузки) <> Тип("Массив") ИЛИ СтруктураДанных.ПравилаЗагрузки.Количество() <= 1 Тогда
		Возврат;
	КонецЕсли;
	
	Если СтруктураДанных.Свойство("ОтобранныеПравилаДляЗагрузкиПроизвольнымиЗначениями") Тогда
		ОтобранныеПравила = СтруктураДанных.ОтобранныеПравилаДляЗагрузкиПроизвольнымиЗначениями;	
	Иначе	
		ОтобранныеПравила = ГлЯдро_СкопироватьМассив(СтруктураДанных.ПравилаЗагрузки,Новый Структура("Загружать,ТипИсточника",Истина,"ПроизвольноеЗначение"));
	КонецЕсли;
	
	Для Каждого Правило Из ОтобранныеПравила Цикл
		ЗначениеРеквизитаДляЗагрузки = "";
		Если ЗначениеЗаполнено(Правило.ИмяПриемника) И ЗначениеЗаполнено(Правило.ЗначениеИсточника) Тогда
			Попытка
				ЗначениеРеквизитаДляЗагрузки = Правило.ЗначениеИсточника;
			Исключение	
				СообщениеОбОшибках = СтруктураДанных.СообщениеОбОшибках + Символы.ВК + "Не удалось произвольное значение для реквизита [" + Правило.ИмяПриемника + "]";
				СтруктураДанных.Вставить("СообщениеОбОшибках", СообщениеОбОшибках);
			КонецПопытки;
			СтруктураДанных[СтруктураДанных.ИмяПриемникаДанных].Вставить(Правило.ИмяПриемника, ЗначениеРеквизитаДляЗагрузки);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

Процедура ГлЯдро_ЗаполнитьДанныеДляЗагрузкиГлобальнымиПараметрами(СтруктураДанных)
	
	Если ТипЗнч(СтруктураДанных.ПравилаЗагрузки) <> Тип("Массив") ИЛИ СтруктураДанных.ПравилаЗагрузки.Количество() <= 1 Тогда
		Возврат;
	КонецЕсли;
	
	Если СтруктураДанных.Свойство("ОтобранныеПравилаДляЗагрузкиГлобальнымиПараметрами") Тогда
		ОтобранныеПравила = СтруктураДанных.ОтобранныеПравилаДляЗагрузкиГлобальнымиПараметрами;
	Иначе
		ОтобранныеПравила = ГлЯдро_СкопироватьМассив(СтруктураДанных.ПравилаЗагрузки,Новый Структура("Загружать,ТипИсточника",Истина,"ГлобальныйПараметр"));
	КонецЕсли;
	
	Для Каждого Правило Из ОтобранныеПравила Цикл
		ЗначениеРеквизитаДляЗагрузки = "";
		Если ЗначениеЗаполнено(Правило.ИмяИсточника) И ЗначениеЗаполнено(Правило.ИмяПриемника) Тогда
			Если ТипЗнч(СтруктураДанных.ЗначенияПараметров) = Тип("ТаблицаЗначений") Тогда
				НайденныйГП = СтруктураДанных.ЗначенияПараметров.Найти(Правило.ИмяИсточника);
			Иначе
				МассивГП = ГлЯдро_СкопироватьМассив(СтруктураДанных.ЗначенияПараметров, Новый Структура("ID_Параметра",Правило.ИмяИсточника));
				Если ЗначениеЗаполнено(МассивГП) И МассивГП.Количество() > 0 Тогда
					НайденныйГП = МассивГП[0];
				Иначе
					НайденныйГП = Неопределено;
				КонецЕсли;
			КонецЕсли;
			
			Если НайденныйГП <> Неопределено Тогда
				ЗначениеРеквизитаДляЗагрузки = НайденныйГП.Значение;
			Иначе
				СообщениеОбОшибках = СтруктураДанных.СообщениеОбОшибках + Символы.ВК + "Не удалось получить значение глобального параметра [" + Правило.СинонимИсточника + "]";
				СтруктураДанных.Вставить("СообщениеОбОшибках", СообщениеОбОшибках);
			КонецЕсли;
			СтруктураДанных[СтруктураДанных.ИмяПриемникаДанных].Вставить(Правило.ИмяПриемника, ЗначениеРеквизитаДляЗагрузки);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

Процедура ГлЯдро_ЗаполнитьДанныеДляЗагрузкиПроизвольнымиКодами(СтруктураДанных,АдресаПеременных)
	
	Если ТипЗнч(СтруктураДанных.ПравилаЗагрузки) <> Тип("Массив") ИЛИ СтруктураДанных.ПравилаЗагрузки.Количество() <= 1 Тогда
		Возврат;
	КонецЕсли;
	
	СтруктураИО = КомЯдро_ПолучитьЗначениеПеременной("ИнтеграционнаяОбработка",АдресаПеременных);
		
	Если (НЕ СтруктураИО = Неопределено
		И ТипЗнч(СтруктураИО) = Тип("Структура")
		И СтруктураИО.Свойство("ИнтеграционнаяОбработка")) Тогда
		Если СтруктураИО.ИнтеграционнаяОбработка = Неопределено Тогда
			ГлЯдро_ПересоздатьИнтеграционнуюОбработку(АдресаПеременных);
			СтруктураИО = КомЯдро_ПолучитьЗначениеПеременной("ИнтеграционнаяОбработка",АдресаПеременных);
		КонецЕсли;
		ИнтеграционнаяОбработка = СтруктураИО.ИнтеграционнаяОбработка;
	Иначе	
		ИнтеграционнаяОбработка = Неопределено;
	КонецЕсли;
	
	СтруктураПеременных = Новый Структура;
	СтруктураПеременных.Вставить("ОбъектДокумент1С", СтруктураДанных.ДокументДляЗаписи);
	СтруктураПеременных.Вставить("СсылкаДокументОснование1С", СтруктураДанных.ДокументОснование);
	СтруктураПеременных.Вставить("ДанныеДляЗагрузки_Шапка", СтруктураДанных.ДанныеДляЗагрузки_Шапка);
	СтруктураПеременных.Вставить("ДокументТСД", СтруктураДанных.ДанныеДокументаMS);
	СтруктураПеременных.Вставить("МодульОбработки", ИнтеграционнаяОбработка);
	Если СтруктураДанных.ИмяПриемникаДанных = "ДанныеДляЗагрузки_Строка" Тогда
		СтруктураПеременных.Вставить("ДанныеДляЗагрузки_Строка", СтруктураДанных.ДанныеДляЗагрузки_Строка);
		СтруктураПеременных.Вставить("СтрокаТабличнойЧастиДокументаТСД", СтруктураДанных.ТаблицаMS[СтруктураДанных.ИндексСтрокиMS]);
		СтруктураПеременных.Вставить("СтрокаНастройкиТЧ", СтруктураДанных.СтрокаНастройкиТЧ);
	КонецЕсли;
	
	Если СтруктураДанных.ИмяПриемникаДанных = "ДанныеДляЗагрузки_Шапка" Тогда
		ПроизвольныеКоды = СтруктураДанных.ПроизвольныеКодыШапки;
	ИначеЕсли СтруктураДанных.ИмяПриемникаДанных = "ДанныеДляЗагрузки_Строка" Тогда
		ПроизвольныеКоды = СтруктураДанных.ПроизвольныеКодыТабличнойЧасти;
	КонецЕсли;
	
	Если СтруктураДанных.Свойство("ОтобранныеПравилаДляЗагрузкиПроизвольнымиКодами") Тогда
		ОтобранныеПравила = СтруктураДанных.ОтобранныеПравилаДляЗагрузкиПроизвольнымиКодами;
	Иначе
		ОтобранныеПравила = ГлЯдро_СкопироватьМассив(СтруктураДанных.ПравилаЗагрузки,Новый Структура("Загружать,ТипИсточника",Истина,"ПроизвольныйКод"));
	КонецЕсли;
	
	Для Каждого Правило Из ОтобранныеПравила Цикл
		ЗначениеРеквизитаДляЗагрузки = "";
		// Временное решение. ИмяИсточника начинает хранить ID кода только после перевыбора его в форме сопоставления полей загрузки
		ID_ПроизвольногоКода = ?(ЗначениеЗаполнено(Правило.ИмяИсточника), Правило.ИмяИсточника, Правило.ЗначениеИсточника);
		Если ЗначениеЗаполнено(ID_ПроизвольногоКода) И ЗначениеЗаполнено(Правило.ИмяПриемника) Тогда
			Если ТипЗнч(ПроизвольныеКоды) = Тип("ТаблицаЗначений") Тогда
				НайденныйПК = ПроизвольныеКоды.Найти(ID_ПроизвольногоКода);	
			ИначеЕсли ТипЗнч(ПроизвольныеКоды) = Тип("Массив") Тогда
				НайденныйПК = ГлЯдро_СкопироватьМассив(ПроизвольныеКоды,Новый Структура("ID_ПроизвольногоКода",ID_ПроизвольногоКода));
				Если НайденныйПК.Количество()>0 Тогда
					НайденныйПК = НайденныйПК[0];
				Иначе 
					НайденныйПК = Неопределено;
				КонецЕсли;
			Иначе
				Продолжить;
			КонецЕсли;
			Если НайденныйПК <> Неопределено Тогда
				РезультатВыполненияКода = ГлЯдро_ВыполнитьПроизвольныйКод(НайденныйПК.ТекстПроизвольногоКода, СтруктураПеременных,ID_ПроизвольногоКода,НайденныйПК.Наименование,АдресаПеременных);
				Если РезультатВыполненияКода.Статус Тогда
					ЗначениеРеквизитаДляЗагрузки = РезультатВыполненияКода.Данные;
				Иначе
					СообщениеОбОшибках = СтруктураДанных.СообщениеОбОшибках + Символы.ВК + "Не удалось выполнить произвольный код [" + Правило.СинонимИсточника + "]";
					СтруктураДанных.Вставить("СообщениеОбОшибках", СообщениеОбОшибках);
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		СтруктураДанных[СтруктураДанных.ИмяПриемникаДанных].Вставить(Правило.ИмяПриемника, ЗначениеРеквизитаДляЗагрузки);
		СтруктураПеременных[СтруктураДанных.ИмяПриемникаДанных].Вставить(Правило.ИмяПриемника, ЗначениеРеквизитаДляЗагрузки);
	КонецЦикла;
	
КонецПроцедуры

Процедура ГлЯдро_НайтиПодходящуюСтрокуТаблицы1СПоКлючам(СтруктураДанных)
	
	// Если мы дошли до конца таблицы 1С и не нашли подходящую строку либо, если правила поиска отсутствуют, то всегда создаем новую строку 1С
	Если СтруктураДанных.ИндексСтрокиДляПоиска >= СтруктураДанных.Таблица1С.Количество() ИЛИ НЕ СтруктураДанных.ПравилаПоиска.Количество() Тогда
		ЭтоПодходящаяСтрока = Ложь;
	Иначе	
		
		СтрокаДляПроверкиСуществованияРеквизита = СтруктураДанных.Таблица1С[СтруктураДанных.ИндексСтрокиДляПоиска];
		
		ЗначенияПолейПоиска = Новый Структура;
		
		СтруктураПоиска = Новый Структура;
		
		Для каждого СтрокаПравила Из СтруктураДанных.ПравилаПоиска Цикл
			Если СтрокаПравила.Свойство("ЭтоТаблицаЗначений") Тогда
				Продолжить;
			КонецЕсли;
			
			ИмяПриемника = СтрокаПравила.ИмяПриемника;
			ИмяИсточника = СтрокаПравила.ИмяИсточника;
			
			// если в таблице MS нашли колонку с именем приемника, то используем данные из неё, например, "АкцизнаяМарка" вместо "АлкоПДФ"
			// + дополнение: если поле "имя приемника" (например, "Номенклатура" не найдено среди выч.полей, также используем имя приемника, 
			// т.к. возможна ситуация, когда выч.поле "Номенклатура" (источник) - это алкоголь, а "НоменклатураСоответствие" (приемник) - обычная ном-ра				
			ДанныеДляЗагрузки_Строка = СтруктураДанных.ДанныеДляЗагрузки_Строка;
			Если ЗначениеЗаполнено(ИмяПриемника) И ДанныеДляЗагрузки_Строка.Свойство(ИмяПриемника) Тогда
				ЗначениеMSДляСравнения = ДанныеДляЗагрузки_Строка[ИмяПриемника];
			ИначеЕсли ЗначениеЗаполнено(ИмяИсточника) И ДанныеДляЗагрузки_Строка.Свойство(ИмяИсточника) Тогда
			    ЗначениеMSДляСравнения = ДанныеДляЗагрузки_Строка[ИмяИсточника];
			Иначе
			    Продолжить;
			КонецЕсли;						
			
			// Проверяем, есть ли в Таблица1С реквизит ИмяПриемника
			Попытка
				ЗначениеРеквизита = СтрокаДляПроверкиСуществованияРеквизита[ИмяПриемника];
			Исключение
				Продолжить;					
			КонецПопытки;
			
			ЗначениеMSДляСравнения = REST_API_ПреобразованиеЗначенияРеквизитаИсточникаВТип1С(
				ЗначениеMSДляСравнения,
				ЗначениеРеквизита);	
			
			// Фильтруем только по тем полям, где точно не нужно учитывать незаполненное значение
			Если (СтрокаПравила.ПравилоПоиска = "Равно" ИЛИ СтрокаПравила.ПравилоПоиска = "РавноПустоТСД") И ЗначениеЗаполнено(ЗначениеMSДляСравнения) Тогда
				СтруктураПоиска.Вставить(ИмяПриемника, ЗначениеMSДляСравнения);
			КонецЕсли;
			
			ЗначенияПолейПоиска.Вставить(ИмяПриемника, Новый Структура("ПравилоПоиска, ЗначениеMSДляСравнения", СтрокаПравила.ПравилоПоиска, ЗначениеMSДляСравнения));
			
		КонецЦикла;
		
		Если СтруктураПоиска.Количество() Тогда
			НайденныеСтроки = СтруктураДанных.Таблица1С.НайтиСтроки(СтруктураПоиска);
		Иначе
			НайденныеСтроки = СтруктураДанных.Таблица1С;
		КонецЕсли;
		
		ИндексСтрокиДляПоиска = СтруктураДанных.ИндексСтрокиДляПоиска;
		ЭтоПодходящаяСтрока = Ложь;
		
		Для каждого ТекущаяСтрока1С ИЗ НайденныеСтроки Цикл
			
			ТекущийИндекс = Неопределено;
			Если ИндексСтрокиДляПоиска > 0 Тогда 
				ТекущийИндекс = СтруктураДанных.Таблица1С.Индекс(ТекущаяСтрока1С);
				Если ТекущийИндекс < ИндексСтрокиДляПоиска Тогда
					Продолжить;
				КонецЕсли;
			КонецЕсли;
			
			ЭтоПодходящаяСтрока = Истина;
			
			Для каждого ЗначениеПолейПоиска Из ЗначенияПолейПоиска Цикл
				
				СтрокаПравила = ЗначениеПолейПоиска.Значение;
				
				ЗначениеMSДляСравнения = REST_API_ПреобразованиеЗначенияРеквизитаИсточникаВТип1С(
					СтрокаПравила.ЗначениеMSДляСравнения,
					ТекущаяСтрока1С[ЗначениеПолейПоиска.Ключ]);	
					
				// Фильтруем только по тем условиям, которые не были учтены в структуре отбора
				//Если СтрокаПравила.ПравилоПоиска = "Равно" И НЕ ЗначениеЗаполнено(СтрокаПравила.ЗначениеMSДляСравнения) Тогда
				Если СтрокаПравила.ПравилоПоиска = "Равно" И НЕ ЗначениеЗаполнено(ЗначениеMSДляСравнения) Тогда
					Если ЗначениеЗаполнено(ТекущаяСтрока1С[ЗначениеПолейПоиска.Ключ]) Тогда
						ЭтоПодходящаяСтрока = Ложь;
						Прервать;
					КонецЕсли;
				ИначеЕсли СтрокаПравила.ПравилоПоиска = "РавноПусто1С" Тогда
					//Если НЕ (ТекущаяСтрока1С[ЗначениеПолейПоиска.Ключ] = СтрокаПравила.ЗначениеMSДляСравнения 
					Если НЕ (ТекущаяСтрока1С[ЗначениеПолейПоиска.Ключ] = ЗначениеMSДляСравнения 
							ИЛИ НЕ ЗначениеЗаполнено(ТекущаяСтрока1С[ЗначениеПолейПоиска.Ключ])) Тогда
						ЭтоПодходящаяСтрока = Ложь;
						Прервать;
					КонецЕсли;
				КонецЕсли;
				
				Если НЕ ЭтоПодходящаяСтрока Тогда
					Прервать;
				КонецЕсли;
			КонецЦикла;
			
			Если ЭтоПодходящаяСтрока Тогда
				Если ТекущийИндекс = Неопределено Тогда
					ТекущийИндекс = СтруктураДанных.Таблица1С.Индекс(ТекущаяСтрока1С);
				КонецЕсли;
				СтруктураДанных.Вставить("ИндексСтроки1С", ТекущийИндекс);
				СтруктураДанных.Вставить("ЭтоНоваяСтрока1С", Ложь);
				СтруктураДанных.Вставить("ИндексСтрокиДляПоиска", ТекущийИндекс + 1);
				Прервать;
			КонецЕсли;
			
		КонецЦикла;
		
		//Для ТекущийИндекс = СтруктураДанных.ИндексСтрокиДляПоиска По СтруктураДанных.Таблица1С.Количество() - 1 Цикл
		//	
		//	ЭтоПодходящаяСтрока = Истина;
		//	ТекущаяСтрока1С = СтруктураДанных.Таблица1С.Получить(ТекущийИндекс);
		//	
		//	Для Каждого СтрокаПравила Из СтруктураДанных.ПравилаПоиска Цикл
		//		Если СтрокаПравила.Свойство("ЭтоТаблицаЗначений") Тогда
		//			Продолжить;
		//		КонецЕсли;
		//		// если в таблице MS нашли колонку с именем приемника, то используем данные из неё, например, "АкцизнаяМарка" вместо "АлкоПДФ"
		//		// + дополнение: если поле "имя приемника" (например, "Номенклатура" не найдено среди выч.полей, также используем имя приемника, 
		//		// т.к. возможна ситуация, когда выч.поле "Номенклатура" (источник) - это алкоголь, а "НоменклатураСоответствие" (приемник) - обычная ном-ра				
		//		ДанныеДляЗагрузки_Строка = СтруктураДанных.ДанныеДляЗагрузки_Строка;
		//		Если ЗначениеЗаполнено(СтрокаПравила.ИмяПриемника) И ДанныеДляЗагрузки_Строка.Свойство(СтрокаПравила.ИмяПриемника) Тогда
		//			ЗначениеMSДляСравнения = ДанныеДляЗагрузки_Строка[СтрокаПравила.ИмяПриемника];
		//		ИначеЕсли ЗначениеЗаполнено(СтрокаПравила.ИмяИсточника) И ДанныеДляЗагрузки_Строка.Свойство(СтрокаПравила.ИмяИсточника) Тогда
		//		    ЗначениеMSДляСравнения = ДанныеДляЗагрузки_Строка[СтрокаПравила.ИмяИсточника];
		//		Иначе
		//		    Продолжить;
		//		КонецЕсли;
		//		
		//		// Проверяем, есть ли в ТекущаяСтрока1С реквизит СтрокаПравила.ИмяПриемника
		//		Попытка
		//			ЗначениеРеквизита = ТекущаяСтрока1С[СтрокаПравила.ИмяПриемника];
		//		Исключение
		//			Продолжить;					
		//		КонецПопытки;
		//		
		//		Если СтрокаПравила.ПравилоПоиска = "Равно" Тогда
		//			Если НЕ (ТекущаяСтрока1С[СтрокаПравила.ИмяПриемника] = ЗначениеMSДляСравнения 
		//					ИЛИ (НЕ ЗначениеЗаполнено(ТекущаяСтрока1С[СтрокаПравила.ИмяПриемника]) И НЕ ЗначениеЗаполнено(ЗначениеMSДляСравнения))) Тогда
		//				ЭтоПодходящаяСтрока = Ложь;
		//				Прервать;
		//			КонецЕсли;
		//		ИначеЕсли СтрокаПравила.ПравилоПоиска = "РавноПусто1С" Тогда
		//			Если НЕ (ТекущаяСтрока1С[СтрокаПравила.ИмяПриемника] = ЗначениеMSДляСравнения 
		//					ИЛИ НЕ ЗначениеЗаполнено(ТекущаяСтрока1С[СтрокаПравила.ИмяПриемника])) Тогда
		//				ЭтоПодходящаяСтрока = Ложь;
		//				Прервать;
		//			КонецЕсли;
		//		ИначеЕсли СтрокаПравила.ПравилоПоиска = "РавноПустоТСД" Тогда
		//			Если НЕ (ТекущаяСтрока1С[СтрокаПравила.ИмяПриемника] = ЗначениеMSДляСравнения 
		//					ИЛИ НЕ ЗначениеЗаполнено(ЗначениеMSДляСравнения)) Тогда
		//				ЭтоПодходящаяСтрока = Ложь;
		//				Прервать;
		//			КонецЕсли;
		//		КонецЕсли;
		//		
		//		Если НЕ ЭтоПодходящаяСтрока Тогда
		//			Прервать;
		//		КонецЕсли;
		//	КонецЦикла;
		//	
		//	Если ЭтоПодходящаяСтрока Тогда
		//		СтруктураДанных.Вставить("ИндексСтроки1С", ТекущийИндекс);
		//		СтруктураДанных.Вставить("ЭтоНоваяСтрока1С", Ложь);
		//		СтруктураДанных.Вставить("ИндексСтрокиДляПоиска", ТекущийИндекс + 1);
		//		Прервать;
		//	КонецЕсли;
		//	
		//КонецЦикла;
		
	КонецЕсли;
	
	Если НЕ ЭтоПодходящаяСтрока Тогда
		НоваяСтрока = СтруктураДанных.Таблица1С.Добавить();
		СтруктураДанных.Вставить("ИндексСтроки1С", СтруктураДанных.Таблица1С.Индекс(НоваяСтрока));
		СтруктураДанных.Вставить("ЭтоНоваяСтрока1С", Истина);
		СтруктураДанных.Вставить("ИндексСтрокиДляПоиска", 0);
	КонецЕсли;
	
КонецПроцедуры

Процедура ГлЯдро_ЗаполнитьАгрегатноеЗначение(СтруктураДанных)
	
	Если СтруктураДанных.Агрегирование_ЭтоКлючСвязи Тогда
		// 1. Поиск подходящего ключа в 1С
		
		// 2. Поиск подходящих строк в Таблице товаров MS
		
		// 3. Замена ключей
	Иначе
		// Проверка наличия реквизита в строке табличной части
		Попытка
			Если СтруктураДанных.Свойство("МетаданныеПриемника") И СтруктураДанных.МетаданныеПриемника.Реквизиты.Найти(СтруктураДанных.Агрегирование_Колонка1С) = Неопределено Тогда
				Возврат;
			КонецЕсли;
		Исключение КонецПопытки;
		
		Если ТипЗнч(СтруктураДанных.СтрокаДокумента1С[СтруктураДанных.Агрегирование_Колонка1С]) = Тип("Число")
			И ТипЗнч(СтруктураДанных.ДанныеДляЗагрузки_Строка[СтруктураДанных.Агрегирование_Колонка1С]) = Тип("Число") Тогда
			Агрегат = СтруктураДанных.СтрокаДокумента1С[СтруктураДанных.Агрегирование_Колонка1С] + СтруктураДанных.ДанныеДляЗагрузки_Строка[СтруктураДанных.Агрегирование_Колонка1С];
			СтруктураДанных.СтрокаДокумента1С[СтруктураДанных.Агрегирование_Колонка1С] = Агрегат;
		ИначеЕсли ТипЗнч(СтруктураДанных.СтрокаДокумента1С[СтруктураДанных.Агрегирование_Колонка1С]) = Тип("Строка")
			И ТипЗнч(СтруктураДанных.ДанныеДляЗагрузки_Строка[СтруктураДанных.Агрегирование_Колонка1С]) = Тип("Строка") Тогда
			Разделитель = ?(ЗначениеЗаполнено(СтруктураДанных.СтрокаДокумента1С[СтруктураДанных.Агрегирование_Колонка1С]), ", ", "");
			Агрегат = СтруктураДанных.СтрокаДокумента1С[СтруктураДанных.Агрегирование_Колонка1С] + Разделитель + СтруктураДанных.ДанныеДляЗагрузки_Строка[СтруктураДанных.Агрегирование_Колонка1С];
			СтруктураДанных.СтрокаДокумента1С[СтруктураДанных.Агрегирование_Колонка1С] = Агрегат;
		ИначеЕсли ТипЗнч(СтруктураДанных.СтрокаДокумента1С[СтруктураДанных.Агрегирование_Колонка1С]) = Тип("Булево")
			И ТипЗнч(СтруктураДанных.ДанныеДляЗагрузки_Строка[СтруктураДанных.Агрегирование_Колонка1С]) = Тип("Булево") Тогда			
			Агрегат = СтруктураДанных.ДанныеДляЗагрузки_Строка[СтруктураДанных.Агрегирование_Колонка1С];
			СтруктураДанных.СтрокаДокумента1С[СтруктураДанных.Агрегирование_Колонка1С] = Агрегат;			
		Иначе
			// если поле непримитивного типа, то просто заменяем его значение в строке 1С на значение, полученное из MS
			Агрегат = СтруктураДанных.ДанныеДляЗагрузки_Строка[СтруктураДанных.Агрегирование_Колонка1С];
			СтруктураДанных.СтрокаДокумента1С[СтруктураДанных.Агрегирование_Колонка1С] = Агрегат;			 
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

// Выполнение обработчика выгрузки бизнес-процесса
//
// Параметры:
//  ИмяОбработчика		 	- Строка 	- имя поля обработчика выгрузки (например, "ПередВыгрузкойДокумента", "ПослеВыгрузкиСтрокиТабличнойЧасти")
//  СтруктураПеременных	 	- Структура - обязательные поля в структуре:
//		* ДанныеДокумента 			- Структура 				- готовые данные документа для выгрузки в Mobile Smarts. Обязательные поля в структуре:
//				- ШапкаДокумента 		- Структура - содержит данные шапки выгружаемого документа
//				- ТабличныеЧасти 		- Структура - содержит данные табличных частей выгружаемого документа
//		* СсылкаДокумент1С 			- ДокументСсылка 			- документ в базе, выгружаемый на сервер Mobile Smarts
//		* НастройкаБП 				- Структура            		- Содержит настройку бизнес-процесса.
//		* ДанныеНастроекИзКэша 		- Неопределено, Структура	- содержит:
//				- СписокБизнесПроцессов - Неопределено, ТаблицаЗначений, Массив из Структура - содержит настройки отобранных бизнес-процессов
//				- ПроизвольныеКодыШапки - Неопределено, ТаблицаЗначений, Массив из Структура - содержит произвольные коды для выгрузки шапки документа
//				- ПроизвольныеКодыТабличнойЧасти - Неопределено, ТаблицаЗначений, Массив из Структура - содержит произвольные коды для выгрузки табличных частей документа
//				- ГлобальныеПараметры - Неопределено, ТаблицаЗначений, Массив из Структура - содержит значения глобальных параметров
//		* ИнтеграционнаяОбработка 	- ОбработкаОбъект 			- подключенная интеграционная обработка
//      * ИмяПриемникаДанных 		- Строка 					- содержит признак выгрузки строки или шапки ("ДанныеДляВыгрузки_Шапка", "ДанныеДляВыгрузки_Строка")
//      * ТЧ 						- ТаблицаЗначений 			- содержит данные выгружаемой табличной части документа 1С
//      * СтрокаДокумента 			- Структура 				- данные выгружаемой строки документа 1С
//  АдресаПеременных 		- Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
//
Процедура ГлЯдро_ВыполнитьОбработчикВыгрузкиДокумента1С(ИмяОбработчика, СтруктураПеременных, АдресаПеременных)
	
	НачалоСобытия = ТекущаяУниверсальнаяДатаВМиллисекундах();
	ИмяСобытия = "ГлЯдро_ВыполнитьОбработчикВыгрузкиДокумента1С";	
	
	ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Начало, Выполнение обработчика выгрузки документа 1С: " + Строка(ИмяОбработчика), , АдресаПеременных);	
	
	СтрокаНастройки 		= СтруктураПеременных.НастройкаБП;
	
	// Если настройки бизнес-процесса давно не обновлялись и данного свойства нет, пропускаем выполнение обработчика
	Если ТипЗнч(СтрокаНастройки) = Тип("Структура") И Не СтрокаНастройки.Свойство(ИмяОбработчика) Тогда
		Возврат;
	КонецЕсли;
	
	ОбработчикВыгрузки 		= СтрокаНастройки[ИмяОбработчика];
	ИнтеграционнаяОбработка = СтруктураПеременных.ИнтеграционнаяОбработка;
	Документ1С 				= СтруктураПеременных.СсылкаДокумент1С;
	ДанныеНастроекИзКэша 	= СтруктураПеременных.ДанныеНастроекИзКэша;
	ДанныеДокумента			= СтруктураПеременных.ДанныеДокумента;
		
	Если ЗначениеЗаполнено(ОбработчикВыгрузки) Тогда		
		
		// Проверяем, является ли обработчик выгрузки произвольным кодом
		ПроизвольныеКоды = Неопределено;
		Если СтруктураПеременных.ИмяПриемникаДанных = "ДанныеДляВыгрузки_Шапка" Тогда 
			Если ДанныеНастроекИзКэша <> Неопределено И ДанныеНастроекИзКэша.Свойство("ПроизвольныеКодыОбработчикаВыгрузки") Тогда
				ПроизвольныеКоды = ДанныеНастроекИзКэша.ПроизвольныеКодыОбработчикаВыгрузки;
			Иначе     
				ПроизвольныеКоды = Неопределено;
			КонецЕсли;
		ИначеЕсли СтруктураПеременных.ИмяПриемникаДанных = "ДанныеДляВыгрузки_Строка" Тогда
			Если СтруктураПеременных.СтрокаДокумента = Неопределено Тогда				
				Если ДанныеНастроекИзКэша <> Неопределено И ДанныеНастроекИзКэша.Свойство("ПроизвольныеКодыОбработчикаТЧ") Тогда
					ПроизвольныеКоды = ДанныеНастроекИзКэша.ПроизвольныеКодыОбработчикаТЧ;
				Иначе     
					ПроизвольныеКоды = Неопределено;
				КонецЕсли;
			Иначе                   
				Если ДанныеНастроекИзКэша <> Неопределено И ДанныеНастроекИзКэша.Свойство("ПроизвольныеКодыОбработчикаСтрокиТЧ") Тогда
					ПроизвольныеКоды = ДанныеНастроекИзКэша.ПроизвольныеКодыОбработчикаСтрокиТЧ;
				Иначе     
					ПроизвольныеКоды = Неопределено;
				КонецЕсли;				
			КонецЕсли;
		КонецЕсли;
		
		Если ТипЗнч(ПроизвольныеКоды) = Тип("ТаблицаЗначений") Тогда
			НайденныйПК = ПроизвольныеКоды.Найти(ОбработчикВыгрузки);	
		ИначеЕсли ТипЗнч(ПроизвольныеКоды) = Тип("Массив") Тогда
			НайденныйПК = ГлЯдро_НайтиСтруктуруВМассивеПоЭлементу(ПроизвольныеКоды, "ID_ПроизвольногоКода", ОбработчикВыгрузки);			
		Иначе
			НайденныйПК = Неопределено;
		КонецЕсли;
		
		ЗначенияПараметров = Неопределено;
		Если ДанныеНастроекИзКэша = Неопределено
			ИЛИ НЕ ДанныеНастроекИзКэша.Свойство("ЗначенияПараметров")
			ИЛИ ТипЗнч(ДанныеНастроекИзКэша.ЗначенияПараметров) <> Тип("Массив") Тогда
			ЗначенияПараметров = ГлЯдро_ПолучитьЗначенияГлобальныхПараметров(,,, АдресаПеременных);
		Иначе
			ЗначенияПараметров = ДанныеНастроекИзКэша.ЗначенияПараметров;
		КонецЕсли;
		
		ТекущиеНастройкиMS = КомЯдро_ПолучитьЗначениеПеременной("ТекущиеНастройкиMS", АдресаПеременных);		
		
		Если Не НайденныйПК = Неопределено Тогда
			
			СтруктураПараметров = Новый Структура;
			СтруктураПараметров.Вставить("ДанныеДокумента", 			ДанныеДокумента);
			СтруктураПараметров.Вставить("СсылкаДокумент1С", 			Документ1С);
			СтруктураПараметров.Вставить("СтрокаНастройки", 			СтрокаНастройки);
			СтруктураПараметров.Вставить("МодульОбработки", 			ИнтеграционнаяОбработка);
			СтруктураПараметров.Вставить("АдресаПеременных", 			АдресаПеременных);								
			СтруктураПараметров.Вставить("КритическаяОшибка", 			Ложь);								
			СтруктураПараметров.Вставить("КритическаяОшибкаОписание", 	"");								
						
			Если СтруктураПеременных.ИмяПриемникаДанных = "ДанныеДляВыгрузки_Шапка" Тогда
			
				СтруктураПараметров.Вставить("ТекущиеНастройкиMS", 	ТекущиеНастройкиMS);
				СтруктураПараметров.Вставить("ЗначенияПараметров",	ЗначенияПараметров);
			
			ИначеЕсли СтруктураПеременных.ИмяПриемникаДанных = "ДанныеДляВыгрузки_Строка" Тогда
				
				Если СтруктураПеременных.СтрокаДокумента = Неопределено Тогда
					
					Если ТипЗнч(СтрокаНастройки) = Тип("Структура") И СтрокаНастройки.Свойство("НастройкаТЧСтрокой") 
						Или ТипЗнч(СтрокаНастройки) = Тип("СтрокаТаблицыЗначений") Тогда
						СтруктураПараметров.Вставить("ИмяТабличнойЧасти", 	СтрокаНастройки.НастройкаТЧСтрокой);
					КонецЕсли;
					СтруктураПараметров.Вставить("ТЧ", 						СтруктураПеременных.ТЧ);                        					
					СтруктураПараметров.Вставить("ТекущиеНастройкиMS", 		ТекущиеНастройкиMS);
					СтруктураПараметров.Вставить("ЗначенияПараметров",	    ЗначенияПараметров);
					
				Иначе
					
					Если ТипЗнч(СтрокаНастройки) = Тип("Структура") И СтрокаНастройки.Свойство("НастройкаТЧСтрокой") 
						Или ТипЗнч(СтрокаНастройки) = Тип("СтрокаТаблицыЗначений") Тогда
						СтруктураПараметров.Вставить("ИмяТабличнойЧасти", 	СтрокаНастройки.НастройкаТЧСтрокой);
					КонецЕсли;
					СтруктураПараметров.Вставить("ТЧ", 						СтруктураПеременных.ТЧ);                        					
					СтруктураПараметров.Вставить("СтрокаДокумента", 		СтруктураПеременных.СтрокаДокумента);		
					СтруктураПараметров.Вставить("ТекущиеНастройкиMS", 		ТекущиеНастройкиMS);
					СтруктураПараметров.Вставить("ЗначенияПараметров",		ЗначенияПараметров);
					
				КонецЕсли;
				
			Иначе
				
				СтруктураПараметров.Вставить("ДанныеНастроекИзКэша", 		ДанныеНастроекИзКэша);			
				
			КонецЕсли;	
			
			РезультатВыполненияКода = ГлЯдро_ВыполнитьПроизвольныйКод(
				НайденныйПК.ТекстПроизвольногоКода, 					
				СтруктураПараметров,
				НайденныйПК.ID_ПроизвольногоКода,
				НайденныйПК.Наименование,
				АдресаПеременных);				
					
			Если НЕ РезультатВыполненияКода.Статус Тогда
				Сообщить("Ошибка! Не удалось выполнить произвольный код <" + НайденныйПК.Наименование + ">");
			КонецЕсли;
						
			Если СтруктураПараметров.КритическаяОшибка Тогда
				
				Если Не ПустаяСтрока(СтруктураПараметров.КритическаяОшибкаОписание) Тогда
					КритическаяОшибкаОписание = СтруктураПараметров.КритическаяОшибкаОписание;	
				Иначе	
					КритическаяОшибкаОписание = "(Пусто)";
				КонецЕсли;
				
				ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(
					"ГлЯдро_ВыполнитьОбработчикВыгрузкиДокумента1С", 
					"Ошибка", 
					"Критическая ошибка при выполнении произвольного кода <" + НайденныйПК.Наименование + ">. Причина: " + КритическаяОшибкаОписание,
					, 
					АдресаПеременных);
					
				ТекстОшибки = "Критическая ошибка при выполнении обработчика <" + НайденныйПК.Наименование + ">. Причина: " + КритическаяОшибкаОписание;
				
				Если ДанныеДокумента.Свойство("СообщениеОбОшибках") И ДанныеДокумента.СообщениеОбОшибках <> "" Тогда
					ТекстОшибки = ДанныеДокумента.СообщениеОбОшибках + "
						|" + ТекстОшибки;
				КонецЕсли;
				
				ДанныеДокумента.Вставить("СообщениеОбОшибках",	ТекстОшибки);
				ДанныеДокумента.Вставить("КритическаяОшибка",	Истина);
				
			КонецЕсли;
			
		Иначе
			
			СтруктураПараметров = Новый Структура;
			СтруктураПараметров.Вставить("Документ1С", 					Документ1С);
			Если ТипЗнч(СтрокаНастройки) = Тип("Структура") И СтрокаНастройки.Свойство("НастройкаТЧСтрокой") 
				Или ТипЗнч(СтрокаНастройки) = Тип("СтрокаТаблицыЗначений") Тогда
				СтруктураПараметров.Вставить("ИмяТабличнойЧасти", 		СтрокаНастройки.НастройкаТЧСтрокой);				
			КонецЕсли;						
			СтруктураПараметров.Вставить("ТЧ", 							СтруктураПеременных.ТЧ);
			СтруктураПараметров.Вставить("СтрокаДокумента", 			СтруктураПеременных.СтрокаДокумента);			
			СтруктураПараметров.Вставить("СтрокаНастройки", 			СтрокаНастройки);
			СтруктураПараметров.Вставить("ТекущиеНастройкиMS", 			ТекущиеНастройкиMS);
			СтруктураПараметров.Вставить("ЗначенияПараметров",			ЗначенияПараметров);
			СтруктураПараметров.Вставить("АдресаПеременных", 			АдресаПеременных);								
			СтруктураПараметров.Вставить("КритическаяОшибка", 			Ложь);								
			СтруктураПараметров.Вставить("КритическаяОшибкаОписание", 	"");								
			
			Попытка
				//Выполнить ("ИнтеграционнаяОбработка." + ОбработчикВыгрузки
				//+ "(ДанныеДокумента, СтруктураПараметров)");
				СтрокаВызова = "ИнтеграционнаяОбработка." + ОбработчикВыгрузки + "(ДанныеДокумента, СтруктураПараметров)";
				СтрокаВызова = СтрЗаменить(СтрокаВызова, "ИнтеграционнаяОбработка", "Параметры.ИнтеграционнаяОбработка");
				СтрокаВызова = СтрЗаменить(СтрокаВызова, "ДанныеДокумента", "Параметры.ДанныеДокумента");
				СтрокаВызова = СтрЗаменить(СтрокаВызова, "СтруктураПараметров", "Параметры.СтруктураПараметров");
				ПараметрыАлгоритма = Новый Структура;
				ПараметрыАлгоритма.Вставить("ИнтеграционнаяОбработка", ИнтеграционнаяОбработка);
				ПараметрыАлгоритма.Вставить("ДанныеДокумента", ДанныеДокумента);
				ПараметрыАлгоритма.Вставить("СтруктураПараметров", СтруктураПараметров);
				ГлЯдро_ВыполнитьВБезопасномРежиме(СтрокаВызова, ПараметрыАлгоритма, АдресаПеременных);
			Исключение
				ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
				ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(
					"ГлЯдро_ВыполнитьОбработчикВыгрузкиДокумента1С", 
					"Ошибка", 
					"Не удалось выполнить обработчик <" + ОбработчикВыгрузки + ">. Причина: " + ТекстОшибки,
					, 
					АдресаПеременных);
			КонецПопытки;			
			
			Если СтруктураПараметров.КритическаяОшибка Тогда
				
				Если Не ПустаяСтрока(СтруктураПараметров.КритическаяОшибкаОписание) Тогда
					КритическаяОшибкаОписание = СтруктураПараметров.КритическаяОшибкаОписание;	
				Иначе	
					КритическаяОшибкаОписание = "(Пусто)";
				КонецЕсли;
				
				ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(
					"ГлЯдро_ВыполнитьОбработчикВыгрузкиДокумента1С", 
					"Ошибка", 
					"Критическая ошибка при выполнении обработчика <" + ОбработчикВыгрузки + ">. Причина: " + КритическаяОшибкаОписание,
					, 
					АдресаПеременных);
					
				ТекстОшибки = "Критическая ошибка при выполнении обработчика <" + ОбработчикВыгрузки + ">. Причина: " + КритическаяОшибкаОписание;
				
				Если ДанныеДокумента.Свойство("СообщениеОбОшибках") И ДанныеДокумента.СообщениеОбОшибках <> "" Тогда
					ТекстОшибки = ДанныеДокумента.СообщениеОбОшибках + "
						|" + ТекстОшибки;
				КонецЕсли;
				
				ДанныеДокумента.Вставить("СообщениеОбОшибках",	ТекстОшибки);
				ДанныеДокумента.Вставить("КритическаяОшибка",	Истина);
				
			КонецЕсли;
						
		КонецЕсли;	
		
	КонецЕсли;
	
	ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(
		ИмяСобытия, 
		"Информация", 
		"Конец, Выполнение обработчика загрузки документа 1С: " + Строка(ИмяОбработчика), 
		НачалоСобытия, 
		АдресаПеременных);
		
КонецПроцедуры

#КонецОбласти

#Область ГлобальныйКонтекст_Документы_1С_ВспомогательныеМеханизмы

// Получает имя типа документа по ссылке на документ
//
// Параметры:
//	СсылкаДокумента - ДокументСсылка, Массив из ДокументСсылка - ссылка или массив ссылок на документы, тип которых необходимо получить		
//
// Возвращаемое значение:
//	Строка	
Функция ГлЯдро_ПолучитьТипДокументаПоСсылке(СсылкаДокумента) Экспорт
	
	Если ТипЗнч(СсылкаДокумента) = Тип("Массив") Тогда
		Возврат СсылкаДокумента[0].Метаданные().Имя;
	Иначе		
		Возврат СсылкаДокумента.Метаданные().Имя;
	КонецЕсли;
	
КонецФункции

// Формирует схему компоновки данных, которая будет использована для отбора документов 1С
//
// Параметры:
//	ИмяДокумента - Строка - имя типа документа 1С, для которого требуется сформировать схему компоновки данных 
//  ПараметрыУзлов - Массив из Структура - содержит значения глобальных параметров для текущего узла в сессии Mobile Smarts
//  ОтборПоПериоду - Структура - содержит значения начала и конца периода отбора по дате (глобальный параметр для всех бизнес-процессов)
//  АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
//
// Возвращаемое значение:
//	СхемаКомпоновкиДанных
Функция ГлЯдро_ПолучитьКомпоновкуСКДДляОтбораДокументов1С(ИмяДокумента, ПараметрыУзлов, ОтборПоПериоду, АдресаПеременных) Экспорт
	
	ИмяТабличнойЧастиДокумента = ГлЯдро_ПолучитьИмяТабличнойЧастиДокумента(ИмяДокумента,АдресаПеременных);
	
	СхемаСКД = Новый СхемаКомпоновкиДанных;
	
	ИсточникСКД = СхемаСКД.ИсточникиДанных.Добавить();
	ИсточникСКД.Имя = "ТекущаяБаза";
	ИсточникСКД.СтрокаСоединения = "";
	ИсточникСКД.ТипИсточникаДанных = "Local";
	                                        
	ДанныеСКД = СхемаСКД.НаборыДанных.Добавить(Тип("НаборДанныхЗапросСхемыКомпоновкиДанных"));
	ДанныеСКД.Имя = "ЗапросСКД";
	ДанныеСКД.ИсточникДанных = ИсточникСКД.Имя;
	ДанныеСКД.АвтоЗаполнениеДоступныхПолей = Истина;
	
	Если ИмяТабличнойЧастиДокумента <> Неопределено Тогда
		// Во временную таблицу выбираем данные по ТЧ
		ДанныеСКД.Запрос = 
		"ВЫБРАТЬ РАЗРЕШЕННЫЕ
		|	ТабличнаяЧасть.Ссылка,
		|	МАКСИМУМ(ТабличнаяЧасть.НомерСтроки) КАК Количество
		|ПОМЕСТИТЬ втТабличнаяЧасть
		|ИЗ
		|	Документ.ИмяДокумента.ИмяТабличнойЧастиДокумента КАК ТабличнаяЧасть
		|ГДЕ
		|	НАЧАЛОПЕРИОДА(ТабличнаяЧасть.Ссылка.Дата, ДЕНЬ) >= ДОБАВИТЬКДАТЕ(НАЧАЛОПЕРИОДА(&ТекущаяДата, ДЕНЬ), ДЕНЬ, -&ГлубинаОтбора)
		|	// #СравнениеНачалоПериодаТЧ
		|	// #СравнениеОкончаниеПериодаТЧ
		|	И ВЫБОР
		|			КОГДА (ВЫРАЗИТЬ(&КомментарийОтсечения КАК СТРОКА(200))) = """"
		|				ТОГДА ИСТИНА
		|			ИНАЧЕ НЕ ВЫРАЗИТЬ(ТабличнаяЧасть.Ссылка.Комментарий КАК СТРОКА(200)) ПОДОБНО &СимволПроцента + &КомментарийОтсечения + &СимволПроцента
		|		КОНЕЦ
		|
		|СГРУППИРОВАТЬ ПО
		|	ТабличнаяЧасть.Ссылка
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|ВЫБРАТЬ РАЗРЕШЕННЫЕ //%ПЕРВЫЕ_N%
		|	ШапкаДокумента.*,
		|	%НомерДокумента,%
		|	ЕСТЬNULL(втТабличнаяЧасть.Количество, 0) КАК Количество
		|ИЗ
		|	Документ.ИмяДокумента КАК ШапкаДокумента
		|		ЛЕВОЕ СОЕДИНЕНИЕ втТабличнаяЧасть КАК втТабличнаяЧасть
		|		ПО ШапкаДокумента.Ссылка = втТабличнаяЧасть.Ссылка		
		|ГДЕ
		|	НАЧАЛОПЕРИОДА(ШапкаДокумента.Дата, ДЕНЬ) >= ДОБАВИТЬКДАТЕ(НАЧАЛОПЕРИОДА(&ТекущаяДата, ДЕНЬ), ДЕНЬ, -&ГлубинаОтбора)
		|	// #СравнениеНачалоПериодаШапка
		|	// #СравнениеОкончаниеПериодаШапка
		|	И ВЫБОР
		|			КОГДА ВЫРАЗИТЬ(&КомментарийОтсечения КАК СТРОКА(200)) = """"
		|				ТОГДА ИСТИНА
		|			ИНАЧЕ НЕ ВЫРАЗИТЬ(ШапкаДокумента.Комментарий КАК СТРОКА(200)) ПОДОБНО &СимволПроцента + &КомментарийОтсечения + &СимволПроцента
		|		КОНЕЦ";
		
		ДанныеСКД.Запрос = СтрЗаменить(ДанныеСКД.Запрос, "ИмяТабличнойЧастиДокумента", ИмяТабличнойЧастиДокумента);

	Иначе 
		ДанныеСКД.Запрос = 
		"ВЫБРАТЬ РАЗРЕШЕННЫЕ //%ПЕРВЫЕ_N%
		|	ШапкаДокумента.*,
		|	%НомерДокумента,%		
		|	0 КАК Количество
		|ИЗ
		|	Документ.ИмяДокумента КАК ШапкаДокумента
		|ГДЕ
		|	НАЧАЛОПЕРИОДА(ШапкаДокумента.Дата, ДЕНЬ) >= ДОБАВИТЬКДАТЕ(НАЧАЛОПЕРИОДА(&ТекущаяДата, ДЕНЬ), ДЕНЬ, -&ГлубинаОтбора)
		|	// #СравнениеНачалоПериодаШапка
		|	// #СравнениеОкончаниеПериодаШапка
		|	И ВЫБОР
		|			КОГДА ВЫРАЗИТЬ(&КомментарийОтсечения КАК СТРОКА(200)) = """"
		|				ТОГДА ИСТИНА
		|			ИНАЧЕ НЕ ВЫРАЗИТЬ(ШапкаДокумента.Комментарий КАК СТРОКА(200)) ПОДОБНО &СимволПроцента + &КомментарийОтсечения + &СимволПроцента
		|		КОНЕЦ";
	КонецЕсли;
	
	ДанныеСКД.Запрос = СтрЗаменить(ДанныеСКД.Запрос, "ИмяДокумента", ИмяДокумента);
	Если ОтборПоПериоду.ДатаНачала <> Дата(1, 1, 1) Тогда                          
		ДанныеСКД.Запрос = СтрЗаменить(ДанныеСКД.Запрос, "// #СравнениеНачалоПериодаШапка", "И НАЧАЛОПЕРИОДА(ШапкаДокумента.Дата, ДЕНЬ) >= НАЧАЛОПЕРИОДА(&НачалоПериодаОтбора, ДЕНЬ)");
		ДанныеСКД.Запрос = СтрЗаменить(ДанныеСКД.Запрос, "// #СравнениеНачалоПериодаТЧ", "И НАЧАЛОПЕРИОДА(ТабличнаяЧасть.Ссылка.Дата, ДЕНЬ) >= НАЧАЛОПЕРИОДА(&НачалоПериодаОтбора, ДЕНЬ)");
	КонецЕсли;
	Если ОтборПоПериоду.ДатаОкончания <> Дата(1, 1, 1) Тогда                          
		ДанныеСКД.Запрос = СтрЗаменить(ДанныеСКД.Запрос, "// #СравнениеОкончаниеПериодаШапка", "И НАЧАЛОПЕРИОДА(ШапкаДокумента.Дата, ДЕНЬ) <= НАЧАЛОПЕРИОДА(&КонецПериодаОтбора, ДЕНЬ)");
		ДанныеСКД.Запрос = СтрЗаменить(ДанныеСКД.Запрос, "// #СравнениеОкончаниеПериодаТЧ", "И НАЧАЛОПЕРИОДА(ТабличнаяЧасть.Ссылка.Дата, ДЕНЬ) <= НАЧАЛОПЕРИОДА(&КонецПериодаОтбора, ДЕНЬ)");
	КонецЕсли;
	
	СтруктураМетаданных = КомЯдро_ПолучитьЗначениеПеременной("СтруктураМетаданных",АдресаПеременных);
	
	// У некоторых документов может отсутствовать номер, например, "УпаковочныйЛист" в УТ 11
	Если СтруктураМетаданных.Документы1С[ИмяДокумента].Реквизиты.НайтиПоЗначению("Номер") <> Неопределено Тогда
		ДанныеСКД.Запрос = СтрЗаменить(ДанныеСКД.Запрос, "%НомерДокумента,%", "");
	Иначе	
		ДанныеСКД.Запрос = СтрЗаменить(ДанныеСКД.Запрос, "%НомерДокумента,%", """"" КАК Номер,");
	КонецЕсли;	
	
	ПолеИтога = СхемаСКД.ПоляИтога.Добавить();
	ПолеИтога.Выражение = "Максимум(Количество)";
	ПолеИтога.ПутьКДанным = "Количество";
	
	КомпоновщикСКД = Новый КомпоновщикНастроекКомпоновкиДанных;
	КомпоновщикСКД.Инициализировать(Новый ИсточникДоступныхНастроекКомпоновкиДанных(СхемаСКД));
	
	// Предопределенные параметры запроса
	Для Каждого ПараметрКомпоновщика Из КомпоновщикСКД.Настройки.ПараметрыДанных.ДоступныеПараметры.Элементы Цикл
		ПараметрСхемыКомпоновкиДанных = СхемаСКД.Параметры.Добавить();
		ЗаполнитьЗначенияСвойств(ПараметрСхемыКомпоновкиДанных, ПараметрКомпоновщика);
		ПараметрСхемыКомпоновкиДанных.ВключатьВДоступныеПоля   = Ложь;
		ПараметрСхемыКомпоновкиДанных.Имя                      = Строка(ПараметрКомпоновщика.Параметр);
		Если Строка(ПараметрКомпоновщика.Параметр) = "ТекущаяДата" Тогда
			ПараметрСхемыКомпоновкиДанных.ОграничениеИспользования = Истина;
			ПараметрСхемыКомпоновкиДанных.Значение = ТекущаяДата();
		КонецЕсли;
		Если Строка(ПараметрКомпоновщика.Параметр) = "ГлубинаОтбора" Тогда
			ПараметрСхемыКомпоновкиДанных.Значение = 0;
		КонецЕсли;
		Если Строка(ПараметрКомпоновщика.Параметр) = "НачалоПериодаОтбора" Тогда
			ПараметрСхемыКомпоновкиДанных.Значение = ОтборПоПериоду.ДатаНачала;
		КонецЕсли;
		Если Строка(ПараметрКомпоновщика.Параметр) = "КонецПериодаОтбора" Тогда
			ПараметрСхемыКомпоновкиДанных.Значение = ОтборПоПериоду.ДатаОкончания;
		КонецЕсли;
		Если Строка(ПараметрКомпоновщика.Параметр) = "СимволПроцента" Тогда
			ПараметрСхемыКомпоновкиДанных.Значение = "%";
			ПараметрСхемыКомпоновкиДанных.ОграничениеИспользования = Истина;
		КонецЕсли;			
		ПараметрСхемыКомпоновкиДанных.Использование = ИспользованиеПараметраКомпоновкиДанных.Всегда;
	КонецЦикла;
	
	// Определяемые общие параметры
	Если НЕ ПараметрыУзлов = Ложь Тогда
		Для Каждого ПараметрУзла Из ПараметрыУзлов Цикл
			ПараметрСхемыКомпоновкиДанных = СхемаСКД.Параметры.Добавить();
			ПараметрСхемыКомпоновкиДанных.Имя                      = ПараметрУзла.ID_Параметра;
			ПараметрСхемыКомпоновкиДанных.Заголовок                = СокрЛП(ПараметрУзла.Наименование);
			ПараметрСхемыКомпоновкиДанных.ВключатьВДоступныеПоля   = Истина;
			ПараметрСхемыКомпоновкиДанных.ОграничениеИспользования = Истина;
			ПараметрСхемыКомпоновкиДанных.Использование            = ИспользованиеПараметраКомпоновкиДанных.Авто;
			ПараметрСхемыКомпоновкиДанных.ТипЗначения.Типы().Добавить(ТипЗнч(ПараметрУзла.Значение));
			ПараметрСхемыКомпоновкиДанных.Значение                 = ПараметрУзла.Значение;
		КонецЦикла;
	КонецЕсли;
	
	Возврат СхемаСКД;
	
КонецФункции

// Формирует схему компоновки данных для последующей проверки попадания в отбор ссылки документа
//
// Параметры:
//	ИмяДокумента - Строка - имя типа документа, переданного в параметре ДокументСсылка
//  ПараметрыУзлов - Массив из Структура - содержит значения глобальных параметров для текущего узла в сессии Mobile Smarts
//  ДокументСсылка - ДокументСсылка - ссылка на документ, попадание в отбор которого необходимо проверить
//  АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
//
// Возвращаемое значение:
//	СхемаКомпоновкиДанных
Функция ГлЯдро_ПолучитьКомпоновкуСКДДляПроверкиСсылки(ИмяДокумента, ПараметрыУзлов,ДокументСсылка,АдресаПеременных) Экспорт		
	
	СхемаСКД = Новый СхемаКомпоновкиДанных;
	
	ИсточникСКД = СхемаСКД.ИсточникиДанных.Добавить();
	ИсточникСКД.Имя = "ТекущаяБаза";
	ИсточникСКД.СтрокаСоединения = "";
	ИсточникСКД.ТипИсточникаДанных = "Local";
	                                        
	ДанныеСКД = СхемаСКД.НаборыДанных.Добавить(Тип("НаборДанныхЗапросСхемыКомпоновкиДанных"));
	ДанныеСКД.Имя = "ЗапросСКД";
	ДанныеСКД.ИсточникДанных = ИсточникСКД.Имя;
	ДанныеСКД.АвтоЗаполнениеДоступныхПолей = Истина;
	
	 
	ДанныеСКД.Запрос = 
	"ВЫБРАТЬ
	|	ШапкаДокумента.*,	
	|ИЗ
	|	Документ.ИмяДокумента КАК ШапкаДокумента
	|ГДЕ
	|	ШапкаДокумента.Ссылка = &Ссылка";	
	
	ДанныеСКД.Запрос = СтрЗаменить(ДанныеСКД.Запрос, "ИмяДокумента", ИмяДокумента);
	
	СтруктураМетаданных = КомЯдро_ПолучитьЗначениеПеременной("СтруктураМетаданных",АдресаПеременных);			
	 	
	КомпоновщикСКД = Новый КомпоновщикНастроекКомпоновкиДанных;
	КомпоновщикСКД.Инициализировать(Новый ИсточникДоступныхНастроекКомпоновкиДанных(СхемаСКД));
	
	// Предопределенные параметры запроса
	Для Каждого ПараметрКомпоновщика Из КомпоновщикСКД.Настройки.ПараметрыДанных.ДоступныеПараметры.Элементы Цикл
		ПараметрСхемыКомпоновкиДанных = СхемаСКД.Параметры.Добавить();
		ЗаполнитьЗначенияСвойств(ПараметрСхемыКомпоновкиДанных, ПараметрКомпоновщика);
		ПараметрСхемыКомпоновкиДанных.ВключатьВДоступныеПоля   = Ложь;
		ПараметрСхемыКомпоновкиДанных.Имя                      = Строка(ПараметрКомпоновщика.Параметр);
		Если Строка(ПараметрКомпоновщика.Параметр) = "Ссылка" Тогда
			ПараметрСхемыКомпоновкиДанных.ОграничениеИспользования = Истина;
			ПараметрСхемыКомпоновкиДанных.Значение = ДокументСсылка;
		КонецЕсли;
		ПараметрСхемыКомпоновкиДанных.Использование = ИспользованиеПараметраКомпоновкиДанных.Всегда;
	КонецЦикла;
	
	// Определяемые общие параметры
	Если НЕ ПараметрыУзлов = Ложь Тогда
		Для Каждого ПараметрУзла Из ПараметрыУзлов Цикл
			ПараметрСхемыКомпоновкиДанных = СхемаСКД.Параметры.Добавить();
			ПараметрСхемыКомпоновкиДанных.Имя                      = ПараметрУзла.ID_Параметра;
			ПараметрСхемыКомпоновкиДанных.Заголовок                = СокрЛП(ПараметрУзла.Наименование);
			ПараметрСхемыКомпоновкиДанных.ВключатьВДоступныеПоля   = Истина;
			ПараметрСхемыКомпоновкиДанных.ОграничениеИспользования = Истина;
			ПараметрСхемыКомпоновкиДанных.Использование            = ИспользованиеПараметраКомпоновкиДанных.Авто;
			ПараметрСхемыКомпоновкиДанных.ТипЗначения.Типы().Добавить(ТипЗнч(ПараметрУзла.Значение));
			ПараметрСхемыКомпоновкиДанных.Значение                 = ПараметрУзла.Значение;
		КонецЦикла;
	КонецЕсли;
	
	Возврат СхемаСКД;
	
КонецФункции

// Вызывает функцию формирования схемы компоновки данных, устанавливает для нее настройки и возвращает результат компоновки данных
//
// Параметры:
//	НастройкиКомпоновкиСтр 	- Строка, НастройкиКомпоновкиДанных - настройки компоновки для схемы компоновки данных, используемой для отбора документов 1С
//	ТипДокумента1С 			- Строка 							- имя типа документа 1С, экземпляры которого требуется отобрать (тип исходного документа 1С в настройке бизнес-процесса)
//	НазваниеБП 				- Строка 							- наименование бизнес-процесса, по настройкам которого выполняется отбор
//	ПараметрыУзлов 			- Массив из Структура 				- содержит значения глобальных параметров для текущего узла в сессии Mobile Smarts
//	ОтборПоПериоду          - Структура							- содержит дату начала и дату окончания периода отбора (глобальный отбор для всех бизнес-процессов)
//	РазмерВыборки 			- Строка 							- если отличен от нуля, ограничивать выборку этим числом документов
//	СписокПолей 			- СписокЗначений 					- содержит имена реквизитов и служебных полей документа, которые требуется получить
//  АдресаПеременных 		- Структура 						- см. КомЯдро_СоздатьСтруктуруАдресаПеременных
//
// Возвращаемое значение: 
//	- Массив из Структура 	- содержит значения реквизитов и служебные поля (например, количество строк в табличной части) документов, попавших в результат отбора
//  - ТаблицаЗначений 		- пустая таблица значений в случае, если отбор документов выполнить не удалось
Функция ГлЯдро_ОтобратьДокументы1СЧерезСКД(НастройкиКомпоновкиСтр, ТипДокумента1С, НазваниеБП, ПараметрыУзлов, ОтборПоПериоду = Неопределено, РазмерВыборки = Неопределено, СписокПолей = Неопределено, АдресаПеременных) Экспорт		
	
	Если ТипЗнч(НастройкиКомпоновкиСтр) = Тип("Строка") Тогда
		НастройкиКомпоновки = ГлЯдро_ЗначениеИзСтрокиXML(НастройкиКомпоновкиСтр);
	Иначе
		НастройкиКомпоновки = НастройкиКомпоновкиСтр;
	КонецЕсли;                                                                                   
	
	ОтборПериодПоУмолчанию = Новый Структура("ДатаНачала,ДатаОкончания", Дата(1, 1, 1), Дата(1, 1, 1));
	
	СхемаСКД = ГлЯдро_ПолучитьКомпоновкуСКДДляОтбораДокументов1С(ТипДокумента1С, ПараметрыУзлов, ?(ОтборПоПериоду = Неопределено, ОтборПериодПоУмолчанию, ОтборПоПериоду), АдресаПеременных);
	
	// Доработки СКД для автотестирования
	АвтотестКлеверенс = КомЯдро_ПолучитьЗначениеПеременной("Автотест",АдресаПеременных);
	Если АвтотестКлеверенс = Неопределено Тогда
		АвтотестКлеверенс = Ложь;
	КонецЕсли;
	
	Если АвтотестКлеверенс Тогда
		// Выбор только одного документа
		Для Каждого НаборДанных Из СхемаСКД.НаборыДанных Цикл		
			Если ТипЗнч(НаборДанных) = Тип("НаборДанныхЗапросСхемыКомпоновкиДанных") Тогда
				
				Запрос = НаборДанных.Запрос;
				// Проверка на отсутствие конструкции "ВЫБРАТЬ ПЕРВЫЕ"
				Если ГлЯдро_СтрНайти(Запрос, "ВЫБРАТЬ ПЕРВЫЕ") = 0 Тогда
					НаборДанных.Запрос = СтрЗаменить(Запрос, "ВЫБРАТЬ", "ВЫБРАТЬ ПЕРВЫЕ 1");
				КонецЕсли;
				
				//Добавление упорядочивания для выбора последнего документа
				НомерСимвола = ГлЯдро_СтрНайти(НаборДанных.Запрос, "УПОРЯДОЧИТЬ");
				//Удалим из текста запроса упорядочивание
				Если НомерСимвола > 0 Тогда
					НаборДанных.Запрос = Лев(НаборДанных.Запрос, НомерСимвола - 1);
				КонецЕсли;
				НаборДанных.Запрос = НаборДанных.Запрос + " УПОРЯДОЧИТЬ По ШапкаДокумента.Дата УБЫВ";
			КонецЕсли;		
		КонецЦикла;
		
		// Установка глубины отбора, чтобы документы наверняка попали в выборку
		ГлубинаОтбораДляАвтотеста = 5000;
		УсловиеГлубинаОтбора = НастройкиКомпоновки.ПараметрыДанных.Элементы.Найти("ГлубинаОтбора");
		Если УсловиеГлубинаОтбора <> Неопределено Тогда
			УсловиеГлубинаОтбора.Значение = ГлубинаОтбораДляАвтотеста;
		КонецЕсли;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(РазмерВыборки) Тогда
		// Ограничиваем выборку переданным количеством
		Для Каждого НаборДанных Из СхемаСКД.НаборыДанных Цикл		
			Если ТипЗнч(НаборДанных) = Тип("НаборДанныхЗапросСхемыКомпоновкиДанных") Тогда
				
				Запрос = НаборДанных.Запрос;
				НаборДанных.Запрос = СтрЗаменить(НаборДанных.Запрос, "//%ПЕРВЫЕ_N%", " ПЕРВЫЕ " + РазмерВыборки);
				
				//Добавление упорядочивания по дате, если оно отсутствует
				//НомерСимвола = ГлЯдро_СтрНайти(НаборДанных.Запрос, "УПОРЯДОЧИТЬ");
				//Если НомерСимвола = 0 Тогда
				//	НаборДанных.Запрос = НаборДанных.Запрос + " УПОРЯДОЧИТЬ ПО ШапкаДокумента.Дата";
				//КонецЕсли;                                                                               			
			КонецЕсли;		
		КонецЦикла;				
	КонецЕсли;	
	
	КомпоновщикНастроек = Новый КомпоновщикНастроекКомпоновкиДанных;
	КомпоновщикНастроек.Инициализировать(Новый ИсточникДоступныхНастроекКомпоновкиДанных(СхемаСКД));
	КомпоновщикНастроек.ЗагрузитьНастройки(НастройкиКомпоновки);
	РезультатНастройкиКомпоновки = КомпоновщикНастроек.ПолучитьНастройки();
	
	РезультатНастройкиКомпоновки.ПараметрыВывода.УстановитьЗначениеПараметра("ВертикальноеРасположениеОбщихИтогов", РасположениеИтоговКомпоновкиДанных.Нет);	
	
	Если СписокПолей  <> Неопределено 
		И СписокПолей.Количество() > 0 Тогда
		
		Если СписокПолей.НайтиПоЗначению("Ссылка") = Неопределено Тогда // Временное решение
			СписокПолей.Добавить("Ссылка", "Ссылка");
		КонецЕсли;
		
		Для Каждого Поле Из СписокПолей Цикл
			ВыбранноеПоле = РезультатНастройкиКомпоновки.Выбор.Элементы.Добавить(Тип("ВыбранноеПолеКомпоновкиДанных"));
			ВыбранноеПоле.Заголовок = Поле.Представление;
			ВыбранноеПоле.Использование = Истина;
			ВыбранноеПоле.Поле = Новый ПолеКомпоновкиДанных(Поле.Значение);	
		КонецЦикла;
		
		ГруппировкаДокументов = РезультатНастройкиКомпоновки.Структура.Добавить(Тип("ГруппировкаКомпоновкиДанных"));
		Для Каждого Поле Из СписокПолей Цикл
			Если Поле.Значение = "Количество" Тогда
				Продолжить;
			КонецЕсли;
			ПолеГруппировки = ГруппировкаДокументов.ПоляГруппировки.Элементы.Добавить(Тип("ПолеГруппировкиКомпоновкиДанных"));    
			ПолеГруппировки.Использование = Истина;
			ПолеГруппировки.Поле = Новый ПолеКомпоновкиДанных(Поле.Значение);	
		КонецЦикла;
		
	Иначе
		ВыбранноеПоле = РезультатНастройкиКомпоновки.Выбор.Элементы.Добавить(Тип("ВыбранноеПолеКомпоновкиДанных"));
		ВыбранноеПоле.Заголовок = "Ссылка";
		ВыбранноеПоле.Использование = Истина;
		ВыбранноеПоле.Поле = Новый ПолеКомпоновкиДанных("Ссылка");
		ВыбранноеПоле = РезультатНастройкиКомпоновки.Выбор.Элементы.Добавить(Тип("ВыбранноеПолеКомпоновкиДанных"));
		ВыбранноеПоле.Заголовок = "Дата";
		ВыбранноеПоле.Использование = Истина;
		ВыбранноеПоле.Поле = Новый ПолеКомпоновкиДанных("Дата");
		ВыбранноеПоле = РезультатНастройкиКомпоновки.Выбор.Элементы.Добавить(Тип("ВыбранноеПолеКомпоновкиДанных"));
		ВыбранноеПоле.Заголовок = "Номер";
		ВыбранноеПоле.Использование = Истина;		
		ВыбранноеПоле.Поле = Новый ПолеКомпоновкиДанных("Номер");
		ВыбранноеПоле = РезультатНастройкиКомпоновки.Выбор.Элементы.Добавить(Тип("ВыбранноеПолеКомпоновкиДанных"));
		ВыбранноеПоле.Заголовок = "Количество";
		ВыбранноеПоле.Использование = Истина;
		ВыбранноеПоле.Поле = Новый ПолеКомпоновкиДанных("Количество");	
		
		ГруппировкаДокументов = РезультатНастройкиКомпоновки.Структура.Добавить(Тип("ГруппировкаКомпоновкиДанных"));
		ПолеГруппировки = ГруппировкаДокументов.ПоляГруппировки.Элементы.Добавить(Тип("ПолеГруппировкиКомпоновкиДанных"));    
		ПолеГруппировки.Использование = Истина;
		ПолеГруппировки.Поле = Новый ПолеКомпоновкиДанных("Ссылка");
		ПолеГруппировки = ГруппировкаДокументов.ПоляГруппировки.Элементы.Добавить(Тип("ПолеГруппировкиКомпоновкиДанных"));    
		ПолеГруппировки.Использование = Истина;
		ПолеГруппировки.Поле = Новый ПолеКомпоновкиДанных("Дата");
		ПолеГруппировки = ГруппировкаДокументов.ПоляГруппировки.Элементы.Добавить(Тип("ПолеГруппировкиКомпоновкиДанных"));    
		ПолеГруппировки.Использование = Истина;
		ПолеГруппировки.Поле = Новый ПолеКомпоновкиДанных("Номер");
	КонецЕсли;
	
	// Добавление упорядочивания по дате, если оно отсутствует
	ЕстьСортировкаПоДате = Ложь;
	Если РезультатНастройкиКомпоновки.Порядок.Элементы.Количество() <> 0 Тогда	
		Для Каждого ЭлементПорядка Из РезультатНастройкиКомпоновки.Порядок.Элементы Цикл
			Если ТипЗнч(ЭлементПорядка) <> Тип("ЭлементПорядкаКомпоновкиДанных") ИЛИ ЭлементПорядка.Использование = Ложь Тогда
				Продолжить;
			КонецЕсли;		
		
			Если ЭлементПорядка.Поле = Новый ПолеКомпоновкиДанных("Дата") Тогда
				ЕстьСортировкаПоДате = Истина;
				Прервать;				
			КонецЕсли;
		КонецЦикла;		
	КонецЕсли;
	Если НЕ ЕстьСортировкаПоДате Тогда
		НовыйЭлементПорядка = РезультатНастройкиКомпоновки.Порядок.Элементы.Добавить(Тип("ЭлементПорядкаКомпоновкиДанных"));
		НовыйЭлементПорядка.Поле 			= Новый ПолеКомпоновкиДанных("Дата");
		НовыйЭлементПорядка.Использование	= Истина;
	КонецЕсли;
	
	//Сортировка
	Если РезультатНастройкиКомпоновки.Порядок.Элементы.Количество() <> 0 Тогда
		Для Каждого ЭлементПорядка Из РезультатНастройкиКомпоновки.Порядок.Элементы Цикл
			Если ЭлементПорядка.Использование = Ложь Тогда
				Продолжить;
			КонецЕсли;
			Если ТипЗнч(ЭлементПорядка) = Тип("АвтоЭлементПорядкаКомпоновкиДанных") Тогда
				// Добавление автосортировки в группировку
				ЭлементПорядка = ГруппировкаДокументов.Порядок.Элементы.Добавить(Тип("АвтоЭлементПорядкаКомпоновкиДанных"));
			Иначе
				// Поиск поля "Ссылка" в группировке
				СсылкаДобавленаВГруппировку 	= Ложь;
				Для Каждого ЭлементГруппировки Из ГруппировкаДокументов.ПоляГруппировки.Элементы Цикл				
					Если ТипЗнч(ЭлементГруппировки) = Тип("АвтоПолеГруппировкиКомпоновкиДанных") Тогда
						Продолжить;
					Иначе
						Если ЭлементГруппировки.Поле = Новый ПолеКомпоновкиДанных("Ссылка") Тогда
							СсылкаДобавленаВГруппировку = Истина;
						КонецЕсли;
					КонецЕсли;
				КонецЦикла;
				// Заполняем поля порядка группироки, только если есть поле "Ссылка". Иначе есть вероятность добавить поле, которого нет группировке,
				// из-за этого выполнение скд может упасть в ошибку.
				Если СсылкаДобавленаВГруппировку Тогда				
					// Добавление элемента порядка в группировку
					// Добавлять будем не само поле, а поле, полученное из ссылки
					ПолеПорядкаСсылка = ГруппировкаДокументов.Порядок.ДоступныеПоляПорядка.НайтиПоле(Новый ПолеКомпоновкиДанных("Ссылка"));
					Если ПолеПорядкаСсылка <> Неопределено Тогда
						// Пытаемся найти у ссылки реквизит с именем поля сортировки
						ПолеПорядкаИзСсылки = ПолеПорядкаСсылка.Элементы.Найти("Ссылка." + Строка(ЭлементПорядка.Поле));
						Если ПолеПорядкаИзСсылки <> Неопределено Тогда
							// Если у ссылки есть реквизит с именем поля сортировки, то добавляем его в поля сортировки группировки
							ЭлементПорядкаГруппировки = ГруппировкаДокументов.Порядок.Элементы.Добавить(Тип("ЭлементПорядкаКомпоновкиДанных"));
							ЭлементПорядкаГруппировки.Поле = ПолеПорядкаИзСсылки.Поле;
							ЭлементПорядкаГруппировки.ТипУпорядочивания = ЭлементПорядка.ТипУпорядочивания;
							ПолеДобавленоВГруппировку = Истина;
						Иначе
							// Пытаемся найти поле в доступных полях сортировки (это сделано для сортировки по ресурсам)
							ДоступноеПолеПорядка = ГруппировкаДокументов.Порядок.ДоступныеПоляПорядка.Элементы.Найти(ЭлементПорядка.Поле);
							Если ДоступноеПолеПорядка <> Неопределено Тогда
								ЭлементПорядкаГруппировки = ГруппировкаДокументов.Порядок.Элементы.Добавить(Тип("ЭлементПорядкаКомпоновкиДанных"));
								ЭлементПорядкаГруппировки.Поле = ДоступноеПолеПорядка.Поле;
								ЭлементПорядкаГруппировки.ТипУпорядочивания = ЭлементПорядка.ТипУпорядочивания;
								ПолеДобавленоВГруппировку = Истина;
							КонецЕсли;
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
		Если ГруппировкаДокументов.Порядок.Элементы.Количество() = 0 Тогда
			// Не удалось установить сортировку, добавим автосортировку
			ЭлементПорядка = ГруппировкаДокументов.Порядок.Элементы.Добавить(Тип("АвтоЭлементПорядкаКомпоновкиДанных"));
		КонецЕсли;
	Иначе
		// Добавляем в группировку автосортировку
		ЭлементПорядка = ГруппировкаДокументов.Порядок.Элементы.Добавить(Тип("АвтоЭлементПорядкаКомпоновкиДанных"));
	КонецЕсли;
		
	АвтоПоле = ГруппировкаДокументов.Выбор.Элементы.Добавить(Тип("АвтоВыбранноеПолеКомпоновкиДанных"));
	АвтоПоле.Использование = Истина;	
	
	КомпоновщикМакета = Новый КомпоновщикМакетаКомпоновкиДанных;
	Попытка
		МакетКомпоновки = КомпоновщикМакета.Выполнить(СхемаСКД, РезультатНастройкиКомпоновки,,,Тип("ГенераторМакетаКомпоновкиДанныхДляКоллекцииЗначений"),Ложь);
	Исключение
		ТекстСообщения =  "Отбор """+НазваниеБП+ """ не может быть выполнен, проверьте настройки ручного отбора и сортировки документов.";
		Сообщить(ТекстСообщения);
		
		ИмяСобытия = "ГлЯдро_ОтобратьДокументы1СЧерезСКД";
		
		ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());		
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", ТекстСообщения + " Текст ошибки: " + ТекстОшибки,, АдресаПеременных);
		
		Возврат Новый ТаблицаЗначений;
	КонецПопытки;
	
	// Если в СКД используются группировки и ресурсы, то нужно использовать процессоры компоновки и вывода,
	// иначе выгрузятся просто детальные записи
	ПроцессорКомпоновки = Новый ПроцессорКомпоновкиДанных;
	ПроцессорКомпоновки.Инициализировать(МакетКомпоновки);
	ПроцессорВывода = Новый ПроцессорВыводаРезультатаКомпоновкиДанныхВКоллекциюЗначений;
	
	Попытка
		Результат = ПроцессорВывода.Вывести(ПроцессорКомпоновки);
	Исключение
		ИмяСобытия = "ГлЯдро_ОтобратьДокументы1СЧерезСКД";
		ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", ТекстОшибки, , АдресаПеременных);		
		
		Возврат Новый ТаблицаЗначений;
	КонецПопытки;
	
	Возврат ГлЯдро_ТаблицуЗначенийВМассивСтруктур(Результат);

КонецФункции

// Получает запрос по идентификатору произвольного отбора документов, заполняет его параметры из глобальных параметров, накладывает дополнительный отбор и возвращает результат выполнения.
// При необходимости преобразует результат в массив структур.
//
// Параметры:
//	ID_ПроизвольногоОтбора - Строка - идентификатор произвольного отбора документов	
//  ВернутьМассивСтруктур - Булево - определяет необходимость преобразовать результат в массив структур, если он получен в виде таблицы значений
//	ДопОтбор - Неопределено, Массив из Структура - содержит:
//		* Описание - Строка - левое значение элемента отбора
//		* ВидСравнения - ВидСравненияКомпоновкиДанных - вид сравнения элемента отбора
//		* Значение - Строка, Число, Массив из ДокументСсылка - правое значение элемента отбора
//  ПараметрыУзлов - Массив из Структура - содержит значения глобальных параметров для текущего узла в сессии Mobile Smarts
//	НастройкиКомпоновкиСтр - Строка, НастройкиКомпоновкиДанных - настройки компоновки схемы компоновки данных, используемой для отбора документов 1С
//  АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
//
// Возвращаемое значение:
//	- Массив из Структура - содержит значения реквизитов и служебные поля (например, количество строк в табличной части) документов, попавших в результат отбора,
//							если ВернутьМассивСтруктур = Истина
//  - ТаблицаЗначений - содержит значения реквизитов и служебные поля (например, количество строк в табличной части) документов, попавших в результат отбора,
//    					если ВернутьМассивСтруктур = Ложь
//	- Неопределено - если отобрать документы не удалось
Функция ГлЯдро_ОтобратьДокументы1СЧерезПроизвольныйОтбор(ID_ПроизвольногоОтбора, ВернутьМассивСтруктур, ДопОтбор, ПараметрыУзлов = Неопределено, НастройкиКомпоновкиСтр = Неопределено, АдресаПеременных) Экспорт
	
	НачалоСобытия = ТекущаяУниверсальнаяДатаВМиллисекундах();
	ИмяСобытия = "ГлЯдро_ОтобратьДокументы1СЧерезПроизвольныйОтбор";
	
	ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Начало, Отбор документов 1С через произвольный отбор", , АдресаПеременных);
	
	ПроизвольныеОтборыДокументов = ГлЯдро_ПолучитьИзКэшаНастройкуSMARTS("ПроизвольныеОтборыДокументов",,АдресаПеременных);
	
	Если ТипЗнч(ПроизвольныеОтборыДокументов) = Тип("ТаблицаЗначений") Тогда
		ПроизвольныеОтборыДокументов = ГлЯдро_ТаблицуЗначенийВМассивСтруктур(ПроизвольныеОтборыДокументов);
	КонецЕсли;
	
	Если ТипЗнч(ПроизвольныеОтборыДокументов) <> Тип("Массив") Тогда 	
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Конец, Отбор документов 1С через произвольный отбор", НачалоСобытия, АдресаПеременных);
		Возврат Неопределено;
	КонецЕсли;	
	
	НайденнаяСтрока = Неопределено;
	Для каждого Строка Из ПроизвольныеОтборыДокументов Цикл
		Если НЕ Строка.Свойство("ID_ПроизвольногоОтбора")
			ИЛИ Строка.ID_ПроизвольногоОтбора <> ID_ПроизвольногоОтбора Тогда
			Продолжить;
		КонецЕсли;
		НайденнаяСтрока = Строка;
		Прервать;
	КонецЦикла;
	
	Если НайденнаяСтрока = Неопределено Тогда
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Конец, Отбор документов 1С через произвольный отбор", НачалоСобытия, АдресаПеременных);
		Возврат Неопределено;
	КонецЕсли; 							
	
	ТекстПроизвольногоОтбора = СтрЗаменить(НайденнаяСтрока.ТекстПроизвольногоОтбора, Символы.ВК, "");
	ТекстПроизвольногоОтбора = СтрЗаменить(ТекстПроизвольногоОтбора, "¶", "");
	
	Результат = Неопределено;
	
	Попытка
		//Выполнить(ТекстПроизвольногоОтбора);
		ПараметрыАлгоритма = Новый Структура;
		ПараметрыАлгоритма.Вставить("Результат", Результат);
		ГлЯдро_ВыполнитьВБезопасномРежиме(СтрЗаменить(ТекстПроизвольногоОтбора, "Результат", "Параметры.Результат"), ПараметрыАлгоритма, АдресаПеременных);
		Результат = ПараметрыАлгоритма.Результат;
	Исключение						
		ИнфоОбОшибке = ИнформацияОбОшибке();
		Сообщить(КраткоеПредставлениеОшибки(ИнфоОбОшибке));
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", ПодробноеПредставлениеОшибки(ИнфоОбОшибке), , АдресаПеременных);		
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Конец, Отбор документов 1С через произвольный отбор", НачалоСобытия, АдресаПеременных);
		Возврат Неопределено;
	КонецПопытки; 
	
	Если ТипЗнч(Результат) <> Тип("Запрос") Тогда
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Конец, Отбор документов 1С через произвольный отбор", НачалоСобытия, АдресаПеременных);
		Возврат Неопределено;
	КонецЕсли; 							
	
	// Предопределенные параметры запроса
	Результат.УстановитьПараметр("ТекущаяДата",   ТекущаяДата());
	Результат.УстановитьПараметр("ГлубинаОтбора", 0);
	Если ТипЗнч(НастройкиКомпоновкиСтр) = Тип("Строка") Тогда
		НастройкиКомпоновки = ГлЯдро_ЗначениеИзСтрокиXML(НастройкиКомпоновкиСтр);
	Иначе
		НастройкиКомпоновки = НастройкиКомпоновкиСтр;
	КонецЕсли;
	Если ТипЗнч(НастройкиКомпоновки) = Тип("НастройкиКомпоновкиДанных") Тогда
		ГлубинаОтбора = НастройкиКомпоновки.ПараметрыДанных.Элементы.Найти("ГлубинаОтбора");
		Если ГлубинаОтбора <> Неопределено Тогда 
			Результат.УстановитьПараметр("ГлубинаОтбора", ГлубинаОтбора.Значение);
		КонецЕсли;
	КонецЕсли;
	
	// Заполнение параметров для произвольного запроса из глобальных параметров
	Если ПараметрыУзлов = Неопределено Тогда
		ПараметрыУзлов = ГлЯдро_ПолучитьЗначенияГлобальныхПараметров(,,,АдресаПеременных);
	КонецЕсли;
	
	Для каждого ПараметрУзла Из ПараметрыУзлов Цикл
		
		ПараметрУзла_Наименование = СтрЗаменить(ПараметрУзла.Наименование, " ", "_");
		ПараметрУзла_Наименование = СтрЗаменить(ПараметрУзла_Наименование, "(", "");
		ПараметрУзла_Наименование = СтрЗаменить(ПараметрУзла_Наименование, ")", "");
		
		Результат.УстановитьПараметр(ПараметрУзла_Наименование,ПараметрУзла.Значение);
	КонецЦикла;	
	
	Если ДопОтбор <> Неопределено и ДопОтбор <> Истина Тогда
		ПЗ = Новый ПостроительЗапроса();
		ПЗ.Текст = Результат.Текст;
		ПЗ.ЗаполнитьНастройки();
		
		Для каждого ПараметрЗапроса Из Результат.Параметры Цикл
			ПЗ.Параметры.Вставить(ПараметрЗапроса.Ключ,ПараметрЗапроса.Значение);
		КонецЦикла;
		 
		Для каждого СтрокаОтбора Из ДопОтбор Цикл
			
			ЗначениеОтбора = СтрокаОтбора.Значение;
			Если (СтрокаОтбора.ВидСравнения = ВидСравнения.ВСписке Или СтрокаОтбора.ВидСравнения = ВидСравнения.ВСпискеПоИерархии)
					И ТипЗнч(ЗначениеОтбора) = Тип("Массив") Тогда
					
				ЗначениеОтбора = Новый СписокЗначений();
				Для Каждого ЭлементМассива Из СтрокаОтбора.Значение Цикл
					ЗначениеОтбора.Добавить(ЭлементМассива);
				КонецЦикла;						
			КонецЕсли;
			
			ЭлементОтбора = ПЗ.Отбор.Добавить(СтрокаОтбора.Описание);
			ЭлементОтбора.ВидСравнения = СтрокаОтбора.ВидСравнения; 
			ЭлементОтбора.Значение = ЗначениеОтбора;
			ЭлементОтбора.Использование = Истина;
		КонецЦикла;
		
		Попытка
			ПЗ.Выполнить();
			ТаблицаЗначений = ПЗ.Результат.Выгрузить();
		Исключение
			ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
			ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", ТекстОшибки, , АдресаПеременных);			
			ТаблицаЗначений = Неопределено;
		КонецПопытки;
	Иначе
		Попытка
			ТаблицаЗначений = Результат.Выполнить().Выгрузить();
		Исключение
			ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
			ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", ТекстОшибки, , АдресаПеременных);			
			ТаблицаЗначений = Неопределено;
		КонецПопытки; 	
	КонецЕсли;
	
	ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Конец, Отбор документов 1С через произвольный отбор", НачалоСобытия, АдресаПеременных);
	
	Если ВернутьМассивСтруктур Тогда
		Возврат ГлЯдро_ТаблицуЗначенийВМассивСтруктур(ТаблицаЗначений);
	Иначе
		Возврат ТаблицаЗначений;
	КонецЕсли;
	
КонецФункции	

// Возвращает флаг попадания ссылки в отбор документов
//
// Параметры:
//	НастройкаОтбора	- Структура - содержит настройку отбора, на попадание в который проверяется документ
//	ДокументСсылка - ДокументСсылка - ссылка на документ, попадание в отбор которого необходимо проверить
//	ПараметрыУзлов - Массив из Структура - содержит значения глобальных параметров для текущего узла в сессии Mobile Smarts
//  АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
//
// Возвращаемое значение:
//	Булево - признак попадания ссылки документа в отбор
Функция ГлЯдро_ПроверитьПопаданиеСсылкиВОтборДокументов(НастройкаОтбора, СсылкаНаДокумент, ПараметрыУзлов, АдресаПеременных) Экспорт
	
	//Результат = Ложь;
	//ТипИсходногоДокумента1С = НастройкаОтбора.ТипИсходногоДокумента1С;
	//Если НастройкаОтбора.ВариантОтбора = "Только конструктор" Тогда
	//	
	//	НастройкиКомпоновки = ЗначениеИзСтрокиВнутр(НастройкаОтбора.НастройкаКомпоновщикаСтрокой);
	//	
	//	СхемаСКД = ГлЯдро_ПолучитьКомпоновкуСКДДляПроверкиСсылки(ТипИсходногоДокумента1С,ПараметрыУзлов,СсылкаНаДокумент,АдресаПеременных);
	//	
	//	КомпоновщикНастроек = Новый КомпоновщикНастроекКомпоновкиДанных;
	//	КомпоновщикНастроек.Инициализировать(Новый ИсточникДоступныхНастроекКомпоновкиДанных(СхемаСКД));
	//	КомпоновщикНастроек.ЗагрузитьНастройки(НастройкиКомпоновки);
	//	РезультатНастройкиКомпоновки = КомпоновщикНастроек.ПолучитьНастройки();
	//	
	//	РезультатНастройкиКомпоновки.ПараметрыВывода.УстановитьЗначениеПараметра("ВертикальноеРасположениеОбщихИтогов", РасположениеИтоговКомпоновкиДанных.Нет);	
	//	
	//	ВыбранноеПоле = РезультатНастройкиКомпоновки.Выбор.Элементы.Добавить(Тип("ВыбранноеПолеКомпоновкиДанных"));
	//	ВыбранноеПоле.Заголовок = "Ссылка";
	//
	//	КомпоновщикМакета = Новый КомпоновщикМакетаКомпоновкиДанных;
	//	МакетКомпоновки = КомпоновщикМакета.Выполнить(СхемаСКД, РезультатНастройкиКомпоновки,,,Тип("ГенераторМакетаКомпоновкиДанныхДляКоллекцииЗначений"),Ложь);
	//			
	//	ПроцессорКомпоновки = Новый ПроцессорКомпоновкиДанных;
	//	ПроцессорКомпоновки.Инициализировать(МакетКомпоновки);
	//	ПроцессорВывода = Новый ПроцессорВыводаРезультатаКомпоновкиДанныхВКоллекциюЗначений;
	//	РезультатЗапроса 	= ПроцессорВывода.Вывести(ПроцессорКомпоновки);
	//КонецЕсли;
	//
	//Возврат Результат;
	
	Если ЗначениеЗаполнено(НастройкаОтбора.НастройкаКомпоновщикаСтрокой) Тогда
		НастройкиКомпоновки = ГлЯдро_ЗначениеИзСтрокиXML(СтрЗаменить(НастройкаОтбора.НастройкаКомпоновщикаСтрокой, Символы.ВК, ""));
	Иначе
		Возврат Ложь;
	КонецЕсли;	
	
	ТаблицаДокументовКонструктора 		  = Неопределено;
	ТаблицаДокументовПроизвольногоЗапроса = Неопределено;
	
	ВариантОтбора = НастройкаОтбора.ВариантОтбора;
	Если ВРег(СокрЛП(ВариантОтбора)) = ВРег(СокрЛП("Только конструктор")) Тогда		
		ТаблицаДокументовКонструктора = ГлЯдро_ОтобратьДокументы1СЧерезСКД(НастройкиКомпоновки, НастройкаОтбора.ТипИсходногоДокумента1С, НастройкаОтбора.Название, ПараметрыУзлов,,,, АдресаПеременных);
	ИначеЕсли ВРег(СокрЛП(ВариантОтбора)) = ВРег(СокрЛП("Только запрос")) Тогда	
		ТаблицаДокументовПроизвольногоЗапроса = ГлЯдро_ОтобратьДокументы1СЧерезПроизвольныйОтбор(НастройкаОтбора.ID_ПроизвольногоОтбора, Истина, Неопределено, ПараметрыУзлов, НастройкиКомпоновки, АдресаПеременных);
	ИначеЕсли ВРег(СокрЛП(ВариантОтбора)) = ВРег(СокрЛП("Конструктор и запрос")) Тогда		
		ТаблицаДокументовКонструктора 		  = ГлЯдро_ОтобратьДокументы1СЧерезСКД(НастройкиКомпоновки, НастройкаОтбора.ТипИсходногоДокумента1С, НастройкаОтбора.Название, ПараметрыУзлов,,,, АдресаПеременных);
		ТаблицаДокументовПроизвольногоЗапроса = ГлЯдро_ОтобратьДокументы1СЧерезПроизвольныйОтбор(НастройкаОтбора.ID_ПроизвольногоОтбора, Истина, Неопределено, ПараметрыУзлов, НастройкиКомпоновки, АдресаПеременных);
	КонецЕсли;
	
	ДокументыОтбора = Новый Массив;
	
	Если ТипЗнч(ТаблицаДокументовКонструктора) = Тип("Массив") Тогда
		Для каждого СтрокаДокумента Из ТаблицаДокументовКонструктора Цикл
			Если СтрокаДокумента.Свойство("ЭтоТаблицаЗначений") Тогда
				Продолжить;
			КонецЕсли;
			ДокументыОтбора.Добавить(СтрокаДокумента);
		КонецЦикла; 
	КонецЕсли;	
		
	Если ТипЗнч(ТаблицаДокументовПроизвольногоЗапроса) = Тип("Массив") Тогда
		Для каждого СтрокаДокумента Из ТаблицаДокументовПроизвольногоЗапроса Цикл
			Если СтрокаДокумента.Свойство("ЭтоТаблицаЗначений") Тогда
				Продолжить;
			КонецЕсли;
			ДокументыОтбора.Добавить(СтрокаДокумента);
		КонецЦикла;
	КонецЕсли;
	
	Возврат ГлЯдро_НайтиПоЗначениюВМассивеСтруктур(ДокументыОтбора, "Ссылка", СсылкаНаДокумент) <> Неопределено;
	
КонецФункции

Функция ГлЯдро_ПолучитьСсылкуНаДокументПоИд(ТипДокумента, ИдДокументаМС)
	
	СсылкаНаДокумент = Неопределено;
	Попытка
		ИдДокументаОснования = ИдДокументаМС;
		Если Найти(ИдДокументаОснования,"#")>0  Тогда
			ИдДокументаОснования = Лев(ИдДокументаОснования, Найти(ИдДокументаОснования,"#")-1 );
		КонецЕсли;
		СсылкаНаДокумент = Документы[ТипДокумента].ПолучитьСсылку(Новый УникальныйИдентификатор(ИдДокументаОснования));				
	Исключение
	КонецПопытки;		
	
	Возврат СсылкаНаДокумент;
КонецФункции

// Возвращает имя табличной части документа, из которой предположительно будет производиться выгрузка на сервер Mobile Smarts
//
// Параметры:
//	ИмяДокумента - Строка - имя типа документа 1С, для которого требуется получить имя табличной части
//  АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
//
// Возвращаемое значение:
//	- Строка
//  - Неопределено
Функция ГлЯдро_ПолучитьИмяТабличнойЧастиДокумента(ИмяДокумента,АдресаПеременных) Экспорт
	
	СтруктураМетаданных = КомЯдро_ПолучитьЗначениеПеременной("СтруктураМетаданных",АдресаПеременных);
	
	ИмяТабличнойЧасти = Неопределено;
	МетаданныеТабличныеЧастиДокумента = СтруктураМетаданных.Документы1С[ИмяДокумента].ТабличныеЧасти;
	
	Если МетаданныеТабличныеЧастиДокумента.Свойство("Товары") Тогда // Сначала попробуем найти самое используемое название в конфигурациях
		ИмяТабличнойЧасти = "Товары";
		
	ИначеЕсли МетаданныеТабличныеЧастиДокумента.Свойство("Состав") Тогда // Используется в Асторе
		ИмяТабличнойЧасти = "Состав";
		
	ИначеЕсли МетаданныеТабличныеЧастиДокумента.Количество() > 0 Тогда // Если среди популярных названий не нашлось, проверим, есть ли вообще ТЧ у документа и вернем первую попавшуюся
		Для Каждого КлючИЗначение Из МетаданныеТабличныеЧастиДокумента Цикл
			ИмяТабличнойЧасти = КлючИЗначение.Ключ;
			Прервать;
		КонецЦикла
	КонецЕсли;
	
	Возврат ИмяТабличнойЧасти;
КонецФункции

Функция ГлЯдро_ПолучитьСсылкуПоШтрихкодуТабличногоДокумента(Штрихкод, Менеджеры = Неопределено)
	
	Результат = Новый Массив;
	Если СокрЛП(Штрихкод) = "" Тогда
		Возврат Результат;
	КонецЕсли;	
	
	// в УНФ в качестве штрихкода сразу приходит уникальный идентификатор
	Попытка			
		
		Идентификатор = Новый УникальныйИдентификатор(Штрихкод);	
		Идентификатор = Штрихкод;
		
	// в УТ 11 и её потомках приходит десятичное число	
	Исключение
		Попытка
			ШтрихкодВШестнаднадцатиричномВиде = ГлЯдро_ПреобразоватьДесятичноеЧислоВШестнадцатиричнуюСистемуСчисления(Число(Штрихкод));
			
			Пока СтрДлина(ШтрихкодВШестнаднадцатиричномВиде) < 32 Цикл
				ШтрихкодВШестнаднадцатиричномВиде = "0" + ШтрихкодВШестнаднадцатиричномВиде;
			КонецЦикла;
			
			Идентификатор =
			Сред(ШтрихкодВШестнаднадцатиричномВиде, 1,  8)
			+ "-" + Сред(ШтрихкодВШестнаднадцатиричномВиде, 9,  4)
			+ "-" + Сред(ШтрихкодВШестнаднадцатиричномВиде, 13, 4)
			+ "-" + Сред(ШтрихкодВШестнаднадцатиричномВиде, 17, 4)
			+ "-" + Сред(ШтрихкодВШестнаднадцатиричномВиде, 21, 12);
		Исключение
		КонецПопытки;
	КонецПопытки; 
		
	Если Менеджеры = Неопределено Тогда
		
		МенеджерыОбъектов = Новый Массив;
		
		Для Каждого ЭлементМетаданных Из Метаданные.Документы Цикл
			МенеджерыОбъектов.Добавить(Документы[ЭлементМетаданных.Имя]);
		КонецЦикла;
		
	Иначе
		
		МенеджерыОбъектов = Новый Массив;
		
		Для Каждого ПустаяСсылка Из Менеджеры Цикл
			
			Если ТипЗнч(ПустаяСсылка) = Тип("Строка") Тогда
				МенеджерыОбъектов.Добавить(Документы[ПустаяСсылка]);
			Иначе
				ТипСсылки = ТипЗнч(ПустаяСсылка);
				
				Если Документы.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
					
					МенеджерыОбъектов.Добавить(Документы[ПустаяСсылка.Метаданные().Имя]);
					
				Иначе
					
					ТекстИсключения = НСтр("ru = 'Ошибка распознавания штрихкода: тип ""%Тип%"" не поддерживается.'");
					ТекстИсключения = СтрЗаменить(ТекстИсключения,"%Тип%",ТипСсылки);
					
					ВызватьИсключение ТекстИсключения;
					
				КонецЕсли;
			КонецЕсли;		
		КонецЦикла;
		
	КонецЕсли;
	
	Запрос = Новый Запрос;
	
	МассивСсылок = Новый СписокЗначений; // Далее используется как правое значение элементов отбора с видом сравнения ВСписке // Новый Массив;
	ПервыйЗапрос = Истина;
	
	Если Идентификатор <> Неопределено
		И СтрДлина(Идентификатор) = 36 Тогда
		Для Каждого Менеджер Из МенеджерыОбъектов Цикл
			
			Попытка
				Ссылка = Менеджер.ПолучитьСсылку(Новый УникальныйИдентификатор(Идентификатор));
			Исключение
				Продолжить;
			КонецПопытки;
			
			Если НЕ ГлЯдро_СсылкаСуществует(Ссылка) Тогда
				Продолжить;
			КонецЕсли;
			
			МетаданныеСсылки = Ссылка.Метаданные();
			
			Если Не ПравоДоступа("Чтение", МетаданныеСсылки) Тогда
				Продолжить;
			КонецЕсли;
			
			МассивСсылок.Добавить(Ссылка);
			
			Результат = МассивСсылок
		КонецЦикла;
	КонецЕсли;
			
	Возврат Результат;
КонецФункции

Функция ГлЯдро_ПреобразоватьДесятичноеЧислоВШестнадцатиричнуюСистемуСчисления(Знач ДесятичноеЧисло)
	
	Результат = "";
	
	Пока ДесятичноеЧисло > 0 цикл
		ОстатокОтДеления = ДесятичноеЧисло % 16;
		ДесятичноеЧисло  = (ДесятичноеЧисло - ОстатокОтДеления) / 16;
		Результат        = Сред("0123456789abcdef", ОстатокОтДеления + 1, 1) + Результат;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Функция ГлЯдро_ПолучитьДокументПоШтрихкоду(UserId, КодДокумента, ТипДокумента, mXmlDoc, ИмяСобытия="ГлЯдро_ПолучитьДокументПоШтрихкоду", ТипИнтерфейса="", АдресаПеременных)
	
	Попытка
		
		ТекущиеНастройкиMS = КомЯдро_ПолучитьЗначениеПеременной("ТекущиеНастройкиMS",АдресаПеременных);
		пCOMБазыMS = КомЯдро_ПолучитьЗначениеПеременной("COMБазыMS",АдресаПеременных);
		СтруктураПодключенияБазыMS = пCOMБазыMS;
		ПараметрыУзлов = ГлЯдро_ПолучитьЗначенияГлобальныхПараметров(,,,АдресаПеременных);
		НастройкиОтборов = ГлЯдро_ПолучитьИзКэшаНастройкуSMARTS("НастройкиОтборовУзлов_Онлайн",,АдресаПеременных);
		
		Если ТипЗнч(НастройкиОтборов) <> Тип("ТаблицаЗначений")
			И ТипЗнч(НастройкиОтборов) <> Тип("Массив") Тогда
			НастройкиОтборов = ГлЯдро_ПолучитьНастройкуНаСервереSMARTS("НастройкиОтборовУзлов_Онлайн",,АдресаПеременных);
		КонецЕсли;
		
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Начало получения документа по штрихкоду:" + Строка(КодДокумента) + ", Тип документа:" + Строка(ТипДокумента) +", Ид пользователя:" + Строка(UserId),,АдресаПеременных);													
		
		Если НастройкиОтборов[0].Свойство("КолонкиТаблицыЗначений") Тогда
			НастройкиОтборовКолонки = ГлЯдро_РазложитьСтрокуВМассивПодстрок(НастройкиОтборов[0].КолонкиТаблицыЗначений);
		Иначе
			НастройкиОтборовКолонки = Новый Массив;
			Для Каждого КлючЗначение Из НастройкиОтборов[0] Цикл
				НастройкиОтборовКолонки.Добавить(КлючЗначение.Ключ);		
			КонецЦикла;
		КонецЕсли;
		
		ЕстьРеквизитИспользуется	= (НастройкиОтборовКолонки.Найти("Используется") <> Неопределено);
		ЕстьРеквизитВариантОтбора	= (НастройкиОтборовКолонки.Найти("ВариантОтбора") <> Неопределено);			
		
		СтруктураМетаданных = КомЯдро_ПолучитьЗначениеПеременной("СтруктураМетаданных",АдресаПеременных);
		
		//Отберем возможные типы документов 1С 
		МассивВозможныхТиповДокументов1С = Новый Массив;
		МассивБП = Новый Массив;
		Если ТекущиеНастройкиMS.НастройкиБизнесПроцессов.Количество() Тогда
			Для Каждого НастройкаБП Из ТекущиеНастройкиMS.НастройкиБизнесПроцессов Цикл
				Если НастройкаБП.Используется = Истина
					И НастройкаБП.ТипДокументаMS = ТипДокумента 
					И ЗначениеЗаполнено(НастройкаБП.ТипИсходногоДокумента1С) Тогда
					ЕстьОтбор = Ложь;
					Для каждого СтрокаОтбора из НастройкиОтборов Цикл
						Если НЕ СтрокаОтбора.Свойство("ЭтоТаблицаЗначений") 
							И СтрокаОтбора.Используется = Истина 
							И СтрокаОтбора.ID_БизнесПроцесса = НастройкаБП.ID_БизнесПроцесса Тогда
							ЕстьОтбор = Истина;
							МассивБП.Добавить(Новый Структура("ID_БизнесПроцесса,НастройкаБП,СтрокаОтбора",НастройкаБП.ID_БизнесПроцесса,НастройкаБП,СтрокаОтбора));
							Прервать;
						КонецЕсли;
					КонецЦикла;
					Если ЕстьОтбор
						И МассивВозможныхТиповДокументов1С.Найти(НастройкаБП.ТипИсходногоДокумента1С) = Неопределено Тогда
						МассивВозможныхТиповДокументов1С.Добавить(НастройкаБП.ТипИсходногоДокумента1С);
					КонецЕсли;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
		МассивСсылок = ГлЯдро_ПолучитьСсылкуПоШтрихкодуТабличногоДокумента(КодДокумента,МассивВозможныхТиповДокументов1С);
		
		Результат = Неопределено;
		ДокуОтбора = Неопределено;
		МассивДокументов = Новый Массив;
		МассивСтруктурДокументов = Новый Массив;
		Для Каждого СтрокаБП из МассивБП Цикл
			Если СтрокаБП.Свойство("ЭтоТаблицаЗначений") Тогда
				Продолжить;
			КонецЕсли;
			
			Настройка = СтрокаБП.СтрокаОтбора;
			
			Если НЕ ЕстьРеквизитВариантОтбора ИЛИ ЕстьРеквизитВариантОтбора
				И Найти(ВРег(СокрЛП(Настройка.ВариантОтбора)), ВРег(СокрЛП("Конструктор")))
				И ЗначениеЗаполнено(Настройка.НастройкаКомпоновщикаСтрокой) Тогда
				НастройкиКомпоновки = ГлЯдро_ЗначениеИзСтрокиXML(СтрЗаменить(Настройка.НастройкаКомпоновщикаСтрокой, Символы.ВК, ""));
				
				Если МассивСсылок.Количество() Тогда
					ОтборДоркументов = НастройкиКомпоновки.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
					ОтборДоркументов.ЛевоеЗначение = Новый ПолеКомпоновкиДанных("Ссылка");
					ОтборДоркументов.ВидСравнения = ВидСравненияКомпоновкиДанных.ВСписке;
					ОтборДоркументов.ПравоеЗначение = МассивСсылок;
					ОтборДоркументов.Использование = Истина;
				Иначе
					Если Метаданные.Документы[СтрокаБП.НастройкаБП.ТипИсходногоДокумента1С].СтандартныеРеквизиты.Номер.Тип.СодержитТип(Тип("Строка")) Тогда
						ОтборДоркументов = НастройкиКомпоновки.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
						ОтборДоркументов.ЛевоеЗначение = Новый ПолеКомпоновкиДанных("Номер");
						ОтборДоркументов.ВидСравнения = ВидСравненияКомпоновкиДанных.Содержит;
						ОтборДоркументов.ПравоеЗначение = КодДокумента;
						ОтборДоркументов.Использование = Истина;
					Иначе
						ОтборДоркументов = НастройкиКомпоновки.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
						ОтборДоркументов.ЛевоеЗначение = Новый ПолеКомпоновкиДанных("Номер");
						ОтборДоркументов.ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
						Попытка
							ЗначениеОтбора = Число(КодДокумента);
						Исключение
							ЗначениеОтбора = Неопределено;
						КонецПопытки;
						ОтборДоркументов.ПравоеЗначение = ЗначениеОтбора;
						ОтборДоркументов.Использование = Истина;
					КонецЕсли;
				КонецЕсли;
				
				ДокументыОтбор = ГлЯдро_ОтобратьДокументы1СЧерезСКД(НастройкиКомпоновки, СтрокаБП.НастройкаБП.ТипИсходногоДокумента1С, строкаБП.НастройкаБП.Название,ПараметрыУзлов,,,,АдресаПеременных);
				Для Каждого СтрокаДокумента Из ДокументыОтбор Цикл
					Если СтрокаДокумента.Свойство("ЭтоТаблицаЗначений") Тогда
						Продолжить;
					КонецЕсли;
					
					Если МассивДокументов.Найти(СтрокаДокумента.Ссылка) = Неопределено Тогда
						МассивДокументов.Добавить(СтрокаДокумента.Ссылка);                                                                                                                						
					КонецЕсли;
					Если МассивСтруктурДокументов.Найти(СтрокаБП.ID_БизнесПроцесса) = Неопределено Тогда
						МассивСтруктурДокументов.Добавить(Новый Структура("ID_БизнесПроцесса,Документ1С,НастройкаБП",СтрокаБП.ID_БизнесПроцесса,СтрокаДокумента.Ссылка,СтрокаБП.НастройкаБП));
					КонецЕсли;
				КонецЦикла;					
			КонецЕсли;		
			
			Если ЕстьРеквизитВариантОтбора
				И Найти(ВРег(СокрЛП(Настройка.ВариантОтбора)), ВРег(СокрЛП("Запрос")))
				И ЗначениеЗаполнено(Настройка.ID_ПроизвольногоОтбора) Тогда
				НастройкиКомпоновки = ГлЯдро_ЗначениеИзСтрокиXML(СтрЗаменить(Настройка.НастройкаКомпоновщикаСтрокой, Символы.ВК, ""));
				
				ДопОтбор = Новый Массив;
				Если МассивСсылок.Количество() Тогда
					МассивСсылокКопия = Новый СписокЗначений;
					МассивСсылокКопия.ЗагрузитьЗначения(МассивСсылок.ВыгрузитьЗначения());									
					ДопОтбор.Добавить(Новый Структура("Описание,ВидСравнения,Значение","Ссылка",ВидСравнения.ВСписке,МассивСсылокКопия));
				Иначе
					СтруктураОтбора = Новый Структура("Описание","Ссылка.Номер");
					//Для строковых номеров документов ищем через подобно
					Если Метаданные.Документы[СтрокаБП.НастройкаБП.ТипИсходногоДокумента1С].СтандартныеРеквизиты.Номер.Тип.СодержитТип(Тип("Строка")) Тогда
						СтруктураОтбора.Вставить("ВидСравнения",ВидСравнения.Содержит);
						СтруктураОтбора.Вставить("Значение",КодДокумента);
					Иначе
						СтруктураОтбора.Вставить("ВидСравнения",ВидСравнения.Равно);
						Попытка
							ЗначениеОтбора = Число(КодДокумента);
						Исключение
							ЗначениеОтбора = Неопределено;
						КонецПопытки;
						СтруктураОтбора.Вставить("Значение",ЗначениеОтбора);
					КонецЕсли;
					ДопОтбор.Добавить(СтруктураОтбора);
				КонецЕсли;
				
				ДокументыОтбор = ГлЯдро_ОтобратьДокументы1СЧерезПроизвольныйОтбор(Настройка.ID_ПроизвольногоОтбора, Истина, ДопОтбор, ПараметрыУзлов, НастройкиКомпоновки, АдресаПеременных);
				Для Каждого СтрокаДокумента Из ДокументыОтбор Цикл
					Если СтрокаДокумента.Свойство("ЭтоТаблицаЗначений") Тогда
						Продолжить;
					КонецЕсли;
					
					Если МассивДокументов.Найти(СтрокаДокумента.Ссылка) = Неопределено Тогда
						МассивДокументов.Добавить(СтрокаДокумента.Ссылка);						
					КонецЕсли;
					Если МассивСтруктурДокументов.Найти(СтрокаБП.ID_БизнесПроцесса) = Неопределено Тогда						
						МассивСтруктурДокументов.Добавить(Новый Структура("ID_БизнесПроцесса,Документ1С,НастройкаБП",СтрокаБП.ID_БизнесПроцесса,СтрокаДокумента.Ссылка,СтрокаБП.НастройкаБП));
					КонецЕсли;
				КонецЦикла;
				
			КонецЕсли;
		КонецЦикла;
		
		Если МассивДокументов.Количество() > 0 Тогда	
			Если МассивСтруктурДокументов <> Неопределено 
				И МассивСтруктурДокументов.Количество() = 1 Тогда
				ДанныеДокумента = ГлЯдро_ПолучитьДанныеДокумента1СДляВыгрузки(МассивСтруктурДокументов[0].Документ1С, , МассивСтруктурДокументов[0].ID_БизнесПроцесса,АдресаПеременных);
				Если ДанныеДокумента = Неопределено Тогда
					Результат = Неопределено;
				Иначе
					НазначенныйПользователь = "";
					НастройкаБП = МассивСтруктурДокументов[0].НастройкаБП;
					Если НастройкаБП.Свойство("КопияДокументаДляКаждогоПользователя")
						И НастройкаБП.КопияДокументаДляКаждогоПользователя Тогда
						НазначенныйПользователь = UserId;
					КонецЕсли;
					
					Если ТипИнтерфейса = "REST_API" Тогда
						Результат = REST_API_СформироватьНовыйДокументSMARTS(ДанныеДокумента, НазначенныйПользователь, АдресаПеременных,Истина,Истина);
						Результат = ГлЯдро_ПолучитьJSON(Результат, "Cleverence.Warehouse.Document, Cleverence.MobileSMARTS");
					Иначе
						ДокументSMARTS = КомЯдро_СформироватьНовыйДокументSMARTS(ДанныеДокумента,НазначенныйПользователь);
						Результат = СтруктураПодключенияБазыMS.StorageConnector.СохранитьОбъектВ_XML(ДокументSMARTS);
					КонецЕсли;	
					
					ГлЯдро_ОбработатьДокумент1СПослеВыгрузкиНаСерверSMARTS(МассивСтруктурДокументов[0].Документ1С, ДанныеДокумента, , МассивСтруктурДокументов[0].ID_БизнесПроцесса, АдресаПеременных);
					
					Отбор = Новый Структура("Используется,ТипИсходногоДокумента1С,ID_БизнесПроцесса", Истина, ГлЯдро_ПолучитьТипДокументаПоСсылке(МассивСтруктурДокументов[0].Документ1С), МассивСтруктурДокументов[0].ID_БизнесПроцесса);
					ОтобранныеБизнесПроцессы = ГлЯдро_ПолучитьИзКэшаЗначениеТабличнойНастройкиSMARTS("НастройкиБизнесПроцессов", Отбор, "", АдресаПеременных);	
					
					ЕстьЧастнаяБаза = КомЯдро_ПолучитьЗначениеПеременной("ЕстьЧастнаяБаза",АдресаПеременных);
					ТипБазы = ?(ЕстьЧастнаяБаза=Истина,"Частная","Основная");
					
					// Выгрузка номенклатуры из документа перед выгрузкой 	
					флВыгрузитьНоменклатуруДокумента = ГлЯдро_ПолучитьИзКэшаНастройкуSMARTS("ВыгружатьНоменклатуруДокументаПередВыгрузкойДокумента",,АдресаПеременных);
					Если флВыгрузитьНоменклатуруДокумента Тогда
						ГлЯдро_ВыгрузитьНоменклатуруИзДокумента(МассивСтруктурДокументов[0].Документ1С, ОтобранныеБизнесПроцессы[0],ТипБазы, АдресаПеременных);	
					КонецЕсли;						
										
				КонецЕсли;
			КонецЕсли;
			
			Если МассивСтруктурДокументов <> Неопределено 
				И МассивСтруктурДокументов.Количество() > 1 Тогда				
				
				Если МассивДокументов.Количество() = 1 Тогда 
					// Один документ на несколько бизнес-процессов
					Документ1С = МассивДокументов[0];					
					
					Если ТипИнтерфейса = "REST_API" Тогда
						
						ИнформацияПоДокументу = Новый Структура;
						ИнформацияПоДокументу.Вставить("Id",				XMLСтрока(Документ1С));
						ИнформацияПоДокументу.Вставить("Name",				Строка(Документ1С));
						ИнформацияПоДокументу.Вставить("DocumentTypeName",	ТипДокумента);						
						ИнформацияПоДокументу.Вставить("ТипДокумента1С",	Документ1С.Метаданные().Имя);
												
						Результат = ГлЯдро_ПолучитьJSON(ИнформацияПоДокументу, "Cleverence.Warehouse.DocumentDescription, Cleverence.MobileSMARTS");
						
					Иначе
						
						#Область НесовместимыйКодFresh
						DocDescription = Новый COMОбъект("Cleverence.Warehouse.DocumentDescription");
						DocDescription.Id				= XMLСтрока(Документ1С);
						DocDescription.Name				= Строка(Документ1С);
						DocDescription.DocumentTypeName = ТипДокумента;
						
						DocDescription.SetField("ТипДокумента1С", Документ1С.Метаданные().Имя);
						
						Результат = СтруктураПодключенияБазыMS.StorageConnector.СохранитьОбъектВ_XML(DocDescription);
						#КонецОбласти //НесовместимыйКодFresh
						
					КонецЕсли;		
				Иначе
					// Несколько документов на несколько бизнес-процессов	
					Если ТипИнтерфейса = "REST_API" Тогда
						
						МассивИнформацииПоДокументам = Новый Массив;
						
						Для каждого СтруктураДокумента из МассивСтруктурДокументов Цикл
							
							Документ1С = СтруктураДокумента.Документ1С;
							
							ИнформацияПоДокументу = Новый Структура;
							ИнформацияПоДокументу.Вставить("Id",				XMLСтрока(Документ1С));
							ИнформацияПоДокументу.Вставить("Name",				Строка(Документ1С));
							ИнформацияПоДокументу.Вставить("DocumentTypeName",	ТипДокумента);							
							ИнформацияПоДокументу.Вставить("ТипДокумента1С",	Документ1С.Метаданные().Имя);
							Попытка					
								ИнформацияПоДокументу.Вставить("ИмяКонтрагента", Строка(Документ1С.Контрагент));					
							Исключение
							КонецПопытки;				
							Попытка					
								ИнформацияПоДокументу.Вставить("ИмяСклада", Строка(Документ1С.Склад));					
							Исключение
							КонецПопытки;			
							Попытка
								Если СтруктураДокумента.Свойство("НастройкаБП") Тогда 
									ИнформацияПоДокументу.Вставить("ИмяБП", СтруктураДокумента.НастройкаБП.Название);
								КонецЕсли;
							Исключение
							КонецПопытки; 						

							МассивИнформацииПоДокументам.Добавить(ИнформацияПоДокументу);
							
						КонецЦикла;
						
						Результат = ГлЯдро_ПолучитьJSON(МассивИнформацииПоДокументам, "Cleverence.Warehouse.DocumentDescriptionCollection, Cleverence.MobileSMARTS", Истина);
						
					Иначе
						
						#Область НесовместимыйКодFresh
						DocumentDescriptions = Новый COMОбъект("Cleverence.Warehouse.DocumentDescriptionCollection");						
						
						Для каждого СтруктураДокумента из МассивСтруктурДокументов Цикл
							
							Документ1С = СтруктураДокумента.Документ1С;
							
							DocDescription = Новый COMОбъект("Cleverence.Warehouse.DocumentDescription");
							DocDescription.Id				= XMLСтрока(Документ1С);
							DocDescription.Name				= Строка(Документ1С);
							DocDescription.DocumentTypeName	= ТипДокумента;							
							
							DocDescription.SetField("ТипДокумента1С", Документ1С.Метаданные().Имя);
							Попытка
								Если СтруктураДокумента.Свойство("НастройкаБП") Тогда 
									DocDescription.SetField("ИмяБП", СтруктураДокумента.НастройкаБП.Название);
								КонецЕсли;
							Исключение
							КонецПопытки; 						
							
							DocumentDescriptions.Add(DocDescription);
							
						КонецЦикла;						
						
						Результат = СтруктураПодключенияБазыMS.StorageConnector.СохранитьОбъектВ_XML(DocumentDescriptions);
						#КонецОбласти //НесовместимыйКодFresh
						
					КонецЕсли;
					
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЕсли;					
		
	Исключение
		ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Ошибка при получении документа по штрихкоду: " + Строка(КодДокумента) + ", Текст ошибки: " + ТекстОшибки + ",  Тип документа:" + Строка(ТипДокумента) +", Ид пользователя:" + Строка(UserId),,АдресаПеременных);		
		Результат = Неопределено;
		
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции

// Формирует схему компоновки данных по переданному запросу
//
// Параметры:
//	ПараметрыВыгрузки - Структура - содержит:
//		* ТекстЗапроса - Строка - текст запроса, по которому необходимо построить СКД
//		* ТекстКодаПолучениеПараметров - Строка - строка кода, из которой будут получены параметры
//		* ТаблицаСопоставленияПолей - Массив - массив строк с сопоставлением реквизит 1с - реквизит MS
//		* ИмяИсточникаДанных - Строка - имя, которое будет установлено для источника данных
//  АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
//
// Возвращаемое значение:
//	СхемаКомпоновкиДанных
Функция ГлЯдро_ПолучитьСхемуСКДПоТекстуЗапроса(ПараметрыВыгрузки, АдресаПеременных) Экспорт		
	
	Если ПараметрыВыгрузки.Свойство("ТекстЗапроса") Тогда
		ТекстЗапроса = ПараметрыВыгрузки.ТекстЗапроса;
	КонецЕсли;
	Если ПараметрыВыгрузки.Свойство("ТекстКодаПолучениеПараметров") Тогда
		ТекстКодаПолучениеПараметров = ПараметрыВыгрузки.ТекстКодаПолучениеПараметров;
	КонецЕсли;
	Если ПараметрыВыгрузки.Свойство("ТаблицаСопоставленияПолей") Тогда
		ТаблицаСопоставленияПолей = ПараметрыВыгрузки.ТаблицаСопоставленияПолей;
	КонецЕсли;				
	Если ПараметрыВыгрузки.Свойство("ИмяИсточникаДанных") Тогда
		ИмяИсточникаДанных = ПараметрыВыгрузки.ИмяИсточникаДанных;
	КонецЕсли;				
	
	СхемаСКД = Новый СхемаКомпоновкиДанных;
	
	ИсточникСКД = СхемаСКД.ИсточникиДанных.Добавить();
	ИсточникСКД.Имя = "ИсточникДанных1";
	ИсточникСКД.СтрокаСоединения = "";
	ИсточникСКД.ТипИсточникаДанных = "Local";
	                                        
	ДанныеСКД = СхемаСКД.НаборыДанных.Добавить(Тип("НаборДанныхЗапросСхемыКомпоновкиДанных"));
	ДанныеСКД.Имя = ?(ЗначениеЗаполнено(ИмяИсточникаДанных), ИмяИсточникаДанных, "НаборДанных1");
	ДанныеСКД.ИсточникДанных = ИсточникСКД.Имя;
	ДанныеСКД.АвтоЗаполнениеДоступныхПолей = Истина;
		 
	ДанныеСКД.Запрос = ТекстЗапроса;
	
	НастройкиПоУмолчанию = СхемаСКД.НастройкиПоУмолчанию;
		
	ПараметрыЗапроса = Новый Структура;	
	Попытка
		//Выполнить(ТекстКодаПолучениеПараметров);
		СтрокаВызова = СтрЗаменить(ТекстКодаПолучениеПараметров, "ПараметрыЗапроса", "Параметры.ПараметрыЗапроса");
		ПараметрыАлгоритма = Новый Структура;
		ПараметрыАлгоритма.Вставить("ПараметрыЗапроса", ПараметрыЗапроса);
		ГлЯдро_ВыполнитьВБезопасномРежиме(СтрокаВызова, ПараметрыАлгоритма, АдресаПеременных);
		ПараметрыЗапроса = ПараметрыАлгоритма.ПараметрыЗапроса;
	
		Для Каждого ПараметрЗапроса Из ПараметрыЗапроса Цикл
			// Добавляем в СКД новый параметр
			ПараметрСКД = СхемаСКД.Параметры.Добавить(); 
			
			ПараметрСКД.Имя 						= ПараметрЗапроса.Ключ;
			ПараметрСКД.ОграничениеИспользования 	= Ложь;
			ПараметрСКД.Значение 					= ПараметрЗапроса.Значение;
			ПараметрСКД.Использование 				= ИспользованиеПараметраКомпоновкиданных.Всегда;
			ПараметрСКД.ВключатьВДоступныеПоля 		= Истина;
			
			// Добавляем в настройки новый параметр
			ПараметрКомпоновщика = НастройкиПоУмолчанию.ПараметрыДанных.Элементы.Добавить();
			ПараметрКомпоновщика.Параметр 								= Новый ПараметрКомпоновкиДанных(ПараметрЗапроса.Ключ);
			ПараметрКомпоновщика.Использование 							= Истина;
			ПараметрКомпоновщика.Значение 								= ПараметрЗапроса.Значение;
		КонецЦикла;
	Исключение
		Сообщить("Ошибка получения параметров запроса." + Символы.ПС + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));		
		Возврат Неопределено;
	КонецПопытки;
			
	Для Каждого СтрокаСопоставления Из ТаблицаСопоставленияПолей Цикл
		Если СтрокаСопоставления.Свойство("ЭтоТаблицаЗначений") Тогда
			Продолжить;
		КонецЕсли;
		
		Если Не СтрокаСопоставления.Выгружать Тогда
			Продолжить;
		КонецЕсли;
		
		ИмяПриемника = СтрЗаменить(СтрокаСопоставления.ИмяПриемника, ".", "_");
		ИмяИсточника = СтрокаСопоставления.ИмяИсточника;
		
		// Создание поля набора данных
		ДобавленноеПоле = ДанныеСКД.Поля.Добавить(Тип("ПолеНабораДанныхСхемыКомпоновкиДанных"));
		ДобавленноеПоле.Заголовок 		= ИмяПриемника;
		ДобавленноеПоле.ПутьКДанным 	= ИмяПриемника;
		ДобавленноеПоле.Поле 			= ИмяИсточника;
		
		Если СтрокаСопоставления.СпособСопоставления = "КакЕсть" 
			Или СтрокаСопоставления.СпособСопоставления = "" Тогда
			// Никаких дополнительных действий не требуется

		Иначе
			// Создание вычисляемого поля
			ВычисляемоеПоле = СхемаСКД.ВычисляемыеПоля.Добавить();
			
			ВычисляемоеПоле.ПутьКДанным = ИмяПриемника;
			ВычисляемоеПоле.Заголовок 	= ИмяПриемника;
			
			// Установка выражения для вычисляемого поля
			Если СтрокаСопоставления.СпособСопоставления = "СтрокаGUID" Тогда
				Выражение = "XMLСтрока(" + ИмяПриемника + ")";
			ИначеЕсли СтрокаСопоставления.СпособСопоставления = "Наименование" Тогда
				Выражение = ИмяПриемника + ".Наименование";
			ИначеЕсли СтрокаСопоставления.СпособСопоставления = "Код" Тогда
				Выражение = ИмяПриемника + ".Код";
			КонецЕсли;
			
			ВычисляемоеПоле.Выражение = Выражение;
			
			// Создание вычисляемого поля для возможности наложения пользовательских отборов по ссылкам 
			Если СтрокаСопоставления.СпособСопоставления = "СтрокаGUID" Тогда
				ВычисляемоеПоле = СхемаСКД.ВычисляемыеПоля.Добавить();
			    ВычисляемоеПоле.ПутьКДанным = ИмяПриемника + "Ссылка";
				ВычисляемоеПоле.Заголовок 	= ИмяПриемника + "Ссылка";
				ВычисляемоеПоле.Выражение 	= ИмяПриемника;
			КонецЕсли;
		КонецЕсли;
		
		//Вывод поля
		ВыбранноеПоле = НастройкиПоУмолчанию.Выбор.Элементы.Добавить(Тип("ВыбранноеПолеКомпоновкиДанных"));
		ВыбранноеПоле.Заголовок 		= ИмяПриемника;
		ВыбранноеПоле.Использование 	= Истина;
		ВыбранноеПоле.Поле 				= Новый ПолеКомпоновкиДанных(ИмяПриемника);
    
	КонецЦикла;
	
	ЭлементГруппировки = НастройкиПоУмолчанию.Структура.Добавить(Тип("ГруппировкаКомпоновкиДанных"));
	ЭлементГруппировки.Использование = Истина;
	ЭлементГруппировки.Выбор.Элементы.Добавить(Тип("АвтоВыбранноеПолеКомпоновкиДанных"));
	ЭлементГруппировки.Порядок.Элементы.Добавить(Тип("АвтоЭлементПорядкаКомпоновкиДанных"));
	
	// Отладка результата сформированной СКД
	//КомпоновщикМакета = Новый КомпоновщикМакетаКомпоновкиДанных;
	//МакетКомпоновки = КомпоновщикМакета.Выполнить(СхемаСКД, НастройкиПоУмолчанию,,,Тип("ГенераторМакетаКомпоновкиДанныхДляКоллекцииЗначений"), Ложь);
	//
	//ПроцессорКомпоновки = Новый ПроцессорКомпоновкиДанных;
	//ПроцессорКомпоновки.Инициализировать(МакетКомпоновки,,, Истина);
	//ПроцессорВывода = Новый ПроцессорВыводаРезультатаКомпоновкиДанныхВКоллекциюЗначений;
	//Результат = ПроцессорВывода.Вывести(ПроцессорКомпоновки);
			
	Возврат СхемаСКД;
	
КонецФункции

// Заполняет значение параметра компоновщика настроек СКД
//
// Параметры:
//  ИмяПараметра  - Строка - имя параметра, значение которого необходимо заполнить
//                 <продолжение описания параметра>
//  АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
//
Процедура ГлЯдро_ЗаполнитьЗначениеПараметраКомпоновщикаНастроекСКД(КомпоновщикСКД, ИмяПараметра, ЗначениеПараметра, АдресаПеременных)

	ПараметрКомпоновщика = КомпоновщикСКД.Настройки.ПараметрыДанных.НайтиЗначениеПараметра(Новый ПараметрКомпоновкиДанных(ИмяПараметра));
	
	Если ПараметрКомпоновщика <> Неопределено Тогда			
		ПараметрКомпоновщика.Использование 	= Истина;
		ПараметрКомпоновщика.Значение 		= ЗначениеПараметра;
	КонецЕсли;

КонецПроцедуры

// Возвращает таблицу произвольных кодов по типу объекта
//
// Параметры:
//  ИмяНастроекИзКэша  		- Строка 					- имя параметра, значение которого необходимо заполнить
//  ДанныеНастроекИзКэша 	- Неопределено, Структура 	- содержит:
//		* НастройкиБизнесПроцессов 				- Неопределено, ТаблицаЗначений, Массив из Структура - содержит настройки бизнес-процессов
//		* ПроизвольныеКодыШапки 				- Неопределено, ТаблицаЗначений, Массив из Структура - содержит произвольные коды загрузки шапки документа
//		* ПроизвольныеКодыТабличнойЧасти 		- Неопределено, ТаблицаЗначений, Массив из Структура - содержит произвольные коды загрузки табличных частей документа
//		* ПроизвольныеКодыОбработчикаЗагрузки 	- Неопределено, ТаблицаЗначений, Массив из Структура - содержит произвольные коды загрузки табличных частей документа
//		* ПроизвольныеКодыОбработчикаТЧ 		- Неопределено, ТаблицаЗначений, Массив из Структура - содержит произвольные коды загрузки табличных частей документа
//		* ПроизвольныеКодыОбработчикаСтрокиТЧ 	- Неопределено, ТаблицаЗначений, Массив из Структура - содержит произвольные коды загрузки табличных частей документа
//		* ЗначенияПараметров 					- Неопределено, ТаблицаЗначений, Массив из Структура - содержит значения глобальных параметров
//  Направление 			- Строка 					- наименование направления обмена ("Выгрузка", "Загрузка")
//  ТипОбъекта 				- Строка 					- наименование типа объекта произвольных кодов
//  АдресаПеременных 		- Структура 				- см. КомЯдро_СоздатьСтруктуруАдресаПеременных
//
Функция ГлЯдро_ПолучитьПроизвольныеКоды(ИмяНастроекИзКэша, ДанныеНастроекИзКэша, Направление, ТипОбъекта, АдресаПеременных)
	
	ПроизвольныеКоды = Неопределено;
	Если ДанныеНастроекИзКэша = Неопределено ИЛИ НЕ ДанныеНастроекИзКэша.Свойство(ИмяНастроекИзКэша) ИЛИ ДанныеНастроекИзКэша[ИмяНастроекИзКэша] = Неопределено Тогда
		Если ТипЗнч(ТипОбъекта) = Тип("Массив") Тогда
			Для Каждого ЭлементМассива Из ТипОбъекта Цикл
				Отбор = Новый Структура("Направление,ТипОбъекта", Направление, ЭлементМассива);
				тПроизвольныеКоды = ГлЯдро_ПолучитьИзКэшаЗначениеТабличнойНастройкиSMARTS("ПроизвольныеКоды", Отбор,,АдресаПеременных);	
				Если ТипЗнч(тПроизвольныеКоды) = Тип("Массив") Тогда
					ТаблицаПроизвольныеКоды = ГлЯдро_МассивСтруктурВТаблицуЗначений(тПроизвольныеКоды);
					Если ТаблицаПроизвольныеКоды <> Неопределено Тогда
						тПроизвольныеКоды = ТаблицаПроизвольныеКоды;	
					КонецЕсли;
				КонецЕсли;				                                       				
				Если ПроизвольныеКоды = Неопределено Тогда
					ПроизвольныеКоды = тПроизвольныеКоды;
				Иначе
					Если тПроизвольныеКоды <> Неопределено Тогда
						Для Каждого СтрокаТаблицы Из тПроизвольныеКоды Цикл
							НоваяСтрокаПК = ПроизвольныеКоды.Добавить();
							ЗаполнитьЗначенияСвойств(НоваяСтрокаПК, СтрокаТаблицы);
						КонецЦикла;
					КонецЕсли;
				КонецЕсли;		
			КонецЦикла;			
		Иначе
			Отбор = Новый Структура("Направление,ТипОбъекта", Направление, ТипОбъекта);
			ПроизвольныеКоды = ГлЯдро_ПолучитьИзКэшаЗначениеТабличнойНастройкиSMARTS("ПроизвольныеКоды", Отбор,,АдресаПеременных);	
		КонецЕсли;		
	Иначе
		Если ТипЗнч(ДанныеНастроекИзКэша[ИмяНастроекИзКэша]) = Тип("Массив") Тогда
			ПроизвольныеКоды = ДанныеНастроекИзКэша[ИмяНастроекИзКэша];
		КонецЕсли;
	КонецЕсли;
	
	Если ТипЗнч(ПроизвольныеКоды) = Тип("Массив") Тогда
		ТаблицаПроизвольныеКоды = ГлЯдро_МассивСтруктурВТаблицуЗначений(ПроизвольныеКоды);
		Если ТаблицаПроизвольныеКоды <> Неопределено Тогда
			ПроизвольныеКоды = ТаблицаПроизвольныеКоды;	
		КонецЕсли;
	КонецЕсли;
	
	Возврат ПроизвольныеКоды;
	
КонецФункции

Функция ГлЯдро_ПолучитьНастройкуОтбораБизнесПроцесса(ID_БизнесПроцесса, ВидОбмена = "Онлайн", АдресаПеременных)

	Если НЕ ЗначениеЗаполнено(ID_БизнесПроцесса) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	НастройкаОтбора = Неопределено;
	
	НастройкиОтборов = ГлЯдро_ПолучитьИзКэшаНастройкуSMARTS("НастройкиОтборовУзлов_" + ВидОбмена, , АдресаПеременных);
	
	Если ТипЗнч(НастройкиОтборов) <> Тип("ТаблицаЗначений")	И ТипЗнч(НастройкиОтборов) <> Тип("Массив") Тогда
		ID_Узла = "";
		ДанныеТекущегоУзла = КомЯдро_ПолучитьЗначениеПеременной("ДанныеТекущегоУзла", АдресаПеременных);
		Если ТипЗнч(ДанныеТекущегоУзла) = Тип("Структура")
			И ДанныеТекущегоУзла.Свойство("ID_Узла")
			И ДанныеТекущегоУзла.ID_Узла <> "" Тогда
			ID_Узла = ДанныеТекущегоУзла.ID_Узла;		
		КонецЕсли;
		
		НастройкиОтборов = ГлЯдро_ПолучитьНастройкуНаСервереSMARTS("НастройкиОтборовУзлов_" + ВидОбмена, ID_Узла, АдресаПеременных);
	КонецЕсли;
	
	Если ТипЗнч(НастройкиОтборов) = Тип("ТаблицаЗначений") Тогда
		НастройкиОтборовБП = НастройкиОтборов.НайтиСтроки(Новый Структура("ID_БизнесПроцесса,Используется", ID_БизнесПроцесса, Истина));
	ИначеЕсли ТипЗнч(НастройкиОтборов) = Тип("Массив") Тогда
		НастройкиОтборовБП = ГлЯдро_СкопироватьМассив(НастройкиОтборов, Новый Структура("ID_БизнесПроцесса,Используется", ID_БизнесПроцесса, Истина));
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
	Если НастройкиОтборовБП.Количество() Тогда
		НастройкаОтбора = НастройкиОтборовБП[0];
	КонецЕсли;	
	
	Возврат НастройкаОтбора;
	
КонецФункции

Функция ГлЯдро_ПроверитьНаличиеМетодовИнтеграционнойОбработки(МассивМетодов, МассивПроверенныхМетодов = Неопределено, АдресаПеременных) Экспорт
	
	МассивПроверенныхМетодов 			= ?(МассивПроверенныхМетодов = Неопределено, Новый Массив, МассивПроверенныхМетодов);	
	МассивРезультатовПроверок 			= Новый Массив;	
	ИнтеграционнаяОбработкаНеопределена = Ложь;
	
	СтруктураИО = КомЯдро_ПолучитьЗначениеПеременной("ИнтеграционнаяОбработка", АдресаПеременных);
	
	Если (СтруктураИО = Неопределено
		Или Не ТипЗнч(СтруктураИО) = Тип("Структура")
		Или Не СтруктураИО.Свойство("ИнтеграционнаяОбработка")
		Или СтруктураИО.ИнтеграционнаяОбработка = Неопределено) Тогда		
				
		ИнтеграционнаяОбработкаНеопределена = Истина;
		
	КонецЕсли;
	
	Для Каждого ИмяМетода Из МассивМетодов Цикл
		
		МассивНайденныхМетодов = ГлЯдро_НайтиВМассивеСтруктурПоОтбору(МассивПроверенныхМетодов, Новый Структура("ИмяМетода", ИмяМетода));
		Если МассивНайденныхМетодов <> Неопределено И МассивНайденныхМетодов.Количество() Тогда
			
			ИмяМетода 		= МассивНайденныхМетодов[0].ИмяМетода;
			МетодДоступен 	= МассивНайденныхМетодов[0].МетодДоступен;
			ТекстОшибки 	= МассивНайденныхМетодов[0].ТекстОшибки;
			
		Иначе
						
			МетодДоступен 	= Ложь;
			ТекстОшибки 	= "";
			
			Если ИнтеграционнаяОбработкаНеопределена Тогда
				ТекстОшибки = "Не удалось получить интеграционную обработку";				
			Иначе                                                                  				
				ИнтеграционнаяОбработка = СтруктураИО.ИнтеграционнаяОбработка;	
				
				Попытка
					//Выполнить("ИнтеграционнаяОбработка." + ИмяМетода + "()");
					СтрокаВызова = "ИнтеграционнаяОбработка." + ИмяМетода + "()";
					СтрокаВызова = СтрЗаменить(СтрокаВызова, "ИнтеграционнаяОбработка", "Параметры.ИнтеграционнаяОбработка");
					ПараметрыАлгоритма = Новый Структура;
					ПараметрыАлгоритма.Вставить("ИнтеграционнаяОбработка", 	ИнтеграционнаяОбработка);
					ГлЯдро_ВыполнитьВБезопасномРежиме(СтрокаВызова, ПараметрыАлгоритма, АдресаПеременных);
				Исключение
					Инфо 		= ИнформацияОбОшибке();
					Описание 	= Инфо.Описание;
				КонецПопытки;
				
				МетодДоступен	= ГлЯдро_СтрНайти(ВРег(Описание), "(" + ВРег(ИмяМетода) + ")") = 0;
				ТекстОшибки 	= ?(Не МетодДоступен, Описание, ТекстОшибки);				
			КонецЕсли;
						
		КонецЕсли;                                              		
		
		СтруктураПроверки = Новый Структура;
		СтруктураПроверки.Вставить("ИмяМетода", 	ИмяМетода);
		СтруктураПроверки.Вставить("МетодДоступен", МетодДоступен);
		СтруктураПроверки.Вставить("ТекстОшибки", 	ТекстОшибки);
		
		МассивРезультатовПроверок.Добавить(СтруктураПроверки);
		// Добавляем в проверенные, чтобы в следующем бизнес-процессе не выполнять проверку, а взять результат из массива
		
		Если МассивНайденныхМетодов = Неопределено Или Не МассивНайденныхМетодов.Количество() Тогда
			МассивПроверенныхМетодов.Добавить(СтруктураПроверки);	     		
		КонецЕсли;
		
	КонецЦикла;                      
	
	СтруктураВозврата = Новый Структура;
	СтруктураВозврата.Вставить("МассивРезультатовПроверок", МассивРезультатовПроверок);
	СтруктураВозврата.Вставить("МассивПроверенныхМетодов", 	МассивПроверенныхМетодов);
	
	Возврат СтруктураВозврата;

КонецФункции

#КонецОбласти

#КонецОбласти

#Область ГлобальныйКонтекст_УниверсальныеМеханизмы

// Вызывает функцию проверки подключения к базе Mobile Smarts
//
// Параметры:
//	РезультатЗакрытияФормы - Неопределено, Структура - содержит:
//		* АвторизацияТокен - Строка - токен авторизации
//      * АвторизацияЛогин - Строка - логин авторизации
//		* АвторизацияЗапомнить - Булево - флаг необходимость сохранить авторизацию
//  ДопПараметры - Структура - содержит:
//		* СтрокаПодключения - Строка
//      * ТипБазы - Строка - "Частная", "Временная", "Основная"
//      * СтруктураПодключения - Структура - структура подключения к базе Mobile Smarts
//      * СохранятьАвторизацию - Булево
//      * ИмяБазы - Строка
//  АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
//
// Возвращаемое значение:
//	Булево - результат проверки соединения с базой Mobile Smarts
Функция ГлЯдро_ПодключитьсяКБазеSMARTSНаСервереЗавершение(РезультатЗакрытияФормы, ДопПараметры, АдресаПеременных) Экспорт
	Если ТипЗнч(ДопПараметры) = Тип("Структура") 
		И ДопПараметры.Свойство("СтруктураПодключения")
		И ТипЗнч(ДопПараметры.СтруктураПодключения) = Тип("Структура")  
		И ДопПараметры.СтруктураПодключения.Свойство("ТипИнтерфейса")
		И ЗначениеЗаполнено(ДопПараметры.СтруктураПодключения.ТипИнтерфейса) Тогда
		ТипИнтерфейса = ДопПараметры.СтруктураПодключения.ТипИнтерфейса;
	Иначе
		ТипИнтерфейса = КомЯдро_ПолучитьЗначениеПеременной("ТипИнтерфейса",АдресаПеременных);
	КонецЕсли;
		
	Если ТипИнтерфейса = "REST_API" Тогда
		Возврат REST_API_ПодключитьсяКБазеSMARTS(ДопПараметры.СтруктураПодключения, Ложь,, АдресаПеременных);
	Иначе
		Возврат КомЯдро_ПодключитьсяКБазеSMARTSНаСервереЗавершение(РезультатЗакрытияФормы, ДопПараметры,АдресаПеременных);
	КонецЕсли;
КонецФункции
	
// Получает макет обработки
//
// Параметры:
//	ИмяМакета - Строка
//
// Возвращаемое значение:
//	- ТабличныйДокумент
//  - ТекстовыйДокумент
//	- другой объект, который может быть макетом.
Функция ГлЯдро_ПолучитьМакетОбработки(ИмяМакета) Экспорт
	Возврат ПолучитьМакет(ИмяМакета);
КонецФункции

// Разбивает строку на несколько строк по указанному разделителю. Разделитель может иметь любую длину.
//
// Параметры:
//  Значение    - Строка - текст с разделителями
//  Разделитель - Строка - разделитель строк текста, минимум 1 символ
//
// Возвращаемое значение:
//  Массив из Строка
Функция ГлЯдро_РазложитьСтрокуВМассивПодстрок(Знач Стр, Разделитель = ",") Экспорт
	
	МассивСтрок = Новый Массив();
	Если Разделитель = " " Тогда
		Стр = СокрЛП(Стр);
		Пока 1 = 1 Цикл
			Поз = Найти(Стр, Разделитель);
			Если Поз = 0 Тогда
				МассивСтрок.Добавить(Стр);
				Возврат МассивСтрок;
			КонецЕсли;
			МассивСтрок.Добавить(Лев(Стр, Поз - 1));
			Стр = СокрЛ(Сред(Стр, Поз));
		КонецЦикла;
	Иначе
		ДлинаРазделителя = СтрДлина(Разделитель);
		Пока 1 = 1 Цикл
			Поз = Найти(Стр, Разделитель);
			Если Поз = 0 Тогда
				Если (СокрЛП(Стр) <> "") Тогда
					МассивСтрок.Добавить(Стр);
				КонецЕсли;
				Возврат МассивСтрок;
			КонецЕсли;
			МассивСтрок.Добавить(Лев(Стр,Поз - 1));
			Стр = Сред(Стр, Поз + ДлинаРазделителя);
		КонецЦикла;
	КонецЕсли;
	
КонецФункции

// Вызывает функцию получения префикса конфигурации из интеграционной обработки
//
// Параметры:
//	АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
//
// Возвращаемое значение:
//	Строка - префикс конфигурации
Функция ГлЯдро_ПолучитьПрефиксКонфигурации(АдресаПеременных) Экспорт
	Возврат Конф_ПолучитьПрефиксКонфигурации(АдресаПеременных);
КонецФункции

Функция ГлЯдро_СложныеТипыОтсутствуют(ОписаниеТипов)
	
	Результат = Истина;
	Для Каждого ВыбранныйТип Из ОписаниеТипов.Типы() Цикл
		Если НЕ (ВыбранныйТип = Тип("Строка") ИЛИ ВыбранныйТип = Тип("Число") ИЛИ ВыбранныйТип = Тип("Дата") ИЛИ ВыбранныйТип = Тип("Булево")) Тогда
			Результат = Ложь;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Результат;
		
КонецФункции

// Получает данные штрихкода EAN13 и возвращает их в виде структуры
//
// Параметры:
//	Штрихкод - Строка
//	АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
//
// Возвращаемое значение:
//	Структура - содержит:	
//		* ЭтоВесовойТовар - Булево
//		* КоличествоТовара - Число
//      * КодСтрока - Строка
//      * КодЧисло - Число
//		* Префикс - Строка
Функция ГлЯдро_ПолучитьСтруктуруШтрихкодаEAN13(Штрихкод,АдресаПеременных) Экспорт
	
	СтруктураШтрихкода = Новый Структура;
	СтруктураШтрихкода.Вставить("ЭтоВесовойТовар", Ложь);
	СтруктураШтрихкода.Вставить("КоличествоТовара", 1);
	СтруктураШтрихкода.Вставить("КодСтрока", Штрихкод);	
	
	Если СтрДлина(Штрихкод) <= 32 Тогда
		Попытка
			СтруктураШтрихкода.Вставить("КодЧисло", Число(Штрихкод));
		Исключение
			СтруктураШтрихкода.Вставить("КодЧисло", -1);
		КонецПопытки;
	Иначе
		СтруктураШтрихкода.Вставить("КодЧисло", -1);
	КонецЕсли;	
	
	ИспользоватьШаблонВесовогоТовара = ГлЯдро_ПолучитьИзКэшаНастройкуSMARTS("ИспользоватьШаблоныВесовогоТовара",,АдресаПеременных);
	ПрефиксШК = ?(ИспользоватьШаблонВесовогоТовара, ГлЯдро_ПолучитьИзКэшаНастройкуSMARTS("ПрефиксКодаВесовогоТовара",,АдресаПеременных), "");
	Если СтрДлина(Штрихкод) = 13 
		И (ИспользоватьШаблонВесовогоТовара = Истина) 
		И (ПрефиксШК <> "") Тогда
						
		ДлинаШК = ?(ИспользоватьШаблонВесовогоТовара, ГлЯдро_ПолучитьИзКэшаНастройкуSMARTS("ДлинаКодаВесовогоТовара",,АдресаПеременных), 0);
		ДробиШК = ?(ИспользоватьШаблонВесовогоТовара, ГлЯдро_ПолучитьИзКэшаНастройкуSMARTS("ЧислоЗнаковПослеЗапятойВесТовара",,АдресаПеременных), 0);
		ПрефиксВключенВКод = ?(ИспользоватьШаблонВесовогоТовара, ГлЯдро_ПолучитьИзКэшаНастройкуSMARTS("ПрефиксВключенВКодВесовогоТовара",,АдресаПеременных),Ложь);
		
		МассивПС = ГлЯдро_РазложитьСтрокуВМассивПодстрок(ПрефиксШК, ",");
		Префикс = "";					
		Для каждого Эл Из МассивПС Цикл
			Если Лев(Штрихкод, СтрДлина(Эл)) = СокрЛП(Эл) Тогда
				Префикс = СокрЛП(Эл);
				СтруктураШтрихкода.Вставить("ЭтоВесовойТовар", Истина);
				СтруктураШтрихкода.Вставить("Префикс",Префикс);
				Прервать;
			КонецЕсли;	
		КонецЦикла; 
			
		Если СтруктураШтрихкода.ЭтоВесовойТовар Тогда						
			КоэффициентВычисленияВеса = 1;
			Для Счетчик = 1 По Число(ДробиШК) Цикл
				КоэффициентВычисленияВеса = КоэффициентВычисленияВеса * 10;
			КонецЦикла; 
			
			КоличествоТовара = Сред(Штрихкод, Число(ДлинаШК) + 3, Число(ДлинаШК));
			Попытка
				СтруктураШтрихкода.Вставить("КоличествоТовара", Число(КоличествоТовара)/КоэффициентВычисленияВеса);
			Исключение
			КонецПопытки;
			
			Если ПрефиксВключенВКод = Истина Тогда
				КодПоиска = Лев(Штрихкод, СтрДлина(Префикс) + Число(ДлинаШК));
			Иначе
				КодПоиска = Сред(Штрихкод, СтрДлина(Префикс) + 1, Число(ДлинаШК));
			КонецЕсли;
			СтруктураШтрихкода.Вставить("КодСтрока", КодПоиска);
			Попытка 
				СтруктураШтрихкода.Вставить("КодЧисло", Число(КодПоиска));
			Исключение	
			КонецПопытки;	
		КонецЕсли;	
	КонецЕсли;
	
	Возврат СтруктураШтрихкода;
	
КонецФункции

// Вызывает функцию получения метаданных НСИ из интеграционной обработки
//
// Параметры:
//	АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных	
//
// Возвращаемое значение:
//	Структура - ключами являются наименования метаданных НСИ, значениями - структуры, содержащие описание
//				этих метаданных в конфигурациях, для которых предназначена интеграционная обработка
Функция ГлЯдро_ПолучитьМетаданныеНСИ(АдресаПеременных) Экспорт
	Возврат Конф_ПолучитьМетаданныеНСИ(АдресаПеременных);
КонецФункции

// Выполняет запрос к регистру штрихкодов номенклатуры с отбором по значению переданного штрихкода
// и возвращает результат выполнения запроса в виде таблицы значений
//
// Параметры:
//	Штрихкод - Строка - штрихкод номенклатуры
//	МетаданныеНСИ - Структура - содержит описание метаданных НСИ - см. ГлЯдро_ПолучитьМетаданныеНСИ 
//
// Возвращаемое значение:
//	ТаблицаЗначений - содержит результат выполнения запроса к регистру штрихкодов номенклатуры
//					  с отбором по значению переданного штрихкода
Функция ГлЯдро_ПолучитьДанныеНоменклатурыПоШтрихкоду(Штрихкод, МетаданныеНСИ) Экспорт
	
	ТекстЗапроса = "";
	Для Каждого РеквизитХранилища Из МетаданныеНСИ.Штрихкоды.Реквизиты Цикл
		ТекстЗапроса = ТекстЗапроса + ",
		|    ХранилищеШтрихкодов." + РеквизитХранилища.Значение + " КАК " + РеквизитХранилища.Ключ;
	КонецЦикла;
	ТекстЗапроса = Сред(ТекстЗапроса, 2);
	
	Запрос = Новый Запрос;
	Запрос.Текст = 		
	"ВЫБРАТЬ" + ТекстЗапроса + "
	|ИЗ
	|    "+ МетаданныеНСИ.Штрихкоды.Путь_ОбъектМетаданных + "  КАК ХранилищеШтрихкодов
	|ГДЕ
	|	 ХранилищеШтрихкодов." + МетаданныеНСИ.Штрихкоды.Реквизиты.Штрихкод + " В(&Штрихкод)";   
	Запрос.УстановитьПараметр("ШтрихКод", Штрихкод);
	
	РезультатЗапроса = Запрос.Выполнить().Выгрузить();
	
	Возврат РезультатЗапроса;
	
КонецФункции

Функция ГлЯдро_ПолучитьЗначениеСправочникаПоID(ИмяСправочника, ID) Экспорт
	
	Если ТипЗнч(ИмяСправочника) = Тип("Строка") Тогда
		МассивИмён = Новый Массив();
		МассивИмён.Добавить(ИмяСправочника);
	ИначеЕсли ТипЗнч(ИмяСправочника) = Тип("Массив") Тогда
		МассивИмён = ИмяСправочника;
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
	ЗначениеСправочника = Справочники[МассивИмён[0]].ПустаяСсылка();
	
	Если ТипЗнч(ID) <> Тип("Строка") ИЛИ СтрДлина(ID) <> 36 Тогда
		Возврат ЗначениеСправочника;
	КонецЕсли;
	
	Для Каждого ИмяСправочникаИзМассива Из МассивИмён Цикл
		Попытка
			ПромежуточноеЗначениеСправочника = Справочники[ИмяСправочникаИзМассива].ПолучитьСсылку(Новый УникальныйИдентификатор(ID));
		Исключение
		КонецПопытки;
		Если ЗначениеЗаполнено(ПромежуточноеЗначениеСправочника) И ГлЯдро_СсылкаСуществует(ПромежуточноеЗначениеСправочника) Тогда
			ЗначениеСправочника = ПромежуточноеЗначениеСправочника;
			Прервать;
		КонецЕслИ;
	КонецЦикла;	
	
	Возврат ЗначениеСправочника;
	
КонецФункции

Функция ГлЯдро_ПолучитьТипГруппыОтбораПоСтроке(ТипГруппыСтрокой)
	
	ТипГруппыОтбора = ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаИ;
	
	Если ТипГруппыСтрокой = "Or" Тогда
		ТипГруппыОтбора = ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаИли;
	ИначеЕсли ТипГруппыСтрокой = "And" Тогда
		ТипГруппыОтбора = ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаИ;
	ИначеЕсли ТипГруппыСтрокой = "Not" Тогда
		ТипГруппыОтбора = ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаНе;
	КонецЕсли;

	Возврат ТипГруппыОтбора;
	
КонецФункции

Функция ГлЯдро_ПолучитьВидСравненияПоСтроке(ВидСравненияСтрокой)
	
	ВыбранныйВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
	
	Если ВидСравненияСтрокой = "==" Тогда
		ВыбранныйВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
	ИначеЕсли ВидСравненияСтрокой = "!=" Тогда
		ВыбранныйВидСравнения = ВидСравненияКомпоновкиДанных.НеРавно;
	ИначеЕсли ВидСравненияСтрокой = ">" Тогда
		ВыбранныйВидСравнения = ВидСравненияКомпоновкиДанных.Больше;
	ИначеЕсли ВидСравненияСтрокой = "<" Тогда
		ВыбранныйВидСравнения = ВидСравненияКомпоновкиДанных.Меньше;
	ИначеЕсли ВидСравненияСтрокой = ">=" Тогда
		ВыбранныйВидСравнения = ВидСравненияКомпоновкиДанных.БольшеИлиРавно;
	ИначеЕсли ВидСравненияСтрокой = "<=" Тогда
		ВыбранныйВидСравнения = ВидСравненияКомпоновкиДанных.МеньшеИлиРавно;
	ИначеЕсли ВидСравненияСтрокой = "Contains" Тогда
		ВыбранныйВидСравнения = ВидСравненияКомпоновкиДанных.Содержит;
	ИначеЕсли ВидСравненияСтрокой = "StartsWith" Тогда
		ВыбранныйВидСравнения = ВидСравненияКомпоновкиДанных.НачинаетсяС;
	КонецЕсли;
	
	Возврат ВыбранныйВидСравнения;
	
КонецФункции

Функция ГлЯдро_ПолучитьЗначениеДляОтбора(ИмяТаблицы, ИмяПоля, ЗначениеПоля, МетаданныеНСИ,АдресаПеременных)
	
	НовоеЗначениеПоля = ЗначениеПоля;
	
	Если ИмяТаблицы = "Характеристики" И МетаданныеНСИ.Характеристики.Использование Тогда
		Если ИмяПоля = "КлючХарактеристик" Тогда
			НовоеЗначениеПоля = ГлЯдро_ПолучитьЗначениеСправочникаПоID(МетаданныеНСИ.Характеристики.Владельцы, ЗначениеПоля);
		ИначеЕсли ИмяПоля = "Ид" Тогда
			НовоеЗначениеПоля = ГлЯдро_ПолучитьЗначениеСправочникаПоID(МетаданныеНСИ.Характеристики.ИмяСправочника, ЗначениеПоля);
		КонецЕсли;
	КонецЕсли;
	
	Если ИмяТаблицы = "Серии" И МетаданныеНСИ.Серии.Использование Тогда
		Если ИмяПоля = "КлючСерий" Тогда
			НовоеЗначениеПоля = ГлЯдро_ПолучитьЗначениеСправочникаПоID(МетаданныеНСИ.Серии.Владельцы, ЗначениеПоля);
		ИначеЕсли ИмяПоля = "Ид" Тогда
			НовоеЗначениеПоля = ГлЯдро_ПолучитьЗначениеСправочникаПоID(МетаданныеНСИ.Серии.ИмяСправочника, ЗначениеПоля);
		ИначеЕсли ИмяПоля = "ДатаСерии"  И ТипЗнч(ЗначениеПоля) = Тип("Строка") Тогда
			#Если Не ВебКлиент тогда
				НовоеЗначениеПоля = ПрочитатьДатуJSON(ЗначениеПоля,ФорматДатыJSON.ISO);					
			#КонецЕсли
		КонецЕсли;
	КонецЕсли;
	
	Если ИмяТаблицы = "Склады" Тогда
		Если ИмяПоля = "Ид" ИЛИ ИмяПоля = "ИдРодителя" Тогда
			НовоеЗначениеПоля = ГлЯдро_ПолучитьЗначениеСправочникаПоID(МетаданныеНСИ.Склады.ИмяСправочника, ЗначениеПоля);
		КонецЕсли;
	КонецЕсли;
	
	Если ИмяТаблицы = "Контрагенты" Тогда
		Если ИмяПоля = "Ид" ИЛИ ИмяПоля = "ИдРодителя" Тогда
			НовоеЗначениеПоля = ГлЯдро_ПолучитьЗначениеСправочникаПоID(МетаданныеНСИ.Контрагенты.ИмяСправочника, ЗначениеПоля);
		КонецЕсли;
	КонецЕсли;
	
	Если ИмяТаблицы = "Остатки" Тогда
		Если ИмяПоля = "ИдСклада" Тогда
			МассивИменСправочников = Новый Массив;
			МассивИменСправочников.Добавить(МетаданныеНСИ.Склады.ИмяСправочника);	
			Если МетаданныеНСИ.Свойство("Помещения") И МетаданныеНСИ.Помещения.Свойство("ИмяСправочника") Тогда
				МассивИменСправочников.Добавить(МетаданныеНСИ.Помещения.ИмяСправочника);			
			КонецЕсли;	
			НовоеЗначениеПоля = ГлЯдро_ПолучитьЗначениеСправочникаПоID(МассивИменСправочников, ЗначениеПоля);
		ИначеЕсли ИмяПоля = "ИдНоменклатуры" ИЛИ ИмяПоля = "ИдТовара" Тогда
			НовоеЗначениеПоля = ГлЯдро_ПолучитьЗначениеСправочникаПоID(МетаданныеНСИ.Номенклатура.ИмяСправочника, ЗначениеПоля);
		ИначеЕсли ИмяПоля = "ИдХарактеристики" Тогда
			НовоеЗначениеПоля = ГлЯдро_ПолучитьЗначениеСправочникаПоID(МетаданныеНСИ.Характеристики.ИмяСправочника, ЗначениеПоля);
		ИначеЕсли ИмяПоля = "ИдСерии" Тогда
			НовоеЗначениеПоля = ГлЯдро_ПолучитьЗначениеСправочникаПоID(МетаданныеНСИ.Серии.ИмяСправочника, ЗначениеПоля);
		ИначеЕсли ИмяПоля = "ИдЯчейки" Тогда
			Если МетаданныеНСИ.Свойство("Ячейки") И МетаданныеНСИ.Ячейки.Свойство("ИмяСправочника") Тогда
				НовоеЗначениеПоля = ГлЯдро_ПолучитьЗначениеСправочникаПоID(МетаданныеНСИ.Ячейки.ИмяСправочника, ЗначениеПоля);
			КонецЕсли;
		ИначеЕсли ИмяПоля = "ИдЕдиницыИзмерения" Тогда
			НовоеЗначениеПоля = ГлЯдро_ПолучитьЗначениеСправочникаПоID(МетаданныеНСИ.ЕдиницыИзмерения.ИмяСправочника, ЗначениеПоля);
		ИначеЕсли ИмяПоля = "ИдТранспортнойУпаковки" Тогда
			Если МетаданныеНСИ.Свойство("ТранспортныеУпаковки") И МетаданныеНСИ.ТранспортныеУпаковки.Свойство("ИмяСправочника") Тогда
				НовоеЗначениеПоля = ГлЯдро_ПолучитьЗначениеСправочникаПоID(МетаданныеНСИ.ТранспортныеУпаковки.ИмяСправочника, ЗначениеПоля);
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	Если ИмяТаблицы = "Цены" Тогда
		Если ИмяПоля = "ИдНоменклатуры" ИЛИ ИмяПоля = "ИдТовара" Тогда
			НовоеЗначениеПоля = ГлЯдро_ПолучитьЗначениеСправочникаПоID(МетаданныеНСИ.Номенклатура.ИмяСправочника, ЗначениеПоля);
		ИначеЕсли ИмяПоля = "Упаковка" Тогда
			НовоеЗначениеПоля = ГлЯдро_ПолучитьЗначениеСправочникаПоID(МетаданныеНСИ.ЕдиницыИзмерения.ИмяСправочника, ЗначениеПоля);
			Если НЕ ГлЯдро_СсылкаСуществует(НовоеЗначениеПоля) Тогда
				НовоеЗначениеПоля = ГлЯдро_ПолучитьЗначениеСправочникаПоID(МетаданныеНСИ.Номенклатура.БазоваяЕдиницаИзмерения.ИмяСправочника, ЗначениеПоля);
			КонецЕсли;
		ИначеЕсли ИмяПоля = "ИдХарактеристики" Тогда
			НовоеЗначениеПоля = ГлЯдро_ПолучитьЗначениеСправочникаПоID(МетаданныеНСИ.Характеристики.ИмяСправочника, ЗначениеПоля);
		КонецЕсли;
	КонецЕсли;
	
	Если ИмяТаблицы = "ДопРеквизиты" Тогда
		Если ИмяПоля = "ИдТовара" Тогда
			НовоеЗначениеПоля = ГлЯдро_ПолучитьЗначениеСправочникаПоID(МетаданныеНСИ.Номенклатура.ИмяСправочника, ЗначениеПоля);						
		КонецЕсли;
	КонецЕсли;	
	
	Если ИмяТаблицы = "Резерв" Тогда		
		Если ИмяПоля = "ИдДокумента" Тогда			
			ТаблицаБизнесПроцессов = ГлЯдро_ПолучитьИзКэшаЗначениеТабличнойНастройкиSMARTS("НастройкиБизнесПроцессов", Новый Структура("ТипДокументаMS", "ПодборЗаказа"),,АдресаПеременных);			
			Если ТипЗнч(ТаблицаБизнесПроцессов) = Тип("ТаблицаЗначений") ИЛИ ТипЗнч(ТаблицаБизнесПроцессов) = Тип("Массив") Тогда				
				НовоеЗначениеПоля = Неопределено;				
				Для Каждого СтрокаТЗ из ТаблицаБизнесПроцессов Цикл					
					Если ТипЗнч(СтрокаТЗ) = Тип("Структура") И СтрокаТЗ.Свойство("ЭтоТаблицаЗначений") И СтрокаТЗ.ЭтоТаблицаЗначений Тогда
						Продолжить;
					КонецЕсли;						
					ТипДокумента1С = СтрокаТЗ.ТипИсходногоДокумента1С;															
					Попытка
						Если Найти(Документы[ТипДокумента1С].ПолучитьСсылку(Новый УникальныйИдентификатор(ЗначениеПоля)), "бъект") = 0 Тогда
							НовоеЗначениеПоля = Документы[ТипДокумента1С].ПолучитьСсылку(Новый УникальныйИдентификатор(ЗначениеПоля));
						КонецЕсли;
					Исключение
					КонецПопытки;					
					Если ЗначениеЗаполнено(НовоеЗначениеПоля) Тогда
						Прервать;
					КонецЕсли;										
				КонецЦикла;				
			КонецЕсли;						
		КонецЕсли;			
	КонецЕсли;
	
	Возврат НовоеЗначениеПоля;
	
КонецФункции

Функция ГлЯдро_ВыполнитьПроизвольныйКод(ТекстПроизвольногоКода, СтруктураПеременных, ID_ПроизвольногоКода = Неопределено, ИмяПроизвольногоКода, АдресаПеременных) Экспорт
	
	ИмяСобытия = "ГлЯдро_ВыполнитьПроизвольныйКод";
	
	Результат = "";
	РезультатСтатус = Истина;
	СообщениеПользователю = "";
	
	ВыполняемыйКод = "";
	Для Каждого ИмяПеременной Из СтруктураПеременных Цикл
		ВыполняемыйКод = ВыполняемыйКод + ИмяПеременной.Ключ + " = СтруктураПеременных." + ИмяПеременной.Ключ + ";" + Символы.ВК;
	КонецЦикла;
	ВыполняемыйКод = ВыполняемыйКод + Символы.ВК + ТекстПроизвольногоКода;
	
	Попытка
		Если ID_ПроизвольногоКода = "" Тогда
			//Сюда вставить текст произвольного кода для его отладки, что бы началась отладка, в условие нужно вставить его ID_ПроизвольногоКода
		Иначе
			//Выполнить(ВыполняемыйКод);
			СтрокаВызова = ВыполняемыйКод;
			СтрокаВызова = СтрЗаменить(СтрокаВызова, "Результат", "Параметры.Результат");
			СтрокаВызова = СтрЗаменить(СтрокаВызова, "Док1СПараметры.Результат", "Док1СРезультат"); // Обратная замена нужна чтоб не ломать переменную Док1СРезультат
			СтрокаВызова = СтрЗаменить(СтрокаВызова, "СтруктураПеременных", "Параметры.СтруктураПеременных");
			ПараметрыАлгоритма = Новый Структура;
			ПараметрыАлгоритма.Вставить("Результат", 			Результат);
			ПараметрыАлгоритма.Вставить("СтруктураПеременных", 	СтруктураПеременных);
			ГлЯдро_ВыполнитьВБезопасномРежиме(СтрокаВызова, ПараметрыАлгоритма, АдресаПеременных);
			Результат = ПараметрыАлгоритма.Результат;
		КонецЕсли;
	Исключение
		ИнфоОбОшибке = ИнформацияОбОшибке();
		СообщениеПользователю = "Ошибка выполнения произвольного кода " + ИмяПроизвольногоКода + ": " + ПодробноеПредставлениеОшибки(ИнфоОбОшибке);
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", СообщениеПользователю,, АдресаПеременных);		
		РезультатСтатус = Ложь;
	КонецПопытки;	

	РезультатВыполненияКода = Новый Структура("Статус, Данные, СообщениеПользователю", РезультатСтатус, Результат, СообщениеПользователю);
	
	Возврат РезультатВыполненияКода;
	
КонецФункции

Функция ГлЯдро_ВыполнитьПроизвольныйОбработчик(СтруктураВызова,АдресаПеременных)
	
	Результат = Неопределено;
	
	ТипМетода = СтруктураВызова.ТипМетода;
	ИмяМетода = СтруктураВызова.ИмяМетода;
	
	СтрокаПараметровМетода = "";
	Если СтруктураВызова.Свойство("ПараметрыМетода") Тогда
		ПараметрыМетода = СтруктураВызова.ПараметрыМетода;
		Для Каждого Параметр Из ПараметрыМетода Цикл
			СтрокаПараметровМетода = СтрокаПараметровМетода + ", ПараметрыМетода." + Параметр.Ключ;
		КонецЦикла;
		СтрокаПараметровМетода = Сред(СтрокаПараметровМетода, 3);
	КонецЕсли;
	
	СтруктураИО = КомЯдро_ПолучитьЗначениеПеременной("ИнтеграционнаяОбработка",АдресаПеременных);
		
	Если (СтруктураИО = Неопределено
		ИЛИ НЕ ТипЗнч(СтруктураИО) = Тип("Структура")
		ИЛИ НЕ СтруктураИО.Свойство("ИнтеграционнаяОбработка")
		ИЛИ СтруктураИО.ИнтеграционнаяОбработка = Неопределено)
		И НЕ ГлЯдро_ПересоздатьИнтеграционнуюОбработку(АдресаПеременных) Тогда
		Возврат Неопределено;
	КонецЕсли;
	СтруктураИО = КомЯдро_ПолучитьЗначениеПеременной("ИнтеграционнаяОбработка",АдресаПеременных);
	ИнтеграционнаяОбработка = СтруктураИО.ИнтеграционнаяОбработка;
	
	СтрокаВызова = "ИнтеграционнаяОбработка." + ИмяМетода + "(" + СтрокаПараметровМетода + ");";
	Если ТипМетода = "Функция" Тогда
		СтрокаВызова = "Результат = " + СтрокаВызова;
	КонецЕсли;
	
	//Выполнить(СтрокаВызова);
	СтрокаВызова = СтрЗаменить(СтрокаВызова, "Результат", "Параметры.Результат");
	СтрокаВызова = СтрЗаменить(СтрокаВызова, "Док1СПараметры.Результат", "Док1СРезультат"); // Обратная замена нужна чтоб не ломать переменную Док1СРезультат
	СтрокаВызова = СтрЗаменить(СтрокаВызова, "ИнтеграционнаяОбработка", "Параметры.ИнтеграционнаяОбработка");
	СтрокаВызова = СтрЗаменить(СтрокаВызова, "ПараметрыМетода", "Параметры.ПараметрыМетода");
	ПараметрыАлгоритма = Новый Структура;
	ПараметрыАлгоритма.Вставить("Результат", 				Результат);
	ПараметрыАлгоритма.Вставить("ИнтеграционнаяОбработка", 	ИнтеграционнаяОбработка);
	ПараметрыАлгоритма.Вставить("ПараметрыМетода", 			ПараметрыМетода);
	ГлЯдро_ВыполнитьВБезопасномРежиме(СтрокаВызова, ПараметрыАлгоритма, АдресаПеременных);
	Результат = ПараметрыАлгоритма.Результат;

	Возврат Результат;
	
КонецФункции

Процедура ГлЯдро_ОчиститьКолонкуТаблицыЗначений(ИсходнаяТаблица, ИмяКолонки)
	
	ЗначениеДляЗаполнения = Неопределено;
	
	ТипыЗначенийКолонки = ИсходнаяТаблица.Колонки[ИмяКолонки].ТипЗначения.Типы();
	
	Если ТипыЗначенийКолонки.Количество() = 1 Тогда
		
		ТипКолонкиСтрокой = Строка(ТипыЗначенийКолонки[0]);
		
		// Сравнение типов строкой не работает для англоязычной версии платформы и для ссылочных типов
		ТипВсеСправочники  = Справочники.ТипВсеСсылки();
		ТипВсеДокументы    = Документы.ТипВсеСсылки();
		ТипВсеПеречисление = Перечисления.ТипВсеСсылки();
		
		ТипКолонки = ТипыЗначенийКолонки[0];
		
		ОбъектМетаданных = Метаданные.НайтиПоТипу(ТипКолонки);
		
		Если ТипКолонки = Тип("Число") Тогда
			ЗначениеДляЗаполнения = 0;
		ИначеЕсли ТипКолонки = Тип("Строка") Тогда
			ЗначениеДляЗаполнения = "";
		ИначеЕсли ТипКолонки = Тип("Дата") Тогда
			ЗначениеДляЗаполнения = Дата(1,1,1);
		ИначеЕсли ТипКолонки = Тип("Булево") Тогда
			ЗначениеДляЗаполнения = Ложь;
		ИначеЕсли ТипВсеСправочники.СодержитТип(ТипКолонки) И ОбъектМетаданных <> Неопределено Тогда
			ЗначениеДляЗаполнения = Справочники[ОбъектМетаданных.Имя].ПустаяСсылка();
		ИначеЕсли ТипВсеДокументы.СодержитТип(ТипКолонки) И ОбъектМетаданных <> Неопределено Тогда
			ЗначениеДляЗаполнения = Документы[ОбъектМетаданных.Имя].ПустаяСсылка();
		ИначеЕсли ТипВсеПеречисление.СодержитТип(ТипКолонки) И ОбъектМетаданных <> Неопределено Тогда
			ЗначениеДляЗаполнения = Перечисления[ОбъектМетаданных.Имя].ПустаяСсылка();			
		КонецЕсли;
		
	КонецЕсли;
	
	ИсходнаяТаблица.ЗаполнитьЗначения(ЗначениеДляЗаполнения, ИмяКолонки);
	
КонецПроцедуры

// Возвращает значения глобальных параметров для текущего узла в сессии Mobile Smarts
//
// Параметры:
//	ОбщиеПараметры - Неопределено, Структура - содержит значения глобальных параметров
//	ЧастныеПараметры - Неопределено, Структура - содержит значения глобальных параметров,
//												 указанные для текущего узла в сессии Mobile Smarts
//	ID_Узла - Строка - идентификатор узла в текущей сессии Mobile Smarts
//	АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
//
// Возвращаемое значение:
//	Массив из Структура - содержит:
//		* Типовой - Булево
//		* ID_Параметра - Строка
//		* Наименование - Строка
//		* Значение - Произвольный
//      * Комментарий - Строка
//      * Использование - Булево
//      * Тип - Строка
//      * ЗначениеПоУмолчанию - Произвольный
Функция ГлЯдро_ПолучитьЗначенияГлобальныхПараметров(ОбщиеПараметры = Неопределено, ЧастныеПараметры = Неопределено, ID_Узла = "", АдресаПеременных) Экспорт

	ТаблицаПараметров = Новый Массив;
	
	ДанныеТекущегоУзла = КомЯдро_ПолучитьЗначениеПеременной("ДанныеТекущегоУзла", АдресаПеременных);
	
	Если ID_Узла = ""
		И ТипЗнч(ДанныеТекущегоУзла) = Тип("Структура")
		И ДанныеТекущегоУзла.ID_Узла <> "" Тогда
		ID_Узла = ДанныеТекущегоУзла.ID_Узла;		
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(ОбщиеПараметры) ИЛИ ОбщиеПараметры = Ложь Тогда
		ОбщиеПараметры = ГлЯдро_ПолучитьИзКэшаНастройкуSMARTS("ГлобальныеПараметры",, АдресаПеременных);
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(ЧастныеПараметры) ИЛИ ЧастныеПараметры = Ложь Тогда // И ЗначениеЗаполнено(ID_Узла)
		ЧастныеПараметры = ГлЯдро_ПолучитьИзКэшаНастройкуSMARTS("ГлобальныеПараметры_Значения",, АдресаПеременных);
	КонецЕсли;
	
	Если ТипЗнч(ОбщиеПараметры) = Тип("Массив") Тогда
		Для Каждого СтрокаОбщегоПараметра Из ОбщиеПараметры Цикл
			Если СтрокаОбщегоПараметра.Свойство("ЭтоТаблицаЗначений") Тогда
				Продолжить;
			КонецЕсли;
			
			пПараметр = ГлЯдро_ПолучитьОписаниеГлобальногоПараметра(СтрокаОбщегоПараметра);
			
			ТаблицаПараметров.Добавить(пПараметр);
		КонецЦикла;
	КонецЕсли;
	
	Если ТипЗнч(ЧастныеПараметры) = Тип("Массив") Тогда
		Для Каждого СтрокаЧастногоПараметра Из ЧастныеПараметры Цикл
			Если СтрокаЧастногоПараметра.Свойство("ЭтоТаблицаЗначений") Тогда
				Продолжить;
            КонецЕсли;
			
			Если НЕ СтрокаЧастногоПараметра.Свойство("Использование")
				ИЛИ НЕ СтрокаЧастногоПараметра.Использование Тогда
				Продолжить;	
			КонецЕсли;
			
			ОбновляемаяСтрокаПараметра = ГлЯдро_НайтиПоЗначениюВМассивеСтруктур(ТаблицаПараметров, "ID_Параметра", СтрокаЧастногоПараметра.ID_Параметра);
			Если ОбновляемаяСтрокаПараметра <> Неопределено Тогда
				ОбновляемаяСтрокаПараметра.Значение 	 = СтрокаЧастногоПараметра.Значение;
				ОбновляемаяСтрокаПараметра.Использование = Истина;
				ОбновляемаяСтрокаПараметра.Тип 	 		 = Строка(ТипЗнч(СтрокаЧастногоПараметра.Значение));
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Возврат ТаблицаПараметров;
	
КонецФункции

Функция ГлЯдро_ПолучитьОписаниеГлобальногоПараметра(СтрокаПараметра)
	
	пПараметр = ГлЯдро_ПолучитьСтруктуруОписанияГлобальногоПараметра();
	
	ЗаполнитьЗначенияСвойств(пПараметр, СтрокаПараметра);
		
	СинонимДляЗапроса = пПараметр.Наименование; 
	СинонимДляЗапроса = СтрЗаменить(СинонимДляЗапроса, " ", "_");
	СинонимДляЗапроса = СтрЗаменить(СинонимДляЗапроса, "(", "");
	СинонимДляЗапроса = СтрЗаменить(СинонимДляЗапроса, ")", "");
	пПараметр.Вставить("СинонимДляЗапроса", СинонимДляЗапроса);
			
	пПараметр.Тип 				  = Строка(ТипЗнч(пПараметр.Значение));
	пПараметр.Использование 	  = Истина;
	пПараметр.ЗначениеПоУмолчанию = пПараметр.Значение;
	
	Возврат пПараметр;
	
КонецФункции

Функция ГлЯдро_ПолучитьСтруктуруОписанияГлобальногоПараметра()

	СтруктураПараметра = Новый Структура;
	
	СтруктураПараметра.Вставить("Типовой");
	СтруктураПараметра.Вставить("ID_Параметра");
	СтруктураПараметра.Вставить("Наименование");
	СтруктураПараметра.Вставить("Значение");
	СтруктураПараметра.Вставить("Комментарий");
	СтруктураПараметра.Вставить("Тип");
	СтруктураПараметра.Вставить("Использование");
	СтруктураПараметра.Вставить("ЗначениеПоУмолчанию");
	СтруктураПараметра.Вставить("СинонимДляЗапроса");
			
	Возврат СтруктураПараметра;	
	
КонецФункции

Функция ГлЯдро_НайтиПоЗначениюВМассивеСтруктур(Массив,КлючПоиска,Значене)
	Для Каждого ЭлементМассива Из Массив Цикл
		Если ЭлементМассива.Свойство(КлючПоиска) И ЭлементМассива[КлючПоиска] = Значене Тогда
			Возврат ЭлементМассива;	
		КонецЕсли;
	КонецЦикла;
	Возврат Неопределено;
КонецФункции

// Определяет наличие штрихкода в базе 1С путем выполнения запроса
// к объекту метаданных, в котором хранятся штрихкоды номенклатуры
//
// Параметры:
//	Штрихкод - Строка	
//  СтруктураХраненияШК - Структура - содержит:
//		* ШК_ОбъектМетаданных - Строка - имя объекта метаданных, в котором хранятся штрихкоды номенклатуры
//      * ШК_ИзмерениеШтрихкода - Строка - имя реквизита объекта метаданных, в котором хранятся значения штрихкодов
//
// Возвращаемое значение:
//	Булево - флаг наличия штрихкода в базе 1С
Функция ГлЯдро_ШтрихКодЕстьВБазе1С(Штрихкод, СтруктураХраненияШК) Экспорт
			
	Запрос = Новый Запрос("ВЫБРАТЬ
							|    Штрихкоды." + СтруктураХраненияШК.ШК_ИзмерениеШтрихкода + " КАК Штрихкод
							|ИЗ
							|    " + СтруктураХраненияШК.ШК_ОбъектМетаданных + " КАК Штрихкоды
							|ГДЕ
							|	Штрихкоды." + СтруктураХраненияШК.ШК_ИзмерениеШтрихкода + " = &Штрихкод");   
	
	Запрос.УстановитьПараметр("ШтрихКод", Штрихкод);
	
	Возврат НЕ Запрос.Выполнить().Пустой();	
	
КонецФункции

// Вызывает функцию получения данных штрихкода из интеграционной обработки
//
// Параметры:
//	Штрихкод - Строка - штрихкод, данные которого требуется получить	
//	АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
//
// Возвращаемое значение:
//	Структура - содержит данные штрихкода, полученные путем выполнения запроса
//				к объекту метаданных, содержащему штрихкоды номенклатуры
Функция ГлЯдро_ПолучитьДанныеШтрихКода(Штрихкод,АдресаПеременных) Экспорт
	
	СтруктураИО = КомЯдро_ПолучитьЗначениеПеременной("ИнтеграционнаяОбработка",АдресаПеременных);
		
	Если (СтруктураИО = Неопределено
		ИЛИ НЕ ТипЗнч(СтруктураИО) = Тип("Структура")
		ИЛИ НЕ СтруктураИО.Свойство("ИнтеграционнаяОбработка")
		ИЛИ СтруктураИО.ИнтеграционнаяОбработка = Неопределено)
		И НЕ ГлЯдро_ПересоздатьИнтеграционнуюОбработку(АдресаПеременных) Тогда
		Возврат Неопределено;
	КонецЕсли;
	СтруктураИО = КомЯдро_ПолучитьЗначениеПеременной("ИнтеграционнаяОбработка",АдресаПеременных);
	ИнтеграционнаяОбработка = СтруктураИО.ИнтеграционнаяОбработка;
	
	Попытка
		Возврат ИнтеграционнаяОбработка.ГлЯдро_ПолучитьДанныеШтрихКода(Штрихкод);
	Исключение
		ИмяСобытия = "ГлЯдро_ПолучитьДанныеШтрихКода";
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Предупреждение", "Не удалось получить данные штрихкода: " + Строка(Штрихкод), , АдресаПеременных);
	КонецПопытки;
	
КонецФункции

// Вызывает функцию получения единицы измерения по умолчанию из интеграционной обработки
//
// Параметры:
//	ТоварСсылка - СправочникСсылка.Номенклатура - ссылка на элемент номенклатуры, единицу измерения которого требуется получить	
//  АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
//
// Возвращаемое значение:
//	- СправочникСсылка.[ИмяОбъектаМетаданныхСодержащегоЕдиницыИзмерения] - единица измерения переданной номенклатуры
//	- Неопределено - если единицу измерения получить не удалось
Функция ГлЯдро_ПолучитьЕдиницуИзмеренияПоУмолчанию(ТоварСсылка,АдресаПеременных) Экспорт		
	
	СтруктураИО = КомЯдро_ПолучитьЗначениеПеременной("ИнтеграционнаяОбработка",АдресаПеременных);
		
	Если (СтруктураИО = Неопределено
		ИЛИ НЕ ТипЗнч(СтруктураИО) = Тип("Структура")
		ИЛИ НЕ СтруктураИО.Свойство("ИнтеграционнаяОбработка")
		ИЛИ СтруктураИО.ИнтеграционнаяОбработка = Неопределено)
		И НЕ ГлЯдро_ПересоздатьИнтеграционнуюОбработку(АдресаПеременных) Тогда
		Возврат Неопределено;
	КонецЕсли;
	СтруктураИО = КомЯдро_ПолучитьЗначениеПеременной("ИнтеграционнаяОбработка",АдресаПеременных);
	ИнтеграционнаяОбработка = СтруктураИО.ИнтеграционнаяОбработка;
	
	Попытка
		Возврат ИнтеграционнаяОбработка.ГлЯдро_ПолучитьЕдиницуИзмеренияПоУмолчанию(ТоварСсылка);
	Исключение
		ИмяСобытия = "ГлЯдро_ПолучитьЕдиницуИзмеренияПоУмолчанию";
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Предупреждение", "Не удалось получить единицу измерения по умолчанию для товара: " + Строка(ТоварСсылка), , АдресаПеременных);
	КонецПопытки;
	
КонецФункции

// Вызывает функцию получения из интеграционной обработки информации совместимости интеграционной обработки
//
// Параметры:
//	АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
//
// Возвращаемое значение:
//	- Структура - содержит:	
//		* ВерсияИнтеграции - Строка
//		* ВерсияAPI - Строка
//		* ПоддерживаемаяКонфигурацияМассивИмен - Массив из Строка
//		* ПоддерживаемаяКонфигурацияСиноним - Строка
//		* флСоответствуетКонфигурации - Булево
//		* ПоддерживаемыеВерсииКонфигурации - Строка
//		* флСоответствуетВерсии - Булево
//		* ПутьКФайлу - Строка
//	- Неопределено - если информацию совместимости получить не удалось
Функция ГлЯдро_ПолучитьИнформациюСовместимости(АдресаПеременных) Экспорт		
	
	СтруктураИО = КомЯдро_ПолучитьЗначениеПеременной("ИнтеграционнаяОбработка",АдресаПеременных);
		
	Если (СтруктураИО = Неопределено
		ИЛИ НЕ ТипЗнч(СтруктураИО) = Тип("Структура")
		ИЛИ НЕ СтруктураИО.Свойство("ИнтеграционнаяОбработка")
		ИЛИ СтруктураИО.ИнтеграционнаяОбработка = Неопределено)
		И НЕ ГлЯдро_ПересоздатьИнтеграционнуюОбработку(АдресаПеременных) Тогда
		Возврат Неопределено;
	КонецЕсли;
	СтруктураИО = КомЯдро_ПолучитьЗначениеПеременной("ИнтеграционнаяОбработка",АдресаПеременных);
	ИнтеграционнаяОбработка = СтруктураИО.ИнтеграционнаяОбработка;
	
	Попытка
		ИнформацияСовместимости = ИнтеграционнаяОбработка.ИнформацияСовместимости();
		ИнформацияСовместимости.Вставить("ПутьКФайлу",СтруктураИО.ПутьКФайлу);
		Возврат ИнформацияСовместимости;
	Исключение
		ИмяСобытия = "ГлЯдро_ПолучитьИнформациюСовместимости";
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Предупреждение", "Не удалось получить информацию совместимости интеграционной обработки", , АдресаПеременных);
	КонецПопытки;
	
КонецФункции

// Возвращает флаг наличия типа документа в структуре метаданных 1С
//
// Параметры:
//	ИмяТипаДокумента - Строка - имя типа, наличие которого требуется проверить	
//  АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
//
// Возвращаемое значение:
//	Булево
Функция ГлЯдро_ТипДокументаЕстьВ1С(ИмяТипаДокумента,АдресаПеременных) Экспорт
	
	СтруктураМетаданных = КомЯдро_ПолучитьЗначениеПеременной("СтруктураМетаданных",АдресаПеременных);
	
	ДокументСуществует = Ложь;
	
	Для каждого ТипДокумента Из СтруктураМетаданных.Документы1С Цикл
		Если ВРег(СокрЛП(ТипДокумента.Значение.Имя)) = ВРег(СокрЛП(ИмяТипаДокумента)) Тогда
			ДокументСуществует = Истина;
			Прервать;
		КонецЕсли;	
	КонецЦикла;
	
	Возврат ДокументСуществует;

КонецФункции

// Возвращает значение реквизита настройки бизнес-процесса
//
// Параметры:
//	НастройкаБП - Структура - содержит настройку бизнес-процесса, значение реквизита которой требуется получить
//	ИмяРеквизита - Строка - имя реквизита, значение которого требуется получить из настройки бизнес-процесса
//
// Возвращаемое значение:
//	- Произвольный - значение реквизита настройки бизнес-процесса
//	- Неопределено - если в настройке бизнес-процесса нет переданного реквизита
//					 или его значение не заполнено
Функция ГлЯдро_ПолучитьЗначениеРеквизитаНастройкиБизнесПроцесса(НастройкаБП, ИмяРеквизита) Экспорт
	
	Если НастройкаБП.Свойство(ИмяРеквизита) Тогда
		ЗначениеРеквизита = НастройкаБП[ИмяРеквизита];
	Иначе	
		ЗначениеРеквизита = Неопределено;
	КонецЕсли;	
	
	Возврат ЗначениеРеквизита;
	
КонецФункции	

// Формирует подробное сообщение о выгрузке таблицы на сервер Mobile Smarts
//
// Параметры:
//	Сообщение - Строка - результат выгрузки таблицы
//  ПредставлениеВремениОбщее - Строка - текстовое представление общего времени выгрузки
//  ПредставлениеВремени1С - Строка - текстовое представление времени получения данных из 1С
//  ПредставлениеВремениMS - Строка - текстовое представление времени выгрузки данных на сервер Mobile Smarts
//
// Возвращаемое значение:
//	Строка	
Функция ГлЯдро_СформироватьПодробноеСообщениеОВыгрузкеТаблицы(Знач Сообщение, ПредставлениеВремениОбщее, ПредставлениеВремени1С, ПредставлениеВремениMS) Экспорт

	Результат = Сообщение;	
	
	Результат = Результат 
				+ Символы.ВК + "Затраченное время:"
				+ Символы.ВК + Символы.Таб + "- " + ПредставлениеВремениОбщее 	+ " - общее время выгрузки"
				+ Символы.ВК + Символы.Таб + "- " + ПредставлениеВремени1С 		+ " - на построение таблицы в 1С"
				+ Символы.ВК + Символы.Таб + "- " + ПредставлениеВремениMS 		+ " - на выгрузку данных в Mobile SMARTS"
				+ Символы.ВК + Символы.ВК;	
				
	Возврат Результат;				

КонецФункции

// Вызывает функцию получения из интеграционной обработки списка доступных реквизитов
// для формирования представлений документов, выгружаемых в базу SMARTS
//
// Параметры:
//	ИмяДокумента1С - Строка - название документа 1С
//  АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
//
// Возвращаемое значение:
//	- СписокЗначений - - список реквизитов документа
//  - Неопределено - если дополнительные реквизиты получить не удалось
Функция ГлЯдро_ПолучитьДопРеквизитыПредставленияДокумента(ИмяДокумента1С,АдресаПеременных) Экспорт
	
	СтруктураИО = КомЯдро_ПолучитьЗначениеПеременной("ИнтеграционнаяОбработка",АдресаПеременных);
		
	Если (СтруктураИО = Неопределено
		ИЛИ НЕ ТипЗнч(СтруктураИО) = Тип("Структура")
		ИЛИ НЕ СтруктураИО.Свойство("ИнтеграционнаяОбработка")
		ИЛИ СтруктураИО.ИнтеграционнаяОбработка = Неопределено)
		И НЕ ГлЯдро_ПересоздатьИнтеграционнуюОбработку(АдресаПеременных) Тогда
		Возврат Неопределено;
	КонецЕсли;
	СтруктураИО = КомЯдро_ПолучитьЗначениеПеременной("ИнтеграционнаяОбработка",АдресаПеременных);
	ИнтеграционнаяОбработка = СтруктураИО.ИнтеграционнаяОбработка;
	
	Результат = Неопределено;
	
	Попытка
		//Выполнить("Результат = ИнтеграционнаяОбработка.ПолучитьДопРеквизитыПредставленияДокумента(ИмяДокумента1С)");
		СтрокаВызова = "Результат = ИнтеграционнаяОбработка.ПолучитьДопРеквизитыПредставленияДокумента(ИмяДокумента1С)";
		СтрокаВызова = СтрЗаменить(СтрокаВызова, "Результат", "Параметры.Результат");
		СтрокаВызова = СтрЗаменить(СтрокаВызова, "ИнтеграционнаяОбработка", "Параметры.ИнтеграционнаяОбработка");
		ПараметрыАлгоритма = Новый Структура;
		ПараметрыАлгоритма.Вставить("Результат", Результат);
		ПараметрыАлгоритма.Вставить("ИнтеграционнаяОбработка", ИнтеграционнаяОбработка);
		ГлЯдро_ВыполнитьВБезопасномРежиме(СтрокаВызова, ПараметрыАлгоритма, АдресаПеременных);
		Результат = ПараметрыАлгоритма.Результат;
	Исключение
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции

Функция ГлЯдро_ПолучитьПредставлениеДокументаПоНастройкам(Документ1С, ТаблицаНастроек)
	
	СтрокаПредставлениеДокумента = "";

	Для Каждого РеквизитНастроек Из ТаблицаНастроек Цикл
		Если НЕ РеквизитНастроек.Свойство("ИспользоватьПриВыгрузке") 
			ИЛИ НЕ РеквизитНастроек.ИспользоватьПриВыгрузке Тогда
			Продолжить;
		КонецЕсли;
		СтрокаПредставлениеДокумента = СтрокаПредставлениеДокумента+?(СтрокаПредставлениеДокумента = "","",", ") +Документ1С[РеквизитНастроек.НазваниеРеквизита];	
	КонецЦикла;
	
	Возврат СтрокаПредставлениеДокумента;
КонецФункции

// Выполняет запись события в журнал регистрации
//
// Параметры:
//	ИмяСобытия - Строка - имя события	
//  УровеньСтрокой - Строка - уровень события строкой
//  Комментарий - Строка - комментарий
//  НачалоСобытия - Неопределено, Число - универсальная дата начала события в миллисекундах
//  АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
Процедура ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, УровеньСтрокой, Комментарий, НачалоСобытия = Неопределено,АдресаПеременных)  Экспорт
	
	// Режимы отладки:
	// "Полный"
	// "ТолькоОшибки", по умолчанию и если режим не задан, то режим "ТолькоОшибки",
	// "БезОтладки", никакая интформация не пишется в ЖР
	РежимОтладки = ГлЯдро_ПолучитьИзКэшаНастройкуSMARTS("РежимОтладки",,АдресаПеременных);
	
	АвтотестКлеверенс = КомЯдро_ПолучитьЗначениеПеременной("Автотест",АдресаПеременных);
	Если АвтотестКлеверенс = Неопределено Тогда
		АвтотестКлеверенс = Ложь;
	КонецЕсли;
	
	Данные = "MobileSMARTSLog"; // Чтобы отличать записи ЖР, сделанные обработкой, от других записей ЖР
	Если АвтотестКлеверенс Тогда		
		Данные 					= КомЯдро_ПолучитьЗначениеПеременной("ИдАвтотеста",АдресаПеременных);
		
		РасположениеКомпоненты 	= КомЯдро_ПолучитьЗначениеПеременной("РасположениеКомпоненты",АдресаПеременных);
		Если РасположениеКомпоненты = "НаСервере" И Ложь Тогда	//Пока закрою этот кусок. Пригодится когда понадобится дублирование записей в ЖР и в лог не только в автотестах
			ПутьКОбщемуЛогу = КомЯдро_ПолучитьЗначениеПеременной("ПутьКОбщемуЛогу",АдресаПеременных);
			ПутьКЛогуОшибок = КомЯдро_ПолучитьЗначениеПеременной("ПутьКЛогуОшибок",АдресаПеременных);
			
			Если ПутьКОбщемуЛогу <> Неопределено И ПутьКЛогуОшибок <> Неопределено Тогда
				ГлЯдро_ДобавитьЗаписьВЛог(ПутьКОбщемуЛогу,ИмяСобытия +". "+Комментарий);
				
				Если УровеньСтрокой = "Ошибка" Тогда
					ГлЯдро_ДобавитьЗаписьВЛог(ПутьКЛогуОшибок,ИмяСобытия +". "+Комментарий);
				КонецЕсли;
			КонецЕсли
		КонецЕсли;
	КонецЕсли;
	
	Если РежимОтладки = Неопределено ИЛИ РежимОтладки = Ложь Тогда
		РежимОтладки = "ТолькоОшибки";
	ИначеЕсли РежимОтладки = "БезОтладки" И Не АвтотестКлеверенс Тогда
		Возврат
	КонецЕсли;
	
	СтрокаМС = "";
	Если НачалоСобытия <> Неопределено
		И ТипЗнч(НачалоСобытия) = Тип("Число") Тогда
		ВремяКонцаСобытия = ТекущаяУниверсальнаяДатаВМиллисекундах();
		ВремяВыполненияВМиллисекундах = ВремяКонцаСобытия-НачалоСобытия;
		СтрокаМС = " ("+Формат(ВремяВыполненияВМиллисекундах,"ЧГ=") + " мс.)";
	КонецЕсли;
	
	Если УровеньСтрокой = "Информация" Тогда
		Уровень = УровеньЖурналаРегистрации.Информация;
	ИначеЕсли УровеньСтрокой = "Ошибка" Тогда	
		Уровень = УровеньЖурналаРегистрации.Ошибка;		
	ИначеЕсли УровеньСтрокой = "Предупреждение" Тогда
		Уровень = УровеньЖурналаРегистрации.Предупреждение;
	ИначеЕсли УровеньСтрокой = "Примечание" Тогда
		Уровень = УровеньЖурналаРегистрации.Примечание;			
	Иначе
		Уровень = УровеньЖурналаРегистрации.Информация;	
	КонецЕсли;
	
	ОсновнойРаздел = ?(АвтотестКлеверенс,"КлеверенсАвтотесты.","КлеверенсТСД.");
	
	Если РежимОтладки = "ТолькоОшибки" 
		И (Уровень = УровеньЖурналаРегистрации.Ошибка ИЛИ Уровень = УровеньЖурналаРегистрации.Предупреждение) Тогда
		ЗаписьЖурналаРегистрации(ОсновнойРаздел + ИмяСобытия, Уровень, ,Данные , Комментарий + СтрокаМС);	
	ИначеЕсли РежимОтладки = "Полный" ИЛИ РежимОтладки = "ВсяИнформация" Или АвтотестКлеверенс Тогда	
		ЗаписьЖурналаРегистрации(ОсновнойРаздел + ИмяСобытия, Уровень, ,Данные , Комментарий + СтрокаМС);
	Иначе
		Возврат
	КонецЕсли; 
	 		
КонецПроцедуры

// Выполняет запись события в файл лога в базе Mobile SMARTS
//
// Параметры:
//	ПутьКФайлу - Строка - путь к файлу	
//  ТекстЗаписи - Строка - текст ошибки
//	СТаймштампом - Булево (необязательный) - с добавлением даты к тексту. Значение по умолчанию:Истина.
Процедура ГлЯдро_ДобавитьЗаписьВЛог(ПутьКФайлу, ТекстЗаписи,СТаймштампом = Истина) Экспорт	
	ФайлЛога = Новый Файл(ПутьКФайлу);
	Если Не ФайлЛога.Существует() Тогда
		Возврат;
	Конецесли;
	
	ВремяСобытия = Формат(ТекущаяДата(),"ДЛФ=DT");
	
	ЗаписьЛога = Новый ЗаписьТекста(ПутьКФайлу,КодировкаТекста.UTF8,,Истина);
	ЗаписьЛога.ЗаписатьСтроку(?(СТаймштампом,ВремяСобытия+Символы.Таб,"")+ТекстЗаписи);
	ЗаписьЛога.Закрыть();
	
КонецПроцедуры

// Выполняет удаление файла лога в базе Mobile SMARTS
//
// Параметры:
//	ПутьКФайлу - Строка - путь к файлу	
Процедура ГлЯдро_УдалитьФайлЛога(ПутьКФайлу) Экспорт	
	
	ФайлЛога = Новый Файл(ПутьКФайлу);
	Если Не ФайлЛога.Существует() Тогда
		Возврат;
	Конецесли;
	
	УдалитьФайлы(ПутьКФайлу);
	
КонецПроцедуры

Процедура ГлЯдро_ОтправитьЛогПоПочте(ПутьКФайлу, ПараметрыОтправкиПочты, АдресаПеременных) Экспорт	
	
	Если ПараметрыОтправкиПочты = Неопределено Тогда
		Возврат;
	Конецесли;
	МассивПолучателей = ПараметрыОтправкиПочты.МассивПолучателей;
			
	АдресSMTP 	= ПараметрыОтправкиПочты.АдресSMTP;
	ПортSMTP 	= ПараметрыОтправкиПочты.ПортSMTP;
	ЛогинSMTP 	= ПараметрыОтправкиПочты.ЛогинSMTP;
	ПарольSMTP 	= ПараметрыОтправкиПочты.ПарольSMTP;
	ОтправительSMTP 	= ПараметрыОтправкиПочты.ОтправительSMTP;
	
	Если МассивПолучателей.Количество() = 0 
		Или Не ЗначениеЗаполнено(АдресSMTP) 
		Или Не ЗначениеЗаполнено(ПортSMTP)
		Или Не ЗначениеЗаполнено(ЛогинSMTP)
		Или Не ЗначениеЗаполнено(ПарольSMTP) Тогда 
		Возврат;
	КонецЕсли;

	#Область НесовместимыйКодFresh
	СисИнфо = ГлЯдро_ПолучитьСистемнуюИнформациюДляШапкиЛога(АдресаПеременных);
		
	Профиль = Вычислить("Новый ИнтернетПочтовыйПрофиль");	
    Профиль.АдресСервераSMTP 	= АдресSMTP;
	Профиль.ПортSMTP 			= ПортSMTP;
	Профиль.ПользовательSMTP 	= ЛогинSMTP;
	Профиль.ПарольSMTP 			= ПарольSMTP;
	Профиль.ИспользоватьSSLSMTP = Истина;
	Профиль.АутентификацияSMTP 	= Вычислить("СпособSMTPАутентификации.Login");
	
	Если ОтправительSMTP =  "" Тогда
		ОтправительSMTP = "autotest1c@cleverence.ru";
	КонецЕсли;
		
	Письмо = Вычислить("Новый ИнтернетПочтовоеСообщение");
	Текст = Письмо.Тексты.Добавить("Ошибки занесены в лог-файл во вложении, ознакомьтесь и передайте разработчикам!");
	Текст.ТипТекста = Вычислить("ТипТекстаПочтовогоСообщения.ПростойТекст");
	Письмо.Тема = "Автотесты 1С: Ошибка при прохождении тестов в базе "+СисИнфо.ИнформацияСтруктурой.ИмяБазы1С; 
	Письмо.Отправитель = ОтправительSMTP;
	Для Каждого Получатель Из МассивПолучателей Цикл
		Письмо.Получатели.Добавить(Получатель);
	КонецЦикла;
	
	Письмо.Вложения.Добавить(ПутьКФайлу);
	
	Почта = Вычислить("Новый ИнтернетПочта");
	ЕстьПодключениеКПочтовомуСерверу = Истина;
	Попытка
		Почта.Подключиться(Профиль);		
	Исключение
		ЕстьПодключениеКПочтовомуСерверу = Ложь;;
		ТекстОшибки = "Не удалось подключиться к почтовому серверу: " + ОписаниеОшибки(); 
		Сообщить(ТекстОшибки);
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации("ГлЯдро_ОтправитьЛогПоПочте", "Ошибка", ТекстОшибки,,АдресаПеременных);
	КонецПопытки;
	
	Если ЕстьПодключениеКПочтовомуСерверу Тогда
		Попытка
			РезультатОтправки = Почта.Послать(Письмо);		
		Исключение			
			ТекстОшибки = "Не удалось отправить письмо: " + ОписаниеОшибки(); 
			Сообщить(ТекстОшибки);
			ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации("ГлЯдро_ОтправитьЛогПоПочте", "Ошибка", ТекстОшибки,,АдресаПеременных);
		КонецПопытки;
	КонецЕсли;

	Почта.Отключиться();	
	#КонецОбласти //НесовместимыйКодFresh
	
КонецПроцедуры

// Записывает новый файл, в который в последующем будут добавляться записи лога
//
// Возвращаемое значение:
//	Булево, Неопределено - при удачной записи возвращается значение Истина.
Функция ГлЯдро_ЗаписатьНачалоЛога(РабочийКаталог = Неопределено, АдресаПеременных) Экспорт
	
	СисИнфо = ГлЯдро_ПолучитьСистемнуюИнформациюДляШапкиЛога(АдресаПеременных);
	ШапкаЛога = СисИнфо.ШапкаЛога;
	Если РабочийКаталог <> Неопределено Тогда
		// Если передан рабочий каталог с клиента, то формируем временные имена файлов		
		РабочийКаталог = КаталогВременныхФайлов();
		
		//ЛогОбщий = Новый ЗаписьТекста(ПутьКОбщемуЛогу,КодировкаТекста.UTF8,,Ложь);
		//ЛогОбщий.Записать(ШапкаЛога);
		//ЛогОбщий.Закрыть();
		//
		//ЛогОшибок = Новый ЗаписьТекста(ПутьКЛогуОшибок,КодировкаТекста.UTF8,,Ложь);
		//ЛогОшибок.Записать(ШапкаЛога);
		//ЛогОшибок.Закрыть();		
		
	Иначе
		РабочийКаталог = СисИнфо.РабочийКаталог;
	КонецЕсли;
	
	ИмяФайлаОбщегоЛога = КомЯдро_ПолучитьЗначениеПеременной("ИмяФайлаОбщегоЛога", АдресаПеременных);
	ИмяФайлаЛогаОшибок = КомЯдро_ПолучитьЗначениеПеременной("ИмяФайлаЛогаОшибок", АдресаПеременных);
	Если ИмяФайлаЛогаОшибок = Неопределено
		Или ИмяФайлаЛогаОшибок = Неопределено Тогда
		ВызватьИсключение "Не удалось получить имя файла лога";
	КонецЕсли;
	
	ПутьКОбщемуЛогу = РабочийКаталог+ИмяФайлаОбщегоЛога+Формат(ТекущаяДата(),"ДФ=dd.MM.yy")+".txt";
	ПутьКЛогуОшибок = РабочийКаталог+ИмяФайлаЛогаОшибок+Формат(ТекущаяДата(),"ДФ=dd.MM.yy")+".txt";
	
	ЛогОбщий = Новый ЗаписьТекста(ПутьКОбщемуЛогу,КодировкаТекста.UTF8,,Ложь);
	ЛогОбщий.Записать(ШапкаЛога);
	ЛогОбщий.Закрыть();
	
	ЛогОшибок = Новый ЗаписьТекста(ПутьКЛогуОшибок,КодировкаТекста.UTF8,,Ложь);
	ЛогОшибок.Записать(ШапкаЛога);
	ЛогОшибок.Закрыть();		
	
	КомЯдро_СохранитьЗначениеПеременной("ПутьКОбщемуЛогу",ПутьКОбщемуЛогу,АдресаПеременных);
	КомЯдро_СохранитьЗначениеПеременной("ПутьКЛогуОшибок",ПутьКЛогуОшибок,АдресаПеременных);
	
	Возврат Истина;
КонецФункции

// Выполняется отбор событий из журнала регистрации по идентификатору автотеста, возвращается в виде текста
// Возвращаемое значение:
//  - Структура
//		* ДанныеЖурналаОбщий - Строка - Строка с данными по всем событиям
//		* ДанныеЖурналаОшибки - Строка - Строка с данными с уровнем "Ошибка"
Функция ГлЯдро_ПолучитьДанныеЖурналаРегистрации(ДанныеДляОтбораЖР,АдресаПеременных) Экспорт
	
	НачалоПериода = КомЯдро_ПолучитьЗначениеПеременной("ДатаНачалаВыгрузкиЖР", АдресаПеременных);
	Если НачалоПериода = Неопределено Тогда
		НачалоПериода = ДобавитьМесяц(ТекущаяДата(),-1);
	КонецЕсли;
	
	СтруктураФильтра=Новый Структура;
	СтруктураФильтра.Вставить("Данные", ДанныеДляОтбораЖР);
	СтруктураФильтра.Вставить("ДатаНачала", НачалоПериода);
	КолонкиЖурнала = "Дата,Событие,Уровень,Комментарий,Сеанс,ИмяПользователя,ПредставлениеПриложения";
	ДанныеЖурнала = Новый ТаблицаЗначений;
	ВыгрузитьЖурналРегистрации(ДанныеЖурнала,СтруктураФильтра,КолонкиЖурнала);
		
	ДанныеЖурналаОбщий = "";
	ДанныеЖурналаОшибки = "";
	Для Каждого Строка Из ДанныеЖурнала Цикл
		СтрокаЛога = Строка(Строка.Дата)+Символы.Таб+Строка(Строка.Сеанс)+Символы.Таб+Строка.ПредставлениеПриложения+Символы.Таб+Строка.ИмяПользователя+Символы.Таб+СтрЗаменить(Строка.Событие,"КлеверенсАвтотесты.","")+Символы.Таб+Строка.Комментарий;
		ДанныеЖурналаОбщий = ДанныеЖурналаОбщий+СтрокаЛога+Символы.ПС;
		Если Строка.Уровень = УровеньЖурналаРегистрации.Ошибка Тогда
			ДанныеЖурналаОшибки = ДанныеЖурналаОшибки+СтрокаЛога+Символы.ПС;		
		КонецЕсли;
	КонецЦикла;
	
	СтруктураРезультата = Новый Структура("ДанныеЖурналаОбщий, ДанныеЖурналаОшибки",ДанныеЖурналаОбщий,ДанныеЖурналаОшибки);
	Возврат СтруктураРезультата;
КонецФункции

// Выполняет запись событий из журнала регистрации с отбором по идентификатору автотеста в поле Данные
// в файл лога в базе Mobile SMARTS
//
// Параметры:
//	ДанныеДляОтбораЖР - Строка - строка, по которой будет наложен отбор на записи журнала регистрации
//	МассивПолучателей - Массив - массив адресов эл почты, на которые необходимо отправить лог
//
Процедура ГлЯдро_ВыгрузитьЛогИзЖурналаРегистрации(ДанныеДляОтбораЖР, ПараметрыОтправкиПочты = Неопределено, АдресаПеременных)Экспорт
	
	ДанныеЖурнала = ГлЯдро_ПолучитьДанныеЖурналаРегистрации(ДанныеДляОтбораЖР, АдресаПеременных);
	ДанныеЖурналаОбщий = ДанныеЖурнала.ДанныеЖурналаОбщий;
	ДанныеЖурналаОшибки = ДанныеЖурнала.ДанныеЖурналаОшибки;
	
	ПутьКОбщемуЛогу = КомЯдро_ПолучитьЗначениеПеременной("ПутьКОбщемуЛогу",АдресаПеременных);
	ПутьКЛогуОшибок = КомЯдро_ПолучитьЗначениеПеременной("ПутьКЛогуОшибок",АдресаПеременных);
		
	Если ПутьКОбщемуЛогу <> Неопределено И ДанныеЖурналаОбщий <> "" Тогда
		ГлЯдро_ДобавитьЗаписьВЛог(ПутьКОбщемуЛогу,ДанныеЖурналаОбщий,Ложь);
	КонецЕсли;
	
	Если ПутьКЛогуОшибок <> Неопределено Тогда 
		Если ДанныеЖурналаОшибки <> "" Тогда
			ГлЯдро_ДобавитьЗаписьВЛог(ПутьКЛогуОшибок,ДанныеЖурналаОшибки,Ложь);
			ГлЯдро_ОтправитьЛогПоПочте(ПутьКЛогуОшибок, ПараметрыОтправкиПочты, АдресаПеременных);			
		Иначе
			ГлЯдро_УдалитьФайлЛога(ПутьКЛогуОшибок);
		КонецЕсли;
	КонецЕсли;
	
	Файл = Новый Файл(ПутьКОбщемуЛогу);
		
	Если Файл.Существует() Тогда
		
		ДвоичныеДанные = Новый ДвоичныеДанные(ПутьКОбщемуЛогу);
		АдресФайлаОбщегоЛога = ПоместитьВоВременноеХранилище(ДвоичныеДанные);
		УдалитьФайлы(ПутьКОбщемуЛогу);
		КомЯдро_СохранитьЗначениеПеременной("ПутьКОбщемуЛогу", АдресФайлаОбщегоЛога, АдресаПеременных);
		
	КонецЕсли;

	Файл = Новый Файл(ПутьКЛогуОшибок);
		
	Если Файл.Существует() Тогда
		
		ДвоичныеДанные = Новый ДвоичныеДанные(ПутьКЛогуОшибок);
		АдресФайлаОбщегоЛога = ПоместитьВоВременноеХранилище(ДвоичныеДанные);
		УдалитьФайлы(ПутьКЛогуОшибок);
		КомЯдро_СохранитьЗначениеПеременной("ПутьКЛогуОшибок", АдресФайлаОбщегоЛога, АдресаПеременных);
		
	КонецЕсли;
	
КонецПроцедуры

// Возвращает информацию об используемой платформе и текущей конфигурации
// Возвращаемое значение:
//  - Структура
//		* ШапкаЛога - Строка - Строка с системной информацией
//		* РабочийКаталог - Строка - Каталог расположения базы Mobile SMARTS
Функция ГлЯдро_ПолучитьСистемнуюИнформациюДляШапкиЛога(АдресаПеременных) Экспорт
	
	//ИнформацияОКонфигурации = Новый Структура("Платформа1С,РазрядностьПлатформы1С,ИмяКонфигурации1С,СинонимКонфигурации1С,
	//										|ВерсияКонфигурации1С,ОперативнаяПамять,ВерсияОС");
	
	ТипИнтерфейса 			= КомЯдро_ПолучитьЗначениеПеременной("ТипИнтерфейса",АдресаПеременных);
	пПараметрыПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("ПараметрыПодключенияMS",АдресаПеременных);
	РасположениеКомпоненты	= КомЯдро_ПолучитьЗначениеПеременной("РасположениеКомпоненты",АдресаПеременных);
	СтруктураИО 			= КомЯдро_ПолучитьЗначениеПеременной("ИнтеграционнаяОбработка", АдресаПеременных);
	//РабочийКаталог = пПараметрыПодключенияMS.РабочийКаталог;
	
	СисИнфо = Новый СистемнаяИнформация;
	ВерсияОбработки = Строка(ГлЯдро_ПолучитьИнформациюОВнешнейОбработке("Версия"));
	ИмяБазы1С = НСтр(СтрокаСоединенияИнформационнойБазы(), "Ref");
	
	ИнформацияСовместимостиИО = ГлЯдро_ПолучитьИнформациюСовместимости(АдресаПеременных);
	СтрокаИнформацииВерсияИО = ?(ИнформацияСовместимостиИО = Неопределено," не подключена.",ИнформацияСовместимостиИО.ВерсияИнтеграции+", Поддерживаемые конфигурации: "+ИнформацияСовместимостиИО.ПоддерживаемаяКонфигурацияСиноним+", Поддерживаемые версии: "+ИнформацияСовместимостиИО.ПоддерживаемыеВерсииКонфигурации);
	ТипОбработки 	= ?(пПараметрыПодключенияMS = Неопределено, " не указано", ?(Не ЗначениеЗаполнено(пПараметрыПодключенияMS.ТипОбработки), "ФайлНаДиске", пПараметрыПодключенияMS.ТипОбработки));
	ПутьОбработки 	= ?(СтруктураИО = Неопределено, "", ", " + Строка(СтруктураИО.ПутьКФайлу));
	РасположениеИО 	= ТипОбработки + ПутьОбработки;
		
	ШапкаЛога = "Платформа 1С: "+СисИнфо.ВерсияПриложения+", "+Строка(СисИнфо.ТипПлатформы)+"
	|Версия ОС, RAM: "+СисИнфо.ВерсияОС+", "+ Строка(СисИнфо.ОперативнаяПамять)+"
	|Конфигурация 1С (синоним): "+Метаданные.Синоним+"
	|Имя конфигурации 1С: "+Метаданные.Имя+"
	|Версия конфигурации: "+Метаданные.Версия+"
	|Имя базы 1С: "+ИмяБазы1С+"
	|Имя подключенной базы Mobile SMARTS: "+пПараметрыПодключенияMS.Имя+"
	|Код подключенной базы Mobile SMARTS: "+пПараметрыПодключенияMS.Ид+"
	|Строка подключения к базе Mobile SMARTS: "+пПараметрыПодключенияMS.СтрокаПодключенияСМАРТС+"
	|ТипИнтерфейса, РасположениеКомпоненты: "+ТипИнтерфейса+", "+РасположениеКомпоненты+"
	|Наименование продукта: "+пПараметрыПодключенияMS.ИмяПриложения+"
	|Версия продукта: "+пПараметрыПодключенияMS.ВерсияПриложения+"
	|Уровень продукта: "+пПараметрыПодключенияMS.УровеньПриложенияСтрокой+"
	|Версия обработки: "+ВерсияОбработки+"
	|Версия ИО: "+СтрокаИнформацииВерсияИО+"
	|Расположение ИО: " + РасположениеИО + "
	|==========================================================================================
	| Дата события || Номер сеанса || Имя приложения || Пользователь || Событие || Комментарий
	|==========================================================================================
	|";
	
	ИнформацияСтруктурой = Новый Структура;
	ИнформацияСтруктурой.Вставить("Платформа1С",СисИнфо.ВерсияПриложения);
	ИнформацияСтруктурой.Вставить("ТипПлатформы1С",Строка(СисИнфо.ТипПлатформы));
	ИнформацияСтруктурой.Вставить("ВерсияОС",СисИнфо.ВерсияОС);
	ИнформацияСтруктурой.Вставить("ОперативнаяПамять",Строка(СисИнфо.ОперативнаяПамять));
	ИнформацияСтруктурой.Вставить("СинонимКонфигурации1С",Метаданные.Синоним);
	ИнформацияСтруктурой.Вставить("ИмяКонфигурации1С",Метаданные.Имя);
	ИнформацияСтруктурой.Вставить("ВерсияКонфигурации1С",Метаданные.Версия);
	ИнформацияСтруктурой.Вставить("ИмяБазы1С",ИмяБазы1С);
	ИнформацияСтруктурой.Вставить("ИмяБазыМС",пПараметрыПодключенияMS.Имя);
	ИнформацияСтруктурой.Вставить("ИдБазыМС",пПараметрыПодключенияMS.Ид);
	ИнформацияСтруктурой.Вставить("СтрокаПодключенияБазыМС",пПараметрыПодключенияMS.СтрокаПодключенияСМАРТС);
	ИнформацияСтруктурой.Вставить("ТипИнтерфейса",ТипИнтерфейса);
	ИнформацияСтруктурой.Вставить("РасположениеКомпоненты",РасположениеКомпоненты);
	ИнформацияСтруктурой.Вставить("ИмяПриложения",пПараметрыПодключенияMS.ИмяПриложения);
	ИнформацияСтруктурой.Вставить("ВерсияПриложения",пПараметрыПодключенияMS.ВерсияПриложения);
	ИнформацияСтруктурой.Вставить("УровеньПриложения",пПараметрыПодключенияMS.УровеньПриложенияСтрокой);
	ИнформацияСтруктурой.Вставить("ВерсияОбработки",ВерсияОбработки);
	ИнформацияСтруктурой.Вставить("ВерсияИнтеграционнойОбработки",СтрокаИнформацииВерсияИО);	
	
	ИнформацияОКонфигурации = Новый Структура("ШапкаЛога,РабочийКаталог,ИнформацияСтруктурой",ШапкаЛога,пПараметрыПодключенияMS.РабочийКаталог,ИнформацияСтруктурой);
	Возврат ИнформацияОКонфигурации;
КонецФункции

Функция ГлЯдро_СвернутьТаблицуЗначений(ТаблицаЗначений, КолонкиСуммирования = "")
	КолонкиГруппировок = "";
	Для каждого Колонка Из ТаблицаЗначений.Колонки Цикл
		Если НЕ Найти(ВРег(СокрЛП(КолонкиСуммирования)), ВРег(СокрЛП(Колонка.Имя))) Тогда
			КолонкиГруппировок = КолонкиГруппировок + Колонка.Имя + ",";
		КонецЕсли;	
	КонецЦикла; 
	ТаблицаЗначений.Свернуть(КолонкиГруппировок, КолонкиСуммирования);
	
	Возврат Истина;
КонецФункции // СвернутьТаблицуЗначений()

Функция ГлЯдро_ТаблицаЗначенийВCOMSafeArray(ТаблицаЗначений)
	
	Результат = Новый COMSafeArray("VT_VARIANT", ТаблицаЗначений.Количество() + 1);
	
	Колонки = Новый Массив;
	Для каждого Колонка Из ТаблицаЗначений.Колонки Цикл
		Колонки.Добавить(Колонка.Имя);			
	КонецЦикла; 
	
	КолонкиArr = Новый COMSafeArray(Колонки, "VT_BSTR", Колонки.Количество()); 
	
	Результат.SetValue(0, КолонкиArr);
	
	Инд = 1;
	Для каждого Строка Из ТаблицаЗначений Цикл
		
		СтрокаРезультата = Новый Массив;
		
		Для каждого Колонка Из ТаблицаЗначений.Колонки Цикл
			СтрокаРезультата.Добавить(?(ЗначениеЗаполнено(Строка[Колонка.Имя]), Строка[Колонка.Имя], ""));
	    	КонецЦикла; 
		
		СтрокаРезультатаArr = Новый COMSafeArray(СтрокаРезультата, "VT_VARIANT", СтрокаРезультата.Количество()); 
		
		Результат.SetValue(Инд, СтрокаРезультатаArr);
				
		Инд = Инд + 1;	
	
	КонецЦикла; 
	
	Возврат Результат;
	
КонецФункции	

// Выполняет поиск в массиве структур по заданным ключу и значению ключа
//
// Параметры:
//	МассивСтруктур - Массив из Структура - массив структур, в котором выполняетчся поиск
//	КлючПоиска - Строка - ключ структуры, по которому выполняется поиск
//	ЗначениеПоиска - Произвольный - значение ключа структуры, по которому выполняется поиск
//	ВернутьИндекс - Булево - флаг необходимости вернуть индекс элемента массива, а не сам элемент
//
// Возвращаемое значение:
//	- Число - индекс найденного элемента массива, если ВернутьИндекс = Истина
//	- Структура - значение найденного элемента массива, если ВернутьИндекс = Ложь
//	- Неопределено - если элемент массива найти не удалось
Функция ГлЯдро_НайтиСтруктуруВМассивеПоЭлементу(МассивСтруктур, КлючПоиска, ЗначениеПоиска,ВернутьИндекс=Ложь) Экспорт
	
	Если ТипЗнч(МассивСтруктур) <> Тип("Массив") 
		ИЛИ КлючПоиска = "" 
		ИЛИ ЗначениеПоиска = Неопределено Тогда
		// переданные параметры некорректны 
		Возврат Неопределено;
	КонецЕсли;
	
	НайденноеЗначениеЭлемента = Неопределено;
	Индекс = -1;
	Для каждого ЭлементМассива Из МассивСтруктур Цикл
		Индекс = Индекс + 1;
		Если ТипЗнч(ЭлементМассива) <> Тип("Структура") Тогда
			Продолжить;
		КонецЕсли;  
		
		Если ЭлементМассива.Свойство(КлючПоиска, НайденноеЗначениеЭлемента) Тогда
			Если НайденноеЗначениеЭлемента = ЗначениеПоиска Тогда
				Возврат ?(ВернутьИндекс,Индекс,ЭлементМассива);
			КонецЕсли; 
		КонецЕсли; 
	
	КонецЦикла; 
	
	Возврат Неопределено;

КонецФункции // НайтиСтруктуруВМассивеПоЭлементу()

// Выполняет обновление структуры настроек бизнес-процессов
//
// Параметры:
//	НастройкиБизнесПроцессов - Массив из Структура - содержит настройки бизнес-процессов
//							 - Строка - адрес временного хранилища, по которому хранятся настройки бизнес-процессов
//  НастройкиОбновились - Булево - флаг того, что настройки обновились
//  ВернутьАдресХранилища - Булево - флаг того, что необходимо вернуть адрес хранилища
//	АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
//
// Возвращаемое значение:
//	- Массив из Структура - содержит обновленные настройки бизнес-процессов, если ВернутьАдресХранилища = Ложь
//	- Строка - адрес временного хранилища, по которому хранятся обновленные настройки бизнес-процессов, если ВернутьАдресХранилища = Истина
Функция ГлЯдро_ОбновитьСтруктуруНастроекБизнесПроцессов(Знач НастройкиБизнесПроцессов,НастройкиОбновились,ВернутьАдресХранилища=Ложь,АдресаПеременных) Экспорт

	Если НЕ ЗначениеЗаполнено(НастройкиБизнесПроцессов) ИЛИ НастройкиБизнесПроцессов = Ложь Тогда			
		Возврат НастройкиБизнесПроцессов;
	КонецЕсли;	
	
	Если ЭтоАдресВременногоХранилища(НастройкиБизнесПроцессов) Тогда
		НастройкиБизнесПроцессов = ПолучитьИзВременногоХранилища(НастройкиБизнесПроцессов);		
	КонецЕсли;
	
	Если НастройкиБизнесПроцессов.Количество() = 0 ИЛИ НЕ НастройкиБизнесПроцессов[0].Свойство("КолонкиТаблицыЗначений") Тогда
		Возврат Ложь;	
	КонецЕсли;
	
	//Временная Заплатка (
	ЕстьИзменение = Ложь;
	Для Каждого СтрокаНастройки из НастройкиБизнесПроцессов Цикл
		Если СтрокаНастройки.Свойство("IDБизнесПроцесса") Тогда
			СтрокаНастройки.Вставить("ID_БизнесПроцесса",СтрокаНастройки.IDБизнесПроцесса);
			СтрокаНастройки.Удалить("IDБизнесПроцесса");
			ЕстьИзменение = Истина;
		КонецЕсли;
	КонецЦикла;
	
	// Проверка на то, что бизнес-процессы уже сконвертированы
	Если НЕ ЕстьИзменение Тогда
		Возврат НастройкиБизнесПроцессов;
	КонецЕсли; 
	
	Если ЕстьИзменение Тогда
		НастройкиБизнесПроцессов[0].КолонкиТаблицыЗначений = СтрЗаменить(НастройкиБизнесПроцессов[0].КолонкиТаблицыЗначений,"IDБизнесПроцесса","ID_БизнесПроцесса");
	КонецЕсли;
	//Временная Заплатка )
	
	НастройкиОбновились = Ложь;	
	Колонки = ГлЯдро_РазложитьСтрокуВМассивПодстрок(НастройкиБизнесПроцессов[0].КолонкиТаблицыЗначений, ",");
	
	СтруктураМетаданных = КомЯдро_ПолучитьЗначениеПеременной("СтруктураМетаданных",АдресаПеременных);
	
	СписокКолонокДляПреобразования = Новый Соответствие;
	Если Колонки.Найти("ИсходныйДокумент1С") <> Неопределено Тогда
		СписокКолонокДляПреобразования.Вставить("ИсходныйДокумент1С","ТипИсходногоДокумента1С");
		//Исправим значение синонимов на типы
		Для Каждого СтрокаНастройки Из НастройкиБизнесПроцессов Цикл
			Если СтрокаНастройки.Свойство("ЭтоТаблицаЗначений") ИЛИ НЕ ЗначениеЗаполнено(СтрокаНастройки.ИсходныйДокумент1С) Тогда
				Продолжить;
			КонецЕсли;
			
			Документ1С = Неопределено;
			Попытка
				Документ1С = СтруктураМетаданных.Документы1С[СтрокаНастройки.ИсходныйДокумент1С];
			Исключение
				Попытка 
					Документ1С = СтруктураМетаданных.Документы1С[СтрокаНастройки.ИсходныйДокумент1ССиноним];
				Исключение
				КонецПопытки;
			КонецПопытки;
			Если Документ1С = Неопределено Тогда
				СтрокаНастройки.Используется = Ложь;
			    СтрокаНастройки.ИсходныйДокумент1С = "";
			Иначе
				СтрокаНастройки.ИсходныйДокумент1С = Документ1С.Имя;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	Если Колонки.Найти("ДокументПриемник") <> Неопределено Тогда
		СписокКолонокДляПреобразования.Вставить("ДокументПриемник","ТипРезультирующегоДокумента1С");
		//Исправим значение синонимов на типы
		Для Каждого СтрокаНастройки Из НастройкиБизнесПроцессов Цикл
			Если СтрокаНастройки.Свойство("ЭтоТаблицаЗначений") ИЛИ НЕ ЗначениеЗаполнено(СтрокаНастройки.ДокументПриемник) Тогда
				Продолжить;
			КонецЕсли;
			Документ1С = Неопределено;
			Попытка
				Документ1С = СтруктураМетаданных.Документы1С[СтрокаНастройки.ДокументПриемник];
			Исключение
				Попытка 
					Документ1С = СтруктураМетаданных.Документы1С[СтрокаНастройки.Приемник1ССиноним];
				Исключение
				КонецПопытки;
			КонецПопытки;
			Если Документ1С = Неопределено Тогда
				СтрокаНастройки.Используется = Ложь;
			    СтрокаНастройки.ДокументПриемник = "";
			Иначе
				СтрокаНастройки.ДокументПриемник = Документ1С.Имя;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	Если Колонки.Найти("НастройкиЗагрузкиТЧ") <> Неопределено Тогда
		СписокКолонокДляПреобразования.Вставить("НастройкиЗагрузкиТЧ","НастройкаЗагрузкиТЧ");
	КонецЕсли;
	
	Если Колонки.Найти("ИсходныйДокумент1ССиноним") <> Неопределено Тогда
		СписокКолонокДляПреобразования.Вставить("ИсходныйДокумент1ССиноним","$Удалить");
	КонецЕсли;
	Если Колонки.Найти("Приемник1ССиноним") <> Неопределено Тогда
		СписокКолонокДляПреобразования.Вставить("Приемник1ССиноним","$Удалить");
	КонецЕсли;
	Если Колонки.Найти("ДокументMSСиноним") <> Неопределено Тогда
		СписокКолонокДляПреобразования.Вставить("ДокументMSСиноним","$Удалить");
	КонецЕсли;
	Если Колонки.Найти("БазаMobileSMARTS") <> Неопределено Тогда
		СписокКолонокДляПреобразования.Вставить("БазаMobileSMARTS","$Удалить");
	КонецЕсли;
	Если Колонки.Найти("НастроитьПравилаВыгрузкиТЧ") <> Неопределено Тогда
		СписокКолонокДляПреобразования.Вставить("НастроитьПравилаВыгрузкиТЧ","$Удалить");
	КонецЕсли;
	Если Колонки.Найти("НастроитьПравилаВыгрузкиШапки") <> Неопределено Тогда
		СписокКолонокДляПреобразования.Вставить("НастроитьПравилаВыгрузкиШапки","$Удалить");
	КонецЕсли;
	Если Колонки.Найти("НастроитьПравилаЗагрузкиШапки") <> Неопределено Тогда
		СписокКолонокДляПреобразования.Вставить("НастроитьПравилаЗагрузкиШапки","$Удалить");
	КонецЕсли;
	Если Колонки.Найти("НастроитьСоставЗагрузкиТЧ") <> Неопределено Тогда
		СписокКолонокДляПреобразования.Вставить("НастроитьСоставЗагрузкиТЧ","$Удалить");
	КонецЕсли;
	Если Колонки.Найти("ТекстЗапросаЗагрузкаСТДС") <> Неопределено Тогда
		СписокКолонокДляПреобразования.Вставить("ТекстЗапросаЗагрузкаСТДС","$Удалить");
	КонецЕсли;
	
	Если Колонки.Найти("НастройкаПредставленийРеквизитовДокумента") = Неопределено Тогда
		СписокКолонокДляПреобразования.Вставить("НастройкаПредставленийРеквизитовДокумента", "$Добавить");
	КонецЕсли;
	Если Колонки.Найти("ЗаменитьПредставлениеДокументаПриВыгрузке") = Неопределено Тогда
		СписокКолонокДляПреобразования.Вставить("ЗаменитьПредставлениеДокументаПриВыгрузке", "$Добавить");
	КонецЕсли;
	Если Колонки.Найти("ЭтоТиповойБизнесПроцесс") = Неопределено Тогда
		СписокКолонокДляПреобразования.Вставить("ЭтоТиповойБизнесПроцесс", "$Добавить");
	КонецЕсли;
	Если Колонки.Найти("Комментарий") = Неопределено Тогда
		СписокКолонокДляПреобразования.Вставить("Комментарий", "$Добавить");
	КонецЕсли;
	Если Колонки.Найти("КоллективнаяРабота") = Неопределено Тогда
		СписокКолонокДляПреобразования.Вставить("КоллективнаяРабота", "$Добавить");
	КонецЕсли;
	Если Колонки.Найти("СоздаватьНовыйДокументПриЗагрузке") = Неопределено Тогда
		СписокКолонокДляПреобразования.Вставить("СоздаватьНовыйДокументПриЗагрузке", "$Добавить");//Новый ОписаниеТипов("Булево"));
	КонецЕсли;
	Если Колонки.Найти("НазначитьПользователю") = Неопределено Тогда
		СписокКолонокДляПреобразования.Вставить("НазначитьПользователю", "$Добавить");// Новый ОписаниеТипов("Строка"));
	КонецЕсли;
	Если Колонки.Найти("КопияДокументаДляКаждогоПользователя") = Неопределено Тогда
		СписокКолонокДляПреобразования.Вставить("КопияДокументаДляКаждогоПользователя", "$Добавить");// Новый ОписаниеТипов("Булево"));
	КонецЕсли;
	Если Колонки.Найти("ЗаписыватьДокументПослеЗагрузки") = Неопределено Тогда
		СписокКолонокДляПреобразования.Вставить("ЗаписыватьДокументПослеЗагрузки", "$Добавить");//Новый ОписаниеТипов("Булево"));
	КонецЕсли;
	Если Колонки.Найти("СвязиТабличныхЧастей") = Неопределено Тогда
		СписокКолонокДляПреобразования.Вставить("СвязиТабличныхЧастей", "$Добавить");// Новый ОписаниеТипов("ТаблицаЗначений"));
	КонецЕсли;
	Если Колонки.Найти("ВыполнитьТолькоПроизвольныйКод") = Неопределено Тогда
		СписокКолонокДляПреобразования.Вставить("ВыполнитьТолькоПроизвольныйКод", "$Добавить");// Новый ОписаниеТипов("Булево"));
	КонецЕсли;
	
	// ****** +++ реализовать выгрузку из 1С из нескольких ТЧ, поэтому меняем состав столбцов ************
	
	// выполняем измененения структуры таблицы настроек только если структура осталась в старом формате (когда нельзя было выгружать несколько ТЧ 1С)
	
	Если Колонки.Найти("НастройкаВыгрузкиТЧ") <> Неопределено 
		И НастройкиБизнесПроцессов.Количество() > 1 Тогда
		КолонкиНастройкаВыгрузкиТЧ = ГлЯдро_РазложитьСтрокуВМассивПодстрок(НастройкиБизнесПроцессов[1].НастройкаВыгрузкиТЧ[0].КолонкиТаблицыЗначений, ",");	
		
		Если КолонкиНастройкаВыгрузкиТЧ.Найти("ТабличнаяЧастьДокумента1С") = Неопределено Тогда
			Соответствие = Новый Соответствие;
			Для Каждого СтрокаНастройки Из НастройкиБизнесПроцессов Цикл 
				Если СтрокаНастройки.Свойство("ЭтоТаблицаЗначений") Тогда
					Продолжить;
				КонецЕсли;
				Соответствие.Вставить(СтрокаНастройки.ID_БизнесПроцесса, СтрокаНастройки.НастройкаВыгрузкиТЧ);						
			КонецЦикла;
			
			СтруктураНовойТЗ  = Новый Структура("ЭтоТаблицаЗначений,КолонкиТаблицыЗначений",Истина,"ТабличнаяЧастьДокументаMS,НастройкаТЧСтрокой,Настроить,ТабличнаяЧастьДокумента1С,ТекстЗапросаВыгрузкиНаТСД,ТекстКодаПолучениеПараметров");					
			
			// копируем существующие настройки выгрузки ТЧ, чтобы не пропали			
			Если Колонки.Найти("ТекстЗапросаВыгрузкиНаТСД") <> Неопределено Тогда
				СписокКолонокДляПреобразования.Вставить("ТекстЗапросаВыгрузкиНаТСД","$Удалить");
			КонецЕсли;
			Для Каждого Строка Из НастройкиБизнесПроцессов Цикл 
				Если Строка.Свойство("ЭтоТаблицаЗначений") Тогда
					Продолжить;
				КонецЕсли;
				КопияТЗ = Новый Массив;
				КопияТЗ.Добавить(СтруктураНовойТЗ);
				
				СтрокаНастройки = Новый Структура(); 		
				
				СтрокаНастройки.Вставить("ТабличнаяЧастьДокументаMS","СтрокиПлан");
				СтрокаНастройки.Вставить("НастройкаТЧСтрокой",Строка.ИмяТЧ1СИсходного);
				СтрокаНастройки.Вставить("ТабличнаяЧастьДокумента1С",Соответствие[Строка.ID_БизнесПроцесса]);				
				СтрокаНастройки.Вставить("Настроить",?(СтрокаНастройки.ТабличнаяЧастьДокумента1С.Количество(), "Настроено", "Настроить"));
				
				Если Колонки.Найти("ТекстЗапросаВыгрузкиНаТСД") <> Неопределено Тогда
					СтрокаНастройки.Вставить("ТекстЗапросаВыгрузкиНаТСД",Строка.ТекстЗапросаВыгрузкиНаТСД);								
				КонецЕсли;	
				КопияТЗ.Добавить(СтрокаНастройки);
				Строка.НастройкаВыгрузкиТЧ = КопияТЗ;
			КонецЦикла;
			
		КонецЕсли;
	КонецЕсли;
	
	Если СписокКолонокДляПреобразования.Количество() > 0 Тогда
		Для Каждого Строка Из НастройкиБизнесПроцессов Цикл
			Если Строка.Свойство("ЭтоТаблицаЗначений") Тогда
				Продолжить;
			КонецЕсли;
			//Исправим структуру
			Для Каждого КолонкаДляПреобразования Из СписокКолонокДляПреобразования Цикл
				Если КолонкаДляПреобразования.Значение = "$Удалить" Тогда
					Строка.Удалить(КолонкаДляПреобразования.Ключ);
				ИначеЕсли КолонкаДляПреобразования.Значение =  "$Добавить" Тогда
					Строка.Вставить(КолонкаДляПреобразования.Ключ);
				Иначе 
					Строка.Вставить(КолонкаДляПреобразования.Значение,Строка[КолонкаДляПреобразования.Ключ]);								
					Строка.Удалить(КолонкаДляПреобразования.Ключ);
				КонецЕсли;
				
			КонецЦикла;	
		КонецЦикла;
		Для Каждого КолонкаДляПреобразования Из СписокКолонокДляПреобразования Цикл
			Если КолонкаДляПреобразования.Значение = "$Удалить" Тогда
				Колонки.Удалить(Колонки.Найти(КолонкаДляПреобразования.Ключ)); 
			ИначеЕсли КолонкаДляПреобразования.Значение =  "$Добавить" Тогда
				Колонки.Добавить(КолонкаДляПреобразования.Ключ);
			Иначе
				Индекс = Колонки.Найти(КолонкаДляПреобразования.Ключ);
				Колонки[Индекс] = КолонкаДляПреобразования.Значение;
			КонецЕсли;
		КонецЦикла;
		СтрокаКолонок = "";
		Для Каждого Колонка из Колонки Цикл
			СтрокаКолонок = СтрокаКолонок + Колонка +",";	
		КонецЦикла;
		СтрокаКолонок = Лев(СтрокаКолонок,СтрДлина(СтрокаКолонок)-1);
		НастройкиБизнесПроцессов[0].КолонкиТаблицыЗначений = СтрокаКолонок;
		НастройкиОбновились = Истина;
	КонецЕсли;
	
	//Конвертируем Настройки Выгрузки/Загрузки Полей  (
	СписокРеквизитовMSДляСовместимостиШапки = ГлЯдро_ПолучитьСписокАнглийскихНазванияПолейШапкиMS();
	СписокРеквизитовMSДляСовместимостиТЧ = ГлЯдро_ПолучитьСписокАнглийскихНазванияПолейТЧMS();
	
	//Костыль на случай конвертации
	СписокКонвертируемыхОперацийMS = Новый СписокЗначений;  
	СписокКонвертируемыхОперацийMS.Добавить("Поступление","ПриходНаСклад");
	СписокКонвертируемыхОперацийMS.Добавить("Перемещение","ПеремещениеПоСкладам");  
	СписокКонвертируемыхОперацийMS.Добавить("Возврат","ВозвратЕГАИС3");    
	СписокКонвертируемыхОперацийMS.Добавить("ВозвратЕГАИС","ВозвратЕГАИС3");
	СписокКонвертируемыхОперацийMS.Добавить("ПоступлениеЕГАИС","ПоступлениеЕГАИС3");
	СписокКонвертируемыхОперацийMS.Добавить("АлкоСборНачальныхОстатков","ПостановкаНаБалансЕГАИС3");
	СписокКонвертируемыхОперацийMS.Добавить("СписаниеЕГАИС","СписаниеЕГАИС3");
	
	Для Каждого СтрокаБП Из НастройкиБизнесПроцессов Цикл
		Если СтрокаБП.Свойство("ЭтоТаблицаЗначений") Тогда
			Продолжить;
		КонецЕсли;
		
		Если СтрокаБП.ЗагружатьВТотЖе = Истина И НЕ ЗначениеЗаполнено(СтрокаБП.ТипРезультирующегоДокумента1С) Тогда
			СтрокаБП.ТипРезультирующегоДокумента1С = СтрокаБП.ТипИсходногоДокумента1С;	
		КонецЕсли;
		
		ТипДокумента1С = СтрокаБП.ТипИсходногоДокумента1С;	
		ТипДокументаMS = ГлЯдро_ПреобразованиеНаименованияДокументаБезПробелов(СтрокаБП.ТипДокументаMS);		
		КонвертируемыйТипДокументаMS = СписокКонвертируемыхОперацийMS.НайтиПоЗначению(ТипДокументаMS);
		Если КонвертируемыйТипДокументаMS <> неопределено Тогда
			ТипДокументаMS = КонвертируемыйТипДокументаMS.Представление;
			СтрокаБП.ТипДокументаMS = КонвертируемыйТипДокументаMS.Представление; 
		КонецЕсли;
		СписокРеквизитовMS = Новый СписокЗначений;
		СписокРеквизитов1С = Новый СписокЗначений;
		Если ЗначениеЗаполнено(ТипДокументаMS) И СтруктураМетаданных.ДокументыMS.Свойство(ТипДокументаMS) Тогда
			СписокРеквизитовMS = СтруктураМетаданных.ДокументыMS[ТипДокументаMS].Реквизиты;
		КонецЕсли;
		Если ЗначениеЗаполнено(ТипДокумента1С) И СтруктураМетаданных.Документы1С.Свойство(ТипДокумента1С) Тогда
			СписокРеквизитов1С = СтруктураМетаданных.Документы1С[ТипДокумента1С].Реквизиты;
		КонецЕсли;
		
		ТаблицаРеквизитовШапки = СтрокаБП.НастройкаВыгрузкиПолей;
		Если ТаблицаРеквизитовШапки <> Неопределено Тогда
			СтрокаБП.НастройкаВыгрузкиПолей = ГлЯдро_КонвертироватьВыгрузкуПолей(ТаблицаРеквизитовШапки,СписокРеквизитовMS,СписокРеквизитов1С);	
		КонецЕсли;
		Если СтрокаБП.НастройкаВыгрузкиТЧ = Неопределено Тогда
			СтрокаБП.НастройкаВыгрузкиТЧ = Новый Массив;
		КонецЕсли;
		Для Каждого СтрокаТЧ Из СтрокаБП.НастройкаВыгрузкиТЧ Цикл
			Если СтрокаТЧ.Свойство("ЭтоТаблицаЗначений") Тогда
				Продолжить;
			КонецЕсли;
			ИмяТабличнойЧасти1С = СтрокаТЧ.НастройкаТЧСтрокой;
			ТекстЗапросаВыгрузкиНаТСД = СтрокаТЧ.ТекстЗапросаВыгрузкиНаТСД;
			ИмяТабличнойЧастиMS = СтрокаТЧ.ТабличнаяЧастьДокументаMS;
			
			Если Найти(ИмяТабличнойЧасти1С, "Запрос") Тогда
				Если ЗначениеЗаполнено(ТекстЗапросаВыгрузкиНаТСД) Тогда
					СписокРеквизитов1С = ГлЯдро_ЗаполнитьСписокПолейЗапроса(ТипДокумента1С, ТекстЗапросаВыгрузкиНаТСД);			
				КонецЕсли;	
			ИначеЕсли ЗначениеЗаполнено(ТипДокумента1С) И ЗначениеЗаполнено(ИмяТабличнойЧасти1С)
				И СтруктураМетаданных.Документы1С.Свойство(ТипДокумента1С) 
				И СтруктураМетаданных.Документы1С[ТипДокумента1С].ТабличныеЧасти.Свойство(ИмяТабличнойЧасти1С) Тогда
				СписокРеквизитов1С = СтруктураМетаданных.Документы1С[ТипДокумента1С].ТабличныеЧасти[ИмяТабличнойЧасти1С].Реквизиты;
			КонецЕсли;
			
			Если (ИмяТабличнойЧастиMS = "СтрокиПлан" 
				ИЛИ ИмяТабличнойЧастиMS = "СтрокиФакт"
				ИЛИ ИмяТабличнойЧастиMS = "СовмещенныеСтроки")
				И СтруктураМетаданных.ДокументыMS.Свойство(ТипДокументаMS) Тогда
				СписокРеквизитовMS = СтруктураМетаданных.ДокументыMS[ТипДокументаMS].РеквизитыТЧ;							
				
			ИначеЕсли (ИмяТабличнойЧастиMS = "СерииПлан" 
				ИЛИ   ИмяТабличнойЧастиMS = "СерииФакт")
				И СтруктураМетаданных.ДокументыMS.Свойство(ТипДокументаMS) Тогда
				СписокРеквизитовMS = СтруктураМетаданных.ДокументыMS[ТипДокументаMS].РеквизитыСерии;							
				
			ИначеЕсли (ИмяТабличнойЧастиMS = "СерийныеНомераПлан" 
				ИЛИ   ИмяТабличнойЧастиMS = "СерийныеНомераФакт")
				И СтруктураМетаданных.ДокументыMS.Свойство(ТипДокументаMS) Тогда
				СписокРеквизитовMS = СтруктураМетаданных.ДокументыMS[ТипДокументаMS].РеквизитыСерийныеНомера;							
				
			ИначеЕсли СтруктураМетаданных.ДокументыMS.Свойство(ТипДокументаMS) Тогда
				СписокДопТаблиц = СтруктураМетаданных.ДокументыMS[ТипДокументаMS].ДополнительныеТаблицы;
				Для Каждого ДопТаблица Из СписокДопТаблиц Цикл
					Если ДопТаблица.Представление = ИмяТабличнойЧастиMS Тогда
						СписокРеквизитовMS = ДопТаблица.Значение;
						Прервать;
					КонецЕсли;
				КонецЦикла;			
			КонецЕсли;
			СтрокаТЧ.ТабличнаяЧастьДокумента1С = ГлЯдро_КонвертироватьВыгрузкуПолей(СтрокаТЧ.ТабличнаяЧастьДокумента1С,СписокРеквизитовMS,СписокРеквизитов1С);
		КонецЦикла;
		
		ТипДокумента1С = СтрокаБП.ТипРезультирующегоДокумента1С;	
		СписокРеквизитов1С = Новый СписокЗначений;
		СписокРеквизитовMS = Новый СписокЗначений;
		Если ЗначениеЗаполнено(ТипДокумента1С) И СтруктураМетаданных.Документы1С.Свойство(ТипДокумента1С) Тогда
			СписокРеквизитов1С = СтруктураМетаданных.Документы1С[ТипДокумента1С].Реквизиты;
		КонецЕсли;
		Если ЗначениеЗаполнено(ТипДокументаMS) И СтруктураМетаданных.ДокументыMS.Свойство(ТипДокументаMS) Тогда
			СписокРеквизитовMS = СтруктураМетаданных.ДокументыMS[ТипДокументаMS].Реквизиты;
		КонецЕсли;
		
		ТаблицаРеквизитовШапки = СтрокаБП.НастройкаЗагрузкиПолей;
		Если ТаблицаРеквизитовШапки <> Неопределено Тогда
			СтрокаБП.НастройкаЗагрузкиПолей = ГлЯдро_КонвертироватьЗагрузкуПолей(ТаблицаРеквизитовШапки,СписокРеквизитовMS,СписокРеквизитов1С,СписокРеквизитовMSДляСовместимостиШапки);	
		КонецЕсли;
		
		Если СтрокаБП.НастройкаЗагрузкиТЧ = Неопределено Тогда
			СтрокаБП.НастройкаЗагрузкиТЧ = Новый Массив;
		КонецЕсли;
		
		Для Каждого СтрокаТЧ Из СтрокаБП.НастройкаЗагрузкиТЧ Цикл
			Если СтрокаТЧ.Свойство("ЭтоТаблицаЗначений") Тогда
				Продолжить;
			КонецЕсли;
			
			ИмяТабличнойЧасти1С = СтрокаТЧ.НастройкаТЧСтрокой;
			Если (НЕ СтрокаТЧ.Свойство("ТабличнаяЧастьДокумента1С") ИЛИ НЕ ЗначениеЗаполнено(СтрокаТЧ.ТабличнаяЧастьДокумента1С))
				И СтрокаТЧ.Свойство("ТабличнаяЧастьДокумента1ССтрокой") И ЗначениеЗаполнено(СтрокаТЧ.ТабличнаяЧастьДокумента1ССтрокой) Тогда
				СтрокаТЧ.Вставить("ТабличнаяЧастьДокумента1С",ГлЯдро_ЗначениеИзСтрокиXML(СтрокаТЧ.ТабличнаяЧастьДокумента1ССтрокой));
			КонецЕсли;
			Если СтруктураМетаданных.ДокументыMS.Свойство(ТипДокументаMS) Тогда
				СписокДопТаблиц = СтруктураМетаданных.ДокументыMS[ТипДокументаMS].ДополнительныеТаблицы;
			Иначе
				СписокДопТаблиц = Новый СписокЗначений;
			КонецЕсли;
			ДополнительнаяТаблица = Неопределено;
			Если ЗначениеЗаполнено(ТипДокумента1С) И СтруктураМетаданных.Документы1С.Свойство(ТипДокумента1С)
				И ЗначениеЗаполнено(ИмяТабличнойЧасти1С) И СтруктураМетаданных.Документы1С.Свойство(ИмяТабличнойЧасти1С) Тогда
				СписокРеквизитов1С = СтруктураМетаданных.Документы1С[ТипДокумента1С].ТабличныеЧасти[ИмяТабличнойЧасти1С].Реквизиты;
			КОнецЕсли;
			Для Каждого ДопТаблица Из СписокДопТаблиц Цикл
				Если ДопТаблица.Представление = ИмяТабличнойЧастиMS Тогда
					ДополнительнаяТаблица = ДопТаблица; 
					Прервать;
				КонецЕсли;
			КонецЦикла;
			
			Если ДополнительнаяТаблица = Неопределено Тогда
				Если СтруктураМетаданных.ДокументыMS.Свойство(ТипДокументаMS) Тогда
					СписокРеквизитовMS = Новый Массив(Новый ФиксированныйМассив(СтруктураМетаданных.ДокументыMS[ТипДокументаMS].РеквизитыТЧ));
					СписокРеквизитовMS.Добавить(Новый Структура("Значение,Ключ","КлючСвязиСерий", "КлючСвязиСерий"));
					СписокРеквизитовMS.Добавить(Новый Структура("Значение,Ключ","КлючСвязиСерийныхНомеров", "КлючСвязиСерийныхНомеров"));
				КонецЕсли;
			Иначе	
				СписокРеквизитовMS = ДополнительнаяТаблица.Значение;	
			КонецЕсли;
			
			СписокПравилПоиска = Новый СписокЗначений;
			СписокПравилПоиска.Добавить("Равно", "Равно или оба пустые");
			СписокПравилПоиска.Добавить("РавноПусто1С", "Равно или в 1С пусто");
			СписокПравилПоиска.Добавить("РавноПустоТСД", "Равно или на ТСД пусто");
			
			СтрокаТЧ.ТабличнаяЧастьДокумента1С = ГлЯдро_КонвертироватьЗагрузкуПолей(СтрокаТЧ.ТабличнаяЧастьДокумента1С,СписокРеквизитовMS,СписокРеквизитов1С,СписокРеквизитовMSДляСовместимостиТЧ);
		КонецЦикла;
	КонецЦикла;
	// )
	НастройкиОбновились = Истина;
	Если ВернутьАдресХранилища Тогда
		
		Возврат ПоместитьВоВременноеХранилище(НастройкиБизнесПроцессов,Новый УникальныйИдентификатор());	
		
	Иначе
		
		Возврат НастройкиБизнесПроцессов;	
		
	КонецЕсли;
КонецФункции

// Конвертирует старые настройки выгрузки полей в новые 
//
// Параметры:
//	ТаблицаРеквизитовИсходная - Массив из Структура - старые настройки выгрузки полей
//	СписокРеквизитовMS - СписокЗначений - список реквизитов Mobile Smarts
//	СписокРеквизитов1С - СписокЗначений - список реквизитов 1С
//
// Возвращаемое значение:
//	Массив из Структура - новые настройки выгрузки полей
Функция ГлЯдро_КонвертироватьВыгрузкуПолей(ТаблицаРеквизитовИсходная,СписокРеквизитовMS,СписокРеквизитов1С) Экспорт
	
	ТаблицаРеквизитов = Новый Массив;
	ТаблицаРеквизитов.Добавить(Новый Структура("ЭтоТаблицаЗначений,КолонкиТаблицыЗначений",Истина,"ТипПриемникаСиноним,ИмяЗначениеПриемника,СинонимПриемника,ИмяПриемника,ТипИсточникаСиноним,ИмяЗначениеИсточника,СинонимИсточника,ЗначениеИсточника,СпособСопоставленияСиноним,Комментарий,ТипПриемника,ТипИсточника,ИмяИсточника,СпособСопоставления,Выгружать,ПрЗначение,ИсЗначение"));
	
	Для Каждого СтрокаИсходнойТаблицы Из ТаблицаРеквизитовИсходная Цикл
		Если СтрокаИсходнойТаблицы.Свойство("ЭтоТаблицаЗначений") Тогда
			Продолжить;
		КонецЕсли;
		НоваяСтрока = Новый Структура("ТипПриемникаСиноним,ИмяЗначениеПриемника,СинонимПриемника,ИмяПриемника,ТипИсточникаСиноним,ИмяЗначениеИсточника,СинонимИсточника,ЗначениеИсточника,СпособСопоставленияСиноним,Комментарий,ТипПриемника,ТипИсточника,ИмяИсточника,СпособСопоставления,Выгружать,ПрЗначение,ИсЗначение");
		ЗаполнитьЗначенияСвойств(НоваяСтрока, СтрокаИсходнойТаблицы);
		
		// Временное решение. Загрузка старых настроек
		Если СтрокаИсходнойТаблицы.Свойство("ИмяMS") Тогда
			НоваяСтрока.ИмяПриемника = СтрокаИсходнойТаблицы.ИмяMS;
			НайденныйЭлементИмениПриемника = Неопределено;
			Для каждого РеквизитMS Из СписокРеквизитовMS Цикл
				Если РеквизитMS.Значение = НоваяСтрока.ИмяПриемника Тогда
					НайденныйЭлементИмениПриемника = Новый Структура("Представление,Значение",РеквизитMS.Ключ,РеквизитMS.Значение);
					Прервать;					
				КонецЕсли;
			КонецЦикла;
			Если НайденныйЭлементИмениПриемника <> Неопределено Тогда
				НоваяСтрока.СинонимПриемника = НайденныйЭлементИмениПриемника.Представление;
			Иначе
				НоваяСтрока.СинонимПриемника = СтрокаИсходнойТаблицы.ИмяMS;
			КонецЕсли;
			НоваяСтрока.ТипПриемника = "РеквизитMS";
			НоваяСтрока.ТипПриемникаСиноним = "Фиксированный реквизит Mobile SMARTS";
		КонецЕсли;
		
		Если СтрокаИсходнойТаблицы.Свойство("Имя1С") <> Неопределено Тогда
			
			Если СтрокаИсходнойТаблицы.Свойство("Тип") И СтрокаИсходнойТаблицы.Тип = "Реквизит 1С" Тогда
				// ищем в реквизитах
				НайденныйЭлементИмениИсточника = СписокРеквизитов1С.НайтиПоЗначению(СтрокаИсходнойТаблицы.Имя1С);
				Если НайденныйЭлементИмениИсточника <> Неопределено Тогда
					НоваяСтрока.ИмяИсточника = НайденныйЭлементИмениИсточника.Значение;
					НоваяСтрока.СинонимИсточника = НайденныйЭлементИмениИсточника.Представление;
					НоваяСтрока.ТипИсточника = "Реквизит1С";
					НоваяСтрока.ТипИсточникаСиноним = "Реквизит 1С";
				КонецЕсли;
				
				Если ЗначениеЗаполнено(НоваяСтрока.ИмяИсточника) Тогда
					Если СтрокаИсходнойТаблицы.Свойство("ВыгружатьКакUID") Тогда
						Если СтрокаИсходнойТаблицы.ВыгружатьКакUID = "Ссылка (GUID)" ИЛИ СтрокаИсходнойТаблицы.ВыгружатьКакUID = "Ссылка(GUID)" Тогда
							НоваяСтрока.СпособСопоставления = "СтрокаGUID";
							НоваяСтрока.СпособСопоставленияСиноним = "Ссылка (строка GUID)";
						ИначеЕсли СтрокаИсходнойТаблицы.ВыгружатьКакUID = "По наименованию" Тогда
							НоваяСтрока.СпособСопоставления = "Наименование";
							НоваяСтрока.СпособСопоставленияСиноним = "Наименование (для справочников)";
						ИначеЕсли СтрокаИсходнойТаблицы.ВыгружатьКакUID = "Код" Тогда
							НоваяСтрока.СпособСопоставления = "Код";
							НоваяСтрока.СпособСопоставленияСиноним = "Код (для справочников)";
						Иначе
							НоваяСтрока.СпособСопоставления = "КакЕсть";
							НоваяСтрока.СпособСопоставленияСиноним = "Как есть (простой тип)";
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
				
			ИначеЕсли СтрокаИсходнойТаблицы.Свойство("Тип") И (СтрокаИсходнойТаблицы.Тип = "Дата" ИЛИ СтрокаИсходнойТаблицы.Тип = "Число" ИЛИ СтрокаИсходнойТаблицы.Тип = "Строка" ИЛИ СтрокаИсходнойТаблицы.Тип = "Булево") Тогда
				НоваяСтрока.ТипИсточника = "ПроизвольноеЗначение";
				НоваяСтрока.ТипИсточникаСиноним = "Произвольное значение";
				НоваяСтрока.СпособСопоставления = "КакЕсть";
				НоваяСтрока.СпособСопоставленияСиноним = "Как есть (простой тип)";
				НоваяСтрока.ЗначениеИсточника = СтрокаИсходнойТаблицы.Имя1С;
				
			ИначеЕсли  СтрокаИсходнойТаблицы.Свойство("Тип")  И СтрокаИсходнойТаблицы.Тип = "Произвольный код" Тогда
				НоваяСтрока.ТипИсточника = "ПроизвольныйКод";
				НоваяСтрока.ТипИсточникаСиноним = "Произвольный код";
				Если СтрокаИсходнойТаблицы.Свойство("ВыгружатьКакUID") Тогда
					Если СтрокаИсходнойТаблицы.ВыгружатьКакUID = "Ссылка (поиск по GUID)" Тогда
						НоваяСтрока.СпособСопоставления = "СтрокаGUID";
						НоваяСтрока.СпособСопоставленияСиноним = "Поиск по GUID";
					ИначеЕсли СтрокаИсходнойТаблицы.ВыгружатьКакUID = "По наименованию" Тогда
						НоваяСтрока.СпособСопоставления = "Наименование";
						НоваяСтрока.СпособСопоставленияСиноним = "Поиск по Наименованию (для справочников)";
					ИначеЕсли СтрокаИсходнойТаблицы.ВыгружатьКакUID = "Код" Тогда
						НоваяСтрока.СпособСопоставления = "Код";
						НоваяСтрока.СпособСопоставленияСиноним = "Поиск по Коду (для справочников)";
					Иначе
						НоваяСтрока.СпособСопоставления = "КакЕсть";
						НоваяСтрока.СпособСопоставленияСиноним = "Как есть (любой тип)";
					КонецЕсли;
				КонецЕсли;
				НоваяСтрока.ЗначениеИсточника = СтрокаИсходнойТаблицы.ID_Кода;
				НоваяСтрока.СинонимИсточника = СтрокаИсходнойТаблицы.Имя1С;	
			КонецЕсли;
		КонецЕсли;			
		ТаблицаРеквизитов.Добавить(НоваяСтрока);
	КонецЦикла;
	Возврат ТаблицаРеквизитов;
КонецФункции

// Конвертирует старые настройки загрузки полей в новые 
//
// Параметры:
//	ТаблицаРеквизитовИсходная - Массив из Структура - старые настройки загрузки полей
//	СписокРеквизитовMS - СписокЗначений - список реквизитов Mobile Smarts
//	СписокРеквизитов1С - СписокЗначений - список реквизитов 1С
//	СписокРеквизитовMSДляСовместимости - СписокЗначений - список реквизитов Mobile Smarts для совместимости
//
// Возвращаемое значение:
//	Массив из Структура - новые настройки загрузки полей
Функция ГлЯдро_КонвертироватьЗагрузкуПолей(ТаблицаРеквизитовИсходная,СписокРеквизитовMS,СписокРеквизитов1С,СписокРеквизитовMSДляСовместимости) Экспорт
	
	ТаблицаРеквизитов = Новый Массив;
	ТаблицаРеквизитов.Добавить(Новый Структура("ЭтоТаблицаЗначений,КолонкиТаблицыЗначений",Истина,"Загружать,ТипПриемникаСиноним,ИмяЗначениеПриемника,СинонимПриемника,ИмяПриемника,ТипИсточникаСиноним,ИмяЗначениеИсточника,СинонимИсточника,ЗначениеИсточника,СпособСопоставленияСиноним,ПравилоПоискаСиноним,Группировать,ОчищатьПередЗагрузкой,ОбработчикПодбораКоличества,Комментарий,ТипПриемника,ТипИсточника,ИмяИсточника,СпособСопоставления,ПравилоПоиска"));
	
	Если ТипЗнч(ТаблицаРеквизитовИсходная) = Тип("Массив") Тогда
		Для Каждого СтрокаИсходнойТаблицы Из ТаблицаРеквизитовИсходная Цикл
			Если СтрокаИсходнойТаблицы.Свойство("ЭтоТаблицаЗначений") Тогда
				Продолжить;
			КонецЕсли;
			
			НоваяСтрока = Новый Структура("Загружать,ТипПриемникаСиноним,ИмяЗначениеПриемника,СинонимПриемника,ИмяПриемника,ТипИсточникаСиноним,ИмяЗначениеИсточника,СинонимИсточника,ЗначениеИсточника,СпособСопоставленияСиноним,ПравилоПоискаСиноним,Группировать,ОчищатьПередЗагрузкой,ОбработчикПодбораКоличества,Комментарий,ТипПриемника,ТипИсточника,ИмяИсточника,СпособСопоставления,ПравилоПоиска");
			ЗаполнитьЗначенияСвойств(НоваяСтрока, СтрокаИсходнойТаблицы);
			
			// Временное решение. Загрузка старых настроек
			Если СтрокаИсходнойТаблицы.Свойство("Имя1С") Тогда
				НоваяСтрока.ИмяПриемника = СтрокаИсходнойТаблицы.Имя1С;
				НайденныйЭлементИмениПриемника = СписокРеквизитов1С.НайтиПоЗначению(НоваяСтрока.ИмяПриемника);
				Если НайденныйЭлементИмениПриемника <> Неопределено Тогда
					НоваяСтрока.СинонимПриемника = НайденныйЭлементИмениПриемника.Представление;
				Иначе
					НоваяСтрока.СинонимПриемника = СтрокаИсходнойТаблицы.Имя1С;
				КонецЕсли;
				НоваяСтрока.ТипПриемника = "Реквизит1С";
				НоваяСтрока.ТипПриемникаСиноним = "Фиксированный реквизит 1С";
			КонецЕсли;
			
			Если СтрокаИсходнойТаблицы.Свойство("ИмяMS") Тогда
				
				Если СтрокаИсходнойТаблицы.Тип = "Реквизит Mobile SMARTS" Тогда
					// ищем в реквизитах
					НайденныйЭлементИмениСовместимости = СписокРеквизитовMSДляСовместимости.НайтиПоЗначению(СтрокаИсходнойТаблицы.ИмяMS);
					Если НайденныйЭлементИмениСовместимости <> Неопределено Тогда
						РеквизитДляПоиска = НайденныйЭлементИмениСовместимости.Представление;
					Иначе
						РеквизитДляПоиска = СтрокаИсходнойТаблицы.ИмяMS;
					КонецЕсли;
					НайденныйЭлементИмениИсточника = Неопределено;
					Для каждого РеквизитMS Из СписокРеквизитовMS Цикл
						Если РеквизитMS.Значение = РеквизитДляПоиска Тогда
							НайденныйЭлементИмениИсточника = Новый Структура("Представление,Значение",РеквизитMS.Ключ,РеквизитMS.Значение);
							Прервать;					
						КонецЕсли;
					КонецЦикла;
					Если НайденныйЭлементИмениИсточника <> Неопределено Тогда
						НоваяСтрока.ИмяИсточника = НайденныйЭлементИмениИсточника.Значение;
						НоваяСтрока.СинонимИсточника = НайденныйЭлементИмениИсточника.Представление;
						НоваяСтрока.ТипИсточника = "РеквизитMS";
						НоваяСтрока.ТипИсточникаСиноним = "Реквизит Mobile SMARTS";
					КонецЕсли;
					
					Если ЗначениеЗаполнено(НоваяСтрока.ИмяИсточника) Тогда
						Если СтрокаИсходнойТаблицы.Свойство("ВыгружатьКакUID") Тогда
							Если СтрокаИсходнойТаблицы.ВыгружатьКакUID = "Ссылка (поиск по GUID)" Тогда
								НоваяСтрока.СпособСопоставления = "СтрокаGUID";
								НоваяСтрока.СпособСопоставленияСиноним = "Поиск по GUID";
							ИначеЕсли СтрокаИсходнойТаблицы.ВыгружатьКакUID = "По наименованию" Тогда
								НоваяСтрока.СпособСопоставления = "Наименование";
								НоваяСтрока.СпособСопоставленияСиноним = "Поиск по Наименованию (для справочников)";
							ИначеЕсли СтрокаИсходнойТаблицы.ВыгружатьКакUID = "Код" Тогда
								НоваяСтрока.СпособСопоставления = "Код";
								НоваяСтрока.СпособСопоставленияСиноним = "Поиск по Коду (для справочников)";
							Иначе
								НоваяСтрока.СпособСопоставления = "КакЕсть";
								НоваяСтрока.СпособСопоставленияСиноним = "Как есть (любой тип)";
							КонецЕсли;
						КонецЕсли;
					КонецЕсли;
				ИначеЕсли СтрокаИсходнойТаблицы.Тип = "Произвольный код" Тогда
				    НоваяСтрока.ТипИсточника = "ПроизвольныйКод";
					НоваяСтрока.ТипИсточникаСиноним = "Произвольный код";
					Если СтрокаИсходнойТаблицы.Свойство("ВыгружатьКакUID") Тогда
						Если СтрокаИсходнойТаблицы.ВыгружатьКакUID = "Ссылка (поиск по GUID)" Тогда
							НоваяСтрока.СпособСопоставления = "СтрокаGUID";
							НоваяСтрока.СпособСопоставленияСиноним = "Поиск по GUID";
						ИначеЕсли СтрокаИсходнойТаблицы.ВыгружатьКакUID = "По наименованию" Тогда
							НоваяСтрока.СпособСопоставления = "Наименование";
							НоваяСтрока.СпособСопоставленияСиноним = "Поиск по Наименованию (для справочников)";
						ИначеЕсли СтрокаИсходнойТаблицы.ВыгружатьКакUID = "Код" Тогда
							НоваяСтрока.СпособСопоставления = "Код";
							НоваяСтрока.СпособСопоставленияСиноним = "Поиск по Коду (для справочников)";
						Иначе
							НоваяСтрока.СпособСопоставления = "КакЕсть";
							НоваяСтрока.СпособСопоставленияСиноним = "Как есть (любой тип)";
						КонецЕсли;
					КонецЕсли;
					НоваяСтрока.ИмяИсточника = СтрокаИсходнойТаблицы.ID_Кода;
					НоваяСтрока.ЗначениеИсточника = СтрокаИсходнойТаблицы.ID_Кода;
					НоваяСтрока.СинонимИсточника = СтрокаИсходнойТаблицы.ИмяMS;
				ИначеЕсли СтрокаИсходнойТаблицы.Тип = "Дата" ИЛИ СтрокаИсходнойТаблицы.Тип = "Число" ИЛИ СтрокаИсходнойТаблицы.Тип = "Строка" ИЛИ СтрокаИсходнойТаблицы.Тип = "Булево" Тогда
					НоваяСтрока.ТипИсточника = "ПроизвольноеЗначение";
					НоваяСтрока.ТипИсточникаСиноним = "Произвольное значение";
					НоваяСтрока.СпособСопоставления = "КакЕсть";
					НоваяСтрока.СпособСопоставленияСиноним = "Как есть (любой тип)";
					НоваяСтрока.ЗначениеИсточника = СтрокаИсходнойТаблицы.ИмяMS;
				КонецЕсли;
				
			КонецЕсли;
			
			// Временное решение Окончание
			
			Если НоваяСтрока.Группировать = Неопределено 
				И СтрокаИсходнойТаблицы.Свойство("ПолеПоиска")  Тогда 
				НоваяСтрока.Группировать =  СтрокаИсходнойТаблицы.ПолеПоиска;
			КонецЕсли;
			
			Если НоваяСтрока.ПравилоПоиска = Неопределено 
				И НоваяСтрока.Группировать = Истина Тогда				
				НоваяСтрока.ПравилоПоиска = "РавноПустоТСД";
				НоваяСтрока.ПравилоПоискаСиноним = "Равно или оба пустые";				
			КонецЕсли;

			ТаблицаРеквизитов.Добавить(НоваяСтрока);
		КонецЦикла;
	КонецЕсли;
	Возврат ТаблицаРеквизитов;
КонецФункции

Функция ГлЯдро_ПолучитьСписокАнглийскихНазванияПолейШапкиMS()
	
	Список = Новый СписокЗначений;
	Список.Добавить("Id", "Ид");
	Список.Добавить("Name", "Имя");
	Список.Добавить("DocumentTypeName", "ИмяТипаДокумента");
	Список.Добавить("WarehouseId", "ИдСклада");
	Список.Добавить("Appointment", "Назначение");
	Список.Добавить("AutoAppointed", "ВыдаватьАвтоматически");
	Список.Добавить("Barcode", "Штрихкод");
	Список.Добавить("ServerHosted", "ИсполняемыйНаСервере");
	Список.Добавить("CreateDate", "ДатаСоздания");
	Список.Добавить("Priority", "Приоритет");
	Список.Добавить("Description", "Описание");
	
	Возврат Список;
КонецФункции

Функция ГлЯдро_ПолучитьСписокАнглийскихНазванияПолейТЧMS()
	
	Список = Новый СписокЗначений;
	Список.Добавить("ProductId", "ИдТовара");
	Список.Добавить("PackingId", "ИдУпаковки");
	Список.Добавить("DeclaredQuantity", "КоличествоПлан");
	Список.Добавить("CurrentQuantity", "КоличествоФакт");
	Список.Добавить("FirstStorageBarcode", "ШтрихкодПервогоМеста");
	Список.Добавить("SecondStorageBarcode", "ШтрихкодВторогоМеста");	
	Список.Добавить("ExpiredDate", "СрокГодности");
	Список.Добавить("RegistrationDate", "ДатаРегистрации");
	Список.Добавить("BindedLine", "СвязаннаяСтрока");
	Список.Добавить("Overload", "Переполнение");
	Список.Добавить("Underload", "Недобор");
	Список.Добавить("UnderloadedOrOverloaded", "ЕстьНедоборИлиПереполнение");
	Список.Добавить("SSCC", "SSCC");
	
	Возврат Список;
КонецФункции

// Проверяет доступность обработчика в интеграционной обработке
//
// Параметры:
//	ИмяОбработчика - Строка - имя обработчика
//  СтруктураПараметров - Структура - содержит параметры обработчика
//  АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
//
// Возвращаемое значение: 
//	Структура - содержит:
//		* Статус - Булево - флаг успешности результата проверки
//		* Сообщение - Строка - информационное сообщение о результатах проверки
Функция ГлЯдро_ПроверитьДоступностьОбработчика(ИмяОбработчика, СтруктураПараметров,АдресаПеременных) Экспорт
	
	СтруктураИО = КомЯдро_ПолучитьЗначениеПеременной("ИнтеграционнаяОбработка",АдресаПеременных);
		
	Если (СтруктураИО = Неопределено
		ИЛИ НЕ ТипЗнч(СтруктураИО) = Тип("Структура")
		ИЛИ НЕ СтруктураИО.Свойство("ИнтеграционнаяОбработка")
		ИЛИ СтруктураИО.ИнтеграционнаяОбработка = Неопределено)
		И НЕ ГлЯдро_ПересоздатьИнтеграционнуюОбработку(АдресаПеременных) Тогда
		Возврат Неопределено;
	КонецЕсли;
	СтруктураИО = КомЯдро_ПолучитьЗначениеПеременной("ИнтеграционнаяОбработка",АдресаПеременных);
	ИнтеграционнаяОбработка = СтруктураИО.ИнтеграционнаяОбработка;
	
	РезультатПроверки = Новый Структура("Статус,Сообщение", Ложь, "");
	
	// Проверка устаревшей функции подбора, оставляем пока для совместимости
	ФункцияПодбораКоличества = ГлЯдро_СтрНайти(ИмяОбработчика, "ПодборКоличества") > 0;
	
	Если ФункцияПодбораКоличества Тогда
		
		Попытка
			//Выполнить("РезультатПроверки = ИнтеграционнаяОбработка." + ИмяОбработчика + "(СтруктураПараметров, Истина)");
			СтрокаВызова = "РезультатПроверки = ИнтеграционнаяОбработка." + ИмяОбработчика + "(СтруктураПараметров, Истина)";
			СтрокаВызова = СтрЗаменить(СтрокаВызова, "РезультатПроверки", "Параметры.РезультатПроверки");
			СтрокаВызова = СтрЗаменить(СтрокаВызова, "ИнтеграционнаяОбработка", "Параметры.ИнтеграционнаяОбработка");
			СтрокаВызова = СтрЗаменить(СтрокаВызова, "СтруктураПараметров", "Параметры.СтруктураПараметров");
			ПараметрыАлгоритма = Новый Структура;
			ПараметрыАлгоритма.Вставить("РезультатПроверки", 		РезультатПроверки);
			ПараметрыАлгоритма.Вставить("ИнтеграционнаяОбработка", 	ИнтеграционнаяОбработка);
			ПараметрыАлгоритма.Вставить("СтруктураПараметров", 		СтруктураПараметров);
			ГлЯдро_ВыполнитьВБезопасномРежиме(СтрокаВызова, ПараметрыАлгоритма, АдресаПеременных);
			РезультатПроверки = ПараметрыАлгоритма.РезультатПроверки;
		Исключение		
		КонецПопытки;
		
	Иначе 
		// Если метод есть в интеграционной обработке, то возвращается ошибка о недостаточности фактических параметров, без имени метода; 
		// а если метода нет, то ошибка возвращает текст, что такой-то метод не обнаружен. Вот наличие имени обработчика в сообщении и проверяем
		Попытка
			//Выполнить("ИнтеграционнаяОбработка." + ИмяОбработчика + "()");
			СтрокаВызова = "ИнтеграционнаяОбработка." + ИмяОбработчика + "()";
			СтрокаВызова = СтрЗаменить(СтрокаВызова, "ИнтеграционнаяОбработка", "Параметры.ИнтеграционнаяОбработка");
			ПараметрыАлгоритма = Новый Структура;
			ПараметрыАлгоритма.Вставить("ИнтеграционнаяОбработка", 	ИнтеграционнаяОбработка);
			ГлЯдро_ВыполнитьВБезопасномРежиме(СтрокаВызова, ПараметрыАлгоритма, АдресаПеременных);
		Исключение
			Инфо 		= ИнформацияОбОшибке();
			Описание 	= Инфо.Описание;
		КонецПопытки;
		
		РезультатПроверки.Статус 	= ГлЯдро_СтрНайти(ВРег(Описание), "(" + ВРег(ИмяОбработчика) + ")") = 0;
		РезультатПроверки.Сообщение = Описание;
		
	КонецЕсли;
	
	Возврат РезультатПроверки;
	
КонецФункции

// Возвращает универсальное имя обработчика в виде [ПрефиксКонфигурации]_[ТипДокумента (при наличии)]_[ТипОбработчика]
//
// Параметры:
//	ТипОбработчика - Строка - тип обработчика	
//  ТипДокумента - Строка - тип документа
//  АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
//
// Возвращаемое значение:
//	Строка
Функция ГлЯдро_ПолучитьУниверсальноеИмяОбработчика(ТипОбработчика, ТипДокумента = "",АдресаПеременных) Экспорт
	
	УниверсальноеИмяОбработчика = Конф_ПолучитьПрефиксКонфигурации(АдресаПеременных);
	Если ЗначениеЗаполнено(ТипДокумента) Тогда
		УниверсальноеИмяОбработчика = УниверсальноеИмяОбработчика + "_" + ТипДокумента;
	КонецЕсли;
	УниверсальноеИмяОбработчика = УниверсальноеИмяОбработчика + "_" + ТипОбработчика;
	
	Возврат УниверсальноеИмяОбработчика;
	
КонецФункции

// Получает тип установленного продукта по описанию подключенной базы Mobile Smarts
//
// Параметры:
//	ИдПриложения - Строка -	идентификатор приложения в описании базы
//	ИдОсновногоПриложения - Строка - идентификатор основного приложения в описании базы
//
// Возвращаемое значение:
//	Строка
Функция ГлЯдро_ПолучитьТипУстановленногоПродукта(ИдПриложения, ИдОсновногоПриложения = Неопределено) Экспорт

	НаборИДСклад	= ГлЯдро_ПолучитьИдСклада();
	НаборИДМагазин	= ГлЯдро_ПолучитьИдМагазина();
	
	Если НаборИДМагазин.Получить(ВРег(СокрЛП(ИдПриложения))) <> Неопределено
		ИЛИ НаборИДМагазин.Получить(ВРег(СокрЛП(ИдОсновногоПриложения))) <> Неопределено Тогда
		
		ТипУстановленногоПродукта = "Магазин";
		
	ИначеЕсли НаборИДСклад.Получить(ВРег(СокрЛП(ИдПриложения))) <> Неопределено
		ИЛИ НаборИДСклад.Получить(ВРег(СокрЛП(ИдОсновногоПриложения))) <> Неопределено Тогда
		
		ТипУстановленногоПродукта = "Склад";
		
	ИначеЕсли ВРег(СокрЛП(ИдПриложения)) = ВРег(СокрЛП("8022B928-C509-4F7A-B119-2F77942FDF63"))
		ИЛИ ВРег(СокрЛП(ИдОсновногоПриложения)) = ВРег(СокрЛП("8022B928-C509-4F7A-B119-2F77942FDF63")) Тогда
		
		ТипУстановленногоПродукта = "Курьер";	
		
	ИначеЕсли ВРег(СокрЛП(ИдПриложения)) = ВРег(СокрЛП("A3AAE75F-9961-4733-AC61-F09EAB9BE328")) 
		ИЛИ ВРег(СокрЛП(ИдОсновногоПриложения)) = ВРег(СокрЛП("A3AAE75F-9961-4733-AC61-F09EAB9BE328")) 
		Или ВРег(СокрЛП(ИдПриложения)) = ВРег(СокрЛП("D30D2520-A6BE-4CBF-B06C-B063095BFBBC")) 
		ИЛИ ВРег(СокрЛП(ИдОсновногоПриложения)) = ВРег(СокрЛП("D30D2520-A6BE-4CBF-B06C-B063095BFBBC")) Тогда		
		
		ТипУстановленногоПродукта = "Прайсчекер";
		
	ИначеЕсли ВРег(СокрЛП(ИдПриложения)) = ВРег(СокрЛП("1DC2DC26-0BEE-4959-98A4-8D70D59C0189"))
		ИЛИ ВРег(СокрЛП(ИдОсновногоПриложения)) = ВРег(СокрЛП("1DC2DC26-0BEE-4959-98A4-8D70D59C0189")) Тогда
		
		ТипУстановленногоПродукта = "МДЛП";
		
	Иначе
		
		ТипУстановленногоПродукта = "Не удалось определить...";
		
	КонецЕсли;		
	
	Возврат ТипУстановленногоПродукта;
	
КонецФункции

Функция ГлЯдро_ПолучитьИдСклада()

	НаборИДСклад = Новый Соответствие();
	
	НаборИДСклад.Вставить("FD6465C0-C44A-455E-869D-02DFF3143373", "Базовый"); 		// Склад 15, Базовый с ЕГАИС: 				Артикул: WH15AE-1C83
	НаборИДСклад.Вставить("9B3E6ADA-9AD3-4928-8F96-10455B03EC94", "Расширенный"); 	// Склад 15, Расширенный с ЕГАИС: 			Артикул: WH15BE-1C83
	НаборИДСклад.Вставить("225366C9-7149-4F43-9D31-2B205CB808E8", "Полный"); 		// Склад 15, Полный с ЕГАИС: 				Артикул: WH15CE-1C83
	НаборИДСклад.Вставить("79C0F5DF-A166-490F-8270-10D082503F1B", "Базовый"); 		// Склад 15, Базовый с МОТП: 				Артикул: WH15AT-1C83
	НаборИДСклад.Вставить("1C0290DA-ACF4-4E1D-AC75-034AD01AC8AF", "Расширенный"); 	// Склад 15, Расширенный с МОТП: 			Артикул: WH15BT-1C83
	НаборИДСклад.Вставить("B6ED486C-B5BA-4E0D-A5F2-065E7C590E6F", "Полный"); 		// Склад 15, Полный с МОТП: 				Артикул: WH15CT-1C83
	НаборИДСклад.Вставить("A3646B4B-421C-465B-BAC9-DE6265CA478D", "Базовый"); 		// Склад 15, Базовый с ЕГАИС и МОТП:		Артикул: WH15AET-1C83
	НаборИДСклад.Вставить("27833CA4-72E4-4D88-B171-F0CD1A929575", "Расширенный"); 	// Склад 15, Расширенный с ЕГАИС и МОТП: 	Артикул: WH15BET-1C83
	НаборИДСклад.Вставить("B648F175-3F6A-462F-AD05-473B00D6DF6A", "Полный"); 		// Склад 15, Полный с ЕГАИС и МОТП: 		Артикул: WH15CET-1C83
	НаборИДСклад.Вставить("6A80DE7A-0DD7-4226-8ADC-4EA01BD40586", "Базовый"); 		// Склад 15, Базовый с Кировкой: 			Артикул: WH15AK-1C83
	НаборИДСклад.Вставить("15266969-9980-4AA4-A34C-08D241B67305", "Расширенный"); 	// Склад 15, Расширенный с Кировкой: 		Артикул: WH15BK-1C83
	НаборИДСклад.Вставить("212E5362-5969-40DC-9781-CB7B8AB811DB", "Полный"); 		// Склад 15, Полный с Кировкой: 			Артикул: WH15CK-1C83
	
	Возврат НаборИДСклад;

КонецФункции

Функция ГлЯдро_ПолучитьИдМагазина()

	НаборИДМагазин = Новый Соответствие();
	
	НаборИДМагазин.Вставить("6D0E08AE-4A95-4D1F-974E-A39BD727D446", "Минимум"); 	// Магазин 15, Минимум
	НаборИДМагазин.Вставить("F42C7B5F-405C-4076-AE07-9348F189EE71", "Базовый"); 	// Магазин 15, Базовый / Базовый с ЕГАИС / Общепит
	НаборИДМагазин.Вставить("BEB9F819-15DA-490A-B3C1-657313366191", "Расширенный"); // Магазин 15, Расширенный / Расширенный с ЕГАИС
	НаборИДМагазин.Вставить("44005805-2DCA-45A7-9C34-0A07FDB3FE12", "Полный"); 		// Магазин 15, Полный / Демо / Мегамаркет с ЕГАИС / Мегамаркет
	НаборИДМагазин.Вставить("1F274C52-AB81-4683-B32B-670377B06C49", "Базовый"); 	// Магазин 15, Базовый с ЕГАИС и МОТП
	НаборИДМагазин.Вставить("5E91F650-A426-4A91-84DB-95F7AD21A74B", "Базовый"); 	// Магазин 15, Базовый с МДЛП
	НаборИДМагазин.Вставить("8C71B6D0-E7F3-4E55-85E9-B672D25FFF93", "Базовый"); 	// Магазин 15, Базовый с МОТП
	НаборИДМагазин.Вставить("84599890-B97D-46F2-BE26-3FCA10168211", "Полный"); 		// Магазин 15, Мегамаркет с ЕГАИС и МОТП
	НаборИДМагазин.Вставить("6737FE34-D882-44E3-9266-67BC0FC2F876", "Полный"); 		// Магазин 15, Мегамаркет с МДЛП
	НаборИДМагазин.Вставить("2992E28B-B3C8-4056-91CA-F1D62B3F7BA5", "Полный"); 		// Магазин 15, Мегамаркет с МОТП
	НаборИДМагазин.Вставить("7390E2F7-4EE1-4354-824A-F8A90BF18A22",	"Базовый"); 	// Магазин 15, Продуктовый Базовый без ЕГАИС
	НаборИДМагазин.Вставить("FD7A47C1-C067-497A-BD99-5447D0446B74", "Базовый"); 	// Магазин 15, Продуктовый Базовый
	НаборИДМагазин.Вставить("4783EE23-6789-4DF0-A143-D63F93DFAD73", "Полный"); 		// Магазин 15, Продуктовый Мегамаркет без ЕГАИС
	НаборИДМагазин.Вставить("46A30E5E-67C3-44E9-9974-21AF99A952ED", "Полный"); 		// Магазин 15, Продуктовый Мегамаркет
	НаборИДМагазин.Вставить("F66F38A5-3826-46EE-82E5-5B63F93658A1", "Расширенный"); // Магазин 15, Продуктовый Расширенный без ЕГАИС
	НаборИДМагазин.Вставить("68C8847C-96B5-482C-979A-5152FCBDC4E9", "Расширенный"); // Магазин 15, Продуктовый Расширенный
	НаборИДМагазин.Вставить("9879D274-E98D-4B1A-B05F-86F3D546D138", "Расширенный"); // Магазин 15, Расширенный с ЕГАИС и МОТП
	НаборИДМагазин.Вставить("F56852C7-EF97-4EFE-BDE3-7F01132BC2FF",	"Расширенный"); // Магазин 15, Расширенный с МДЛП
	НаборИДМагазин.Вставить("54281FF1-A6FB-47BC-A8DF-C6EE289592A1", "Расширенный"); // Магазин 15, Расширенный с МОТП
	НаборИДМагазин.Вставить("77318905-FB62-4C3C-8DD6-374F0BEA1450",	"Базовый"); 	// Магазин 15, Шмотки Базовый
	НаборИДМагазин.Вставить("D843170E-A956-4CDA-B3EF-47E244482C86", "Полный"); 		// Магазин 15, Шмотки Мегамаркет
	НаборИДМагазин.Вставить("A0043528-C6CC-48F9-8BB3-8C5BEF2FCA79", "Расширенный"); // Магазин 15, Шмотки Расширенный
	
	Возврат НаборИДМагазин;
	
КонецФункции
	
// Получает уровень приложения строкой по описанию подключенной базы Mobile Smarts
//
// Параметры:
//	УровеньЧислом - Число - уровень приложения в описании базы	
//	
// Возвращаемое значение:
//	Строка
Функция ГлЯдро_ПолучитьУровеньПриложения(УровеньЧислом) Экспорт

	Если УровеньЧислом = 0 Тогда
		
		УровеньПриложения = "Минимум";
		
	ИначеЕсли УровеньЧислом = 1 Тогда
		
		УровеньПриложения = "Базовый";	
		
	ИначеЕсли УровеньЧислом = 2 Тогда
		
		УровеньПриложения = "Расширенный";		
		
	ИначеЕсли УровеньЧислом = 100 Тогда
		
		УровеньПриложения = "Полный";	
		
	Иначе	
		
		УровеньПриложения = "Не удалось определить...";	
		
	КонецЕсли;	
	
	Возврат УровеньПриложения;
	
КонецФункции

// Получает информацию об установленном продукте Mobile Smarts по описанию подключенной базы
//
// Параметры:
//	ИдПриложения - Строка -	идентификатор приложения в описании базы
//	ИдОсновногоПриложения - Строка - идентификатор основного приложения в описании базы
//
// Возвращаемое значение 
//	Структура - содержит:
//		* ТипУстановленногоПродукта - Строка
//		* УровеньПриложения - Строка
Функция ГлЯдро_ПолучитьИнформациюОПродукте(ИдПриложения, ИдОсновногоПриложения = Неопределено) Экспорт
	
	СоответствиеПродуктов = Новый Соответствие;
	
	НаборИдМагазин = ГлЯдро_ПолучитьИдМагазина();
	Для каждого ИдМагазина ИЗ НаборИдМагазин Цикл
		СоответствиеПродуктов.Вставить(ИдМагазина.Ключ, Новый Структура("ТипУстановленногоПродукта, УровеньПриложения", "Магазин", ИдМагазина.Значение));
	КонецЦикла;
		
	НаборИдСклад = ГлЯдро_ПолучитьИдСклада();
	Для каждого ИдСклад ИЗ НаборИдСклад Цикл
		СоответствиеПродуктов.Вставить(ИдСклад.Ключ, Новый Структура("ТипУстановленногоПродукта, УровеньПриложения", "Склад", ИдСклад.Значение));
	КонецЦикла;
	
	СоответствиеПродуктов.Вставить("8022B928-C509-4F7A-B119-2F77942FDF63", Новый Структура("ТипУстановленногоПродукта, УровеньПриложения", "Курьер", "")); 	 		   // Курьер
	СоответствиеПродуктов.Вставить("A3AAE75F-9961-4733-AC61-F09EAB9BE328", Новый Структура("ТипУстановленногоПродукта, УровеньПриложения", "Прайсчекер", "")); 	 	   // Прайсчекер
	СоответствиеПродуктов.Вставить("D30D2520-A6BE-4CBF-B06C-B063095BFBBC", Новый Структура("ТипУстановленногоПродукта, УровеньПриложения", "Прайсчекер", "")); 	 	   // Прайсчекер
	СоответствиеПродуктов.Вставить("1DC2DC26-0BEE-4959-98A4-8D70D59C0189", Новый Структура("ТипУстановленногоПродукта, УровеньПриложения", "МДЛП", "")); 	 		   // МДЛП
	
	ИнформацияОПродукте = СоответствиеПродуктов.Получить(ВРег(СокрЛП(ИдПриложения)));
	
	Если ИнформацияОПродукте = Неопределено Тогда
		ИнформацияОПродукте = СоответствиеПродуктов.Получить(ВРег(СокрЛП(ИдОсновногоПриложения)));	
	КонецЕсли;	
	
	Если ИнформацияОПродукте = Неопределено Тогда
		ИнформацияОПродукте = Новый Структура("ТипУстановленногоПродукта, УровеньПриложения", "Не удалось определить...", "");			
	КонецЕсли;
	
	Возврат ИнформацияОПродукте;
	
КонецФункции

// Получает из кэша тип интерфейса для переданного типа базы
//
// Параметры:
//	ТипБазы - Строка - "Частная", "Временная", "Основная"
//
// Возвращаемое значение:
//	Строка - "COM", "REST_API"
Функция ГлЯдро_ПолучитьТипИнтерфейса(ТипБазы = "Основная", АдресаПеременных) Экспорт

	ДанныеТекущегоУзла = КомЯдро_ПолучитьЗначениеПеременной("ДанныеТекущегоУзла", АдресаПеременных);
	
	ТипИнтерфейса = Неопределено;
	
	Если ТипБазы = "Частная" И ТипЗнч(ДанныеТекущегоУзла) = Тип("Структура") Тогда
		ДанныеУзла = Неопределено;
		ВсеУзлы = ГлЯдро_ПолучитьИзКэшаНастройкуSMARTS("Узлы",, АдресаПеременных);
		Если ТипЗнч(ВсеУзлы) = Тип("Массив") Тогда
			ДанныеУзла = ГлЯдро_НайтиСтруктуруВМассивеПоЭлементу(ВсеУзлы, "ID_Узла", ДанныеТекущегоУзла.ID_Узла);
		КонецЕсли;
			
		Если ДанныеУзла <> Неопределено И ДанныеУзла.Свойство("ТипИнтерфейсаЧБ") Тогда
			ТипИнтерфейса = ДанныеУзла.ТипИнтерфейсаЧБ;
		КонецЕсли;
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(ТипИнтерфейса) Тогда
		ТипИнтерфейса = КомЯдро_ПолучитьЗначениеПеременной("ТипИнтерфейса", АдресаПеременных);
	КонецЕсли;
	
	Возврат ТипИнтерфейса;
	
КонецФункции

// Преобразует переданную строку в транслит
//
// Параметры:
//	пИсходнаяСтрока - Строка - исходная строка	
//
// Возвращаемое значение:
//	Строка - результирующая строка
Функция ГлЯдро_СтрокуВТранслитENG(Знач ИсходныйТекст) Экспорт
	
	Если СоотвСимволов = Неопределено Тогда
		СоотвСимволов = ГлЯдро_ПолучитьСоответствиеСимволовТранслита();
	КонецЕсли;
	
	ИсходныйТекст = СокрЛП(ИсходныйТекст);
	ГотовоеЗначение = "";
	ТекущийСимвол = "";
	ТекущийГотовыйСимвол = "";
	Для к = 1 по СтрДлина(ИсходныйТекст) Цикл
		ТекущийСимвол = Сред(ИсходныйТекст, к, 1);
		ТекущийГотовыйСимвол = СоотвСимволов.Получить(ТекущийСимвол);
		Если ТекущийГотовыйСимвол = Неопределено Тогда
			ГотовоеЗначение = ГотовоеЗначение + ТекущийСимвол;
		Иначе
			ГотовоеЗначение = ГотовоеЗначение + ТекущийГотовыйСимвол;
		КонецЕсли;
		
	КонецЦикла;
	Возврат ГотовоеЗначение;
КонецФункции

Функция ГлЯдро_ПолучитьСоответствиеСимволовТранслита()
	СоответствиеСимволов = Новый Соответствие;
	СоответствиеСимволов.Вставить("А", "A");
	СоответствиеСимволов.Вставить("Б", "B");
	СоответствиеСимволов.Вставить("В", "V");
	СоответствиеСимволов.Вставить("Г", "G");
	СоответствиеСимволов.Вставить("Д", "D");
	СоответствиеСимволов.Вставить("Е", "E");
	СоответствиеСимволов.Вставить("Ё", "E");
	СоответствиеСимволов.Вставить("Ж", "Zh");
	СоответствиеСимволов.Вставить("З", "Z");
	СоответствиеСимволов.Вставить("И", "I");
	СоответствиеСимволов.Вставить("Й", "J");
	СоответствиеСимволов.Вставить("К", "K");
	СоответствиеСимволов.Вставить("Л", "L");
	СоответствиеСимволов.Вставить("М", "M");
	СоответствиеСимволов.Вставить("Н", "N");
	СоответствиеСимволов.Вставить("О", "O");
	СоответствиеСимволов.Вставить("П", "P");
	СоответствиеСимволов.Вставить("Р", "R");
	СоответствиеСимволов.Вставить("С", "S");
	СоответствиеСимволов.Вставить("Т", "T");
	СоответствиеСимволов.Вставить("У", "U");
	СоответствиеСимволов.Вставить("Ф", "F");
	СоответствиеСимволов.Вставить("Х", "H");
	СоответствиеСимволов.Вставить("Ц", "C");
	СоответствиеСимволов.Вставить("Ч", "Ch");
	СоответствиеСимволов.Вставить("Ш", "Sh");
	СоответствиеСимволов.Вставить("Щ", "Shh");
	СоответствиеСимволов.Вставить("Ъ", "");
	СоответствиеСимволов.Вставить("Ы", "Y");
	СоответствиеСимволов.Вставить("Ь", "");
	СоответствиеСимволов.Вставить("Э", "E");
	СоответствиеСимволов.Вставить("Ю", "Yu");
	СоответствиеСимволов.Вставить("Я", "Ya");
	
	СоответствиеСимволов.Вставить("а", "a");
	СоответствиеСимволов.Вставить("б", "b");
	СоответствиеСимволов.Вставить("в", "v");
	СоответствиеСимволов.Вставить("г", "g");
	СоответствиеСимволов.Вставить("д", "d");
	СоответствиеСимволов.Вставить("е", "e");
	СоответствиеСимволов.Вставить("Ё", "e");
	СоответствиеСимволов.Вставить("ж", "zh");
	СоответствиеСимволов.Вставить("з", "z");
	СоответствиеСимволов.Вставить("и", "i");
	СоответствиеСимволов.Вставить("й", "j");
	СоответствиеСимволов.Вставить("к", "k");
	СоответствиеСимволов.Вставить("л", "l");
	СоответствиеСимволов.Вставить("м", "m");
	СоответствиеСимволов.Вставить("н", "n");
	СоответствиеСимволов.Вставить("о", "o");
	СоответствиеСимволов.Вставить("п", "p");
	СоответствиеСимволов.Вставить("р", "r");
	СоответствиеСимволов.Вставить("с", "s");
	СоответствиеСимволов.Вставить("т", "t");
	СоответствиеСимволов.Вставить("у", "u");
	СоответствиеСимволов.Вставить("ф", "f");
	СоответствиеСимволов.Вставить("х", "h");
	СоответствиеСимволов.Вставить("ц", "c");
	СоответствиеСимволов.Вставить("ч", "ch");
	СоответствиеСимволов.Вставить("ш", "sh");
	СоответствиеСимволов.Вставить("щ", "shh");
	СоответствиеСимволов.Вставить("ъ", "");
	СоответствиеСимволов.Вставить("ы", "y");
	СоответствиеСимволов.Вставить("ь", "");
	СоответствиеСимволов.Вставить("э", "e");
	СоответствиеСимволов.Вставить("ю", "yu");
	СоответствиеСимволов.Вставить("я", "ya");

	Возврат СоответствиеСимволов;
КонецФункции

Функция ГлЯдро_ПреобразоватьИзUnicode(СтрокаUnicode)
	
	ПозицияСимвола = Найти(СтрокаUnicode, "\u");
	
	Если НЕ ПозицияСимвола Тогда
		Возврат СтрокаUnicode;
	КонецЕсли;
	
	СоответствиеСимволовUnicode = ГлЯдро_ПолучитьСоответствиеСимволовUnicode();
	
	Пока ПозицияСимвола > 0 Цикл
		
		СимволUnicode = Сред(СтрокаUnicode, ПозицияСимвола + 2, 4);
		ВыводимыйСимвол = СоответствиеСимволовUnicode.Получить(СимволUnicode);
		Если ВыводимыйСимвол = Неопределено Тогда
			ВыводимыйСимвол = "?Unicode?";
		КонецЕсли;
		СтрокаUnicode = СтрЗаменить(СтрокаUnicode, "\u" + СимволUnicode, ВыводимыйСимвол);
		
		ПозицияСимвола = Найти(СтрокаUnicode, "\u");
                    
	КонецЦикла;
    
	Возврат СтрокаUnicode;
	
КонецФункции

Функция ГлЯдро_ПолучитьСоответствиеСимволовUnicode()

	СоответствиеСимволов = Новый Соответствие;
	
	СоответствиеСимволов.Вставить("0410", "А"); 
	СоответствиеСимволов.Вставить("0430", "а");
	СоответствиеСимволов.Вставить("0411", "Б");
	СоответствиеСимволов.Вставить("0431", "б");
	СоответствиеСимволов.Вставить("0412", "В");
	СоответствиеСимволов.Вставить("0432", "в");
	СоответствиеСимволов.Вставить("0413", "Г");
	СоответствиеСимволов.Вставить("0433", "г");
	СоответствиеСимволов.Вставить("0414", "Д");
	СоответствиеСимволов.Вставить("0434", "д");
	СоответствиеСимволов.Вставить("0415", "Е");
	СоответствиеСимволов.Вставить("0435", "е");
	СоответствиеСимволов.Вставить("0401", "Ё");
	СоответствиеСимволов.Вставить("0451", "ё");
	СоответствиеСимволов.Вставить("0416", "Ж");
	СоответствиеСимволов.Вставить("0436", "ж");
	СоответствиеСимволов.Вставить("0417", "З");
	СоответствиеСимволов.Вставить("0437", "з");
	СоответствиеСимволов.Вставить("0418", "И");
	СоответствиеСимволов.Вставить("0438", "и");
	СоответствиеСимволов.Вставить("0419", "Й");
	СоответствиеСимволов.Вставить("0439", "й");
	СоответствиеСимволов.Вставить("041a", "К");
	СоответствиеСимволов.Вставить("043a", "к");
	СоответствиеСимволов.Вставить("041b", "Л");
	СоответствиеСимволов.Вставить("043b", "л");
	СоответствиеСимволов.Вставить("041c", "М");
	СоответствиеСимволов.Вставить("043c", "м");
	СоответствиеСимволов.Вставить("041d", "Н");
	СоответствиеСимволов.Вставить("043d", "н");
	СоответствиеСимволов.Вставить("041e", "О");
	СоответствиеСимволов.Вставить("043e", "о");
	СоответствиеСимволов.Вставить("041f", "П");
	СоответствиеСимволов.Вставить("043f", "п");
	СоответствиеСимволов.Вставить("0420", "Р");
	СоответствиеСимволов.Вставить("0440", "р");
	СоответствиеСимволов.Вставить("0421", "С");
	СоответствиеСимволов.Вставить("0441", "с");
	СоответствиеСимволов.Вставить("0422", "Т");
	СоответствиеСимволов.Вставить("0442", "т");
	СоответствиеСимволов.Вставить("0423", "У");
	СоответствиеСимволов.Вставить("0443", "у");
	СоответствиеСимволов.Вставить("0424", "Ф");
	СоответствиеСимволов.Вставить("0444", "ф");
	СоответствиеСимволов.Вставить("0425", "Х");
	СоответствиеСимволов.Вставить("0445", "х");
	СоответствиеСимволов.Вставить("0426", "Ц");
	СоответствиеСимволов.Вставить("0446", "ц");
	СоответствиеСимволов.Вставить("0427", "Ч");
	СоответствиеСимволов.Вставить("0447", "ч");
	СоответствиеСимволов.Вставить("0428", "Ш");
	СоответствиеСимволов.Вставить("0448", "ш");
	СоответствиеСимволов.Вставить("0429", "Щ");
	СоответствиеСимволов.Вставить("0449", "щ");
	СоответствиеСимволов.Вставить("042a", "Ъ");
	СоответствиеСимволов.Вставить("044a", "ъ");
	СоответствиеСимволов.Вставить("042b", "Ы");
	СоответствиеСимволов.Вставить("044b", "ы");
	СоответствиеСимволов.Вставить("042c", "Ь");
	СоответствиеСимволов.Вставить("044c", "ь");
	СоответствиеСимволов.Вставить("042d", "Э");
	СоответствиеСимволов.Вставить("044d", "э");
	СоответствиеСимволов.Вставить("042e", "Ю");
	СоответствиеСимволов.Вставить("044e", "ю");
	СоответствиеСимволов.Вставить("042f", "Я");
	СоответствиеСимволов.Вставить("044f", "я");	
	
	Возврат СоответствиеСимволов;
	
КонецФункции

Функция ГлЯдро_ОчиститьНедопустимыеСимволыXML(СтрокаXML)
	
	#Если НЕ ВебКлиент Тогда
		ПозицияСимвола = НайтиНедопустимыеСимволыXML(СтрокаXML);
		Пока ПозицияСимвола <> 0 Цикл
			НедопустимыйСимвол 	= Сред(СтрокаXML, ПозицияСимвола, 1);
			СтрокаXML 			= СтрЗаменить(СтрокаXML, НедопустимыйСимвол, "");
			ПозицияСимвола 		= НайтиНедопустимыеСимволыXML(СтрокаXML);
		КонецЦикла;
	#КонецЕсли		

	Возврат СтрокаXML;
	
КонецФункции

Функция ГлЯдро_РасшифроватьGZIP(ЗашифрованныеДвоичныеДанные) Экспорт
	
	// Получение сжатого тела из GZIP
	Поток = ЗашифрованныеДвоичныеДанные.ОткрытьПотокДляЧтения();
	Поток.Перейти(10, ПозицияВПотоке.Начало);
	БуферТелаФайла = Новый БуферДвоичныхДанных(Поток.Размер() - 10);
	Поток.Прочитать(БуферТелаФайла, 0, Поток.Размер() - 18);
	
	// Получение CRC(Контрольного хэша файла)
	БуферCRC = Новый БуферДвоичныхДанных(4);
	Поток.Перейти(Поток.Размер() - 8, ПозицияВПотоке.Начало);
	Поток.Прочитать(БуферCRC, 0, 4);
	CRC = БуферCRC.ПрочитатьЦелое32(0);
	
	// Получение размера несжатого файла
	БуферРазмерНесжатого = Новый БуферДвоичныхДанных(4);
	Поток.Перейти(Поток.Размер() - 4, ПозицияВПотоке.Начало);
	Поток.Прочитать(БуферРазмерНесжатого, 0, 4);
	РазмерРаспакованногоФайла = БуферРазмерНесжатого.ПрочитатьЦелое32(0);
	
	Поток.Закрыть();
	
	ПотокВПамяти = Новый ПотокВПамяти(БуферТелаФайла);
	
	// Формирование валидной ZIP структуры
	
	ПолноеИмяСжатогоФайла 		= ПолучитьИмяВременногоФайла("json");
	ИмяСжатогоФайла 			= Сред(ПолноеИмяСжатогоФайла, ГлЯдро_СтрНайти(ПолноеИмяСжатогоФайла, ПолучитьРазделительПути(), "СКонца") + 1); // "body.json";
	ДлинаИмениСжатогоФайла		= СтрДлина(ИмяСжатогоФайла);
	РазмерСжатогоФайла			= ПотокВПамяти.Размер();
	ВремяФайла					= 0;
	ДатаФайла					= 0;
	
	РазмерZIP 	  = 98 + ДлинаИмениСжатогоФайла * 2 + РазмерСжатогоФайла; // 98 Байт - заголовки, Длина файла * 2, Размер сжатого тела файла
	БинарныйБуфер = Новый БуферДвоичныхДанных(РазмерZIP);
	
	// [Local File Header]
	ДлинаФиксированнойЧастиLFH = 30;
	
	БинарныйБуфер.ЗаписатьЦелое32(0	, 67324752);					// Обязательная сигнатура 0x04034B50
	БинарныйБуфер.ЗаписатьЦелое16(4	, 20); 							// Минимальная версия для распаковки
	БинарныйБуфер.ЗаписатьЦелое16(6	, 2050);						// Битовый флаг
	БинарныйБуфер.ЗаписатьЦелое16(8	, 8); 							// Метод сжатия (0 - без сжатия, 8 - deflate)
	БинарныйБуфер.ЗаписатьЦелое16(10, ВремяФайла); 					// Время модификации файла
	БинарныйБуфер.ЗаписатьЦелое16(12, ДатаФайла); 					// Дата модификации файла
	БинарныйБуфер.ЗаписатьЦелое32(14, CRC);							// Контрольная сумма
	БинарныйБуфер.ЗаписатьЦелое32(18, РазмерСжатогоФайла);			// Сжатый размер
	БинарныйБуфер.ЗаписатьЦелое32(22, РазмерРаспакованногоФайла);	// Несжатый размер
	БинарныйБуфер.ЗаписатьЦелое16(26, ДлинаИмениСжатогоФайла);		// Длина название файла
	БинарныйБуфер.ЗаписатьЦелое16(28, 0);							// Длина поля с дополнительными данными
	
	// Название файла
	Для ПозицияСимвола = 0 По ДлинаИмениСжатогоФайла - 1 Цикл
		БинарныйБуфер.Установить(ДлинаФиксированнойЧастиLFH + ПозицияСимвола, КодСимвола(Сред(ИмяСжатогоФайла, ПозицияСимвола + 1, 1)));
	КонецЦикла;
	
	// Сжатые данные
	БуферСжатыхДанных = Новый БуферДвоичныхДанных(РазмерСжатогоФайла);
	
	ПотокВПамяти.Прочитать(БуферСжатыхДанных, 0, РазмерСжатогоФайла);
	ПотокВПамяти.Закрыть();
	
	БинарныйБуфер.Записать(ДлинаФиксированнойЧастиLFH + ДлинаИмениСжатогоФайла, БуферСжатыхДанных);
	
	ТекущееСмещение = ДлинаФиксированнойЧастиLFH + ДлинаИмениСжатогоФайла + РазмерСжатогоФайла;
	
	// [Central directory file header]
	ДлинаФиксированнойЧастиCDFH	= 46;
	ДлинаДополнительныхДанных	= 0;
	
	БинарныйБуфер.ЗаписатьЦелое32(ТекущееСмещение + 0	, 33639248);					//Обязательная сигнатура 0x02014B50
	БинарныйБуфер.ЗаписатьЦелое16(ТекущееСмещение + 4	, 814); 						//Версия для создания
	БинарныйБуфер.ЗаписатьЦелое16(ТекущееСмещение + 6	, 20); 							//Минимальная версия для распаковки
	БинарныйБуфер.ЗаписатьЦелое16(ТекущееСмещение + 8	, 2050);						//Битовый флаг
	БинарныйБуфер.ЗаписатьЦелое16(ТекущееСмещение + 10	, 8); 							//Метод сжатия (0 - без сжатия, 8 - deflate)
	БинарныйБуфер.ЗаписатьЦелое16(ТекущееСмещение + 12	, ВремяФайла); 					//Время модификации файла
	БинарныйБуфер.ЗаписатьЦелое16(ТекущееСмещение + 14	, ДатаФайла); 					//Дата модификации файла
	БинарныйБуфер.ЗаписатьЦелое32(ТекущееСмещение + 16	, CRC);							//Контрольная сумма
	БинарныйБуфер.ЗаписатьЦелое32(ТекущееСмещение + 20	, РазмерСжатогоФайла);			//Сжатый размер
	БинарныйБуфер.ЗаписатьЦелое32(ТекущееСмещение + 24	, РазмерРаспакованногоФайла);	//Несжатый размер
	БинарныйБуфер.ЗаписатьЦелое16(ТекущееСмещение + 28	, ДлинаИмениСжатогоФайла);		//Длина название файла
	БинарныйБуфер.ЗаписатьЦелое16(ТекущееСмещение + 30	, ДлинаДополнительныхДанных);	//Длина поля с дополнительными данными
	БинарныйБуфер.ЗаписатьЦелое16(ТекущееСмещение + 32	, 0);							//Длина комментариев к файлу
	БинарныйБуфер.ЗаписатьЦелое16(ТекущееСмещение + 34	, 0);							//Номер диска
	БинарныйБуфер.ЗаписатьЦелое16(ТекущееСмещение + 36	, 0);							//Внутренние аттрибуты файла
	БинарныйБуфер.ЗаписатьЦелое32(ТекущееСмещение + 38	, 2176057344);					//Внешние аттрибуты файла
	БинарныйБуфер.ЗаписатьЦелое32(ТекущееСмещение + 42	, 0);							//Смещение до структуры LocalFileHeader
	
	// Название файла
	Для ПозицияСимвола = 0 По ДлинаИмениСжатогоФайла - 1 Цикл
		БинарныйБуфер.Установить(ТекущееСмещение + ДлинаФиксированнойЧастиCDFH + ПозицияСимвола, КодСимвола(Сред(ИмяСжатогоФайла, ПозицияСимвола + 1, 1)));
	КонецЦикла;
	
	ТекущееСмещение = ТекущееСмещение + ДлинаФиксированнойЧастиCDFH + ДлинаИмениСжатогоФайла;
	
	ТекущееСмещение = ТекущееСмещение + ДлинаДополнительныхДанных;
	
	// [End of central directory record (EOCD)]
	РазмерCentralDirectory		= ДлинаФиксированнойЧастиCDFH + ДлинаИмениСжатогоФайла + ДлинаДополнительныхДанных;
	СмещениеCentralDirectory	= ДлинаФиксированнойЧастиLFH  + ДлинаИмениСжатогоФайла + РазмерСжатогоФайла;
	
	БинарныйБуфер.ЗаписатьЦелое32(ТекущееСмещение + 0	, 101010256);					//Обязательная сигнатура 0x06054B50
	БинарныйБуфер.ЗаписатьЦелое16(ТекущееСмещение + 4	, 0); 							//Номер диска
	БинарныйБуфер.ЗаписатьЦелое16(ТекущееСмещение + 6	, 0); 							//Номер диска, где находится начало Central Directory
	БинарныйБуфер.ЗаписатьЦелое16(ТекущееСмещение + 8	, 1); 							//Количество записей в Central Directory в текущем диске
	БинарныйБуфер.ЗаписатьЦелое16(ТекущееСмещение + 10	, 1); 							//Всего записей в Central Directory
	БинарныйБуфер.ЗаписатьЦелое32(ТекущееСмещение + 12	, РазмерCentralDirectory);		//Размер Central Directory
	БинарныйБуфер.ЗаписатьЦелое32(ТекущееСмещение + 16	, СмещениеCentralDirectory);	//Смещение Central Directory
	БинарныйБуфер.ЗаписатьЦелое16(ТекущееСмещение + 20	, 0);							//Длина комментария
	
	КаталогВременныхФайлов = КаталогВременныхФайлов(); // КаталогВременныхФайлов() + ПолучитьРазделительПути() + "GZIP";
	                   
	ПотокВПамяти = Новый ПотокВПамяти(БинарныйБуфер);
	Файл = Новый ЧтениеZipФайла(ПотокВПамяти);
	Файл.Извлечь(Файл.Элементы[0], КаталогВременныхФайлов, РежимВосстановленияПутейФайловZIP.НеВосстанавливать);
	ПотокВПамяти.Закрыть();
	
	// Чтение текста
	ЧтениеТекста = Новый ЧтениеТекста(ПолноеИмяСжатогоФайла); // Новый ЧтениеТекста(КаталогВременныхФайлов + ПолучитьРазделительПути() + "body.json");
	Текст = ЧтениеТекста.Прочитать();
	ЧтениеТекста.Закрыть();
	
	УдалитьФайлы(ПолноеИмяСжатогоФайла);
	
	Возврат Текст;
	
КонецФункции	

Функция ГлЯдро_ЗашифроватьGZIP(ИсходнаяСтрока) Экспорт
	
	ИмяТекстовогоФайла = ПолучитьИмяВременногоФайла("json");
	ЗаписьТекста = Новый ЗаписьТекста(ИмяТекстовогоФайла,"UTF-8",,,Символы.ПС);
	ЗаписьТекста.Записать(ИсходнаяСтрока);
	ЗаписьТекста.Закрыть();
	
	ИмяЗипФайла = ПолучитьИмяВременногоФайла("zip");
	Сжатие = Новый ЗаписьZipФайла(ИмяЗипФайла,,, МетодСжатияZIP.Сжатие, УровеньСжатияZIP.Максимальный);
	Сжатие.Добавить(ИмяТекстовогоФайла, РежимСохраненияПутейZIP.НеСохранятьПути);
	Сжатие.Записать();
	
	ЧтениеДанных = Новый ЧтениеДанных(ИмяЗипФайла, КодировкаТекста.UTF8);
	
	Сигнатура 					= ЧтениеДанных.ПрочитатьЦелое32();
	Версия 						= ЧтениеДанных.ПрочитатьЦелое16();
	БитФлаг 					= ЧтениеДанных.ПрочитатьЦелое16();
	МетодКомпрессии 			= ЧтениеДанных.ПрочитатьЦелое16();
	ВремяМодификации 			= ЧтениеДанных.ПрочитатьЦелое16();
	ДатаМодификации 			= ЧтениеДанных.ПрочитатьЦелое16();
	КонтрольнаяСумма 			= ЧтениеДанных.ПрочитатьЦелое32();
	РазмерСжатогоФайла			= ЧтениеДанных.ПрочитатьЦелое32();
	РаспакованныйРазмер 		= ЧтениеДанных.ПрочитатьЦелое32();
	ДлинаИмениФайла 			= ЧтениеДанных.ПрочитатьЦелое16();
	ДлинаДополнительныхПолей 	= ЧтениеДанных.ПрочитатьЦелое16();
	
	ЧтениеДанных.Пропустить(ДлинаИмениФайла + ДлинаДополнительныхПолей);
	РезультатЧтения = ЧтениеДанных.Прочитать(РазмерСжатогоФайла);
	
	СжатыйБуфер = РезультатЧтения.ПолучитьБуферДвоичныхДанных();
	
	СигнатураГзип 			= 35615; // 2 байта
	МетодСжатияДефлейт 		= 8;	 // 1 байт
	ФлагМетодаКомпрессии 	= 2; 	 // 1 байт
	
	БуферГзипНачало = Новый БуферДвоичныхДанных(10);
	БуферГзипНачало.ЗаписатьЦелое16(0, СигнатураГзип);
	БуферГзипНачало.Установить(2, МетодСжатияДефлейт);
	БуферГзипНачало.Установить(8, ФлагМетодаКомпрессии);
	
	БуферГзипКонец = Новый БуферДвоичныхДанных(8);
	БуферГзипКонец.ЗаписатьЦелое32(0, КонтрольнаяСумма);
	БуферГзипКонец.ЗаписатьЦелое32(4, РаспакованныйРазмер);
	
	БуферРезультат = БуферГзипНачало.Соединить(СжатыйБуфер).Соединить(БуферГзипКонец);
	Поток = Новый ПотокВПамяти(БуферРезультат);
	СжатыеДанные = Поток.ЗакрытьИПолучитьДвоичныеДанные();
	
	ЧтениеДанных.Закрыть();
	
	УдалитьФайлы(ИмяТекстовогоФайла);
	УдалитьФайлы(ИмяЗипФайла);
	
	Возврат СжатыеДанные;
	
КонецФункции

Процедура ГлЯдро_ПреобразоватьUni(МассивИлиСоответствие)
	// Если приходит массив, то находим в каждой структуре реквизит Uni
	Если ТипЗнч(МассивИлиСоответствие) = Тип("Массив") Тогда
		Для Каждого Структура Из МассивИлиСоответствие Цикл
			Если ТипЗнч(Структура) = Тип("Структура") 
				И Структура.Свойство("Uni") Тогда
				Структура.Uni = ГлЯдро_ПреобразоватьПервыйСимволВНижнийРегистр(Структура.Uni);
			КонецЕсли;
		КонецЦикла;
	// Если приходит соответствие, то преобразовываем значение каждого элемента соответствия
	ИначеЕсли ТипЗнч(МассивИлиСоответствие) = Тип("Соответствие") Тогда
		Для Каждого Элемент Из МассивИлиСоответствие Цикл
			МассивИлиСоответствие.Вставить(Элемент.Ключ, ГлЯдро_ПреобразоватьПервыйСимволВНижнийРегистр(Элемент.Значение));
		КонецЦикла;
	КонецЕсли;
КонецПроцедуры

Функция ГлЯдро_ПреобразоватьПервыйСимволВНижнийРегистр(Строка)
 	Возврат	НРег(Лев(Строка,1))+Сред(Строка,2,СтрДлина(Строка)-1);
КонецФункции

// Возвращает список полей запроса по переданному типу документа 1С и тексту запроса
//
// Параметры:
//	ТипДокумента1С - Строка - тип документа 1С	
//  ТекстЗапроса - Строка - текст запроса
//
// Возвращаемое значение:
//	СписокЗначений
Функция ГлЯдро_ЗаполнитьСписокПолейЗапроса(ТипДокумента1С, ТекстЗапроса) Экспорт
	
	СписокПолей = Новый СписокЗначений;
	
	Запрос = Новый Запрос(ТекстЗапроса);
	Запрос.УстановитьПараметр("Ссылка", Документы[ТипДокумента1С].ПустаяСсылка());
	Попытка
		Результат = Запрос.Выполнить().Выгрузить();
		Для Каждого Колонка из Результат.Колонки Цикл
			СписокПолей.Добавить(Колонка.Имя, Колонка.Имя);
		КонецЦикла;
	Исключение
		Сообщить("Не удалось получить список полей по причине ошибки выполнения запроса.");
	КонецПопытки;
	
	Возврат СписокПолей;

КонецФункции

Функция ГлЯдро_ЗагрузитьИзJSON(СтрокаJSON)
	
	Если СтрокаJSON = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ЧтениеJSON = Новый ЧтениеJSON ;
	ЧтениеJSON.УстановитьСтроку(СтрокаJSON);
	
	Реквизиты = Новый Массив;
	Реквизиты.Добавить("$type");
	
	Возврат ПрочитатьJSON(ЧтениеJSON, Истина, , , "ФункцияВосстановленияЧтенияJSON", ЭтотОбъект, ,Реквизиты) ;
КонецФункции

Функция ГлЯдро_ПолучитьJSON(ОтправляемыеДанные, Тип="", ЕстьСостав=Ложь)
	
	ЗаписьJSON = Новый ЗаписьJSON; 
	ПараметрыJSON = Новый ПараметрыЗаписиJSON(ПереносСтрокJSON.Авто,"",Истина,,Ложь,Ложь,Ложь,Истина,Ложь);
	ЗаписьJSON.УстановитьСтроку(ПараметрыJSON);
	ЗаписатьJSON(ЗаписьJSON, ОтправляемыеДанные); 
	ЗакрытыйJSON = ЗаписьJSON.Закрыть();
	
	Если ЕстьСостав Тогда
		// Передается коллекция		
		ЗакрытыйJSON = "{
			|""$type"":""" + Тип + """,
			|""$values"":" + ЗакрытыйJSON + "
			|}";	
	ИначеЕсли ЗначениеЗаполнено(Тип) ТОгда
		Инд = ГлЯдро_СтрНайти(ЗакрытыйJSON, "{");
		Если Инд > 0 Тогда
			ЗакрытыйJSON = "{
			|""$type"":""" + Тип + """," + Прав(ЗакрытыйJSON, СтрДлина(ЗакрытыйJSON)-Инд);
		КонецЕсли;
	КонецЕсли;
	
	Возврат ЗакрытыйJSON;
	
КонецФункции

// Получает структуру из переданного соответствия
//
// Параметры:
//	ЗначВход - Соответствие, Массив из Соответствие - соответствие или массив соответствий, которые требуется преобразовать в структуру		
//
// Возвращаемое значение:
//	- Структура - если было передано соответствие
//	- Массив из Структура - если был передан массив соответствий
Функция ГлЯдро_ПолучитьСтруктуруИзСоответствия(ЗначВход) Экспорт
 
 СтруктураВозврат=Новый Структура;
 
 Если ТипЗнч(ЗначВход)=Тип("Соответствие") Тогда
  
  ФлагОщибка=Ложь;
  
  Для Каждого р Из ЗначВход Цикл
	Если Лев(р.Ключ, 1) = "$" Тогда		  		  
		Продолжить;
	 КонецЕсли;
	Попытка
    СтруктураВозврат.Вставить(р.Ключ,ГлЯдро_ПолучитьСтруктуруИзСоответствия(р.Значение));
   Исключение
    ФлагОщибка=Истина;
    Прервать;
   КонецПопытки;
  КонецЦикла;
  
   Если ФлагОщибка Тогда // пришел ключ который не возможно поместить в структуру
   СтруктураВозврат = Новый Массив;
   Для Каждого р Из ЗначВход Цикл
    ДопСтруктура=Новый Структура;
    ДопСтруктура.Вставить("Ключ",р.Ключ);
    ДопСтруктура.Вставить("Значение",ГлЯдро_ПолучитьСтруктуруИзСоответствия(р.Значение));
    СтруктураВозврат.Добавить(ДопСтруктура);
   КонецЦикла;
  КонецЕсли;
  
  Возврат СтруктураВозврат; 
  
 ИначеЕсли ТипЗнч(ЗначВход)=Тип("Массив") Тогда
  
  НовыйМассив=Новый Массив;
  Для Каждого ЭлМ Из ЗначВход Цикл
   НовыйМассив.Добавить(ГлЯдро_ПолучитьСтруктуруИзСоответствия(ЭлМ));
  КонецЦикла;
  Возврат НовыйМассив;
  
 КонецЕсли;
 
 Возврат ЗначВход; 
 
КонецФункции

// Вызывается при чтении свойств объекта JSON
//
// Параметры:
//	Свойство - Строка - имя свойства	
//	Значение - [Допустимый для сериализации тип] - значение свойства
//	ДополнительныеПараметры - Структура - дополнительные параметры
//
// Возвращаемое значение:
//	Строка
Функция ФункцияВосстановленияЧтенияJSON(Свойство, Значение, ДополнительныеПараметры) Экспорт
	 Возврат "";
КонецФункции	

Функция ГлЯдро_НайтиВМассивеСтруктурПоОтбору(пМассив, пОтбор)
	
	Если ТипЗнч(пМассив) <> Тип("Массив") 
		ИЛИ ТипЗнч(пОтбор) <> Тип("Структура") 
		ИЛИ пМассив.Количество() = 0
		ИЛИ ТипЗнч(пМассив[0]) <> Тип("Структура") Тогда
		Возврат Неопределено;
	КонецЕсли;
	МассивРезультат = Новый Массив;	
	Для Каждого пСтруктура Из пМассив Цикл
		Если пСтруктура.Свойство("ЭтоТаблицаЗначений") Тогда
			Продолжить;
		КонецЕсли;
		Подходит = Истина;
		Для Каждого ЭлОтбора Из пОтбор Цикл
			Значение = Неопределено;
			Если НЕ пСтруктура.Свойство(ЭлОтбора.Ключ,Значение)
				ИЛИ Значение <> ЭлОтбора.Значение Тогда
				Подходит = Ложь;
				Прервать;
			КонецЕсли;
		КонецЦикла;
		Если Подходит Тогда
			МассивРезультат.Добавить(пСтруктура);
		КонецЕсли;
	КонецЦикла;
	Если МассивРезультат.Количество() > 0 Тогда
		Возврат МассивРезультат;
	Иначе
		Возврат Неопределено;
	КонецЕсли;	
	
КонецФункции

Функция ГлЯдро_ЗначениеИзСтрокиXML(Знач ЗначениеНастройки, КонвертироватьТаблицуЗначенийВМассивСтруктур = Ложь) Экспорт
	
	Если Не ЗначениеЗаполнено(ЗначениеНастройки) Или ТипЗнч(ЗначениеНастройки) <> Тип("Строка") Тогда
		Возврат ЗначениеНастройки;
	КонецЕсли;
	
	ЧтениеXML = Новый ЧтениеXML;
	ЧтениеXML.УстановитьСтроку(ЗначениеНастройки);
	
	Попытка
		ПолученноеЗначение = СериализаторXDTO.ПрочитатьXML(ЧтениеXML);
	Исключение
	    Если Найти(ЗначениеНастройки, "http://v8.1c.ru/8.1/data/core") = 0 Тогда
			// Это не xml, пытаемся использовать ЗначениеИзСтрокиВнутр
			ПолученноеЗначение = ЗначениеИзСтрокиВнутр(ЗначениеНастройки);
		Иначе
			ПолученноеЗначение = ГлЯдро_ПреобразованиеЗначенияXMLЧерезXSL(ЗначениеНастройки);    
		КонецЕсли;
	КонецПопытки;
		
	Если ТипЗнч(ПолученноеЗначение) = Тип ("ТаблицаЗначений") И КонвертироватьТаблицуЗначенийВМассивСтруктур Тогда
		ПолученноеЗначение = ГлЯдро_ТаблицуЗначенийВМассивСтруктур(ПолученноеЗначение);
	КонецЕсли; 
	
	Возврат ПолученноеЗначение;
	
КонецФункции

Функция ГлЯдро_ЗначениеВСтрокуXML(Знач ЗначениеНастройки, КонвертироватьМассивСтруктурВТаблицуЗначений = Ложь) Экспорт
	
	ВозвращаемоеЗначение = ЗначениеНастройки;
	
	Если ТипЗнч(ЗначениеНастройки) = Тип("Массив") И КонвертироватьМассивСтруктурВТаблицуЗначений Тогда
		ВозвращаемоеЗначение = ГлЯдро_МассивСтруктурВТаблицуЗначений(ЗначениеНастройки);	
	КонецЕсли;
	
	ПолученнаяСтрока = Новый ЗаписьXML;
	ПолученнаяСтрока.УстановитьСтроку();
	СериализаторXDTO.ЗаписатьXML(ПолученнаяСтрока, ВозвращаемоеЗначение, НазначениеТипаXML.Явное);
	
	СтрокаXML = ПолученнаяСтрока.Закрыть();
	
	Возврат СтрокаXML;
	
КонецФункции

// Вызывает функцию получения строки штрихкода
//
// Параметры:
//	СтруктураЗаполненияСтрокиШК - Структура - структура, содержащие параметры заполнения строки штрихкода
//	АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
//
// Возвращаемое значение:
//	Структура - содержит данные строки штрихкода, полученные из интеграционной обработки
//
Функция ГлЯдро_ПолучитьЗаполнитьСтрокуШК(СтруктураЗаполненияСтрокиШК, АдресаПеременных) Экспорт
	
	СтруктураИО = КомЯдро_ПолучитьЗначениеПеременной("ИнтеграционнаяОбработка",АдресаПеременных);
		
	Если (СтруктураИО = Неопределено
		ИЛИ НЕ ТипЗнч(СтруктураИО) = Тип("Структура")
		ИЛИ НЕ СтруктураИО.Свойство("ИнтеграционнаяОбработка")
		ИЛИ СтруктураИО.ИнтеграционнаяОбработка = Неопределено)
		И НЕ ГлЯдро_ПересоздатьИнтеграционнуюОбработку(АдресаПеременных) Тогда
		Возврат Неопределено;
	КонецЕсли;
	СтруктураИО = КомЯдро_ПолучитьЗначениеПеременной("ИнтеграционнаяОбработка",АдресаПеременных);
	ИнтеграционнаяОбработка = СтруктураИО.ИнтеграционнаяОбработка;
	
	Попытка
		Возврат ИнтеграционнаяОбработка.ПолучитьЗаполнитьСтрокуШК(СтруктураЗаполненияСтрокиШК);
	Исключение
		ИмяСобытия = "ГлЯдро_ПолучитьЗаполнитьСтрокуШК";
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Предупреждение", "Не удалось получить строку штрихкода", , АдресаПеременных);
	КонецПопытки;
	
КонецФункции

// Получает массив имен макетов из интеграционной обработки
//
//	АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
//
// Возвращаемое значение:
//   Массив   - массив имен макетов
//
Функция ГлЯдро_ПолучитьМассивИменМакетовИО(АдресаПеременных) Экспорт

	МассивИменМакетов = Новый Массив;
	
	СтруктураИО = КомЯдро_ПолучитьЗначениеПеременной("ИнтеграционнаяОбработка", АдресаПеременных);
		
	Если (СтруктураИО = Неопределено
		ИЛИ НЕ ТипЗнч(СтруктураИО) = Тип("Структура")
		ИЛИ НЕ СтруктураИО.Свойство("ИнтеграционнаяОбработка")
		ИЛИ СтруктураИО.ИнтеграционнаяОбработка = Неопределено)
		И НЕ ГлЯдро_ПересоздатьИнтеграционнуюОбработку(АдресаПеременных) Тогда
		Возврат МассивИменМакетов;
	КонецЕсли;
	СтруктураИО = КомЯдро_ПолучитьЗначениеПеременной("ИнтеграционнаяОбработка", АдресаПеременных);
	ИнтеграционнаяОбработка = СтруктураИО.ИнтеграционнаяОбработка;
	
	Если ИнтеграционнаяОбработка <> Неопределено Тогда
		МетаданныеМакетов = ИнтеграционнаяОбработка.Метаданные().Макеты;
		
		Для каждого МетаданныеМакета Из МетаданныеМакетов Цикл
		
			МассивИменМакетов.Добавить(МетаданныеМакета.Имя);
		
		КонецЦикла;
	КонецЕсли;
	
	Возврат МассивИменМакетов;
	
КонецФункции

// Получает пустую структуру параметров выгрузки справочника
//
//	АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
//
// Возвращаемое значение:
//   Структура   - содержит:
//		* СпособВыгрузки - Строка - ПоУмолчанию, СвойМакетСКД, ПроизвольныйЗапрос
//		* ИмяМакетаИО - Строка - имя макета ИО, по которому необходимо получить СКД
//		* ТекстЗапроса - Строка - текст запроса, по которому необходимо построить СКД
//		* ТекстКодаПолучениеПараметров - Строка - строка кода, из которой будут получены параметры
//		* ТаблицаСопоставленияПолей - Массив - массив строк с сопоставлением реквизит 1с - реквизит MS
//		* ИмяИсточникаДанных - Строка - имя источника данных, который будет указан в наборе данных СКД
//			в дальнейшем происходит получение запроса из набора данных СКД по имени выгружаемой таблицы
//
Функция ГлЯдро_ПолучитьПустуюСтруктуруПараметровВыгрузкиСправочника(АдресаПеременных) Экспорт

	ПараметрыВыгрузки = Новый Структура;
	
	ПараметрыВыгрузки.Вставить("СпособВыгрузки", 				);
	ПараметрыВыгрузки.Вставить("ИмяМакетаИО", 					);
	ПараметрыВыгрузки.Вставить("ТекстЗапроса", 					);
	ПараметрыВыгрузки.Вставить("ТекстКодаПолучениеПараметров", 	);
	ПараметрыВыгрузки.Вставить("ТаблицаСопоставленияПолей", 	);
	ПараметрыВыгрузки.Вставить("ИмяИсточникаДанных", 			);
	ПараметрыВыгрузки.Вставить("ОчищатьПередВыгрузкой",			);
	
	Возврат ПараметрыВыгрузки;

КонецФункции

// Получает и заполняет структуру параметров выгрузки справочника
//
// Параметры:
//  ИмяТаблицы  - Строка - имя таблицы, для которой необходимо получить сохраненное имя макета ИО
//	АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
//
// Возвращаемое значение:
//   Структура   - см. ГлЯдро_ПолучитьПустуюСтруктуруПараметровВыгрузкиСправочника()
//
Функция ГлЯдро_ПолучитьЗаполнитьСтруктуруПараметровВыгрузкиСправочника(ИмяТаблицы, АдресаПеременных) Экспорт

	ПараметрыВыгрузки = ГлЯдро_ПолучитьПустуюСтруктуруПараметровВыгрузкиСправочника(АдресаПеременных);
	
	НастройкиОбменаСправочников = ГлЯдро_ПолучитьИзКэшаНастройкуSMARTS("НастройкиОбменаСправочников",, АдресаПеременных);
	
	Отбор = Новый Структура("ИмяТаблицы", ИмяТаблицы);
	СтрокаНастроекОбмена = ГлЯдро_ПолучитьИзКэшаЗначениеТабличнойНастройкиSMARTS("НастройкиОбменаСправочников", Отбор, ,АдресаПеременных);
	
	ПараметрыВыгрузки.ИмяИсточникаДанных						= ИмяТаблицы;	
	ПараметрыВыгрузки.СпособВыгрузки							= "";
	ПараметрыВыгрузки.ИмяМакетаИО								= "";
	ПараметрыВыгрузки.ТекстЗапроса								= "";
	ПараметрыВыгрузки.ТекстКодаПолучениеПараметров				= "";
	ПараметрыВыгрузки.ТаблицаСопоставленияПолей					= Новый Массив;
	
	Если СтрокаНастроекОбмена <> Неопределено Тогда
		Если ТипЗнч(СтрокаНастроекОбмена) = Тип("Массив") Тогда
			Для каждого СтрокаНастройки ИЗ СтрокаНастроекОбмена Цикл			
				Если СтрокаНастройки.Свойство("ЭтоТаблицаЗначений") Тогда
					Продолжить;					                                                     	
				КонецЕсли;
				ЗаполнитьЗначенияСвойств(ПараметрыВыгрузки, СтрокаНастройки);
				Если СтрокаНастройки.Свойство("ТекстЗапросаВыгрузкиНаТСД") Тогда
					ПараметрыВыгрузки.ТекстЗапроса = СтрокаНастройки.ТекстЗапросаВыгрузкиНаТСД;
				КонецЕсли;
			КонецЦикла;			
		Иначе		
			ЗаполнитьЗначенияСвойств(ПараметрыВыгрузки, СтрокаНастроекОбмена);
		КонецЕсли;
	КонецЕсли;
		
	Возврат ПараметрыВыгрузки;

КонецФункции

// Получает массив имен полей номенклатуры MS, которые используются при выгрузке номенклатуры из 1с
//
// Параметры:
//	АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
//
// Возвращаемое значение:
//   Массив   - массив имен полей номенклатуры MS
//
Функция ГлЯдро_ПолучитьМассивВыгружаемыхПолейНоменклатурыMS(АдресаПеременных) Экспорт

	 МассивПолей = Новый Массив;
	 МассивПолей.Добавить("Product_Id_GUID");
	 МассивПолей.Добавить("Product_Name");
	 МассивПолей.Добавить("Product_Barcode");
	 МассивПолей.Добавить("Product_ЭтоГруппа");
	 МассивПолей.Добавить("Product_Marking");
	 МассивПолей.Добавить("Product_Весовой");
	 МассивПолей.Добавить("Product_BasePackingId_GUID");
	 МассивПолей.Добавить("Product_Маркировка");
	 МассивПолей.Добавить("Packing_Barcode");
	 МассивПолей.Добавить("Packing_ИдХарактеристики_GUID");
	 МассивПолей.Добавить("Packing_ИмяХарактеристики");
	 МассивПолей.Добавить("Packing_Id_GUID");
	 МассивПолей.Добавить("Packing_ИдЕдиницыИзмерения_GUID");
	 МассивПолей.Добавить("Packing_Name");
	 МассивПолей.Добавить("Packing_UnitsQuantity");
	 МассивПолей.Добавить("Product_Алко");
	 МассивПолей.Добавить("Packing_АлкоКод");
	 МассивПолей.Добавить("Packing_АлкоОбъем");
	 МассивПолей.Добавить("Packing_АлкоКрепость");
	 МассивПолей.Добавить("Product_АлкоМарк");
	 МассивПолей.Добавить("Packing_АлкоПроизводитель");
	 МассивПолей.Добавить("Packing_АлкоПроизвИНН");
	 МассивПолей.Добавить("Packing_АлкоПроизвКПП");
	 МассивПолей.Добавить("Packing_ТНВЭД");
	 МассивПолей.Добавить("Packing_Бренд");
	 МассивПолей.Добавить("Packing_ИсходныйGTIN");
	 МассивПолей.Добавить("Packing_Производитель");
	 МассивПолей.Добавить("Packing_price");
	 МассивПолей.Добавить("Packing_qty");
	 МассивПолей.Добавить("Product_КлючХарактеристик_GUID");
	 МассивПолей.Добавить("Product_ПоХарактеристикам");
	 МассивПолей.Добавить("Product_ПоСериям");
	 МассивПолей.Добавить("Product_ПоСН");
	 МассивПолей.Добавить("Product_КлючСерий_GUID");
	 МассивПолей.Добавить("Packing_ИдСерии_GUID");
	 
	 Возврат МассивПолей;

КонецФункции

// Получает массив структур имен макетов по умолчанию из интеграционной обработки
//
// Параметры:
//  МассивИменСправочников 	- Массив - массив имен справочников, для которых будут получены макеты ИО
//	АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
//
// Возвращаемое значение:
//	Массив, содержащий структуры
//   Структура   - содержит:
//		* ИмяСправочника - имя таблицы (справочника)
//		* ИмяМакета - имя макета ИО по умолчанию
//
Функция ГлЯдро_ПолучитьМассивСтруктурМакетовИОПоУмолчанию(МассивСтруктурИменСправочников, АдресаПеременных) Экспорт

	СтруктураИменМакетовИО = Новый Структура;
		
	СтруктураИО = КомЯдро_ПолучитьЗначениеПеременной("ИнтеграционнаяОбработка", АдресаПеременных);
		
	Если (СтруктураИО = Неопределено
		ИЛИ НЕ ТипЗнч(СтруктураИО) = Тип("Структура")
		ИЛИ НЕ СтруктураИО.Свойство("ИнтеграционнаяОбработка")
		ИЛИ СтруктураИО.ИнтеграционнаяОбработка = Неопределено)
		И НЕ ГлЯдро_ПересоздатьИнтеграционнуюОбработку(АдресаПеременных) Тогда
		// Не получена интерационная обработка
		Возврат МассивСтруктурИменСправочников;
	КонецЕсли;
	СтруктураИО = КомЯдро_ПолучитьЗначениеПеременной("ИнтеграционнаяОбработка", АдресаПеременных);
	ИнтеграционнаяОбработка = СтруктураИО.ИнтеграционнаяОбработка;
	
	Если ИнтеграционнаяОбработка <> Неопределено Тогда

		РаботаБезАлкоголя = ГлЯдро_ПолучитьИзКэшаНастройкуSMARTS("РаботаБезАлкоголя",,АдресаПеременных);		
		
		Для Каждого СтруктураИмениСправочника Из МассивСтруктурИменСправочников Цикл
			
			ИмяТаблицы = СтруктураИмениСправочника.ИмяСправочника;
			
			СтруктураСхемыСКД = ИнтеграционнаяОбработка.ПолучитьМакетСКД(ИмяТаблицы, РаботаБезАлкоголя);	
			
			Если ТипЗнч(СтруктураСхемыСКД) = Тип("Структура") 
				И СтруктураСхемыСКД.Свойство("ИмяМакета")  Тогда
				ИмяМакета = СтруктураСхемыСКД.ИмяМакета;
				Если ЗначениеЗаполнено(ИмяМакета) Тогда
					СтруктураИмениСправочника.ИмяМакета = ИмяМакета;				
				КонецЕсли; 
			КонецЕсли;
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат МассивСтруктурИменСправочников;
	
КонецФункции

// Получает пустую структуру параметров для передачи в процедуру выполнения обработчика выгрузки документа
//
Функция ГлЯдро_ПолучитьСтруктуруПараметровВыполненияОбработчикаВыгрузки()
	
	СтруктураПараметров = Новый Структура;
	СтруктураПараметров.Вставить("ДанныеДокумента");
	СтруктураПараметров.Вставить("СсылкаДокумент1С");
	СтруктураПараметров.Вставить("НастройкаБП");
	СтруктураПараметров.Вставить("ДанныеНастроекИзКэша");
	СтруктураПараметров.Вставить("ИнтеграционнаяОбработка");
	СтруктураПараметров.Вставить("ИмяПриемникаДанных");
	СтруктураПараметров.Вставить("ТЧ");
	СтруктураПараметров.Вставить("СтрокаДокумента");
	
	Возврат СтруктураПараметров
	
КонецФункции

Функция ГлЯдро_ПреобразованиеЗначенияXMLЧерезXSL(Знач ЗначениеНастройки) Экспорт
	
	ПолученноеЗначение = Неопределено;
	
	// Получаем сначала узлы с атрибутами типа перечислений (для проверки их значений)
	Преобразование = Новый ПреобразованиеXSL;
	ПравилаПреобразования = 			
		"<?xml version=""1.0"" encoding=""UTF-8""?>
		|<xsl:stylesheet xmlns:ones=""http://v8.1c.ru/8.1/data/core""
		|xmlns:xsl=""http://www.w3.org/1999/XSL/Transform"" version=""1.0""
		|xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"">
		|
		|<!-- установим способ вывода результата -->
		|<xsl:output method=""xml"" encoding=""utf-8""/>
		|
		|<!-- отберем узлы со значениями атрибутов -->
		|<xsl:template match=""*"">
		|	<xsl:choose>
		|		<xsl:when test=""contains(@xsi:type, 'EnumRef')"">										
		|			BPOINT
		|			<xsl:value-of select="".""/>										
		|			EVALUE
		|			<xsl:apply-templates select=""@xsi:type""/>										
		|			EPOINT
		|		</xsl:when>
		|		<xsl:otherwise>
		|			<xsl:apply-templates select=""@* | node()""/>									
		|		</xsl:otherwise>
		|	</xsl:choose>
		|</xsl:template>
		|<xsl:template match=""@xsi:type"">
		|	<xsl:value-of select="".""/>				
		|</xsl:template>				
		|</xsl:stylesheet>";
	
	Преобразование.ЗагрузитьИзСтроки(ПравилаПреобразования);
	СтрокаСТипамиПеречислений = Преобразование.ПреобразоватьИзСтроки(ЗначениеНастройки);			
	
	// Убираем переносы строк
	СтрокаСТипамиПеречислений = СтрЗаменить(СтрокаСТипамиПеречислений, Символы.ПС, "");
	
	МассивПеречислений = Новый Массив;
	
	// По введенным маркерам находим типы перечислений и их значения в файле XML
	Пока (Истина) Цикл
		
		ТекДлина 		= СтрДлина(СтрокаСТипамиПеречислений);				
		ИндексЗначения 	= ГлЯдро_СтрНайти(СтрокаСТипамиПеречислений, "BPOINT");
		
		Если ИндексЗначения = 0 Тогда
			Прервать;
		КонецЕсли;
		
		СтрокаСТипамиПеречислений 	= СокрЛП(Прав(СтрокаСТипамиПеречислений, ТекДлина - ИндексЗначения - 6));
		ИндексОкончанияЗначения 	= ГлЯдро_СтрНайти(СтрокаСТипамиПеречислений, "EVALUE");				
		ВыделенноеЗначение 			= СокрЛП(Лев(СтрокаСТипамиПеречислений, ИндексОкончанияЗначения - 1));
		
		ТекДлина 		= СтрДлина(СтрокаСТипамиПеречислений);
		ИндексТипа 		= ГлЯдро_СтрНайти(СтрокаСТипамиПеречислений, "EnumRef");
		
		Если ИндексТипа = 0 Тогда
			Прервать;
		КонецЕсли;
		
		СтрокаСТипамиПеречислений 	= СокрЛП(Прав(СтрокаСТипамиПеречислений, ТекДлина - ИндексТипа - 7));				
		ИндексОкончанияТипа 		= ГлЯдро_СтрНайти(СтрокаСТипамиПеречислений, "EPOINT");				
		ВыделенныйТип 				= СокрЛП(Лев(СтрокаСТипамиПеречислений, ИндексОкончанияТипа - 1));
		
		СтруктураПеречисления = Новый Структура("Тип,Значение", ВыделенныйТип, ВыделенноеЗначение);				
		МассивПеречислений.Добавить(СтруктураПеречисления);
		
	КонецЦикла;		
	
	МассивПеречисленийКПреобразованию = Новый Массив;
	
	// Проверяем перечисления на наличие типа или требуемого значения в конфигурации
	Для Каждого СтрПеречисление Из МассивПеречислений Цикл			
		
		Если Метаданные.Перечисления.Найти(СтрПеречисление.Тип) = Неопределено 
			Или Метаданные.Перечисления[СтрПеречисление.Тип].ЗначенияПеречисления.Найти(СтрПеречисление.Значение) = Неопределено Тогда
			МассивПеречисленийКПреобразованию.Добавить(СтрПеречисление.Тип);
			Продолжить;
		КонецЕсли;
		
	КонецЦикла;			
	
	// Формируем условия фильтра для преобразования XSL по найденным некорректным значениям перечислений
	СтрокаФильтра = "";
	Для Каждого СтрТипПеречисления Из МассивПеречисленийКПреобразованию Цикл			
		СтрокаФильтра = СтрокаФильтра + "
		|			<xsl:when test=""contains(@xsi:type, 'EnumRef." + СтрТипПеречисления + "')"">						
		|				<xsl:attribute name=""xsi:type"">
		|					<xsl:value-of select=""'xs:string'""/>
		|				</xsl:attribute>
		|				<xsl:apply-templates select=""node()""/>
		|			</xsl:when>";
		
	КонецЦикла;			
	
	РегистрацияОшибки = Ложь;
	
	// Если найдены некорректные значения и сформирован фильтр, пытаемся преобразовать XML
	Если Не ПустаяСтрока(СтрокаФильтра) Тогда
		
		ПравилаПреобразования = 			
		"<?xml version=""1.0"" encoding=""UTF-8""?>
		|<xsl:stylesheet xmlns:ones=""http://v8.1c.ru/8.1/data/core""
		|xmlns:xsl=""http://www.w3.org/1999/XSL/Transform"" version=""1.0""
		|xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"">
		|
		|<!-- установим способ вывода результата -->
		|<xsl:output method=""xml"" encoding=""utf-8""/>
		|
		|<!-- скопируем все узлы документа -->
		|<xsl:template match=""@* | node()"">
		|	<xsl:copy>
		|		<xsl:apply-templates select=""@* | node()""/>
		|	</xsl:copy>
		|</xsl:template>
		|
		|<!-- во всех строках где имеется некорректное ссылочное значение меняем тип на строку -->					
		|<xsl:template match=""*"">			
		|	<xsl:copy>
		|		<xsl:choose>" + СтрокаФильтра + "
		|			<xsl:otherwise>
		|				<xsl:apply-templates select=""@* | node()""/>				
		|			</xsl:otherwise>
		|		</xsl:choose>
		|	</xsl:copy>
		|</xsl:template>
		|
		|</xsl:stylesheet>";
		
		Преобразование.ЗагрузитьИзСтроки(ПравилаПреобразования);
		НормализованнаяСтрокаXML = Преобразование.ПреобразоватьИзСтроки(ЗначениеНастройки);
		
		// Пробуем десериализовать нормализованный XML
		НовыйЧтениеXML = Новый ЧтениеXML;
		НовыйЧтениеXML.УстановитьСтроку(НормализованнаяСтрокаXML);
		
		Попытка
			ПолученноеЗначение = СериализаторXDTO.ПрочитатьXML(НовыйЧтениеXML);
		Исключение
			РегистрацияОшибки = Истина;	
		КонецПопытки;
		
	Иначе
		РегистрацияОшибки = Истина;	
	КонецЕсли;
	
	Если РегистрацияОшибки Тогда
		ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		ИмяСобытия = "ГлЯдро_ЗначениеИзСтрокиXML";
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Не удалось преобразовать настройку, ОписаниеОшибки: " + ТекстОшибки+", ЗначениеНастройки: "+ЗначениеНастройки,, );
	КонецЕсли;
	
	Возврат ПолученноеЗначение;
	
КонецФункции

// Выполняет произвольный алгоритм на встроенном языке 1С:Предприятия
// Параметры:
//  Алгоритм  - Строка - алгоритм на встроенном языке "1С:Предприятия".
//  Параметры - Произвольный -  контекст, который требуется для выполнения алгоритма.
//    В тексте алгоритма обращение к контексту должно происходить по имени "Параметры".
//    Например, выражение "Параметры.Значение1 = Параметры.Значение2" обращается к значениям
//    "Значение1" и "Значение2", переданным в Параметры, как свойства.
//	АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
//
// Пример 1
//  Параметры = Новый Структура;
//  Параметры.Вставить("Значение1", 1);
//  Параметры.Вставить("Значение2", 10);
//  Результат = ГлЯдро_ВыполнитьАлгоритм("Параметры.Значение1 = Параметры.Значение2", Параметры);
//
//  // Пример 2
//  Результат = ГлЯдро_ВыполнитьАлгоритм("СтандартныеПодсистемыСервер.ВерсияБиблиотеки()");
//
Процедура ГлЯдро_ВыполнитьВБезопасномРежиме(Знач Алгоритм, Знач Параметры = Неопределено, АдресаПеременных) Экспорт
	
	#Область НесовместимыйКодFresh
	Выполнить(Алгоритм);
	#КонецОбласти //НесовместимыйКодFresh
	#Область СовместимыйКодFresh
	//ОбщегоНазначения.ВыполнитьВБезопасномРежиме(Алгоритм, Параметры);
	#КонецОбласти //СовместимыйКодFresh
	
КонецПроцедуры

// Вычисляет переданное выражение, предварительно устанавливая безопасный режим выполнения кода
// и безопасный режим разделения данных для всех разделителей, присутствующих в составе конфигурации.
//
// Параметры:
//  Выражение - Строка - выражение на встроенном языке 1С:Предприятия.
//  Параметры - Произвольный - контекст, который требуется для вычисления выражения.
//    В тексте выражения обращение к контексту должно происходить по имени "Параметры".
//    Например, выражение "Параметры.Значение1 = Параметры.Значение2" обращается к значениям
//    "Значение1" и "Значение2" переданные в Параметры, как свойства.
//	АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
//
// Возвращаемое значение:
//   Произвольный - результат вычисления выражения.
//
// Пример:
//
//  // Пример 1
//  Параметры = Новый Структура;
//  Параметры.Вставить("Значение1", 1);
//  Параметры.Вставить("Значение2", 10);
//  Результат = ОбщегоНазначения.ВычислитьВБезопасномРежиме("Параметры.Значение1 = Параметры.Значение2", Параметры);
//
//  // Пример 2
//  Результат = ОбщегоНазначения.ВычислитьВБезопасномРежиме("СтандартныеПодсистемыСервер.ВерсияБиблиотеки()");
//
Функция ГлЯдро_ВычислитьВБезопасномРежиме(Знач Выражение, Знач Параметры = Неопределено) Экспорт

	#Область НесовместимыйКодFresh
	Возврат Вычислить(Выражение);
	#КонецОбласти //НесовместимыйКодFresh
	#Область СовместимыйКодFresh
	//Возврат ОбщегоНазначения.ВычислитьВБезопасномРежиме(Выражение, Параметры);
	#КонецОбласти //СовместимыйКодFresh
	
КонецФункции

Процедура ГлЯдро_Пауза(Секунды) Экспорт
	
	Если ТипЗнч(Секунды) = Тип("Строка") Тогда
		Секунды = ГлЯдро_СтрокаВЧисло(Секунды);
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(Секунды)
		ИЛИ ТипЗнч(Секунды) <> Тип("Число") Тогда
		Возврат;		
	КонецЕсли;
	
	#Область СовместимыйКодFresh
	//ОбщегоНазначения.ОбщийМодуль("ОбщегоНазначенияБТС").Пауза(Секунды);	
	#КонецОбласти //СовместимыйКодFresh
	
	#Область НесовместимыйКодFresh
	НастройкиProxy = Новый ИнтернетПрокси(Ложь);
	НастройкиProxy.НеИспользоватьПроксиДляЛокальныхАдресов = Истина;
	НастройкиProxy.НеИспользоватьПроксиДляАдресов.Добавить("127.0.0.0");
		
	Попытка
		СоединениеHTTP = Новый HTTPСоединение("127.0.0.0",,,, НастройкиProxy, Секунды);
		СоединениеHTTP.Получить(Новый HTTPЗапрос());
	Исключение
	КонецПопытки;
	#КонецОбласти //НесовместимыйКодFresh	
	
КонецПроцедуры

// Преобразует исходную строку в число без вызова исключений.
//
// Параметры:
//   Значение - Строка - строка, которую необходимо привести к числу.
//                       Например, "10", "+10", "010", вернет 10;
//                                 "(10)", "-10",вернет -10;
//                                 "10,2", "10.2",вернет 10.2;
//                                 "000", " ", "",вернет 0;
//                                 "10текст", вернет Неопределено.
//
// Возвращаемое значение:
//   Число, Неопределено - полученное число, либо Неопределено, если строка не является числом.
//
Функция ГлЯдро_СтрокаВЧисло(Знач Значение) Экспорт
	
	Значение = СтрЗаменить(Значение, " ", "");
	Если Лев(Значение, 1) = "(" Тогда
		Значение = СтрЗаменить(Значение, "(", "-");
		Значение = СтрЗаменить(Значение, ")", "");
	КонецЕсли;
	
	СтрокаБезНулей = СтрЗаменить(Значение, "0", "");
	Если ПустаяСтрока(СтрокаБезНулей) Или СтрокаБезНулей = "-" Тогда
		Возврат 0;
	КонецЕсли;
	
	ТипЧисло  = Новый ОписаниеТипов("Число");
	Результат = ТипЧисло.ПривестиЗначение(Значение);
	
	Возврат ?(Результат <> 0 И Не ПустаяСтрока(СтрокаБезНулей), Результат, Неопределено);
	
КонецФункции

// Функция вычисляет контрольный символ кода EAN.
//
// Параметры:
//  Штрихкод - Строка - штрихкод (без контрольной цифры).
//  Тип      - Число - тип штрихкода (13 для EAN13, 8 для EAN8).
//
// Возвращаемое значение:
//  Строка - Контрольный символ штрихкода.
//
Функция ГлЯдро_КонтрольныйСимволEAN(ШтрихКод, Тип) Экспорт

	Четн   = 0;
	Нечетн = 0;

	КоличествоИтераций = ?(Тип = 13, 6, 4);

	Для Индекс = 1 По КоличествоИтераций Цикл
		Если (Тип = 8) И (Индекс = КоличествоИтераций) Тогда
		Иначе
			Четн   = Четн   + Сред(ШтрихКод, 2 * Индекс, 1);
		КонецЕсли;
		Нечетн = Нечетн + Сред(ШтрихКод, 2 * Индекс - 1, 1);
	КонецЦикла;

	Если Тип = 13 Тогда
		Четн = Четн * 3;
	Иначе
		Нечетн = Нечетн * 3;
	КонецЕсли;

	КонтЦифра = 10 - (Четн + Нечетн) % 10;

	Возврат ?(КонтЦифра = 10, "0", Строка(КонтЦифра));

КонецФункции

Функция ГлЯдро_ПреобразоватьGTIN_В_EAN(GTIN)
	
	Если СтрДлина(GTIN) <> 14 Тогда
		Возврат GTIN;		
	КонецЕсли;

	EAN_БезКонтрольногоСимвола = Сред(GTIN, 2, 12);
	
	EAN_КонтрольныйСимвол = ГлЯдро_КонтрольныйСимволEAN(EAN_БезКонтрольногоСимвола, ?(Лев(EAN_БезКонтрольногоСимвола, 5) = "0", 8, 13));
	
	EAN = "0" + EAN_БезКонтрольногоСимвола + EAN_КонтрольныйСимвол;
	
	Возврат EAN;
	
КонецФункции

Функция ГлЯдро_ВыполнитьКодПолученияПараметровЗапроса(СтрокаВызова, ПараметрыАлгоритма, АдресаПеременных) Экспорт

	СтруктураИО = КомЯдро_ПолучитьЗначениеПеременной("ИнтеграционнаяОбработка", АдресаПеременных);
	Если (СтруктураИО = Неопределено
		ИЛИ НЕ ТипЗнч(СтруктураИО) = Тип("Структура")
		ИЛИ НЕ СтруктураИО.Свойство("ИнтеграционнаяОбработка")
		ИЛИ СтруктураИО.ИнтеграционнаяОбработка = Неопределено)
		И НЕ ГлЯдро_ПересоздатьИнтеграционнуюОбработку(АдресаПеременных) Тогда
		Возврат Новый Структура;
	КонецЕсли;
	СтруктураИО = КомЯдро_ПолучитьЗначениеПеременной("ИнтеграционнаяОбработка", АдресаПеременных);
	ИнтеграционнаяОбработка = СтруктураИО.ИнтеграционнаяОбработка;
	
	ПараметрыАлгоритма.Вставить("МодульОбработки", ИнтеграционнаяОбработка);
	
	ГлЯдро_ВыполнитьПроизвольныйКод(СтрокаВызова, ПараметрыАлгоритма,, "ТекстКодаПолученияПараметров", АдресаПеременных);
	
	ПараметрыЗапроса = ПараметрыАлгоритма.ПараметрыЗапроса;
	
	Возврат ПараметрыЗапроса;	
	
КонецФункции

Функция ГлЯдро_ПолучитьТекущуюДату() Экспорт

	Возврат ТекущаяДата();	
	
КонецФункции

#КонецОбласти

#Область ГлобальныйКонтекст_МеханизмыИзБСП

// Возвращает текстовое представление интервала времени, заданного в секундах.
//
// Параметры:
//	Время - Число - интервал времени в секундах.
//	ПолноеПредставление	- Булево - кратное или полное представление времени.
//		Например, интервал 1 000 000 секунд:
//			- полное представление:  11 дней 13 часов 46 минут 40 секунд;
//			- краткое представление: 11 дней 13 часов.
//
// Возвращаемое значение:
//	Строка - представление интервала времени.
Функция ГлЯдро_ПредставлениеВремени(Знач Время, ПолноеПредставление = Истина, ВыводитьСекунды = Истина) Экспорт
	Результат = "";
	
	// Представление единиц измерения времени в винительном падеже для количеств: 1, 2-4, 5-20.
	ПредставлениеНедель = НСтр("ru = ';%1 неделю;;%1 недели;%1 недель;%1 недели'");
	ПредставлениеДней   = НСтр("ru = ';%1 день;;%1 дня;%1 дней;%1 дня'");
	ПредставлениеЧасов  = НСтр("ru = ';%1 час;;%1 часа;%1 часов;%1 часа'");
	ПредставлениеМинут  = НСтр("ru = ';%1 минуту;;%1 минуты;%1 минут;%1 минуты'");
	ПредставлениеСекунд = НСтр("ru = ';%1 секунду;;%1 секунды;%1 секунд;%1 секунды'");
	ПредставлениеЧасов  = НСтр("ru = ';%1 ч;;%1 ч;%1 ч;%1 ч'");
	ПредставлениеМинут  = НСтр("ru = ';%1 мин;;%1 мин;%1 мин;%1 мин'");
	ПредставлениеСекунд = НСтр("ru = ';%1 сек;;%1 сек;%1 сек;%1 сек'");
	
	ПредставлениеВремени = "ЧДЦ=0; ЧРГ=' '; ЧН=0; ЧГ=3,0; ЧО=1";
	
	Время = Число(Время);
	
	Если Время < 0 Тогда
		Время = -Время;
	КонецЕсли;
	
	КоличествоНедель = Цел(Время / 60/60/24/7);
	КоличествоДней   = Цел(Время / 60/60/24);
	КоличествоЧасов  = Цел(Время / 60/60);
	КоличествоМинут  = Цел(Время / 60);
	КоличествоСекунд = Цел(Время);
	
	КоличествоСекунд = КоличествоСекунд - КоличествоМинут * 60;
	КоличествоМинут  = КоличествоМинут - КоличествоЧасов * 60;
	КоличествоЧасов  = КоличествоЧасов - КоличествоДней * 24;
	КоличествоДней   = КоличествоДней - КоличествоНедель * 7;
	
	Если Не ВыводитьСекунды Тогда
		КоличествоСекунд = 0;
	КонецЕсли;
	
	Если КоличествоНедель > 0 И КоличествоДней+КоличествоЧасов+КоличествоМинут+КоличествоСекунд=0 Тогда
		Результат = ГлЯдро_СтрокаСЧисломДляЛюбогоЯзыка(ПредставлениеНедель, КоличествоНедель, , ПредставлениеВремени) + " нед ";
	Иначе
		КоличествоДней = КоличествоДней + КоличествоНедель * 7;
		
		Счетчик = 0;
		Если КоличествоДней > 0 Тогда
			Результат = Результат + ГлЯдро_СтрокаСЧисломДляЛюбогоЯзыка(ПредставлениеДней, КоличествоДней, , ПредставлениеВремени) + " дн ";
			Счетчик = Счетчик + 1;
		КонецЕсли;
		
		Если КоличествоЧасов > 0 Тогда
			Результат = Результат + ГлЯдро_СтрокаСЧисломДляЛюбогоЯзыка(ПредставлениеЧасов, КоличествоЧасов, , ПредставлениеВремени) + " ч ";
			Счетчик = Счетчик + 1;
		КонецЕсли;
		
		Если (ПолноеПредставление Или Счетчик < 2) И КоличествоМинут > 0 Тогда
			Результат = Результат + ГлЯдро_СтрокаСЧисломДляЛюбогоЯзыка(ПредставлениеМинут, КоличествоМинут, , ПредставлениеВремени) + " мин ";
			Счетчик = Счетчик + 1;
		КонецЕсли;
		
		Если (ПолноеПредставление Или Счетчик < 2) И (КоличествоСекунд > 0 Или КоличествоНедель+КоличествоДней+КоличествоЧасов+КоличествоМинут = 0) Тогда
			Результат = Результат + ГлЯдро_СтрокаСЧисломДляЛюбогоЯзыка(ПредставлениеСекунд, КоличествоСекунд, , ПредставлениеВремени) + " сек";
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат СокрП(Результат);
	
КонецФункции

// Формирует представление числа для определенного языка и параметров числа.
//
// Параметры:
//  Шаблон          - Строка - строка, содержит перечисленные через точку с запятой 6 форм строки
//                             для каждой категории числительного: 
//                             - %1 обозначает позицию числа;
//  Число           - Число - число, которое будет подставлено в строку вместо параметра "%1".
//  Вид             - ВидЧисловогоЗначения - определяет вид числового значения, для которого формируется представление. 
//                             - Количественное (по умолчанию) или Порядковое.
//  ФорматнаяСтрока - Строка - Строка параметров форматирования. См. аналогичный параметр в СтрокаСЧислом. 
//
// Возвращаемое значение:
//  Строка - Представление строки числа в требуемой форме.
//
// Пример:
//
//	Представление параметров:
//		Lang | Zero | One             | Two            | Few               | Many                  | Other
//		============================================================================================================
//		ru   |      | XX1 / X11       |                | XX2-XX4 / X12-X14 | XX0, XX5-XX9, X11-X14 | дробные
//		Card.|      | остался %1 день |                | осталось %1 дня   | осталось %1 дней      | осталось %1 дня
//		     |      | вижу %1 рыбу    |                | вижу %1-х рыб     | вижу %5 рыб           | вижу %1 рыбы
//		------------------------------------------------------------------------------------------------------------
//		ru   |      |                 |                |                   |                       | других нет
//		Ord. |      |                 |                |                   |                       | %1-й день 
//		------------------------------------------------------------------------------------------------------------
//		en   |      | для 1           |                |                   |                       | остальное
//		Card.|      | left %1 day     |                |                   |                       | left %1 days
//		------------------------------------------------------------------------------------------------------------
//		en   |      | XX1 / X11       | XX2 / X12      | XX3 / X13         |                       | остальное
//		Ord. |      | %1st day        | %1nd day       | %1rd day          |                       | %1th day.
//
//		Card. - Cardinal - Количественное;
//		Ord.  - Ordinal  - Порядковое;
//		X - любая цифра;
//		/ - кроме.
//  
//	Строка = ГлЯдро_СтрокаСЧисломДляЛюбогоЯзыка(
//		НСтр("ru=';остался %1 день;;осталось %1 дня;осталось %1 дней;осталось %1 дня';
//			|en=';left %1 day;;;;left %1 days'"), 
//			0.05,, "ЧДЦ=1");
Функция ГлЯдро_СтрокаСЧисломДляЛюбогоЯзыка(Шаблон, Число, Вид = Неопределено, ФорматнаяСтрока = Неопределено) Экспорт

	// В версиях платформы 8.3.9 и ниже отсутствует метод "СтрокаСЧислом" и перечисление "ВидЧисловогоЗначения"
	// Поэтому используем метод "Формат"	
	
	Возврат Формат(Число, ФорматнаяСтрока);

КонецФункции

// Проверяет физическое наличие записи в информационной базе данных о переданном значении ссылки.
//
// Параметры:
//	ПроверяемаяСсылка - ЛюбаяСсылка - значение любой ссылки информационной базы данных.
// 
// Возвращаемое значение:
//	Булево - Истина, если существует.
Функция ГлЯдро_СсылкаСуществует(ПроверяемаяСсылка) Экспорт
	            
	ТекстЗапроса = "
	|ВЫБРАТЬ ПЕРВЫЕ 1
	|	1
	|ИЗ
	|	[ИмяТаблицы]
	|ГДЕ
	|	Ссылка = &Ссылка
	|";
	
	ИмяТаблицыПоСсылке = ПроверяемаяСсылка.Метаданные().ПолноеИмя();
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "[ИмяТаблицы]", ИмяТаблицыПоСсылке);
	
	Запрос = Новый Запрос;
	Запрос.Текст = ТекстЗапроса;
	Запрос.УстановитьПараметр("Ссылка", ПроверяемаяСсылка);
	
	УстановитьПривилегированныйРежим(Истина);
	
	Возврат НЕ Запрос.Выполнить().Пустой();
	
КонецФункции

// Проверяет, содержит ли строка только цифры.
//
// Параметры:
//  Значение         - Строка - проверяемая строка.
//  Устаревший       - Булево - устаревший параметр, не используется.
//  ПробелыЗапрещены - Булево - если Ложь, то в строке допустимо наличие пробелов.
//
// Возвращаемое значение:
//   Булево - Истина - строка содержит только цифры или пустая, Ложь - строка содержит иные символы.
//
// Пример:
//  Результат = ГлЯдро_ТолькоЦифрыВСтроке("0123"); // Истина
//  Результат = ГлЯдро_ТолькоЦифрыВСтроке("0123abc"); // Ложь
//  Результат = ГлЯдро_ТолькоЦифрыВСтроке("01 2 3",, Ложь); // Истина
//
Функция ГлЯдро_ТолькоЦифрыВСтроке(Знач Значение, Знач Устаревший = Истина, Знач ПробелыЗапрещены = Истина) Экспорт
	
	Если ТипЗнч(Значение) <> Тип("Строка") Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если Не ПробелыЗапрещены Тогда
		Значение = СтрЗаменить(Значение, " ", "");
	КонецЕсли;
		
	Если СтрДлина(Значение) = 0 Тогда
		Возврат Истина;
	КонецЕсли;
	
	// Если содержит только цифры, то в результате замен должна быть получена пустая строка.
	// Проверять при помощи ПустаяСтрока нельзя, так как в исходной строке могут быть пробельные символы.
	Возврат СтрДлина(
		СтрЗаменить( СтрЗаменить( СтрЗаменить( СтрЗаменить( СтрЗаменить(
		СтрЗаменить( СтрЗаменить( СтрЗаменить( СтрЗаменить( СтрЗаменить( 
			Значение, "0", ""), "1", ""), "2", ""), "3", ""), "4", ""), "5", ""), "6", ""), "7", ""), "8", ""), "9", "")) = 0;
	
КонецФункции

// Функция из БСП
Функция ГлЯдро_ЗарегистрироватьОбработку(Знач Объект, Знач ПараметрыРегистрации, АдресДанныхОбработки)
	// Получает файл обработки из временного хранилища, пытается создать объект
	// обработки (внешнего отчета) и получает информацию из объекта внешней обработки (отчета)
	
	#Область НесовместимыйКодFresh	
	ВидДополнительныйОтчет 	= Вычислить("Перечисления.ВидыДополнительныхОтчетовИОбработок.ДополнительныйОтчет");
	ВидОтчет 				= Вычислить("Перечисления.ВидыДополнительныхОтчетовИОбработок.Отчет");
	
	Если ПараметрыРегистрации.ОтключатьКонфликтующие = Истина Тогда
		Для Каждого ЭлементСписка Из ПараметрыРегистрации.Конфликтующие Цикл
			КонфликтующийОбъект = ЭлементСписка.Значение.ПолучитьОбъект();
			КонфликтующийОбъект.Публикация = Перечисления.ВариантыПубликацииДополнительныхОтчетовИОбработок.РежимОтладки;
			КонфликтующийОбъект.Записать();
		КонецЦикла;
	КонецЕсли;
	
	Результат = Новый Структура("ИмяОбъекта, СтароеИмяОбъекта, Успешно, ИмяОбъектаЗанято, Конфликтующие, КраткоеПредставлениеОшибки");
	Результат.ИмяОбъектаЗанято = Ложь;
	Результат.Успешно = Ложь;
	//Результат.СтароеИмяОбъекта = ?(ЭтоНовый, Объект.ИмяОбъекта, Объект.Ссылка.ИмяОбъекта);
	Результат.СтароеИмяОбъекта = Объект.ИмяОбъекта; // Данный метод используются только для создание новых обработок. Закомментированные строки из БСП
	
	// Подключение и получение имени, под которым объект будет подключаться
	Менеджер = ?(ПараметрыРегистрации.ЭтоОтчет, ВнешниеОтчеты, ВнешниеОбработки);
	Результат.ИмяОбъекта = СокрЛП(Менеджер.Подключить(АдресДанныхОбработки, , Истина));
	
	// Если отчет публикуется, то необходим контроль уникальности имени объекта, 
	//     под которым дополнительный отчет регистрируется в системе
	Если Объект.Публикация = Вычислить("Перечисления.ВариантыПубликацииДополнительныхОтчетовИОбработок.Используется") Тогда
		// Проверка имени
		ТекстЗапроса =
		"ВЫБРАТЬ
		|	ДОиО.Ссылка,
		|	ДОиО.Представление
		|ИЗ
		|	Справочник.ДополнительныеОтчетыИОбработки КАК ДОиО
		|ГДЕ
		|	ДОиО.ИмяОбъекта = &ИмяОбъекта
		|	И &УсловиеДопОтчет
		|	И ДОиО.Публикация = ЗНАЧЕНИЕ(Перечисление.ВариантыПубликацииДополнительныхОтчетовИОбработок.Используется)
		|	И ДОиО.ПометкаУдаления = ЛОЖЬ
		|	И ДОиО.Ссылка <> &Ссылка";
		
		ВидыДопОтчетов = Новый Массив;
		ВидыДопОтчетов.Добавить(ВидДополнительныйОтчет);
		ВидыДопОтчетов.Добавить(ВидОтчет);
		
		Запрос = Новый Запрос;
		Запрос.УстановитьПараметр("ИмяОбъекта",     Результат.ИмяОбъекта);
		Запрос.УстановитьПараметр("ВидыДопОтчетов", ВидыДопОтчетов);
		Запрос.УстановитьПараметр("Ссылка", Объект.Ссылка);
		
		Если ПараметрыРегистрации.ЭтоОтчет Тогда
			ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&УсловиеДопОтчет", "ДОиО.Вид В (&ВидыДопОтчетов)");
		Иначе
			ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&УсловиеДопОтчет", "НЕ ДОиО.Вид В (&ВидыДопОтчетов)");
		КонецЕсли;
		
		Запрос.Текст = ТекстЗапроса;
		
		УстановитьПривилегированныйРежим(Истина);
		Конфликтующие = Запрос.Выполнить().Выгрузить();
		УстановитьПривилегированныйРежим(Ложь);
		
		Если Конфликтующие.Количество() > 0 Тогда
			Результат.ИмяОбъектаЗанято = Истина;
			Результат.Конфликтующие = Новый СписокЗначений;
			Для Каждого СтрокаТаблицы Из Конфликтующие Цикл
				Результат.Конфликтующие.Добавить(СтрокаТаблицы.Ссылка, СтрокаТаблицы.Представление);
			КонецЦикла; 
			Возврат Результат;
		КонецЕсли;
	КонецЕсли;
	
	// Получение сведений о внешней обработке
	ВнешняяОбработка = Менеджер.Создать(Результат.ИмяОбъекта);
	
	Попытка
		РегистрационныеДанные = ВнешняяОбработка.СведенияОВнешнейОбработке();
	Исключение
		Префикс = "Ошибка получения сведений о внешней обработке " + ПараметрыРегистрации.ИмяФайла + " при ее загрузке:'";
		// Данный метод используются только для создание новых обработок. Закомментированные строки из БСП
		//Если Не ЭтоНовый Тогда
		//	ЗаписьЖурналаРегистрации(
		//		НСтр("ru = 'Дополнительные отчеты и обработки'"),
		//		УровеньЖурналаРегистрации.Ошибка,
		//		Метаданные.Справочники.ДополнительныеОтчетыИОбработки,
		//		Объект.Ссылка,
		//		Префикс + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке())
		//	);
		//КонецЕсли;
		Результат.КраткоеПредставлениеОшибки = Префикс + КраткоеПредставлениеОшибки(ИнформацияОбОшибке());
		Возврат Результат;
	КонецПопытки;
	
	ЭтоПолноправныйПользователь = Вычислить("Пользователи.ЭтоПолноправныйПользователь(, Истина)");
	Если РегистрационныеДанные.БезопасныйРежим
		ИЛИ ЭтоПолноправныйПользователь Тогда
		// ничего не делаем
	Иначе
		Результат.КраткоеПредставлениеОшибки = НСтр("ru = 'Для добавления обработок запускаемых в небезопасном режиме требуются полные права.'");
		Возврат Результат;
	КонецЕсли;
	
	Вид = Вычислить("Перечисления.ВидыДополнительныхОтчетовИОбработок[РегистрационныеДанные.Вид]");
	Если ПараметрыРегистрации.ЭтоОтчет <> (Вид = ВидДополнительныйОтчет ИЛИ Вид = ВидОтчет) Тогда
		Результат.КраткоеПредставлениеОшибки = НСтр("ru = 'Вид обработки, указанный в сведениях о внешней обработке, не соответствует её расширению.'");
		Возврат Результат;
	КонецЕсли;
	
	// Инициализация сведений об обработке
	Объект.Наименование		= РегистрационныеДанные.Наименование;
	Объект.Версия			= РегистрационныеДанные.Версия;
	Объект.БезопасныйРежим	= РегистрационныеДанные.БезопасныйРежим;
	Объект.Информация		= РегистрационныеДанные.Информация;
	Объект.ИмяФайла         = ПараметрыРегистрации.ИмяФайла;
	Объект.ИмяОбъекта       = Результат.ИмяОбъекта;
	
	// Загружена другая обработка (изменилось имя объекта или вид обработки)
	Если Объект.ИмяОбъекта <> Результат.ИмяОбъекта ИЛИ Объект.Вид <> Вид Тогда
		Объект.Назначение.Очистить();
		Объект.Вид = Вид;
	КонецЕсли;
	
	// Если не заполнено назначение - устанавливаем назначение из обработки
	Если 
		(
			//ЭтоНовый // Данный метод используются только для создание новых обработок. Закомментированные строки из БСП
			Истина
			ИЛИ Объект.Назначение.Количество() = 0
		)
		И (
			Объект.Вид = Вычислить("Перечисления.ВидыДополнительныхОтчетовИОбработок.ЗаполнениеОбъекта")
			ИЛИ Объект.Вид = Вычислить("Перечисления.ВидыДополнительныхОтчетовИОбработок.Отчет")
			ИЛИ Объект.Вид = Вычислить("Перечисления.ВидыДополнительныхОтчетовИОбработок.ПечатнаяФорма")
			ИЛИ Объект.Вид = Вычислить("Перечисления.ВидыДополнительныхОтчетовИОбработок.СозданиеСвязанныхОбъектов")
		) Тогда
		
		Объект.ИспользоватьДляФормыОбъекта = Истина;
		Объект.ИспользоватьДляФормыСписка = Истина;
		
		ПолноеНазначениеЗначение = Вычислить("ДополнительныеОтчетыИОбработки.ПолучитьПолноеНазначениеПоВидуДополнительнойВнешнейОбработки(Объект.Вид)");
		
		Если РегистрационныеДанные.Свойство("Назначение") Тогда
			
			Для Каждого ЭлементЗаданноеНазначение Из РегистрационныеДанные.Назначение Цикл
				
				РазделеннаяСтрока = ГлЯдро_РазложитьСтрокуВМассивПодстрок(ЭлементЗаданноеНазначение, ".");
				
				Если РазделеннаяСтрока[1] = "*" Тогда
					
					НайденныеНазначения = ПолноеНазначениеЗначение.НайтиСтроки(Новый Структура("Класс", РазделеннаяСтрока[0]));
					
					Для Каждого ЭлементНайденноеНазначение Из НайденныеНазначения Цикл
						НоваяСтрока = Объект.Назначение.Добавить();
						НоваяСтрока.ПолноеИмяОбъектаМетаданных = ЭлементНайденноеНазначение.ПолноеИмяОбъектаМетаданных;
					КонецЦикла;
					
				Иначе
					
					Если ПолноеНазначениеЗначение.НайтиСтроки(Новый Структура("ПолноеИмяОбъектаМетаданных", ЭлементЗаданноеНазначение)).Количество() > 0 Тогда
						НоваяСтрока = Объект.Назначение.Добавить();
						НоваяСтрока.ПолноеИмяОбъектаМетаданных = ЭлементЗаданноеНазначение;
					КонецЕсли;
					
				КонецЕсли;
				
			КонецЦикла;
		КонецЕсли;
		
		Объект.Назначение.Свернуть("ПолноеИмяОбъектаМетаданных", "");
				
	КонецЕсли;
	
	КомандыСохраненные = Объект.Команды.Выгрузить();
	
	Объект.Команды.Очистить();
	
	// Инициализация команд
	
	Для Каждого ЭлементОписаниеКоманды Из РегистрационныеДанные.Команды Цикл
		
		НоваяСтрока = Объект.Команды.Добавить();
		НоваяСтрока.Идентификатор	= ЭлементОписаниеКоманды.Идентификатор;
		НоваяСтрока.Представление	= ЭлементОписаниеКоманды.Представление;
		НоваяСтрока.Модификатор		= ЭлементОписаниеКоманды.Модификатор;
		НоваяСтрока.ПоказыватьОповещение = ЭлементОписаниеКоманды.ПоказыватьОповещение;
		
		Если ЭлементОписаниеКоманды.Использование = "ОткрытиеФормы" Тогда
			НоваяСтрока.ВариантЗапуска = Вычислить("Перечисления.СпособыВызоваДополнительныхОбработок.ОткрытиеФормы");
		ИначеЕсли ЭлементОписаниеКоманды.Использование = "ВызовКлиентскогоМетода" Тогда
			НоваяСтрока.ВариантЗапуска = Вычислить("Перечисления.СпособыВызоваДополнительныхОбработок.ВызовКлиентскогоМетода");
		ИначеЕсли ЭлементОписаниеКоманды.Использование = "ВызовСерверногоМетода" Тогда
			НоваяСтрока.ВариантЗапуска = Вычислить("Перечисления.СпособыВызоваДополнительныхОбработок.ВызовСерверногоМетода");
		Иначе
			ТекстСообщения = "Для команды " + ЭлементОписаниеКоманды.Представление + " не определен способ запуска.";
			ВызватьИсключение ТекстСообщения;
		КонецЕсли;
		
	КонецЦикла;
	
	Объект.Ответственный = Вычислить("Пользователи.ТекущийПользователь()");
		
	Результат.Успешно = Истина;
	
	Возврат Результат;
	#КонецОбласти //НесовместимыйКодFresh
КонецФункции

#КонецОбласти

#Область КомпонентаMobileSMARTS

#КонецОбласти

#КонецОбласти

#Область РегламентныйОбмен

Процедура ВыполнитьКоманду(ИдентификаторКоманды, ОбъектыНазначения = Неопределено) Экспорт
	
	Если ИдентификаторКоманды = "Регламентная выгрузка справочников в Mobile SMARTS" Тогда		
		РегламентноеЗадание_ВыгрузитьСправочники();
	КонецЕсли;
			
КонецПроцедуры

Процедура РегламентноеЗадание_ВыгрузитьСправочники() 
	
	ТипИнтерфейса = ГлЯдро_ПолучитьДанныеИзХранилища1С("Cleverence_ТипИнтерфейса");		
	ЭтоWebСервис = Истина;
	АдресаПеременных = КомЯдро_СоздатьСтруктуруАдресаПеременных();
	НачалоВыгрузки = ТекущаяУниверсальнаяДатаВМиллисекундах();
	
	ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации("Регламентная выгрузка", "Информация", "Начало. ТипИнтерфейса:"+ТипИнтерфейса, ,АдресаПеременных);	
	
	ИмяСобытия = "Регламентная выгрузка";
	
	НастройкиИнициализированы = КомЯдро_ПолучитьЗначениеПеременной("НастройкиИнициализированы",АдресаПеременных);
			
	НастройкиИзменились = ГлЯдро_НастройкиИзменились(АдресаПеременных);
	Если НастройкиИзменились
		ИЛИ НЕ НастройкиИнициализированы = Истина Тогда
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Предупреждение", "Переинициализация настроек. НастройкиИнициализированы = "+Строка(НастройкиИнициализированы)+", НастройкиИзменились = "+Строка(НастройкиИзменились),,АдресаПеременных);
		ГлЯдро_Инициализация(ИмяСобытия,НастройкиИзменились,,АдресаПеременных);
	КонецЕсли;
	
	МетаданныеНСИ = ГлЯдро_ПолучитьМетаданныеНСИ(АдресаПеременных);
	
	СписокИспользуемыхСправочников = ГлЯдро_ПолучитьСписокИспользуемыхСправочников(АдресаПеременных);
	РасположениеКомпоненты = ГлЯдро_ПолучитьДанныеИзХранилища1С("Cleverence_РасположениеКомпоненты");
	//Может вернуться неопределено в случае, если нет интеграционной обработки
	//Попробуем получить ИО снова
	Если  МетаданныеНСИ = Неопределено
		ИЛИ СписокИспользуемыхСправочников = Неопределено Тогда
		
		ГлЯдро_ПодключитьИнтеграционнуюОбработку(,,,,АдресаПеременных);
		
		МетаданныеНСИ = ГлЯдро_ПолучитьМетаданныеНСИ(АдресаПеременных);
		СписокИспользуемыхСправочников = ГлЯдро_ПолучитьСписокИспользуемыхСправочников(АдресаПеременных);
		Если  МетаданныеНСИ = Неопределено
			ИЛИ СписокИспользуемыхСправочников = Неопределено Тогда
			ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации("Регламентная выгрузка", "Ошибка", "Не удалось получить список используемых справочников", ,АдресаПеременных);
			Возврат;
		КонецЕсли;
		
	КонецЕсли;
	
	АвтотестКлеверенс = КомЯдро_ПолучитьЗначениеПеременной("Автотест",АдресаПеременных);
	Если АвтотестКлеверенс = Неопределено Тогда
		АвтотестКлеверенс = Ложь;
	КонецЕсли;
		
	СоответствиеСправочниковКлючамИспользования = ГлЯдро_СоответствиеСправочниковКлючамИспользованияПоУмолчанию(АдресаПеременных);
	
	Для Каждого ИмяСправочника ИЗ СписокИспользуемыхСправочников Цикл
		
		СправочникИмя 	= ИмяСправочника.Значение;
		ПараметрыВыгрузки 	= ГлЯдро_ПолучитьЗаполнитьСтруктуруПараметровВыгрузкиСправочника(СправочникИмя, АдресаПеременных);
		КлючНастройкиПоУмолчанию 	= СоответствиеСправочниковКлючамИспользования.Получить(СправочникИмя);
		НастройкаВыгружатьСразу 	= ГлЯдро_ПолучитьИзКэшаНастройкуSMARTS(КлючНастройкиПоУмолчанию,,АдресаПеременных);
		
		Если СправочникИмя = "Номенклатура" Тогда			
			
			Если (НастройкаВыгружатьСразу Или АвтотестКлеверенс) Тогда			
				РазмерПорцииНоменклатуры = РазмерПорцииНоменклатуры = ГлЯдро_ПолучитьИзКэшаНастройкуSMARTS("РазмерПорцииНоменклатуры",,АдресаПеременных);
				
				Если РазмерПорцииНоменклатуры <> Ложь И ЗначениеЗаполнено(РазмерПорцииНоменклатуры) Тогда
					ГлЯдро_ВыгрузитьТаблицуНаСерверSMARTSПорциями("Номенклатура",,,"Основная",Истина,РазмерПорцииНоменклатуры,,ПараметрыВыгрузки, АдресаПеременных);
				Иначе
				ГлЯдро_ВыгрузитьТаблицуНаСерверSMARTS("Номенклатура",,,"Основная",Истина,,ПараметрыВыгрузки,АдресаПеременных);	
				КонецЕсли;
			КонецЕсли;
			
		ИначеЕсли СправочникИмя = "Характеристики" Тогда 
			
			Если (НастройкаВыгружатьСразу Или АвтотестКлеверенс) И МетаданныеНСИ.Характеристики.Использование Тогда			
				ГлЯдро_ВыгрузитьТаблицуНаСерверSMARTS("Характеристики",,,,,,ПараметрыВыгрузки,АдресаПеременных);													
			КонецЕсли;
			
		ИначеЕсли СправочникИмя = "ДопРеквизиты" Тогда 
			
			ВыгружатьИнформациюДляЦенниковСразу = ГлЯдро_ПолучитьИзКэшаНастройкуSMARTS("ВыгружатьИнформациюДляЦенниковСразу",, АдресаПеременных);
			Если ВыгружатьИнформациюДляЦенниковСразу = Неопределено Тогда
				ВыгружатьИнформациюДляЦенниковСразу = Ложь;				
			КонецЕсли;
			
			Если (НастройкаВыгружатьСразу ИЛИ ВыгружатьИнформациюДляЦенниковСразу ИЛИ АвтотестКлеверенс) Тогда			
				ГлЯдро_ВыгрузитьТаблицуНаСерверSMARTS("ДопРеквизиты",,,,,,ПараметрыВыгрузки,АдресаПеременных);					
			КонецЕсли;
			
		ИначеЕсли НастройкаВыгружатьСразу = Истина Или АвтотестКлеверенс Тогда
			
			ГлЯдро_ВыгрузитьТаблицуНаСерверSMARTS(СправочникИмя,,,,,,ПараметрыВыгрузки,АдресаПеременных);
			
		КонецЕсли;		
		
	КонецЦикла;	
	
	ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации("Регламентная выгрузка", "Информация", "Конец выгрузки",НачалоВыгрузки ,АдресаПеременных);	
КонецПроцедуры
#КонецОбласти

#Область КомпонентаMobileSMARTS_Подключение

// Вызывает функцию проверки соединения с сервером Mobile Smarts, при успешном выполнении проверки - с подключенной базой Mobile Smarts
//
// Параметры:
//	СтруктураПодключения - Структура - структура подключения к базе Mobile Smarts
//  Переподключиться - Булево - определяет необходимость явного переподключения к базе Mobile Smarts
//  ТипБазы - Строка - "Частная", "Временная", "Основная"
//	СохранятьАвторизацию - Булево - флаг необходимости сохранять данные авторизации
//  Интерактивно - Булево - флаг работы в интерактивном режиме
//	НеПроверятьАвторизацию - Булево - признак необходимости проверки авторизации
//  АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
//
// Возвращаемое значение:
//	- Структура - если требуется авторизация в интерактивном режиме - содержит:
//  	* Статус - Строка	
//      * СтрокаПодключения - Строка
//      * ИмяБазы - Строка
//      * Логин - Строка
//      * ТипБазы - Строка
//      * ДопПараметры - Структура - содержит:
//			** СтрокаПодключения - Строка
//          ** ТипБазы - Строка
//          ** СтруктураПодключения - Структура - структура подключения к базе Mobile Smarts
//          ** СохранятьАвторизацию - Булево
//          ** ИмяБазы - Строка
//			** Логин - Строка
//	- Булево - результат проверки соединения с сервером Mobile Smarts
Функция ГлЯдро_ПроверитьСоединениеССерверомSMARTS(СтруктураПодключения = Неопределено, Переподключиться = ложь,
	ТипБазы = "Основная",СохранятьАвторизацию = Ложь,Интерактивно = Ложь,НеПроверятьАвторизацию = Ложь,АдресаПеременных) Экспорт
	
	Если ТипЗнч(СтруктураПодключения) = Тип("Структура")
		И СтруктураПодключения.Свойство("ТипИнтерфейса")
		И ЗначениеЗаполнено(СтруктураПодключения.ТипИнтерфейса) Тогда
		ТипИнтерфейса = СтруктураПодключения.ТипИнтерфейса;
	Иначе
		ТипИнтерфейса = ГлЯдро_ПолучитьТипИнтерфейса(ТипБазы, АдресаПеременных); // ТипИнтерфейса = КомЯдро_ПолучитьЗначениеПеременной("ТипИнтерфейса",АдресаПеременных);
	КонецЕсли;
	
	Если ТипИнтерфейса = Неопределено Тогда
		ТипИнтерфейса = ГлЯдро_ПолучитьДанныеИзХранилища1С("Cleverence_ТипИнтерфейса");
	КонецЕсли;
	
	Если ТипИнтерфейса = "REST_API" Тогда
		
		Если ТипБазы = "Частная" Тогда
			КлючПеременной = "REST_API_СтруктураПодключенияЧастнойБазыMS";
		ИначеЕсли ТипБазы = "Временная" Тогда
			КлючПеременной = "REST_API_СтруктураПодключенияВременнойБазыMS";
		Иначе
			КлючПеременной = "REST_API_СтруктураПодключенияБазыMS";
		КонецЕсли;
		
		Если СтруктураПодключения = Неопределено ИЛИ СтруктураПодключения = "" Тогда
			СтруктураПодключения = КомЯдро_ПолучитьЗначениеПеременной(КлючПеременной,АдресаПеременных);
			Если НЕ СтруктураПодключения.Свойство("ТипБазы") Тогда
				СтруктураПодключения.Вставить("ТипБазы",ТипБазы);
			КонецЕсли;
		Иначе
			Если НЕ СтруктураПодключения.Свойство("ТипБазы") Тогда
				СтруктураПодключения.Вставить("ТипБазы",ТипБазы);
			КонецЕсли;
			КомЯдро_СохранитьЗначениеПеременной(КлючПеременной,СтруктураПодключения,АдресаПеременных);
		КонецЕсли;
		
		ЭтоВнешнееСоединение = Ложь;
		
		#Если ВнешнееСоединение Тогда
			ЭтоВнешнееСоединение = Истина;	
		#КонецЕсли
		
		Если ЭтоВнешнееСоединение И НЕ КомЯдро_ПолучитьЗначениеПеременной("ИспJSON_mXmlDoc",АдресаПеременных) = Истина Тогда
			КомЯдро_ПроверитьСоединениеССерверомSMARTS(СтруктураПодключения, Переподключиться,ТипБазы,СохранятьАвторизацию,Интерактивно,АдресаПеременных);
		КонецЕсли;			
		
		Возврат REST_API_ПодключитьсяКБазеSMARTS(СтруктураПодключения, Интерактивно, НеПроверятьАвторизацию, АдресаПеременных);
	Иначе
		Возврат КомЯдро_ПроверитьСоединениеССерверомSMARTS(СтруктураПодключения, Переподключиться,ТипБазы,СохранятьАвторизацию,Интерактивно,АдресаПеременных);
	КонецЕсли;
	
КонецФункции

// Проверяет создание COM-объекта и возвращает результат проверки
//
// Параметры:
//	АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных	
//
// Возвращаемое значение:
//	- Булево - полученное значение переменной КОМСоздан
//  - Неопределено - если получить значение переменной КОМСоздан не удалось
Функция ГлЯдро_ПроверитьСозданиеКОМОбъекта(АдресаПеременных) Экспорт
	Возврат КомЯдро_ПолучитьЗначениеПеременной("КОМСоздан",АдресаПеременных);
КонецФункции

Функция КомЯдро_ПроверитьСоединениеССерверомSMARTS(СтруктураПодключения = Неопределено, Переподключиться = ложь,ТипБазы = "Основная",СохранятьАвторизацию = Ложь,Интерактивно = Ложь, АдресаПеременных)
	
	Если НЕ КомЯдро_ПодключитьсяКСерверуSMARTS(Переподключиться,ТипБазы, АдресаПеременных) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если ТипБазы = "Частная" Тогда
		СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("COMЧастнойБазыMS",АдресаПеременных);
		пСтруктура = КомЯдро_ПолучитьЗначениеПеременной("ДанныеТекущегоУзла",АдресаПеременных);
	ИначеЕсли ТипБазы = "Временная" Тогда
		СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("COMВременнойБазыMS",АдресаПеременных);
		пСтруктура = Неопределено;
	Иначе
		СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("COMБазыMS",АдресаПеременных);
		пСтруктура = КомЯдро_ПолучитьЗначениеПеременной("ПараметрыПодключенияMS",АдресаПеременных);
	КонецЕсли;
		
	Если СтруктураПодключенияMS = Неопределено Тогда
		Возврат Ложь;
	Иначе
		
		Если СтруктураПодключения = Неопределено Тогда
			нСтруктура = пСтруктура;
		Иначе
			нСтруктура = СтруктураПодключения;
		КонецЕсли;
		Возврат КомЯдро_ПодключитьсяКБазеSMARTS(нСтруктура,Переподключиться,ТипБазы,СохранятьАвторизацию,Интерактивно,АдресаПеременных);								
	КонецЕсли;	
	
КонецФункции

// Выполняет проверку подключения к базе Mobile Smarts по идентификатору подключенной базы.
//
// Параметры:
//	ЕстьПодключение - Булево - флаг установления соединения с сервером Mobile Smarts	
//  ДопПараметры - Структура - содержит:
//		* СтрокаПодключения - Строка
//      * ТипБазы - Строка - "Частная", "Временная", "Основная"
//      * СтруктураПодключения - Структура - структура подключения к базе Mobile Smarts
//      * СохранятьАвторизацию - Булево
//      * ИмяБазы - Строка
//	АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
//
// Возвращаемое значение:
//	Булево
Функция КомЯдро_ПроверитьСоединениеССерверомSMARTSЗавершение(ЕстьПодключение, ДопПараметры,АдресаПеременных) Экспорт
	
	НачалоСобытия = ТекущаяУниверсальнаяДатаВМиллисекундах();
	Если ДопПараметры.ТипБазы = "Частная" Тогда
		СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("COMЧастнойБазыMS",АдресаПеременных);
	ИначеЕсли ДопПараметры.ТипБазы = "Временная" Тогда
		СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("COMВременнойБазыMS",АдресаПеременных);
	Иначе
		СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("COMБазыMS",АдресаПеременных);
	КонецЕсли;
	
	Если ЕстьПодключение <> Ложь Тогда
		Если ЗначениеЗаполнено(СтруктураПодключенияMS.StorageConnector.ИдПодключеннойБазы) тогда
			ЕстьПодключение = СтруктураПодключенияMS.StorageConnector.ПроверитьСоединение();
		Иначе
			ЕстьПодключение = Ложь;
		КонецЕсли;
	КонецЕсли;	
	
	Возврат ЕстьПодключение;
КонецФункции

// Проверяет наличие подключения к серверу Mobile Smarts. Если подключения нет, пытается переподключиться и поднять COM.
//
// Параметры:
//	Переподключиться - Булево - определяет необходимость явного переподключения к базе Mobile Smarts
//  ТипБазы - Строка - "Частная", "Временная", "Основная"
//	АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
//
// Возвращаемое значение:
//	Булево - флаг наличия подключения к серверу Mobile Smarts
Функция КомЯдро_ПодключитьсяКСерверуSMARTS(Переподключиться, ТипБазы, АдресаПеременных) Экспорт
	
	НачалоСобытия = ТекущаяУниверсальнаяДатаВМиллисекундах();
	ИмяСобытия = "КомЯдро_ПодключитьсяКСерверуSMARTS";
	
	Если ТипБазы = "Частная" Тогда
		СтруктураБазMSCOM = КомЯдро_ПолучитьЗначениеПеременной("COMЧастнойБазыMS",АдресаПеременных);
		КлючПеременной = "СтруктураПодключенияЧастнойБазыMS";
	ИначеЕсли ТипБазы = "Временная" Тогда
		СтруктураБазMSCOM = КомЯдро_ПолучитьЗначениеПеременной("COMВременнойБазыMS",АдресаПеременных);
		КлючПеременной = "СтруктураПодключенияВременнойБазыMS";
	Иначе
		СтруктураБазMSCOM = КомЯдро_ПолучитьЗначениеПеременной("COMБазыMS",АдресаПеременных);
		КлючПеременной = "СтруктураПодключенияБазыMS";
	КонецЕсли;
	
	СтруктураБазMS = КомЯдро_ПолучитьЗначениеПеременной(КлючПеременной,АдресаПеременных);
	
	НужноПересоздатьКом = Переподключиться = Истина
		 ИЛИ СтруктураБазMSCOM = Неопределено 
		 ИЛИ Строка(СтруктураБазMSCOM.TerminalConnector) <> "COMОбъект";		 
		 
	Если НЕ НужноПересоздатьКом Тогда
		
		ЭтоВнешнееСоединение = Ложь;
		#Если ВнешнееСоединение Тогда
			ЭтоВнешнееСоединение = Истина;	
		#КонецЕсли
					 
		Попытка
			Если ЭтоВнешнееСоединение ИЛИ ЭтоWebСервис Тогда	
				Если Не ЗначениеЗаполнено(СтруктураБазMSCOM.StorageConnector.ИдПодключеннойБазы)  Тогда
					НужноПересоздатьКом = Истина;
				КонецЕсли;
			Иначе
				НужноПересоздатьКом = ЗначениеЗаполнено(СтруктураБазMSCOM.StorageConnector.ИдПодключеннойБазы) И СтруктураБазMSCOM.StorageConnector.ПроверитьСоединение() <> Истина;
				ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Проверка соединения с базой Mobile SMARTS",НачалоСобытия,АдресаПеременных);
			КонецЕсли;
		Исключение
			ИнфоОбОшибке = ИнформацияОбОшибке();
			ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Тест cоединения с базой Mobile SMARTS не пройден, запуск переподключения, Описание ошибки: " + ПодробноеПредставлениеОшибки(ИнфоОбОшибке), НачалоСобытия, АдресаПеременных);
			НужноПересоздатьКом = Истина;
		КонецПопытки;
	КонецЕсли;
		 
	Если НужноПересоздатьКом Тогда
		СтруктураБазMSCOM = КомЯдро_ПолучитьСтруктуруПодключенияБазыСМАРТС(АдресаПеременных);
	КонецЕсли;
	
	ЕстьПодключение = СтруктураБазMSCOM <> Неопределено И Строка(СтруктураБазMSCOM.TerminalConnector) = "COMОбъект";
	
	Если НужноПересоздатьКом И ЕстьПодключение 
		И СтруктураБазMS <> Неопределено
		И ТипЗнч(СтруктураБазMS) = Тип("Структура") Тогда
		
		Если СтруктураБазMS.Свойство("СтрокаПодключенияСМАРТС") И ЗначениеЗаполнено(СтруктураБазMS.СтрокаПодключенияСМАРТС) Тогда
			СтрокаПодключения = СтруктураБазMS.СтрокаПодключенияСМАРТС;
		ИначеЕсли СтруктураБазMS.Свойство("IdBaseSMARTS") И ЗначениеЗаполнено(СтруктураБазMS.IdBaseSMARTS) Тогда
			СтрокаПодключения = СтруктураБазMS.IdBaseSMARTS;
		ИначеЕсли СтруктураБазMS.Свойство("ОписаниеБазы")
			И СтруктураБазMS.ОписаниеБазы.Свойство("IdBaseSMARTS") Тогда
			СтрокаПодключения = СтруктураБазMS.ОписаниеБазы.Ид;
		Иначе
			СтрокаПодключения = Неопределено;
		КонецЕсли;
		
		Если СтрокаПодключения <> Неопределено Тогда
			Попытка
				Результат = СтруктураБазMSCOM.TerminalConnector.УстановитьТекущуюБазуСМАРТСБезАвт(СтрокаПодключения) = Истина;
				СтруктураБазMSCOM.StorageConnector.УстановитьТекущуюБазуСМАРТСБезАвт(СтрокаПодключения);
				ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Проверка соединения с базой Mobile SMARTS",НачалоСобытия,АдресаПеременных);
			Исключение
				Результат = СтруктураБазMSCOM.TerminalConnector.УстановитьТекущуюБазуСМАРТС(СтрокаПодключения) = Истина;
				Если Результат Тогда
					СтруктураБазMSCOM.StorageConnector.УстановитьПодключениеСБазойСМАРТС(СтрокаПодключения);
				КонецЕсли;
			КонецПопытки;
			
			Если Результат И СтруктураБазMS.Свойство("ОписаниеБазы")
				И ТипЗнч(СтруктураБазMS.ОписаниеБазы) = Тип("Структура")
				И СтруктураБазMS.ОписаниеБазы.Свойство("АвторизацияВключена")
				И СтруктураБазMS.ОписаниеБазы.АвторизацияВключена
				И СтруктураБазMS.ОписаниеБазы.Свойство("АвторизацияЛогин")
				И ЗначениеЗаполнено(СтруктураБазMS.ОписаниеБазы.АвторизацияЛогин)
				И СтруктураБазMS.ОписаниеБазы.Свойство("АвторизацияТокен")
				И ЗначениеЗаполнено(СтруктураБазMS.ОписаниеБазы.АвторизацияТокен) Тогда
				//Если авторизация сохранена
				
				РезультатАвторизации= Неопределено;
				Попытка
					РезультатАвторизации = СтруктураБазMSCOM.TerminalConnector.АвторизоватьсяПоТокену(СтруктураБазMS.ОписаниеБазы.АвторизацияЛогин,СтруктураБазMS.ОписаниеБазы.АвторизацияТокен);
					//Подключим StorageConnector отдельно т.к. теперь StorageConnector создается не из TerminalConnector
					СтруктураБазMSCOM.StorageConnector.АвторизоватьсяПоТокену(СтруктураБазMS.ОписаниеБазы.АвторизацияЛогин,СтруктураБазMS.ОписаниеБазы.АвторизацияТокен);
					ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Проверка соединения с базой Mobile SMARTS",НачалоСобытия,АдресаПеременных);
				Исключение	
				КонецПопытки;
			КонецЕсли;
			
		КонецЕсли;
	
	КонецЕсли;
	
	Если ТипБазы = "Частная" Тогда
		пCOMЧастнойБазыMS = СтруктураБазMSCOM;
		КомЯдро_СохранитьЗначениеПеременной("COMЧастнойБазыMS",пCOMЧастнойБазыMS,АдресаПеременных)
	ИначеЕсли ТипБазы = "Временная" Тогда
		пCOMВременнойБазыMS = СтруктураБазMSCOM;
		КомЯдро_СохранитьЗначениеПеременной("COMВременнойБазыMS",пCOMВременнойБазыMS,АдресаПеременных)
	Иначе
		пCOMБазыMS = СтруктураБазMSCOM;
		КомЯдро_СохранитьЗначениеПеременной("COMБазыMS",пCOMБазыMS,АдресаПеременных)
	КонецЕсли;
	ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Есть подключение: "+Строка(ЕстьПодключение),НачалоСобытия,АдресаПеременных);
	Возврат ЕстьПодключение;
	
КонецФункции

Функция КомЯдро_ПолучитьСтруктуруПодключенияБазыСМАРТС(АдресаПеременных,ВтораяПопытка = Ложь)
	
	НачалоСобытия = ТекущаяУниверсальнаяДатаВМиллисекундах();
	ИмяСобытия="КомЯдро_ПолучитьСтруктуруПодключенияБазыСМАРТС";
		
	TerminalConnector = Неопределено;
	ТекстОшибки = "";
	НужноПочиститьКеш = Ложь;
	
	ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Начало, перед созданием ком объектов",НачалоСобытия,АдресаПеременных);
	Попытка
		#Область НесовместимыйКодFresh
		TerminalConnector = Новый COMОбъект("AddIn.Cl.TerminalConnector");
		StorageConnector = Новый COMОбъект("Cleverence.Warehouse.StorageConnector");
		#КонецОбласти //НесовместимыйКодFresh
		КОМсоздан = Истина;
	Исключение
		КОМсоздан = Ложь;
		ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
	КонецПопытки;
	ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Комсоздан = "+Строка(КОМсоздан),НачалоСобытия,АдресаПеременных);
	Если TerminalConnector = Неопределено Тогда
		КОМсоздан = Ложь;
	Иначе
		Попытка
			ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Перед: УстановитьВерсию1С",НачалоСобытия,АдресаПеременных);
			TerminalConnector.УстановитьВерсию1С("v8");
			ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "После: УстановитьВерсию1С",НачалоСобытия,АдресаПеременных);
		Исключение
			КОМсоздан = Ложь;
			ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());			
			НужноПочиститьКеш = Истина;
		КонецПопытки;
	КонецЕсли;
	
	Если КОМсоздан = Ложь Тогда
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Ком НЕ Создался! ВтораяПопытка = " + Строка(ВтораяПопытка) + ", ОписаниеОшибки: " + ТекстОшибки, НачалоСобытия, АдресаПеременных);		
		TerminalConnector = Неопределено;
		Если НЕ ВтораяПопытка И НужноПочиститьКеш Тогда
			КомЯдро_УдалитьПеременныеCOM(АдресаПеременных);
			ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Очистка комов и кеша выполнена",,АдресаПеременных);
			Возврат КомЯдро_ПолучитьСтруктуруПодключенияБазыСМАРТС(АдресаПеременных,Истина);			
		КонецЕсли;
		Возврат Неопределено;
	КонецЕсли;
		
	СтруктураПодключенияMSСМАРТС = Новый Структура;
	#Область НесовместимыйКодFresh
	СтруктураПодключенияMSСМАРТС.Вставить("TerminalConnector", TerminalConnector);
	СтруктураПодключенияMSСМАРТС.Вставить("StorageConnector", StorageConnector);
	#КонецОбласти //НесовместимыйКодFresh
	
	КомЯдро_СохранитьЗначениеПеременной("КОМсоздан",КОМсоздан,АдресаПеременных);
	ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Конец создания комов и помещения их в структуру, структура: " +Строка(СтруктураПодключенияMSСМАРТС),НачалоСобытия,АдресаПеременных);
	Возврат СтруктураПодключенияMSСМАРТС;
	
КонецФункции

Процедура КомЯдро_УдалитьПеременныеCOM(АдресаПеременных)
	КомЯдро_УдалитьЗначениеПеременной("COMЧастнойБазыMS",АдресаПеременных);
	КомЯдро_УдалитьЗначениеПеременной("COMВременнойБазыMS",АдресаПеременных);
	КомЯдро_УдалитьЗначениеПеременной("COMБазыMS",АдресаПеременных);		
КонецПроцедуры

Функция КомЯдро_ПолучитьЗначениеПеременной(КлючПеременной,АдресаПеременных)
	Если НЕ ЗначениеЗаполнено(КлючПеременной)
		ИЛИ НЕ ТипЗнч(АдресаПеременных) = Тип("Структура")
		ИЛИ НЕ АдресаПеременных.Свойство(КлючПеременной) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ЭтоФоновоеЗадание = Ложь;
	Если АдресаПеременных.Свойство("ЭтоФоновоеЗадание")
		И АдресаПеременных.ЭтоФоновоеЗадание = Истина Тогда
		ЭтоФоновоеЗадание = Истина;
	КонецЕсли;

	Если ТипЗнч(КлючПеременной) = Тип("Строка") Тогда
		Если НЕ ЭтоАдресВременногоХранилища(АдресаПеременных[КлючПеременной]) Тогда
			Если Не ЭтоФоновоеЗадание Тогда
				Возврат Неопределено;
			Иначе
				// В фоновом задании значения могут быть не сохранены во временное хранилище
				Возврат АдресаПеременных[КлючПеременной];
			КонецЕсли;
		КонецЕсли;
		Возврат ПолучитьИзВременногоХранилища(АдресаПеременных[КлючПеременной]);
	ИначеЕсли ТипЗнч(КлючПеременной) = Тип("Структура") Тогда
		Для Каждого КлючЗначение ИЗ КлючПеременной Цикл
			Если НЕ ЭтоАдресВременногоХранилища(АдресаПеременных[КлючЗначение.Ключ]) Тогда
				Если Не ЭтоФоновоеЗадание Тогда
					ПолученноеЗначение = Неопределено;
				Иначе
					// В фоновом задании значения могут быть не сохранены во временное хранилище
					ПолученноеЗначение = АдресаПеременных[КлючЗначение.Ключ];
				КонецЕсли;
			Иначе
				ПолученноеЗначение = ПолучитьИзВременногоХранилища(АдресаПеременных[КлючЗначение.Ключ]);
			КонецЕсли;	
			КлючПеременной.Вставить(КлючЗначение.Ключ,ПолученноеЗначение); 
		КонецЦикла;		
		Возврат КлючПеременной;
	КонецЕсли;
КонецФункции

// Сохраняет значения во временном хранилище и добавляет адрес в переменную для хранения 
//
// Параметры:
//	КлючПеременной - Строка, Структура - ключ для хранения переменной в структуре адресов или структура сохраняемых значений.
//	СохраняемоеЗначение	- Произвольный, Структура - Сохраняемое значение переменной или, если КлючПеременной содержит структуру,
//													то Структура с адресами переменных.
//  АдресаПеременных - Структура - структура с адресами переменных. Должно содержать как минимум один ключ "ИдентификаторФормы" для привязки переменных.
//
// Возвращаемое значение:
//   Булево - Возвращает признак успешности сохранения.
Функция КомЯдро_СохранитьЗначениеПеременной(КлючПеременной,СохраняемоеЗначение,АдресаПеременных = Неопределено)
	
	Если НЕ ЗначениеЗаполнено(КлючПеременной)
		ИЛИ НЕ ТипЗнч(АдресаПеременных) = Тип("Структура")
		ИЛИ НЕ АдресаПеременных.Свойство("ИдентификаторФормы") Тогда
		Возврат Ложь;
	КонецЕсли;

	НеСохранятьВоВремХранилище = Ложь;
	Если АдресаПеременных.Свойство("ЭтоФоновоеЗадание")
		И АдресаПеременных.ЭтоФоновоеЗадание = Истина Тогда
		// Не сохраняем во временное хранилище, т.к. сохраненные значения не будут доступны в родительском сеансе
		// Сохраним во врем хранилище особым образом в конце выполнения ФЗ. См. ГлЯдро_ПересохранитьЗначенияПеременныхВФЗ()
		НеСохранятьВоВремХранилище = Истина;
	КонецЕсли;
	
	Если ТипЗнч(КлючПеременной) = Тип("Строка") Тогда
		Если Не НеСохранятьВоВремХранилище Тогда
			Значение = ПоместитьВоВременноеХранилище(СохраняемоеЗначение, АдресаПеременных.ИдентификаторФормы);
		Иначе
			Значение = СохраняемоеЗначение;
		КонецЕсли;
		АдресаПеременных.Вставить(КлючПеременной, Значение);
	ИначеЕсли ТипЗнч(КлючПеременной) = Тип("Структура") Тогда
		АдресаПеременных = СохраняемоеЗначение;
		Для Каждого КлючЗначение ИЗ КлючПеременной Цикл
			Если Не НеСохранятьВоВремХранилище Тогда
				Значение = ПоместитьВоВременноеХранилище(КлючЗначение.Значение, АдресаПеременных.ИдентификаторФормы);
			Иначе
				Значение = КлючЗначение.Значение;
			КонецЕсли;
			АдресаПеременных.Вставить(КлючЗначение.Ключ, Значение);
		КонецЦикла;		
		Возврат КлючПеременной;
	КонецЕсли;
	
	КэшАдресаПеременных = АдресаПеременных;	
	
	Возврат Истина;
	
КонецФункции

Функция КомЯдро_УдалитьЗначениеПеременной(КлючПеременной,АдресаПеременных = Неопределено)
	
	Если НЕ ЗначениеЗаполнено(КлючПеременной)
		ИЛИ НЕ ТипЗнч(АдресаПеременных) = Тип("Структура")
		ИЛИ НЕ АдресаПеременных.Свойство(КлючПеременной) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если ТипЗнч(КлючПеременной) = Тип("Строка") Тогда
		Если НЕ ЭтоАдресВременногоХранилища(АдресаПеременных[КлючПеременной]) Тогда 
			Возврат Истина;
		КонецЕсли;
		УдалитьИзВременногоХранилища(АдресаПеременных[КлючПеременной]);
	ИначеЕсли ТипЗнч(КлючПеременной) = Тип("Структура") Тогда
		Для Каждого КлючЗначение ИЗ КлючПеременной Цикл
			Если НЕ ЭтоАдресВременногоХранилища(АдресаПеременных[КлючЗначение.Ключ]) Тогда  
				Возврат Истина;
			КонецЕсли;
			УдалитьИзВременногоХранилища(АдресаПеременных[КлючЗначение.Ключ]);	 
		КонецЦикла;		
	КонецЕсли;	
	
	Возврат Истина;
	
КонецФункции

// Создает структуру АдресаПеременных 
// Должно вызываться только в COM соединении
//
// Возвращаемое значение:
//	Структура - содержит структуру АдресаПеременных
Функция КомЯдро_СоздатьСтруктуруАдресаПеременных()
	
	Если КэшАдресаПеременных = Неопределено Тогда
		Возврат Новый Структура("ИдентификаторФормы",Новый УникальныйИдентификатор());
	Иначе
		Возврат КэшАдресаПеременных;
	КонецЕсли;
	
КонецФункции

Функция КомЯдро_ПолучитьОшибку(ТипБазы,АдресаПеременных)
	
	Если ТипБазы = "Частная" Тогда
		СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("COMЧастнойБазыMS",АдресаПеременных);
	ИначеЕсли ТипБазы = "Временная" Тогда
		СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("COMВременнойБазыMS",АдресаПеременных);
	Иначе
		СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("COMБазыMS",АдресаПеременных);
	КонецЕсли;
		
	ОписаниеОшибки = "";
	Ошибка = СтруктураПодключенияMS.TerminalConnector.ПолучитьОшибку(ОписаниеОшибки);
	Возврат ОписаниеОшибки;
	
КонецФункции

#КонецОбласти

#Область КомпонентаMobileSMARTS_БазыSMARTS

// Выполняет авторизацию в базе Mobile Smarts и возвращает токен авторизации
//
// Параметры:
//	СтрокаПодключения - Строка - строка подключения к базе Mobile Smarts
//	Логин - Строка - логин авторизации
//	Пароль - Строка - пароль авторизации
//	ТипБазы - Строка - "Частная", "Временная", "Основная"
//	АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных	
//
// Возвращаемое значение:
//	Строка - токен авторизации
Функция КомЯдро_ПолучитьТокенSMARTS(СтрокаПодключения,Логин,Пароль,ТипБазы = "Основная",АдресаПеременных) Экспорт
		
	Если НЕ КомЯдро_ПодключитьсяКСерверуSMARTS(Истина,ТипБазы,АдресаПеременных) Тогда
		Возврат Ложь;		
	КонецЕсли;
	
	Токен = "";
	
	Если ТипБазы = "Частная" Тогда
		СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("COMЧастнойБазыMS",АдресаПеременных);
	ИначеЕсли ТипБазы = "Временная" Тогда
		СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("COMВременнойБазыMS",АдресаПеременных);
	Иначе
		СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("COMБазыMS",АдресаПеременных);
	КонецЕсли;
	
	Если СтруктураПодключенияMS.TerminalConnector.УстановитьТекущуюБазуСМАРТСБезАвт(СтрокаПодключения) = Истина Тогда
	
		Токен = СтруктураПодключенияMS.TerminalConnector.АвторизоватьсяПоЛогину(Логин,Пароль);
	
	КонецЕсли;
	
	Возврат Токен;
	
КонецФункции

// Проверяет соединение с базой Mobile Smarts, если не требуется явного переподключения. Если тест соединения не пройден или требуется явное переподключение,
// проверяет соединение с сервером Mobile Smarts и получает описание подключаемой базы. Если авторизация не требуется или сохранена, выполняет попытку подключиться
// к базе без авторизации или по сохраненным данным авторизации соответственно.
//
// Параметры:
//	СтруктураПодключения - Структура - структура подключения к базе Mobile Smarts
//  Переподключиться - Булево - определяет необходимость явного переподключения к базе Mobile Smarts
//  ТипБазы - Строка - "Частная", "Временная", "Основная"
//	СохранятьАвторизацию - Булево - флаг необходимости сохранять авторизацию
//  Интерактивно - Булево - флаг работы в интерактивном режиме
//  АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
//
// Возвращаемое значение:
//	- Структура - если требуется авторизация в интерактивном режиме - содержит:
//  	* Статус - Строка	
//      * СтрокаПодключения - Строка
//      * ИмяБазы - Строка
//      * Логин - Строка
//      * ТипБазы - Строка
//      * ДопПараметры - Структура - содержит:
//			** СтрокаПодключения - Строка
//          ** ТипБазы - Строка
//          ** СтруктураПодключения - Структура - структура подключения к базе Mobile Smarts
//          ** СохранятьАвторизацию - Булево
//          ** ИмяБазы - Строка
//			** Логин - Строка
//	- Булево - результат проверки соединения с подключенной базой Mobile Smarts
Функция КомЯдро_ПодключитьсяКБазеSMARTS(СтруктураПодключения,Переподключиться = Ложь,ТипБазы = "Основная", СохранятьАвторизацию=Ложь,Интерактивно=Ложь,АдресаПеременных) Экспорт
	
	Перем ID_ПодключаемойБазы,СтрокаПодключенияСМАРТС,ОписаниеБазы,СтруктураОписанияБазы;
	ЭтоВнешнееСоединение = Ложь;
	НачалоСобытия = ТекущаяУниверсальнаяДатаВМиллисекундах();
	ИмяСобытия = "КомЯдро_ПодключитьсяКБазеSMARTS";
	
	Если ТипЗнч(СтруктураПодключения) <> Тип("Структура") Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если ТипБазы = "Частная" Тогда
		СтруктураБазMSCOM = КомЯдро_ПолучитьЗначениеПеременной("COMЧастнойБазыMS",АдресаПеременных);
		КлючПеременной = "СтруктураПодключенияЧастнойБазыMS";
	ИначеЕсли ТипБазы = "Временная" Тогда
		СтруктураБазMSCOM = КомЯдро_ПолучитьЗначениеПеременной("COMВременнойБазыMS",АдресаПеременных);
		КлючПеременной = "СтруктураПодключенияВременнойБазыMS";
	Иначе
		СтруктураБазMSCOM = КомЯдро_ПолучитьЗначениеПеременной("COMБазыMS",АдресаПеременных);
		КлючПеременной = "СтруктураПодключенияБазыMS";
	КонецЕсли;
	
	СтруктураБазMS = КомЯдро_ПолучитьЗначениеПеременной(КлючПеременной,АдресаПеременных);
	
	Если НЕ Переподключиться  
		И НЕ СтруктураБазMS = Неопределено
		И ТипЗнч(СтруктураБазMS) = Тип("Структура")
		И СтруктураБазMS.Свойство("ОписаниеБазы") 
		И ТипЗнч(СтруктураБазMS.ОписаниеБазы) = Тип("Структура") Тогда
		
		#Если ВнешнееСоединение Тогда
			ЭтоВнешнееСоединение = Истина;	
		#КонецЕсли
		Если ЭтоВнешнееСоединение ИЛИ ЭтоWebСервис Тогда
			Возврат Истина;
		КонецЕсли;
		
		//Если пропала структура с комом и не нужно явно переподключиться, то проверяем соединение и если с ним все ОК то возврат истина
		Попытка
			ТестСоединения = СтруктураБазMSCOM.StorageConnector.ПроверитьСоединение() = Истина;
			ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "После теста cоединения с базой Mobile SMARTS "+Строка(ТестСоединения),НачалоСобытия,АдресаПеременных);
		Исключение
			ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
			ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Тест cоединения с базой Mobile SMARTS не пройден, запуск переподключения, Описание ошибки: " + ТекстОшибки, НачалоСобытия, АдресаПеременных);			
			ТестСоединения = Ложь;
		КонецПопытки;
		
		Если ТестСоединения Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЕсли;
	
	//Если нам надо явно переподключиться или нет соединения с базой то пересоздаем ком и снова подключаемся
	Если НЕ КомЯдро_ПодключитьсяКСерверуSMARTS(Переподключиться,ТипБазы,АдресаПеременных) Тогда
		Возврат Ложь;		
	КонецЕсли;
	
	СтрокаПодключения = Неопределено;
	
	Если СтруктураПодключения.Свойство("СтрокаПодключенияСМАРТС") И ЗначениеЗаполнено(СтруктураПодключения.СтрокаПодключенияСМАРТС) Тогда
		СтрокаПодключения = СтруктураПодключения.СтрокаПодключенияСМАРТС;
	ИначеЕсли СтруктураПодключения.Свойство("IdBaseSMARTS") И ЗначениеЗаполнено(СтруктураПодключения.IdBaseSMARTS) Тогда
		СтрокаПодключения = СтруктураПодключения.IdBaseSMARTS;
	ИначеЕсли СтруктураПодключения.Свойство("Ид") Тогда
		СтрокаПодключения = СтруктураПодключения.Ид;
	КонецЕсли;
	
	Если ТипБазы = "Частная" Тогда
		СтруктураБазMSCOM = КомЯдро_ПолучитьЗначениеПеременной("COMЧастнойБазыMS",АдресаПеременных);
	ИначеЕсли ТипБазы = "Временная" Тогда
		СтруктураБазMSCOM = КомЯдро_ПолучитьЗначениеПеременной("COMВременнойБазыMS",АдресаПеременных);
	Иначе
		СтруктураБазMSCOM = КомЯдро_ПолучитьЗначениеПеременной("COMБазыMS",АдресаПеременных);
	КонецЕсли;
	
	ОписаниеБазы = СтруктураБазMSCOM.TerminalConnector.ПолучитьБазуСМАРТСПоИД(СтрокаПодключения);
	Если ТипЗнч(ОписаниеБазы) = Тип("COMОбъект") Тогда
		СтруктураОписанияБазы = КомЯдро_СоздатьСтруктуруОписанияБазыSMARTS(ОписаниеБазы);
		Если НЕ СтруктураПодключения.Свойство("АвторизацияВключена")
			ИЛИ НЕ СтруктураПодключения.АвторизацияВключена = Истина Тогда
			СтруктураПодключения.Вставить("АвторизацияВключена",СтруктураОписанияБазы.АвторизацияВключена);
		Иначе
			СтруктураОписанияБазы.Вставить("АвторизацияВключена",Истина);
		КонецЕсли;
	Иначе
		Возврат Ложь;
	КонецЕсли;
		
	Токен = Неопределено;
	Если СтруктураОписанияБазы.АвторизацияВключена Тогда
		Если СтруктураПодключения.Свойство("АвторизацияТокен")
			И ЗначениеЗаполнено(СтруктураПодключения.АвторизацияТокен) Тогда
			Токен = СтруктураПодключения.АвторизацияТокен;
		Иначе		
        	АвторизацияЛогин  = ГлЯдро_ПолучитьДанныеИзХранилища1С("СохраненнаяАвторизацияЛогин");
			Если ЗначениеЗаполнено(АвторизацияЛогин) Тогда
				АвторизацияПароль = ГлЯдро_ПолучитьДанныеИзХранилища1С("СохраненнаяАвторизацияПароль");
				АвторизацияПароль = ГлЯдро_РасшифроватьСтроку(АвторизацияПароль, ГлЯдро_ПолучитьКлючШифрования(АвторизацияЛогин, СтрДлина(АвторизацияПароль)));
				
				Токен = КомЯдро_ПолучитьТокенSMARTS(СтрокаПодключения, АвторизацияЛогин, АвторизацияПароль, ТипБазы, АдресаПеременных);
				Если Токен <> Ложь И Токен <> Неопределено Тогда
					СтруктураПодключения.Вставить("АвторизацияЛогин", АвторизацияЛогин);
					СтруктураПодключения.Вставить("АвторизацияТокен", Токен);
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	ДопПараметры = Новый Структура("СтрокаПодключения,ТипБазы,СтруктураПодключения,СохранятьАвторизацию,ИмяБазы",СтрокаПодключения,ТипБазы,СтруктураПодключения,СохранятьАвторизацию,СтруктураОписанияБазы.Имя);
	Если СтруктураОписанияБазы.АвторизацияВключена
		И (Токен = Ложь ИЛИ Токен = Неопределено) Тогда
		
		//Если авторизация не сохранена
		Если Интерактивно Тогда
			Возврат Новый Структура("Статус,СтрокаПодключения,ИмяБазы,Логин,ТипБазы,ДопПараметры,ТекстОшибки","ТребуетсяАвторизация",СтрокаПодключения,СтруктураОписанияБазы.Имя,?(СтруктураПодключения.Свойство("АвторизацияЛогин"),СтруктураПодключения.АвторизацияЛогин,""),ТипБазы,ДопПараметры,"");
		Иначе
			Возврат КомЯдро_ПодключитьсяКБазеSMARTSНаСервереЗавершение(,ДопПараметры,АдресаПеременных);
		КонецЕсли;
		
	Иначе
		
		Попытка
			Результат = СтруктураБазMSCOM.TerminalConnector.УстановитьТекущуюБазуСМАРТСБезАвт(СтрокаПодключения) = Истина;
			//Подключим StorageConnector отдельно т.к. теперь StorageConnector создается не из TerminalConnector
			СтруктураБазMSCOM.StorageConnector.УстановитьТекущуюБазуСМАРТСБезАвт(СтрокаПодключения);
			ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Попытка подключится к базе Mobile SMARTS: Строка подключения: "+Строка(СтрокаПодключения),НачалоСобытия,АдресаПеременных);
		Исключение
			Результат = СтруктураБазMSCOM.TerminalConnector.УстановитьТекущуюБазуСМАРТС(СтрокаПодключения) = Истина;
			//Подключим StorageConnector отдельно т.к. теперь StorageConnector создается не из TerminalConnector
			СтруктураБазMSCOM.StorageConnector.УстановитьПодключениеСБазойСМАРТС(СтрокаПодключения);
			ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация","Исключение подключится к базе Mobile SMARTS: Строка подключения: "+Строка(СтрокаПодключения),НачалоСобытия,АдресаПеременных);
		КонецПопытки;
		
		Если Результат Тогда
			Если ТипЗнч(СтруктураПодключения) = Тип("Структура")
				И СтруктураПодключения.Свойство("АвторизацияВключена")
				И СтруктураПодключения.АвторизацияВключена
				И СтруктураПодключения.Свойство("АвторизацияЛогин")
				И ЗначениеЗаполнено(СтруктураПодключения.АвторизацияЛогин)
				И СтруктураПодключения.Свойство("АвторизацияТокен")
				И ЗначениеЗаполнено(СтруктураПодключения.АвторизацияТокен) Тогда
				//Если авторизация сохранена
				
				РезультатАвторизации= Неопределено;
				Попытка
					РезультатАвторизации = СтруктураБазMSCOM.TerminalConnector.АвторизоватьсяПоТокену(СтруктураПодключения.АвторизацияЛогин,СтруктураПодключения.АвторизацияТокен);
					//Подключим StorageConnector отдельно т.к. теперь StorageConnector создается не из TerminalConnector
					СтруктураБазMSCOM.StorageConnector.АвторизоватьсяПоТокену(СтруктураПодключения.АвторизацияЛогин,СтруктураПодключения.АвторизацияТокен);
					ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация","Авторизация по токену, результат: "+Строка(РезультатАвторизации),НачалоСобытия,АдресаПеременных);
				Исключение
					ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Не удалось авторизоваться по токену", НачалоСобытия, АдресаПеременных);
				КонецПопытки;
				
				//Проверяем соединение после авторизации
				Если НЕ СтруктураБазMSCOM.StorageConnector.ПроверитьСоединение() = Истина Тогда
					//Если не удалось авторизоваться
					Если Интерактивно Тогда
						Возврат Новый Структура("Статус,СтрокаПодключения,ИмяБазы,Логин,ТипБазы,ДопПараметры,ТекстОшибки","ОшибкаАвторизации",СтрокаПодключения,СтруктураОписанияБазы.Имя,?(СтруктураПодключения.Свойство("АвторизацияЛогин"),СтруктураПодключения.АвторизацияЛогин,""),ТипБазы,ДопПараметры,"");
					Иначе
						Возврат КомЯдро_ПодключитьсяКБазеSMARTSНаСервереЗавершение(,ДопПараметры,АдресаПеременных);
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		Возврат КомЯдро_ПодключитьсяКБазеSMARTSНаСервереЗавершение(,ДопПараметры,АдресаПеременных);
	КонецЕсли;
			
КонецФункции

// Выполняет проверку подключения к базе Mobile Smarts по идентификатору подключенной базы.
// Если проверка пройдена, сохраняет описание подключенной базы в структуре баз Mobile Smarts.
//
// Параметры:
//	РезультатЗакрытияФормы - Неопределено, Структура - содержит:
//		* АвторизацияТокен - Строка - токен авторизации
//      * АвторизацияЛогин - Строка - логин авторизации
//		* АвторизацияЗапомнить - Булево - флаг необходимость сохранить авторизацию
//  ДопПараметры - Структура - содержит:
//		* СтрокаПодключения - Строка
//      * ТипБазы - Строка - "Частная", "Временная", "Основная"
//      * СтруктураПодключения - Структура - структура подключения к базе Mobile Smarts
//      * СохранятьАвторизацию - Булево
//      * ИмяБазы - Строка
//  АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
//
// Возвращаемое значение:
//	Булево - результат проверки соединения с базой Mobile Smarts	
Функция КомЯдро_ПодключитьсяКБазеSMARTSНаСервереЗавершение(РезультатЗакрытияФормы, ДопПараметры,АдресаПеременных) Экспорт
	
	ИмяСобытия = "КомЯдро_ПодключитьсяКБазеSMARTSНаСервереЗавершение";
	НачалоСобытия = ТекущаяУниверсальнаяДатаВМиллисекундах();
	
	СтруктураПодключения = ДопПараметры.СтруктураПодключения;
	Если ДопПараметры.Свойство("СтруктураОписанияБазы") Тогда
		СтруктураОписанияБазы = ДопПараметры.СтруктураОписанияБазы;
	Иначе
		СтруктураОписанияБазы = ГлЯдро_ПолучитьБазуНаСервереSMARTS(ДопПараметры.СтрокаПодключения,ДопПараметры.ТипБазы,АдресаПеременных);
	КонецЕсли;
	
	Если ДопПараметры.ТипБазы = "Частная" Тогда
		СтруктураБазMSCOM = КомЯдро_ПолучитьЗначениеПеременной("COMЧастнойБазыMS",АдресаПеременных);
		КлючПеременной = "СтруктураПодключенияЧастнойБазыMS";
	ИначеЕсли ДопПараметры.ТипБазы = "Временная" Тогда
		СтруктураБазMSCOM = КомЯдро_ПолучитьЗначениеПеременной("COMВременнойБазыMS",АдресаПеременных);
		КлючПеременной = "СтруктураПодключенияВременнойБазыMS";
	Иначе
		СтруктураБазMSCOM = КомЯдро_ПолучитьЗначениеПеременной("COMБазыMS",АдресаПеременных);
		КлючПеременной = "СтруктураПодключенияБазыMS";
	КонецЕсли;

	СтруктураБазMS = КомЯдро_ПолучитьЗначениеПеременной(КлючПеременной,АдресаПеременных);
	
	Если ЗначениеЗаполнено(СтруктураБазMSCOM.StorageConnector.ИдПодключеннойБазы) тогда
		ПроверкаСоединения = СтруктураБазMSCOM.StorageConnector.ПроверитьСоединение() = Истина;
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Проверка соединения StorageConnector, результат: "+Строка(ПроверкаСоединения),НачалоСобытия,АдресаПеременных);
	Иначе
		ПроверкаСоединения = Ложь;
	КонецЕсли;
	
	Если ПроверкаСоединения Тогда
		ID_ПодключаемойБазы = ?(СтруктураПодключения.Свойство("IdBaseSMARTS") И ЗначениеЗаполнено(СтруктураПодключения.IdBaseSMARTS),СтруктураПодключения.IdBaseSMARTS,СтруктураБазMSCOM.StorageConnector.НастройкиТекущейБазы.СерверныйИдентификаторПриложения);
		СтрокаПодключенияСМАРТС = ?(СтруктураПодключения.Свойство("СтрокаПодключенияСМАРТС") И ЗначениеЗаполнено(СтруктураПодключения.СтрокаПодключенияСМАРТС),СтруктураПодключения.СтрокаПодключенияСМАРТС,СтруктураОписанияБазы.СтрокаПодключения);
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Проверка соединения StorageConnector. ИдБазы: " +Строка(ID_ПодключаемойБазы) + ", Строка подключения: "+ Строка(СтрокаПодключенияСМАРТС),НачалоСобытия,АдресаПеременных);
	КонецЕсли;
	
	Если СтруктураПодключения.Свойство("АвторизацияВключена")
		И СтруктураПодключения.АвторизацияВключена = Истина Тогда
		СтруктураОписанияБазы.Вставить("АвторизацияВключена",Истина);
	КонецЕсли;
	Если СтруктураБазMS = Неопределено Тогда
		СтруктураБазMS = Новый Структура;
	КонецЕсли;
	
	//В описании базы может быть некорректная строка подключения. Заменим на строку подключения на введенную пользователем
	Если ЗначениеЗаполнено(СтрокаПодключенияСМАРТС)
		И ТипЗнч(СтруктураОписанияБазы) = Тип("Структура") Тогда
		СтруктураОписанияБазы.Вставить("СтрокаПодключения",СтрокаПодключенияСМАРТС);
		СтруктураОписанияБазы.Вставить("СтрокаПодключенияСМАРТС",СтрокаПодключенияСМАРТС);
	КонецЕсли;
	
	СтруктураБазMS.Вставить("IdBaseSMARTS", ID_ПодключаемойБазы);
	СтруктураБазMS.Вставить("СтрокаПодключенияСМАРТС", СтрокаПодключенияСМАРТС);
	СтруктураБазMS.Вставить("ОписаниеБазы", СтруктураОписанияБазы);
	
	КомЯдро_СохранитьЗначениеПеременной(КлючПеременной,СтруктураБазMS,АдресаПеременных);
	
	ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Структура инициализации. ИдБазы: " +Строка(ID_ПодключаемойБазы) + ", Строка подключения: "+ Строка(СтрокаПодключенияСМАРТС),НачалоСобытия,АдресаПеременных);
	Возврат ПроверкаСоединения;
	
КонецФункции

Функция КомЯдро_ПолучитьСписокБазНаСервереSMARTS(Полное,АдресаПеременных)
	
	Если НЕ КомЯдро_ПодключитьсяКСерверуSMARTS(Ложь,"Основная",АдресаПеременных) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	РезультатМассив = Новый Массив;
	СтруктураПодключенияБазыMS = КомЯдро_ПолучитьЗначениеПеременной("COMБазыMS",АдресаПеременных);
	
	СписокБазНаСервере = СтруктураПодключенияБазыMS.TerminalConnector.ПолучитьСписокБазСМАРТС("");
	Для Индекс = 0 По СписокБазНаСервере.Количество - 1 Цикл
		ВыбраннаяБазаSMARTS = СписокБазНаСервере.Элемент(Индекс);
		СтруктураДанныеБазы = КомЯдро_СоздатьСтруктуруОписанияБазыSMARTS(ВыбраннаяБазаSMARTS,Полное);
		РезультатМассив.Добавить(СтруктураДанныеБазы);
	КонецЦикла;
	
	Если РезультатМассив.Количество() > 0 Тогда
		СтруктураСтрокой = "";
		НужнаЗапятая = Ложь;
		Для Каждого ЭлементСтруктуры Из РезультатМассив[0] Цикл
			Если НужнаЗапятая Тогда
				СтруктураСтрокой = СтруктураСтрокой + ",";
			КонецЕсли;
			СтруктураСтрокой = СтруктураСтрокой + ЭлементСтруктуры.Ключ;
			НужнаЗапятая = Истина;
		КонецЦикла;
	КонецЕсли; 
		
	ОписаниеТаблицыЗначений = Новый Структура("ЭтоТаблицаЗначений, КолонкиТаблицыЗначений", Истина, СтруктураСтрокой); 
	РезультатМассив.Вставить(0, ОписаниеТаблицыЗначений);
	
	Возврат РезультатМассив;
	
КонецФункции

Функция КомЯдро_ПолучитьБазуНаСервереSMARTS(ИдентификаторБазы,ТипБазы, АдресаПеременных)
	
	Если ТипБазы = "Частная" Тогда
		СтруктураПодключенияMSCOM = КомЯдро_ПолучитьЗначениеПеременной("COMЧастнойБазыMS",АдресаПеременных);
		КлючПеременной = "СтруктураПодключенияЧастнойБазыMS";
	ИначеЕсли ТипБазы = "Временная" Тогда
		СтруктураПодключенияMSCOM = КомЯдро_ПолучитьЗначениеПеременной("COMВременнойБазыMS",АдресаПеременных);
		КлючПеременной = "СтруктураПодключенияВременнойБазыMS";
	Иначе
		СтруктураПодключенияMSCOM = КомЯдро_ПолучитьЗначениеПеременной("COMБазыMS",АдресаПеременных);
		КлючПеременной = "СтруктураПодключенияБазыMS";
	КонецЕсли;

	СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной(КлючПеременной,АдресаПеременных);
	
	Если НЕ ЗначениеЗаполнено(ИдентификаторБазы) Тогда
		Если СтруктураПодключенияMS.Свойство("СтрокаПодключенияСМАРТС") И ЗначениеЗаполнено(СтруктураПодключенияMS.СтрокаПодключенияСМАРТС) Тогда
			СтрокаПодключения = СтруктураПодключенияMS.СтрокаПодключенияСМАРТС;
		ИначеЕсли СтруктураПодключенияMS.Свойство("IdBaseSMARTS") И ЗначениеЗаполнено(СтруктураПодключенияMS.IdBaseSMARTS) Тогда
			СтрокаПодключения = СтруктураПодключенияMS.IdBaseSMARTS;
		Иначе
			СтрокаПодключения = СтруктураПодключенияMS.Ид;
		КонецЕсли;
		
		БазаSMARTS = СтруктураПодключенияMSCOM.TerminalConnector.ПолучитьБазуСМАРТСПоИД(СтрокаПодключения);
	Иначе
	    БазаSMARTS = СтруктураПодключенияMSCOM.TerminalConnector.ПолучитьБазуСМАРТСПоИД(ИдентификаторБазы);
	КонецЕсли;
	
	Возврат БазаSMARTS;
	
КонецФункции

Функция КомЯдро_СоздатьСтруктуруОписанияБазыSMARTS(ОписаниеБазы,Полное = Истина)
	
	СтруктураДанныеБазы = Новый Структура;
		
	СтруктураДанныеБазы.Вставить("Ид", ОписаниеБазы.Ид);
	СтруктураДанныеБазы.Вставить("Имя", ОписаниеБазы.Имя);
	
	Попытка
		НастройкиБазыСМАРТС = ОписаниеБазы.ПолучитьНастройки();
	Исключение
		// при невозможности открыть базу
		СтруктураДанныеБазы.Имя = "(Повреждена!) " + СтруктураДанныеБазы.Имя;
		Возврат СтруктураДанныеБазы;
	КонецПопытки;	
	
	Если НЕ Полное Тогда
		Возврат СтруктураДанныеБазы;
	КонецЕсли;
	
	Попытка
		ПолноеНаименованиеПродукта = ОписаниеБазы.ПолучитьОписаниеПриложения().ToString;
	Исключение
		ПолноеНаименованиеПродукта = "Не удалось получить имя продукта";
	КонецПопытки;
	
	ПозицияV = ГлЯдро_СтрНайти(ПолноеНаименованиеПродукта, "v.");
	ВерсияПриложения = ?(ПозицияV > 0, СокрЛП(Сред(ПолноеНаименованиеПродукта, ПозицияV + 2)), "");
	
	СтруктураДанныеБазы.Вставить("Комментарий", ОписаниеБазы.Комментарий);
	СтруктураДанныеБазы.Вставить("СтрокаПодключения", ОписаниеБазы.СтрокаПодключения);
	СтруктураДанныеБазы.Вставить("РабочийКаталог", ОписаниеБазы.РабочийКаталог);
	СтруктураДанныеБазы.Вставить("ИдПриложения", ОписаниеБазы.Приложение.Id);		
	СтруктураДанныеБазы.Вставить("ИмяПриложения", ОписаниеБазы.Приложение.Name);
	СтруктураДанныеБазы.Вставить("УровеньПриложения", ОписаниеБазы.Приложение.Level);
	СтруктураДанныеБазы.Вставить("ИдОсновногоПриложения", ОписаниеБазы.Приложение.ParentId);
	СтруктураДанныеБазы.Вставить("РаботаСУстройствомНапрямую", НастройкиБазыСМАРТС.РаботаСУстройствомНапрямую);
	СтруктураДанныеБазы.Вставить("РаботаСКаталогом", НастройкиБазыСМАРТС.РаботаСКаталогом);
	СтруктураДанныеБазы.Вставить("РаботаССервером", НастройкиБазыСМАРТС.РаботаССервером);
	СтруктураДанныеБазы.Вставить("РаботаСЛокальнымСервером", НастройкиБазыСМАРТС.РаботаСЛокальнымСервером);
	СтруктураДанныеБазы.Вставить("РаботаСУдаленнымСервером", НастройкиБазыСМАРТС.РаботаСУдаленнымСервером);
	СтруктураДанныеБазы.Вставить("ПапкаОбмена", НастройкиБазыСМАРТС.ПолучитьТекущуюПапкуОбмена());
	ИнформацияОПродукте = ГлЯдро_ПолучитьИнформациюОПродукте(ОписаниеБазы.Приложение.Id,ОписаниеБазы.Приложение.ParentId);
	СтруктураДанныеБазы.Вставить("УровеньПриложенияСтрокой",	?(ЗначениеЗаполнено(ИнформацияОПродукте.УровеньПриложения), ИнформацияОПродукте.УровеньПриложения, ГлЯдро_ПолучитьУровеньПриложения(ОписаниеБазы.Приложение.Level)));
	СтруктураДанныеБазы.Вставить("ТипУстановленногоПродукта",	ИнформацияОПродукте.ТипУстановленногоПродукта);
	СтруктураДанныеБазы.Вставить("АвторизацияВключена", 		Ложь);
	СтруктураДанныеБазы.Вставить("АвторизацияЛогин", 			"");
	СтруктураДанныеБазы.Вставить("АвторизацияТокен", 			"");
	СтруктураДанныеБазы.Вставить("АвторизацияРефрешТокен",		"");
	СтруктураДанныеБазы.Вставить("СтрокаПодключенияСМАРТС",		ОписаниеБазы.СтрокаПодключения);
	СтруктураДанныеБазы.Вставить("IdBaseSMARTS", 				ОписаниеБазы.Ид);
	СтруктураДанныеБазы.Вставить("QR", 							"");
	СтруктураДанныеБазы.Вставить("ВерсияПриложения",			ВерсияПриложения);
	СтруктураДанныеБазы.Вставить("ВерсияКонфигурацииSMARTS",	"");
	
	//В старых версиях платформы MS нет поля АвторизацияВключена
	Попытка 
		СтруктураДанныеБазы.АвторизацияВключена = НастройкиБазыСМАРТС.АвторизацияВключена;
	Исключение
	КонецПопытки;
	
	
	Попытка // Если нет связи с удаленной базой смартс, то платформа выдает ошибку
		ИмяИнтеграционнойОбработки 	= НастройкиБазыСМАРТС.Получить("ИмяИнтеграционнойОбработкиКонфигурации1С");
		ПутьИнтеграционнойОбработки = НастройкиБазыСМАРТС.Получить("ПутьИнтеграционнойОбработкиКонфигурации1С");
		ТипОбработки = НастройкиБазыСМАРТС.Получить("ТипОбработки");
	Исключение
		ИмяИнтеграционнойОбработки 	= Неопределено;
		ПутьИнтеграционнойОбработки = Неопределено;
		ТипОбработки = Неопределено;
	КонецПопытки;
	
	Если ТипОбработки = "СправочникСсылка" Тогда
		Попытка
			Путь = ГлЯдро_ЗначениеИзСтрокиXML(ПутьИнтеграционнойОбработки);
		Исключение
			Путь = Неопределено;
		КонецПопытки;
	Иначе
		Путь = ПутьИнтеграционнойОбработки;
	КонецЕсли;
	
	//Заплатка
	Если ТипЗнч(Путь) = Тип("COMОбъект") Тогда
		Путь = Неопределено;
	КонецЕсли;
	
	СтруктураДанныеБазы.Вставить("ТипОбработки",ТипОбработки);
	СтруктураДанныеБазы.Вставить("ИмяИнтеграционнойОбработки", ?(НЕ ЗначениеЗаполнено(ИмяИнтеграционнойОбработки),"",ИмяИнтеграционнойОбработки));
	СтруктураДанныеБазы.Вставить("ПутьИнтеграционнойОбработки", ?(НЕ ЗначениеЗаполнено(ИмяИнтеграционнойОбработки),"\Обработки 1С\Обработки интеграции\", Путь));		
	
	Попытка // Если нет связи с удаленной базой смартс, то платформа выдает ошибку
		ПутьОсновнойОбработки 	= НастройкиБазыСМАРТС.Получить("ПутьОсновнойОбработки");
		ТипОсновнойОбработки 	= НастройкиБазыСМАРТС.Получить("ТипОсновнойОбработки");
	Исключение
		ПутьОсновнойОбработки 	= Неопределено;
		ТипОсновнойОбработки 	= Неопределено;
	КонецПопытки;

	Если ТипОсновнойОбработки = "СправочникСсылка" Тогда
		Попытка
			Путь = ГлЯдро_ЗначениеИзСтрокиXML(ПутьОсновнойОбработки);
		Исключение
			Путь = Неопределено;
		КонецПопытки;
	Иначе
		Путь = ПутьОсновнойОбработки;
	КонецЕсли;
	
	//Заплатка
	Если ТипЗнч(Путь) = Тип("COMОбъект") Тогда
		Путь = Неопределено;
	КонецЕсли;
	
	СтруктураДанныеБазы.Вставить("ТипОсновнойОбработки", ТипОсновнойОбработки);
	СтруктураДанныеБазы.Вставить("ПутьОсновнойОбработки", Путь);
	
	Возврат СтруктураДанныеБазы;
	
КонецФункции

#КонецОбласти

#Область КомпонентаMobileSMARTS_НастройкиSMARTS

Функция КомЯдро_ПолучитьНастройкиНаСервереSMARTS(ИдентификаторБазы = Неопределено,ТипБазы,АдресаПеременных)
	
	НастройкиБазыSMARTS = Неопределено;
	Если НЕ ЗначениеЗаполнено(ИдентификаторБазы) Тогда 
		БазаSMARTS = КомЯдро_ПолучитьБазуНаСервереSMARTS(,ТипБазы,АдресаПеременных);
	Иначе
		БазаSMARTS = КомЯдро_ПолучитьБазуНаСервереSMARTS(ИдентификаторБазы,ТипБазы,АдресаПеременных);
	КонецЕсли;
	Если БазаSMARTS <> Неопределено Тогда
		НастройкиБазыSMARTS = БазаSMARTS.ПолучитьНастройки();
	КонецЕсли;
	
	Возврат НастройкиБазыSMARTS;
	
КонецФункции

Функция КомЯдро_ЗаполнитьНастройкиSMARTS(СтруктураНастроек, УзловыеНастройки, ID_Узла = "",ТипБазы = "Основная",АдресаПеременных)
	
	Если НЕ КомЯдро_ПодключитьсяКСерверуSMARTS(Ложь,ТипБазы,АдресаПеременных) Тогда
		Возврат СтруктураНастроек;
	КонецЕсли;
	
	НастройкиБазыSMARTS = КомЯдро_ПолучитьНастройкиНаСервереSMARTS(,ТипБазы,АдресаПеременных);
	Если НастройкиБазыSMARTS = Неопределено Тогда
		Возврат СтруктураНастроек;
	КонецЕсли;
	
	Для Каждого Настройка Из СтруктураНастроек Цикл
		ИтоговыйКлючНастройки = Настройка.Ключ;
		Если УзловыеНастройки.Найти(Настройка.Ключ) <> Неопределено Тогда
			ИтоговыйКлючНастройки = ИтоговыйКлючНастройки + ?(ID_Узла = "" или ID_Узла = НЕОПРЕДЕЛЕНО, "", "_"+ ID_Узла);
		КонецЕсли;
		ЗначениеНастройки = НастройкиБазыSMARTS.Получить(ИтоговыйКлючНастройки);
		// Для совместимости со старыми настройками
		Если ЗначениеНастройки = Неопределено 
			И Найти(ИтоговыйКлючНастройки,"ПроизвольныеКоды_")  > 0  Тогда
			ЗначениеНастройки = НастройкиБазыSMARTS.Получить(СтрЗаменить(ИтоговыйКлючНастройки,"ПроизвольныеКоды_","ПроизвольныйКод_"));
		КонецЕсли;			
		// Для совместимости со старыми настройками
		Если ЗначениеНастройки = "Да" Тогда
			ЗначениеНастройки = Истина;
		ИначеЕсли ЗначениеНастройки = "Нет" Тогда
			ЗначениеНастройки = Ложь;	
		КонецЕсли;	
		СтруктураНастроек.Вставить(Настройка.Ключ, ?(ЗначениеНастройки = Неопределено, Ложь, ЗначениеНастройки));
	КонецЦикла;
	
	Возврат СтруктураНастроек;
	
КонецФункции

Процедура КомЯдро_ЗаписатьНастройкиSMARTS(СтруктураНастроек, УзловыеНастройки, ID_Узла = "",АдресаПеременных)
	
	ИмяСобытия = "КомЯдро_ЗаписатьНастройкиSMARTS (ГлЯдро)"; 
	
	Если НЕ КомЯдро_ПодключитьсяКСерверуSMARTS(Ложь,"Основная",АдресаПеременных) Тогда
		Возврат;
	КонецЕсли;
	
	//Обновляем дату актуальности настроек, чтобы при последующем онлайн-вызове были получены сохраненные настройки.
	ИзменилисьКлючевыеНастройки = Ложь;
	МассивИсключений = Новый Массив;
	МассивИсключений.Добавить("НастройкиОтборовУзлов_Онлайн");
	МассивИсключений.Добавить("НастройкиБизнесПроцессов_Пользовательские");
	МассивИсключений.Добавить("НастройкиОбменаСправочников");
	МассивИсключений.Добавить("ИспользоватьШаблоныВесовогоТовара");
	МассивИсключений.Добавить("ПрефиксКодаВесовогоТовара");
	МассивИсключений.Добавить("ЧислоЗнаковПослеЗапятойВесТовара");
	МассивИсключений.Добавить("ДлинаКодаВесовогоТовара");
	МассивИсключений.Добавить("ПрефиксВключенВКодВесовогоТовара");
	МассивИсключений.Добавить("ВыгружатьНоменклатуруДокументаПередВыгрузкойДокумента");
	МассивИсключений.Добавить("ЗначенияПараметровУзлов");
	МассивИсключений.Добавить("ГлобальныеПараметры_Значения");
	МассивИсключений.Добавить("ГлобальныеПараметры");
	МассивИсключений.Добавить("ГлобальныеПараметры_Пользовательские");
	МассивИсключений.Добавить("НастройкиБизнесПроцессов_ПользовательскиеНастройки");
	
	ИзменилисьКэшируемыеНастройки = Ложь;
	МассивИсключенийКэшируемыеНастройки = Новый Массив; // Ключевые настройки для оффлайна в дополнение к МассивИсключений
	МассивИсключенийКэшируемыеНастройки.Добавить("НастройкиОтборовУзлов_Интерактивный");
	
	СтруктураПодключенияБазыMS = КомЯдро_ПолучитьЗначениеПеременной("СтруктураПодключенияБазыMS",АдресаПеременных);
	
	БазаSMARTS = КомЯдро_ПолучитьБазуНаСервереSMARTS(СтруктураПодключенияБазыMS.IdBaseSMARTS,"Основная",АдресаПеременных); 
	Если БазаSMARTS = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	НастройкиБазыSMARTS = БазаSMARTS.ПолучитьНастройки();
	Если НастройкиБазыSMARTS = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Для Каждого Настройка Из СтруктураНастроек Цикл		
		Если НЕ ИзменилисьКлючевыеНастройки
			И МассивИсключений.Найти(Настройка.Ключ) <> Неопределено Тогда
			ИзменилисьКлючевыеНастройки = Истина;
			ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Изменение ключевых настроек, изменена настройка: " + Настройка.Ключ,, АдресаПеременных);
		КонецЕсли;
		
		Если НЕ ИзменилисьКэшируемыеНастройки
			И (ИзменилисьКлючевыеНастройки ИЛИ МассивИсключенийКэшируемыеНастройки.Найти(Настройка.Ключ) <> Неопределено) Тогда
			ИзменилисьКэшируемыеНастройки = Истина;
			ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Изменение кэшируемых настроек, изменена настройка: " + Настройка.Ключ,, АдресаПеременных);
		КонецЕсли;
		
		ИтоговыйКлючНастройки = Настройка.Ключ;
		Если УзловыеНастройки.Найти(Настройка.Ключ) <> Неопределено Тогда
			ИтоговыйКлючНастройки = ИтоговыйКлючНастройки + ?(ID_Узла = "", "", "_"+ ID_Узла);
		КонецЕсли;
		
		НастройкиБазыSMARTS.Настройка(ИтоговыйКлючНастройки).Значение = Настройка.Значение;
	КонецЦикла;
	ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Запись настроек в CustomSettings",,АдресаПеременных);
	
	БазаSMARTS.СохранитьНастройки(НастройкиБазыSMARTS);
	
	пCOMБазыMS = КомЯдро_ПолучитьЗначениеПеременной("COMБазыMS",АдресаПеременных);
	
	StorageConnector 	= пCOMБазыMS.StorageConnector;
	ConnectorID 		= "OneC_Connector";
	
	Если ИзменилисьКлючевыеНастройки ИЛИ ИзменилисьКэшируемыеНастройки Тогда
		ПостфиксБазы = СтрЗаменить(БазаSMARTS.Ид, "-", "_");
		ДатаАктуальности = ТекущаяДата();
		
		Если ИзменилисьКлючевыеНастройки Тогда
			ГлЯдро_СохранитьДанныеВХранилище1С("Cleverence_ДатаАктуальностиНастроек_" + ПостфиксБазы, ТекущаяДата());
			ГлЯдро_СохранитьДанныеВХранилище1С("Cleverence_REST_API_ДатаАктуальностиСоединения", Неопределено);
			ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Сброшена дата актуальности настроек, постфикс базы: " + ПостфиксБазы,, АдресаПеременных);
		КонецЕсли;
		
		Если ИзменилисьКэшируемыеНастройки Тогда
			ГлЯдро_СохранитьНастройкуВБазеSMARTS("ДатаАктуальностиКэшируемыхНастроек", ДатаАктуальности,, АдресаПеременных);
			ГлЯдро_СохранитьДанныеВХранилище1С("Cleverence_ДатаАктуальностиКэшируемыхНастроек_" + ПостфиксБазы, ДатаАктуальности);
		КонецЕсли;		
	КонецЕсли;
	
КонецПроцедуры

Процедура КомЯдро_УдалитьНастройкиSMARTS(СтруктураНастроек, УзловыеНастройки, ID_Узла = "",АдресаПеременных)
	
	Если НЕ КомЯдро_ПодключитьсяКСерверуSMARTS(Ложь,"Основная",АдресаПеременных) Тогда
		Возврат;
	КонецЕсли;
	
	СтруктураПодключенияБазыMS = КомЯдро_ПолучитьЗначениеПеременной("СтруктураПодключенияБазыMS",АдресаПеременных);
	
	БазаSMARTS = КомЯдро_ПолучитьБазуНаСервереSMARTS(СтруктураПодключенияБазыMS.IdBaseSMARTS,"Основная",АдресаПеременных); 
	Если БазаSMARTS = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	НастройкиБазыSMARTS = БазаSMARTS.ПолучитьНастройки();
	Если НастройкиБазыSMARTS = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Для Каждого Настройка Из СтруктураНастроек Цикл
		ИтоговыйКлючНастройки = Настройка.Ключ;
		Если УзловыеНастройки.Найти(Настройка.Ключ) <> Неопределено Тогда
			ИтоговыйКлючНастройки = ИтоговыйКлючНастройки + ?(ID_Узла = "", "", "_"+ ID_Узла);
		КонецЕсли;
		НастройкиБазыSMARTS.Удалить(ИтоговыйКлючНастройки);
	КонецЦикла;
	
	БазаSMARTS.СохранитьНастройки(НастройкиБазыSMARTS);
	
КонецПроцедуры

// Получает структуру подключения базы Mobile Smarts и выполняет тест соединения
//
// Параметры:
//	ТипБазы - Строка - "Частная", "Временная", "Основная"
//  АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
//
// Возвращаемое значение:
//	- Структура	- структура подключения базы Mobile Smarts
//  - Булево - если тест соединения не пройден
Функция КомЯдро_ПолучитьСтруктуруПодключенияMS(ТипБазы,АдресаПеременных) Экспорт
	
	ИмяСобытия = "КомЯдро_ПолучитьСтруктуруПодключенияMS";
	ЭтоВнешнееСоединение = Ложь;
	Если ТипБазы = "Частная" Тогда
		СтруктураБазMS = КомЯдро_ПолучитьЗначениеПеременной("COMЧастнойБазыMS",АдресаПеременных);
	ИначеЕсли ТипБазы = "Временная" Тогда
		СтруктураБазMS = КомЯдро_ПолучитьЗначениеПеременной("COMВременнойБазыMS",АдресаПеременных);
	Иначе
		СтруктураБазMS = КомЯдро_ПолучитьЗначениеПеременной("COMБазыMS",АдресаПеременных);
	КонецЕсли;
	
	#Если ВнешнееСоединение Тогда
		ЭтоВнешнееСоединение = Истина;	
	#КонецЕсли
	Если ЭтоВнешнееСоединение ИЛИ ЭтоWebСервис Тогда
		Возврат СтруктураБазMS;
	КонецЕсли;
	
	Попытка
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "1. Перед тестом cоединения с базой Mobile SMARTS",,АдресаПеременных);
		ТестСоединения = СтруктураБазMS.StorageConnector.ПроверитьСоединение() = Истина;
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "2. После теста cоединения с базой Mobile SMARTS"+Строка(ТестСоединения),,АдресаПеременных);
	Исключение
		ТестСоединения = Ложь;
	КонецПопытки;
	
	Если ТестСоединения Тогда
		Возврат СтруктураБазMS;
	Иначе
		Возврат неопределено;
	КонецЕсли;
КонецФункции

#КонецОбласти

#Область КомпонентаMobileSMARTS_EnironmentSMARTS

Функция КомЯдро_ПолучитьМетаданныеДокументовMS(ТипБазы, ИмяПеременнойНастройки, АдресаПеременных)
	
	Если НЕ КомЯдро_ПодключитьсяКСерверуSMARTS(Ложь,ТипБазы,АдресаПеременных) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если ТипБазы = "Частная" Тогда
		СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("COMЧастнойБазыMS",АдресаПеременных);
	ИначеЕсли ТипБазы = "Временная" Тогда
		СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("COMВременнойБазыMS",АдресаПеременных);
	Иначе
		СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("COMБазыMS",АдресаПеременных);
	КонецЕсли;	
	
	Если НЕ СтруктураПодключенияMS.Свойство("Окружение") ИЛИ СтруктураПодключенияMS.Окружение = Неопределено Тогда
		СтруктураПодключенияMS.Вставить("Окружение", СтруктураПодключенияMS.TerminalConnector.ПолучитьСреду());
		
		Если ТипБазы = "Частная" Тогда
			пCOMЧастнойБазыMS = СтруктураПодключенияMS;
			КомЯдро_СохранитьЗначениеПеременной("COMЧастнойБазыMS",пCOMЧастнойБазыMS,АдресаПеременных);
		ИначеЕсли ТипБазы = "Временная" Тогда
			пCOMВременнойБазыMS = СтруктураПодключенияMS;
			КомЯдро_СохранитьЗначениеПеременной("COMВременнойБазыMS",пCOMВременнойБазыMS,АдресаПеременных);
		Иначе
			пCOMБазыMS = СтруктураПодключенияMS;
			КомЯдро_СохранитьЗначениеПеременной("COMБазыMS",пCOMБазыMS,АдресаПеременных);
		КонецЕсли; 
	КонецЕсли;
	
	Если СтруктураПодключенияMS.Окружение = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	МетаданныеДокументовMS = Новый Структура;
	
	СписокОбязательныхПолей = Новый Массив;
	СписокОбязательныхПолей.Добавить(Новый Структура("Значение,Ключ","Ид", "Идентификатор"));
	СписокОбязательныхПолей.Добавить(Новый Структура("Значение,Ключ","СозданНаТСД", "Создан на ТСД"));
	СписокОбязательныхПолей.Добавить(Новый Структура("Значение,Ключ","Имя", "Имя"));
	СписокОбязательныхПолей.Добавить(Новый Структура("Значение,Ключ","Назначение", "Назначение"));
	СписокОбязательныхПолей.Добавить(Новый Структура("Значение,Ключ","ДатаСоздания", "Дата создания"));
	СписокОбязательныхПолей.Добавить(Новый Структура("Значение,Ключ","ИмяТипаДокумента", "Имя типа документа"));
	СписокОбязательныхПолей.Добавить(Новый Структура("Значение,Ключ","ИдСклада", "Идентификатор склада"));
	СписокОбязательныхПолей.Добавить(Новый Структура("Значение,Ключ","Штрихкод", "Штрихкод"));
	СписокОбязательныхПолей.Добавить(Новый Структура("Значение,Ключ","Приоритет", "Приоритет"));
	СписокОбязательныхПолей.Добавить(Новый Структура("Значение,Ключ","Описание", "Описание"));
	СписокОбязательныхПолей.Добавить(Новый Структура("Значение,Ключ","ВыдаватьПоШтрихкоду", "Выдавать по штрихкоду"));
	СписокОбязательныхПолей.Добавить(Новый Структура("Значение,Ключ","ИсполняемыйНаСервере", "Исполняемый на сервере"));
	СписокОбязательныхПолей.Добавить(Новый Структура("Значение,Ключ","Завершен", "Завершен"));
	СписокОбязательныхПолей.Добавить(Новый Структура("Значение,Ключ","ВОбработке", "В обработке"));
	СписокОбязательныхПолей.Добавить(Новый Структура("Значение,Ключ","Изменен", "Изменен"));
	СписокОбязательныхПолей.Добавить(Новый Структура("Значение,Ключ","ИдПользователя", "Идентификатор пользователя"));
	СписокОбязательныхПолей.Добавить(Новый Структура("Значение,Ключ","DeviceId", "ИдУстройства"));
	СписокОбязательныхПолей.Добавить(Новый Структура("Значение,Ключ","UserName", "ИмяПользователя"));
	СписокОбязательныхПолей.Добавить(Новый Структура("Значение,Ключ","Underloaded", "Underloaded"));
	СписокОбязательныхПолей.Добавить(Новый Структура("Значение,Ключ","Overloaded", "Overloaded"));
	СписокОбязательныхПолей.Добавить(Новый Структура("Значение,Ключ","UnderloadedOrOverloaded","UnderloadedOrOverloaded"));
	
	СписокОбязательныхПолейТЧ = Новый Массив;
	СписокОбязательныхПолейТЧ.Добавить(Новый Структура("Значение,Ключ","ИдТовара", "ИдТовара"));
	СписокОбязательныхПолейТЧ.Добавить(Новый Структура("Значение,Ключ","ИдУпаковки", "ИдУпаковки"));
	СписокОбязательныхПолейТЧ.Добавить(Новый Структура("Значение,Ключ","КоличествоПлан", "Количество (План)"));
	СписокОбязательныхПолейТЧ.Добавить(Новый Структура("Значение,Ключ","КоличествоФакт", "Количество (Факт)"));
	СписокОбязательныхПолейТЧ.Добавить(Новый Структура("Значение,Ключ","ИдПервогоМеста", "Ид первого места"));
	СписокОбязательныхПолейТЧ.Добавить(Новый Структура("Значение,Ключ","ИдВторогоМеста", "Ид второго места"));
	СписокОбязательныхПолейТЧ.Добавить(Новый Структура("Значение,Ключ","ДатаРегистрации", "Дата регистрации"));
	СписокОбязательныхПолейТЧ.Добавить(Новый Структура("Значение,Ключ","СрокГодности", "Срок годности"));
	СписокОбязательныхПолейТЧ.Добавить(Новый Структура("Значение,Ключ","Переполнение", "Переполнение"));
	СписокОбязательныхПолейТЧ.Добавить(Новый Структура("Значение,Ключ","Недобор", "Недобор"));
	СписокОбязательныхПолейТЧ.Добавить(Новый Структура("Значение,Ключ","ЕстьНедоборИлиПереполнение", "Есть недобор или переполнение"));
	СписокОбязательныхПолейТЧ.Добавить(Новый Структура("Значение,Ключ","Остаток", "Остаток"));
	СписокОбязательныхПолейТЧ.Добавить(Новый Структура("Значение,Ключ","СвязаннаяСтрока", "Связанная строка"));
	СписокОбязательныхПолейТЧ.Добавить(Новый Структура("Значение,Ключ","SSCC", "SSCC", "SSCC"));
		
	РеквизитыСерии = Новый Массив;
	РеквизитыСерии.Добавить(Новый Структура("Значение,Ключ","ИдСерии", "Идентификатор Серии"));
	РеквизитыСерии.Добавить(Новый Структура("Значение,Ключ","ИмяСерии", "Имя серии"));
	РеквизитыСерии.Добавить(Новый Структура("Значение,Ключ","ИдТовара", "ИдТовара"));
	РеквизитыСерии.Добавить(Новый Структура("Значение,Ключ","КоличествоФакт", "Количество (Факт)"));
	РеквизитыСерии.Добавить(Новый Структура("Значение,Ключ","Характеристика", "Характеристика"));
	РеквизитыСерии.Добавить(Новый Структура("Значение,Ключ","АлкоКод", "АлкоКод"));
	РеквизитыСерии.Добавить(Новый Структура("Значение,Ключ","ФормаА", "ФормаА"));
	РеквизитыСерии.Добавить(Новый Структура("Значение,Ключ","КлючСерии", "КлючСерии"));
	РеквизитыСерии.Добавить(Новый Структура("Значение,Ключ","АлкоНаим", "АлкоНаим"));
	РеквизитыСерии.Добавить(Новый Структура("Значение,Ключ","ДатаРозлива", "ДатаРозлива"));
	РеквизитыСерии.Добавить(Новый Структура("Значение,Ключ","НаименованиеДляПоиска", "НаименованиеДляПоиска"));
	РеквизитыСерии.Добавить(Новый Структура("Значение,Ключ","ДатаСерии", "ДатаСерии"));
	РеквизитыСерии.Добавить(Новый Структура("Значение,Ключ","ИндексСорт", "ИндексСорт"));
	РеквизитыСерии.Добавить(Новый Структура("Значение,Ключ","Код", "Код"));
	РеквизитыСерии.Добавить(Новый Структура("Значение,Ключ","Штрихкод", "Штрихкод"));
	РеквизитыСерии.Добавить(Новый Структура("Значение,Ключ","Номер", "Номер"));
	РеквизитыСерии.Добавить(Новый Структура("Значение,Ключ","Ид", "Ид"));
	РеквизитыСерии.Добавить(Новый Структура("Значение,Ключ","Дополнительно", "Дополнительно"));
	
	РеквизитыСерийныеНомера = Новый Массив;
	РеквизитыСерийныеНомера.Добавить(Новый Структура("Значение,Ключ","СН", "Серийный номер"));
	РеквизитыСерийныеНомера.Добавить(Новый Структура("Значение,Ключ","ИдСерии", "Идентификатор Серии"));
	РеквизитыСерийныеНомера.Добавить(Новый Структура("Значение,Ключ","ИдТовара", "ИдТовара"));
	РеквизитыСерийныеНомера.Добавить(Новый Структура("Значение,Ключ","КоличествоФакт", "Количество (факт)"));
	РеквизитыСерийныеНомера.Добавить(Новый Структура("Значение,Ключ","Характеристика", "Характеристика"));
	
	Для Каждого ТипДокумента из СтруктураПодключенияMS.Окружение.DocumentTypes Цикл
		
		Если ТипДокумента.Virtual Тогда    //  Виртуальный
			Продолжить;
		КонецЕсли;
		
		СтруктураДокумента = Новый Структура();
		СтруктураДокумента.Вставить("Имя", ТипДокумента.Name);
		СтруктураДокумента.Вставить("Синоним", ТипДокумента.Alias);
		// реквизиты документа
		СписокРеквизитов = КомЯдро_ПолучитьСписокРеквизитовСущностиMS(ТипДокумента.Fields, СписокОбязательныхПолей);
		СтруктураДокумента.Вставить("Реквизиты", СписокРеквизитов);
		// реквизиты табличной части
		СписокРеквизитов = КомЯдро_ПолучитьСписокРеквизитовСущностиMS(ТипДокумента.Columns, СписокОбязательныхПолейТЧ);
		СтруктураДокумента.Вставить("РеквизитыТЧ", СписокРеквизитов);
		// серии и серийные номера
		СтруктураДокумента.Вставить("РеквизитыСерии", РеквизитыСерии);
		СтруктураДокумента.Вставить("РеквизитыСерийныеНомера", РеквизитыСерийныеНомера);
		
		// Дополнительные таблицы
		СписокДополнительныхТаблиц = Новый СписокЗначений();
			
		Для ИндексТаблицы = 0 По ТипДокумента.Tables.Count-1 Цикл 
			ДопТаблица = ТипДокумента.Tables.Item(ИндексТаблицы); 	
			СписокПолейДопТаблицы = КомЯдро_ПолучитьСписокРеквизитовСущностиMS(ДопТаблица.Fields);
			СписокДополнительныхТаблиц.Добавить(СписокПолейДопТаблицы, ДопТаблица.Name);
		КонецЦикла;
									
		СтруктураДокумента.Вставить("ДополнительныеТаблицы", СписокДополнительныхТаблиц);									
		
		ИмяТипаДокумента = ГлЯдро_ПреобразованиеНаименованияДокументаБезПробелов(ТипДокумента.Name);
		МетаданныеДокументовMS.Вставить(ИмяТипаДокумента, СтруктураДокумента);
		
	КонецЦикла; 
	
	Таблицы = Новый СписокЗначений;	
	
	Для ИндексТаблицы = 0 По СтруктураПодключенияMS.Окружение.Tables.Count-1 Цикл 
		ДопТаблица = СтруктураПодключенияMS.Окружение.Tables.Item(ИндексТаблицы); 	
		СписокПолейДопТаблицы = КомЯдро_ПолучитьСписокРеквизитовСущностиMS(ДопТаблица.Fields);
		Таблицы.Добавить(СписокПолейДопТаблицы, ДопТаблица.Name);
	КонецЦикла;
		
	СписокПользователейMS = Новый СписокЗначений;
	
	СписокПользователейMS.Добавить("Выгружать всем;Выгружать всем"); 	
	СписокПользователейMS.Добавить("Спрашивать при выгрузке;Спрашивать при выгрузке");	
	
	Для Инд = 0 По СтруктураПодключенияMS.Окружение.Users.count - 1 Цикл
		ТекущийПользователь = СтруктураПодключенияMS.Окружение.Users.Item(Инд);
		СписокПользователейMS.Добавить(Строка(ТекущийПользователь.Id) + ";" + Строка(ТекущийПользователь.Name), Строка(ТекущийПользователь.GroupId) + ";" + Строка(ТекущийПользователь.GroupName));
	КонецЦикла;	
	
	InternetGateOption = ГлЯдро_ПолучитьИзКэшаНастройкуSMARTS("InternetGateOption",, АдресаПеременных);
	Если InternetGateOption <> Ложь И ВРег(InternetGateOption) = "AVAILABLE" Тогда
		флЛегкоеОблако = Истина;
	Иначе
		флЛегкоеОблако = Ложь;
	КонецЕсли;
	
	// Устройства MS
	СписокУстройствMS = Новый СписокЗначений;
	Если Не флЛегкоеОблако Тогда
		СписокУстройствMS.Добавить("Выгружать всем;Выгружать всем"); 	
		СписокУстройствMS.Добавить("Спрашивать при выгрузке;Спрашивать при выгрузке");	
	КонецЕсли;
	
	УстройстваMS = СтруктураПодключенияMS.StorageConnector.ПолучитьДанныеОТерминалах();
	Для Счетчик = 0 По УстройстваMS.Количество - 1 Цикл
		Если флЛегкоеОблако Тогда
			Pincode = СокрЛП(УстройстваMS.Item(Счетчик).pincode);
		КонецЕсли;
		DeviceId   = СокрЛП(УстройстваMS.Item(Счетчик).DeviceId);
		DeviceName = СокрЛП(УстройстваMS.Item(Счетчик).DeviceName);
		Если флЛегкоеОблако Тогда
			СписокУстройствMS.Добавить(Pincode + ";" + DeviceId + ";" + ?(НЕ ЗначениеЗаполнено(DeviceName), DeviceId, DeviceName + ", (" + DeviceId + ")") + ";");
		Иначе
			СписокУстройствMS.Добавить(DeviceId + ";" + ?(НЕ ЗначениеЗаполнено(DeviceName), DeviceId, DeviceName + ", (" + DeviceId + ")") + ";");
		КонецЕсли;
	КонецЦикла;
	
	МассивВыгружаемыхПолейНоменклатурыMS = ГлЯдро_ПолучитьМассивВыгружаемыхПолейНоменклатурыMS(АдресаПеременных);
	
	СтрРезультат = Новый Структура;
	СтрРезультат.Вставить("ДокументыMS",					МетаданныеДокументовMS);
	СтрРезультат.Вставить("Tables",							Таблицы);
	СтрРезультат.Вставить("ПользователиMS",					СписокПользователейMS);
	СтрРезультат.Вставить("УстройстваMS",					СписокУстройствMS);
	СтрРезультат.Вставить("UniПолейНоменклатуры",			Неопределено);
	СтрРезультат.Вставить("ВыгружаемыеПоляНоменклатурыMS", 	МассивВыгружаемыхПолейНоменклатурыMS);
	
	ГлЯдро_СохранитьДанныеВХранилище1С(ИмяПеременнойНастройки, СтрРезультат);
	
	ПользователиMSАдрес = ГлЯдро_ДеревоПользователейВоВременноеХранилище(СписокПользователейMS);
	УстройстваMSАдрес 	= ГлЯдро_ДеревоУстройствВоВременноеХранилище(СписокУстройствMS, флЛегкоеОблако);
	
	СтрРезультат.Вставить("ПользователиMS", ПользователиMSАдрес);
	СтрРезультат.Вставить("УстройстваMS",	УстройстваMSАдрес);
	
	Возврат СтрРезультат;
	
КонецФункции

Функция КомЯдро_ПолучитьМетаданныеMSИзХранилища1С(ТипБазы, ИмяПеременнойНастройки, АдресаПеременных)
	
	ИмяСобытия = "КомЯдро_ПолучитьМетаданныеMSИзХранилища1С";
	
	пСтруктураМетаданных = ГлЯдро_ПолучитьДанныеИзХранилища1С(ИмяПеременнойНастройки);
	Если ТипЗнч(пСтруктураМетаданных) <> Тип("Структура") Тогда
		Возврат Неопределено;		
	КонецЕсли;
	
	InternetGateOption = ГлЯдро_ПолучитьИзКэшаНастройкуSMARTS("InternetGateOption",, АдресаПеременных);
	Если InternetGateOption <> Ложь И ВРег(InternetGateOption) = "AVAILABLE" Тогда
		флЛегкоеОблако = Истина;
	Иначе
		флЛегкоеОблако = Ложь;
	КонецЕсли;
	
	ЭтоВнешнееСоединение = Ложь;
	#Если ВнешнееСоединение Тогда
		ЭтоВнешнееСоединение = Истина;	
	#КонецЕсли
	ИспользоватьКэш = ЭтоWebСервис ИЛИ ЭтоВнешнееСоединение;
	
	СписокПользователейMS = пСтруктураМетаданных.ПользователиMS;
	СписокУстройствMS 	  = пСтруктураМетаданных.УстройстваMS;
	
	ОбновитьСписокПользователей = ТипЗнч(СписокПользователейMS) <> Тип("СписокЗначений");
	ОбновитьСписокУстройств		= (флЛегкоеОблако И НЕ ИспользоватьКэш) ИЛИ ТипЗнч(СписокУстройствMS) <> Тип("СписокЗначений");
	
	Если ОбновитьСписокПользователей ИЛИ ОбновитьСписокУстройств Тогда
		Если НЕ КомЯдро_ПодключитьсяКСерверуSMARTS(Ложь, ТипБазы, АдресаПеременных) Тогда
			Возврат Неопределено;
		КонецЕсли;
		
		Если ТипБазы = "Частная" Тогда
			СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("COMЧастнойБазыMS",АдресаПеременных);
		ИначеЕсли ТипБазы = "Временная" Тогда
			СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("COMВременнойБазыMS",АдресаПеременных);
		Иначе
			СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("COMБазыMS",АдресаПеременных);
		КонецЕсли;	
		
		Если НЕ СтруктураПодключенияMS.Свойство("Окружение") ИЛИ СтруктураПодключенияMS.Окружение = Неопределено Тогда
			СтруктураПодключенияMS.Вставить("Окружение", СтруктураПодключенияMS.TerminalConnector.ПолучитьСреду());
			
			Если ТипБазы = "Частная" Тогда
				пCOMЧастнойБазыMS = СтруктураПодключенияMS;
				КомЯдро_СохранитьЗначениеПеременной("COMЧастнойБазыMS",пCOMЧастнойБазыMS,АдресаПеременных);
			ИначеЕсли ТипБазы = "Временная" Тогда
				пCOMВременнойБазыMS = СтруктураПодключенияMS;
				КомЯдро_СохранитьЗначениеПеременной("COMВременнойБазыMS",пCOMВременнойБазыMS,АдресаПеременных);
			Иначе
				пCOMБазыMS = СтруктураПодключенияMS;
				КомЯдро_СохранитьЗначениеПеременной("COMБазыMS",пCOMБазыMS,АдресаПеременных);
			КонецЕсли; 
		КонецЕсли;
		
		Если СтруктураПодключенияMS.Окружение = Неопределено Тогда
			Возврат Неопределено;
		КонецЕсли;	
	КонецЕсли;
	
	// ***

	Если ОбновитьСписокПользователей Тогда
		СписокПользователейMS = Новый СписокЗначений;
	    СписокПользователейMS.Добавить("Выгружать всем;Выгружать всем"); 	
		СписокПользователейMS.Добавить("Спрашивать при выгрузке;Спрашивать при выгрузке");	
		
		Для Инд = 0 По СтруктураПодключенияMS.Окружение.Users.count - 1 Цикл
			ТекущийПользователь = СтруктураПодключенияMS.Окружение.Users.Item(Инд);
			СписокПользователейMS.Добавить(Строка(ТекущийПользователь.Id) + ";" + Строка(ТекущийПользователь.Name), Строка(ТекущийПользователь.GroupId) + ";" + Строка(ТекущийПользователь.GroupName));
		КонецЦикла;
		
		пСтруктураМетаданных.Вставить("ПользователиMS", СписокПользователейMS);
	КонецЕсли;
	
	// ***
	
	Если ОбновитьСписокУстройств Тогда
		СписокУстройствMS = Новый СписокЗначений;
		Если Не флЛегкоеОблако Тогда
			СписокУстройствMS.Добавить("Выгружать всем;Выгружать всем"); 	
			СписокУстройствMS.Добавить("Спрашивать при выгрузке;Спрашивать при выгрузке");	
		КонецЕсли;
		
		УстройстваMS = СтруктураПодключенияMS.StorageConnector.ПолучитьДанныеОТерминалах();
		Для Счетчик = 0 По УстройстваMS.Количество - 1 Цикл
			Если флЛегкоеОблако Тогда
				Pincode = СокрЛП(УстройстваMS.Item(Счетчик).pincode);
			КонецЕсли;
			DeviceId   = СокрЛП(УстройстваMS.Item(Счетчик).DeviceId);
			DeviceName = СокрЛП(УстройстваMS.Item(Счетчик).DeviceName);
			Если флЛегкоеОблако Тогда
				СписокУстройствMS.Добавить(Pincode + ";" + DeviceId + ";" + ?(НЕ ЗначениеЗаполнено(DeviceName), DeviceId, DeviceName + ", (" + DeviceId + ")") + ";");
			Иначе
				СписокУстройствMS.Добавить(DeviceId + ";" + ?(НЕ ЗначениеЗаполнено(DeviceName), DeviceId, DeviceName + ", (" + DeviceId + ")") + ";");
			КонецЕсли;
		КонецЦикла;
			
		пСтруктураМетаданных.Вставить("УстройстваMS", СписокУстройствMS);
	КонецЕсли;	

	Если ОбновитьСписокПользователей ИЛИ ОбновитьСписокУстройств Тогда
		ГлЯдро_СохранитьДанныеВХранилище1С(ИмяПеременнойНастройки, пСтруктураМетаданных);
	КонецЕсли;
	
	ПользователиMSАдрес = ГлЯдро_ДеревоПользователейВоВременноеХранилище(СписокПользователейMS);
	УстройстваMSАдрес 	= ГлЯдро_ДеревоУстройствВоВременноеХранилище(СписокУстройствMS, флЛегкоеОблако);
	
	пСтруктураМетаданных.Вставить("ПользователиMS", ПользователиMSАдрес);
	пСтруктураМетаданных.Вставить("УстройстваMS",	УстройстваMSАдрес);

    Возврат пСтруктураМетаданных;
	
КонецФункции

Функция КомЯдро_ОбновитьМетаданныеТаблицMS(ТипБазы, АдресаПеременных)
	
	Если НЕ КомЯдро_ПодключитьсяКСерверуSMARTS(Ложь, ТипБазы, АдресаПеременных) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если ТипБазы = "Частная" Тогда
		СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("COMЧастнойБазыMS", АдресаПеременных);
	ИначеЕсли ТипБазы = "Временная" Тогда
		СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("COMВременнойБазыMS", АдресаПеременных);
	Иначе
		СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("COMБазыMS", АдресаПеременных);
	КонецЕсли;	
	
	Если НЕ СтруктураПодключенияMS.Свойство("Окружение") ИЛИ СтруктураПодключенияMS.Окружение = Неопределено Тогда
		СтруктураПодключенияMS.Вставить("Окружение", СтруктураПодключенияMS.TerminalConnector.ПолучитьСреду());
	КонецЕсли;
	
	Если СтруктураПодключенияMS.Окружение = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Таблицы = Новый СписокЗначений;	
	
	Для ИндексТаблицы = 0 По СтруктураПодключенияMS.Окружение.Tables.Count - 1 Цикл 
		ДопТаблица = СтруктураПодключенияMS.Окружение.Tables.Item(ИндексТаблицы); 	
		СписокПолейДопТаблицы = КомЯдро_ПолучитьСписокРеквизитовСущностиMS(ДопТаблица.Fields);
		Таблицы.Добавить(СписокПолейДопТаблицы, ДопТаблица.Name);
	КонецЦикла;
		
	Возврат Таблицы;
	
КонецФункции

Функция КомЯдро_ПолучитьПользователейSMARTS(ТипБазы, АдресаПеременных)
	
	Если НЕ КомЯдро_ПодключитьсяКСерверуSMARTS(Ложь,ТипБазы,АдресаПеременных) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если ТипБазы = "Частная" Тогда
		СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("COMЧастнойБазыMS",АдресаПеременных);
	ИначеЕсли ТипБазы = "Временная" Тогда
		СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("COMВременнойБазыMS",АдресаПеременных);
	Иначе
		СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("COMБазыMS",АдресаПеременных);
	КонецЕсли;	
	
	Если НЕ СтруктураПодключенияMS.Свойство("Окружение") ИЛИ СтруктураПодключенияMS.Окружение = Неопределено Тогда
		СтруктураПодключенияMS.Вставить("Окружение", СтруктураПодключенияMS.TerminalConnector.ПолучитьСреду());
		
		Если ТипБазы = "Частная" Тогда
			пCOMЧастнойБазыMS = СтруктураПодключенияMS;
			КомЯдро_СохранитьЗначениеПеременной("COMЧастнойБазыMS",пCOMЧастнойБазыMS,АдресаПеременных);
		ИначеЕсли ТипБазы = "Временная" Тогда
			пCOMВременнойБазыMS = СтруктураПодключенияMS;
			КомЯдро_СохранитьЗначениеПеременной("COMВременнойБазыMS",пCOMВременнойБазыMS,АдресаПеременных);
		Иначе
			пCOMБазыMS = СтруктураПодключенияMS;
			КомЯдро_СохранитьЗначениеПеременной("COMБазыMS",пCOMБазыMS,АдресаПеременных);
		КонецЕсли; 
	КонецЕсли;
	
	Если СтруктураПодключенияMS.Окружение = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	МассивПользователейMS = Новый Массив;      
	
	Для Инд = 0 По СтруктураПодключенияMS.Окружение.Users.count - 1 Цикл
		
		ТекущийПользователь = СтруктураПодключенияMS.Окружение.Users.Item(Инд);
		
		стрПользователиMS = Новый Структура("Ид,Имя,ИдГруппы,ИмяГруппы,Пароль,Описание,Штрихкод,ИдСкладов");
		стрПользователиMS.Ид 		= ТекущийПользователь.Id;
		стрПользователиMS.Имя 		= ТекущийПользователь.Name;
		стрПользователиMS.ИдГруппы 	= ТекущийПользователь.GroupId;
		стрПользователиMS.ИмяГруппы = ТекущийПользователь.GroupName;
		стрПользователиMS.Описание 	= ТекущийПользователь.Description;			
		стрПользователиMS.Пароль 	= ТекущийПользователь.Password;			
		стрПользователиMS.Штрихкод 	= ТекущийПользователь.Barcode;    			
		
		СписокСкладов = Новый СписокЗначений;		
		Warehouses = ТекущийПользователь.WarehouseIds;                     
		Если Warehouses <> Неопределено Тогда                           
			Для ИндСклада = 0 По (Warehouses.count - 1) Цикл			
				СписокСкладов.Добавить(Warehouses.Item(ИндСклада));
			КонецЦикла;
		КонецЕсли;
		
		стрПользователиMS.ИдСкладов = СписокСкладов; 		
		
		МассивПользователейMS.Добавить(стрПользователиMS);
		
	КонецЦикла;	
	
	Возврат ПоместитьВоВременноеХранилище(МассивПользователейMS, Новый УникальныйИдентификатор());

	
КонецФункции

Функция КомЯдро_ПолучитьСкладыSMARTS(ТипБазы, АдресаПеременных)
	
	Если НЕ КомЯдро_ПодключитьсяКСерверуSMARTS(Ложь,ТипБазы,АдресаПеременных) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если ТипБазы = "Частная" Тогда
		СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("COMЧастнойБазыMS",АдресаПеременных);
	ИначеЕсли ТипБазы = "Временная" Тогда
		СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("COMВременнойБазыMS",АдресаПеременных);
	Иначе
		СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("COMБазыMS",АдресаПеременных);
	КонецЕсли;	
	
	Если НЕ СтруктураПодключенияMS.Свойство("Окружение") ИЛИ СтруктураПодключенияMS.Окружение = Неопределено Тогда
		СтруктураПодключенияMS.Вставить("Окружение", СтруктураПодключенияMS.TerminalConnector.ПолучитьСреду());
		
		Если ТипБазы = "Частная" Тогда
			пCOMЧастнойБазыMS = СтруктураПодключенияMS;
			КомЯдро_СохранитьЗначениеПеременной("COMЧастнойБазыMS",пCOMЧастнойБазыMS,АдресаПеременных);
		ИначеЕсли ТипБазы = "Временная" Тогда
			пCOMВременнойБазыMS = СтруктураПодключенияMS;
			КомЯдро_СохранитьЗначениеПеременной("COMВременнойБазыMS",пCOMВременнойБазыMS,АдресаПеременных);
		Иначе
			пCOMБазыMS = СтруктураПодключенияMS;
			КомЯдро_СохранитьЗначениеПеременной("COMБазыMS",пCOMБазыMS,АдресаПеременных);
		КонецЕсли; 
	КонецЕсли;
	
	Если СтруктураПодключенияMS.Окружение = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	МассивСкладовMS = Новый Массив;
	
	Для Инд = 0 По СтруктураПодключенияMS.Окружение.Warehouses.count - 1 Цикл
		
		ТекущийСклад = СтруктураПодключенияMS.Окружение.Warehouses.Item(Инд);
		
		стрСкладыMS = Новый Структура("Ид,Имя");
		стрСкладыMS.Ид	= ТекущийСклад.Id;
		стрСкладыMS.Имя = ТекущийСклад.Name;		
		
		МассивСкладовMS.Добавить(стрСкладыMS);
		
	КонецЦикла;	
	
	Возврат ПоместитьВоВременноеХранилище(МассивСкладовMS, Новый УникальныйИдентификатор());	
КонецФункции

Функция КомЯдро_ПолучитьГруппыПользователейSMARTS(ТипБазы, АдресаПеременных)
	
	Если НЕ КомЯдро_ПодключитьсяКСерверуSMARTS(Ложь,ТипБазы,АдресаПеременных) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если ТипБазы = "Частная" Тогда
		СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("COMЧастнойБазыMS",АдресаПеременных);
	ИначеЕсли ТипБазы = "Временная" Тогда
		СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("COMВременнойБазыMS",АдресаПеременных);
	Иначе
		СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("COMБазыMS",АдресаПеременных);
	КонецЕсли;	
	
	Если НЕ СтруктураПодключенияMS.Свойство("Окружение") ИЛИ СтруктураПодключенияMS.Окружение = Неопределено Тогда
		СтруктураПодключенияMS.Вставить("Окружение", СтруктураПодключенияMS.TerminalConnector.ПолучитьСреду());
		
		Если ТипБазы = "Частная" Тогда
			пCOMЧастнойБазыMS = СтруктураПодключенияMS;
			КомЯдро_СохранитьЗначениеПеременной("COMЧастнойБазыMS",пCOMЧастнойБазыMS,АдресаПеременных);
		ИначеЕсли ТипБазы = "Временная" Тогда
			пCOMВременнойБазыMS = СтруктураПодключенияMS;
			КомЯдро_СохранитьЗначениеПеременной("COMВременнойБазыMS",пCOMВременнойБазыMS,АдресаПеременных);
		Иначе
			пCOMБазыMS = СтруктураПодключенияMS;
			КомЯдро_СохранитьЗначениеПеременной("COMБазыMS",пCOMБазыMS,АдресаПеременных);
		КонецЕсли; 
	КонецЕсли;
	
	Если СтруктураПодключенияMS.Окружение = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	МассивГруппПользователейMS = Новый Массив;
		
	Для Инд = 0 По СтруктураПодключенияMS.Окружение.Groups.count - 1 Цикл
		
		ТекущаяГруппа = СтруктураПодключенияMS.Окружение.Groups.Item(Инд);
		
		стрГруппыПользователейMS = Новый Структура("Ид,Имя,Роль,ТипыДокументов");
		стрГруппыПользователейMS.Ид 	= ТекущаяГруппа.Id;
		стрГруппыПользователейMS.Имя 	= ТекущаяГруппа.Name;
		Если ТипЗнч(ТекущаяГруппа.Role) = Тип("Число") Тогда
			Если ТекущаяГруппа.Role = 3 Тогда 
				РольСтрока = "User";				
			ИначеЕсли ТекущаяГруппа.Role = 2 Тогда 
				РольСтрока = "Administrator";
			Иначе
				РольСтрока = "MobileDeviceUser";
			КонецЕсли;
		Иначе     
			РольСтрока = ТекущаяГруппа.Role;
		КонецЕсли;
		стрГруппыПользователейMS.Роль 	= РольСтрока;
		
		ТипыДокументов = Новый Массив; 
		documentTypeNames = ТекущаяГруппа.DocumentTypeNames;
		Если documentTypeNames <> Неопределено Тогда
			Для ИндТипа = 0 По (documentTypeNames.count - 1) Цикл			
				ТипыДокументов.Добавить(documentTypeNames.Item(ИндТипа));
			КонецЦикла;					
		КонецЕсли;	
		стрГруппыПользователейMS.ТипыДокументов = ТипыДокументов;
		
		МассивГруппПользователейMS.Добавить(стрГруппыПользователейMS);	
		
	КонецЦикла;	
	
	Возврат ПоместитьВоВременноеХранилище(МассивГруппПользователейMS, Новый УникальныйИдентификатор());
	
КонецФункции

Функция КомЯдро_ЗагрузитьПользователейВSMARTS(ПараметрыПользователя, ТипБазы, АдресаПеременных)
	
	Если НЕ КомЯдро_ПодключитьсяКСерверуSMARTS(Ложь,ТипБазы,АдресаПеременных) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если ТипБазы = "Частная" Тогда
		СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("COMЧастнойБазыMS",АдресаПеременных);
	ИначеЕсли ТипБазы = "Временная" Тогда
		СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("COMВременнойБазыMS",АдресаПеременных);
	Иначе
		СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("COMБазыMS",АдресаПеременных);
	КонецЕсли;	
		
	Ответ = Новый Структура("Результат,ТекстОшибки", Истина, "");
	
	#Область НесовместимыйКодFresh
	Попытка  	
		Users 		= СтруктураПодключенияMS.Окружение.Users;
		// Находим объект UserGroup по идентификатору
		CurrentUser = Users.FindById(ПараметрыПользователя["id"]);	
		
		// Если такого элемента нет, создаем новый
		НовыйЭлемент = Ложь;
		Если CurrentUser = Неопределено Или CurrentUser = Null Тогда			
			CurrentUser 	= Новый COMОбъект("Cleverence.Warehouse.User");
			CurrentUser.Id 	= ПараметрыПользователя["id"];          
			НовыйЭлемент = Истина;
		КонецЕсли;
		
		// Заполняем переданные поля
		CurrentUser.Name 	= Строка(ПараметрыПользователя["name"]);
		Если Не ПустаяСтрока(ПараметрыПользователя["password"]) Тогда
			CurrentUser.Password = ПараметрыПользователя["password"];
		ИначеЕсли НовыйЭлемент Тогда
			CurrentUser.Password = " ";
		КонецЕсли;
		Если Не ПустаяСтрока(ПараметрыПользователя["barcode"]) Тогда		
			CurrentUser.Barcode = ПараметрыПользователя["barcode"];
		ИначеЕсли НовыйЭлемент Тогда
			CurrentUser.Barcode = " ";
		КонецЕсли;
		
		CurrentUser.GroupName 	= ПараметрыПользователя["groupName"];
		CurrentUser.GroupId		= ПараметрыПользователя["groupId"];
	
		Warehouses = СтруктураПодключенияMS.Окружение.Warehouses;
		
		Для Каждого Склад Из ПараметрыПользователя["allWarehouses"] Цикл
			ИдСклада 		= Склад.Значение;
			Использование 	= Склад.Пометка;
			
			Warehouse = Warehouses.FindById(ИдСклада);                    
			Если (Warehouses <> Неопределено И Warehouses <> Null) Тогда 
				Если (CurrentUser.Warehouses.FindById(ИдСклада) = Неопределено Или CurrentUser.Warehouses.FindById(ИдСклада) = Null) 
					И Использование Тогда
					CurrentUser.Warehouses.Add(Warehouse);
				ИначеЕсли (CurrentUser.Warehouses.FindById(ИдСклада) <> Неопределено И CurrentUser.Warehouses.FindById(ИдСклада) <> Null) 
					И Не Использование Тогда       
					CurrentUser.Warehouses.Remove(Warehouse);
				КонецЕсли;
			КонецЕсли;						
		КонецЦикла;
		
		// Зашифровываем штрихкод и пароль
		CurrentUser.Encrypt();
		
		// Проверяем штрихкод пользователя на уникальность
		Если НовыйЭлемент Тогда 
			Если Users.FindByBarcode(CurrentUser.Barcode) = Неопределено Или  Users.FindByBarcode(CurrentUser.Barcode) = Null Тогда
				// Если элемент новый, добавляем его в UserCollection
				Users.Add(CurrentUser);				
			Иначе 
				Сообщить("Пользователь """ + Строка(CurrentUser.Name) + """ не выгружен в базу SMARTS. Пользователь с таким паролем уже существует.");
		    	Ответ.Результат =  Ложь;						
			КонецЕсли;	
		КонецЕсли;
		
		// Выгружаем обновленную UserCollection
		Если Ответ.Результат Тогда
			СтруктураПодключенияMS.StorageConnector.SetUsers(Users); 	
			
			Если НовыйЭлемент Тогда 
				Сообщить("Создан новый пользователь """ + Строка(CurrentUser.Name) + """.");			
			КонецЕсли;
		КонецЕсли;		   
		
	Исключение
		
		Ответ.Результат 	=  Ложь;
		Ответ.ТекстОшибки 	= ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		
	КонецПопытки;    
	#КонецОбласти //НесовместимыйКодFresh	

	Возврат Ответ;

	
КонецФункции

Функция КомЯдро_ЗагрузитьГруппыПользователейВSMARTS(ПараметрыГруппы, ТипБазы, АдресаПеременных)
	
		Если НЕ КомЯдро_ПодключитьсяКСерверуSMARTS(Ложь,ТипБазы,АдресаПеременных) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если ТипБазы = "Частная" Тогда
		СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("COMЧастнойБазыMS",АдресаПеременных);
	ИначеЕсли ТипБазы = "Временная" Тогда
		СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("COMВременнойБазыMS",АдресаПеременных);
	Иначе
		СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("COMБазыMS",АдресаПеременных);
	КонецЕсли;	
		
	Ответ = Новый Структура("Результат,ТекстОшибки", Истина, "");
	
	#Область НесовместимыйКодFresh	
	Попытка  			
		Groups 		= СтруктураПодключенияMS.Окружение.Groups;
		// Находим объект UserGroup по идентификатору
		CurrentGroup = Groups.FindById(ПараметрыГруппы["id"]);	
		
		// Если такого элемента нет, создаем новый
		НовыйЭлемент = Ложь;
		Если CurrentGroup = Неопределено Или CurrentGroup = Null Тогда			
			CurrentGroup 	= Новый COMОбъект("Cleverence.Warehouse.UserGroup");
			CurrentGroup.Id = ПараметрыГруппы["id"];          
			НовыйЭлемент = Истина;
		КонецЕсли;
		
		// Заполняем переданные поля
		CurrentGroup.Name 					= ПараметрыГруппы["name"];
		CurrentGroup.BatchMode 				= ПараметрыГруппы["batchMode"];
		CurrentGroup.ServerSideInventory 	= ПараметрыГруппы["serverSideInventory"];
		
		// Проставляем числовой эквивалент роли
		РольСтрока = ПараметрыГруппы["role"];		
		Если РольСтрока = "User" Тогда 
			ТекРоль = 3;							
		ИначеЕсли РольСтрока = "Administrator" Тогда
			ТекРоль = 2;
		Иначе
			ТекРоль = 0;
		КонецЕсли;                                   	
		CurrentGroup.Role 					= ТекРоль;
		
		// Заполняем таблицу доступных типов документов
		DocumentTypes = СтруктураПодключенияMS.Окружение.DocumentTypes;
		
		Для Каждого ТипДокумента Из ПараметрыГруппы["AlldocumentTypeNames"] Цикл
			ИмяТипа 		= ТипДокумента.Значение;
			Использование 	= ТипДокумента.Пометка;
			
			DocumentType = DocumentTypes.FindByName(ИмяТипа);                    
			Если (DocumentType <> Неопределено И DocumentType <> Null) Тогда 
				Если (CurrentGroup.DocumentTypes.FindByName(ИмяТипа) = Неопределено Или CurrentGroup.DocumentTypes.FindByName(ИмяТипа) = Null) 
					И Использование Тогда
					CurrentGroup.DocumentTypes.Add(DocumentType);
				ИначеЕсли (CurrentGroup.DocumentTypes.FindByName(ИмяТипа) <> Неопределено И CurrentGroup.DocumentTypes.FindByName(ИмяТипа) <> Null) 
					И Не Использование Тогда       
					CurrentGroup.DocumentTypes.Remove(DocumentType);
				КонецЕсли;
			КонецЕсли;						
		КонецЦикла;
		
		// Если элемент новый, добавляем его в UserGroupCollection, и выгружаем обновленную коллекцию
		Если НовыйЭлемент Тогда 
			Groups.Add(CurrentGroup);
		КонецЕсли;		  		
		СтруктураПодключенияMS.StorageConnector.SetUserGroups(Groups); 	
		
		Если НовыйЭлемент Тогда 
			Сообщить("Создана новая группа """ + Строка(CurrentGroup.Name) + """.");
		КонецЕсли;
		
	Исключение
		
		Ответ.Результат 	=  Ложь;
		Ответ.ТекстОшибки 	= ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		
	КонецПопытки;    
	#КонецОбласти //НесовместимыйКодFresh
	
	Возврат Ответ;
	
КонецФункции

Функция КомЯдро_ПолучитьСписокСлужебныхДокументовMS(ТипБазы, АдресаПеременных)
	
	Если НЕ КомЯдро_ПодключитьсяКСерверуSMARTS(Ложь,ТипБазы,АдресаПеременных) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если ТипБазы = "Частная" Тогда
		СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("COMЧастнойБазыMS",АдресаПеременных);
	ИначеЕсли ТипБазы = "Временная" Тогда
		СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("COMВременнойБазыMS",АдресаПеременных);
	Иначе
		СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("COMБазыMS",АдресаПеременных);
	КонецЕсли;	
		
	Если НЕ СтруктураПодключенияMS.Свойство("Окружение") ИЛИ СтруктураПодключенияMS.Окружение = Неопределено Тогда
		СтруктураПодключенияMS.Вставить("Окружение", СтруктураПодключенияMS.TerminalConnector.ПолучитьСреду());
	КонецЕсли;
	
	Если СтруктураПодключенияMS.Окружение = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	СлужебныеДокументыMS = Новый СписокЗначений;
		
	Для Каждого ТипДокумента из СтруктураПодключенияMS.Окружение.DocumentTypes Цикл
		
		Если Не ТипДокумента.Virtual Тогда
			Продолжить;
		КонецЕсли;
		
		СлужебныеДокументыMS.Добавить(ТипДокумента.Name, ТипДокумента.ToString);
		
	КонецЦикла; 
	
	Возврат СлужебныеДокументыMS;
	
КонецФункции

Функция КомЯдро_ОбновитьМетаданныеПользователейMS(ТипБазы, АдресаПеременных)
	
	Если НЕ КомЯдро_ПодключитьсяКСерверуSMARTS(Ложь,ТипБазы,АдресаПеременных) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если ТипБазы = "Частная" Тогда
		СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("COMЧастнойБазыMS",АдресаПеременных);
	ИначеЕсли ТипБазы = "Временная" Тогда
		СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("COMВременнойБазыMS",АдресаПеременных);
	Иначе
		СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("COMБазыMS",АдресаПеременных);
	КонецЕсли;	
		
	Если НЕ СтруктураПодключенияMS.Свойство("Окружение") ИЛИ СтруктураПодключенияMS.Окружение = Неопределено Тогда
		СтруктураПодключенияMS.Вставить("Окружение", СтруктураПодключенияMS.TerminalConnector.ПолучитьСреду());
	КонецЕсли;
	
	Если СтруктураПодключенияMS.Окружение = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	СписокПользователейMS = Новый СписокЗначений;
	
	СписокПользователейMS.Добавить("Выгружать всем;Выгружать всем"); 	
	СписокПользователейMS.Добавить("Спрашивать при выгрузке;Спрашивать при выгрузке");	
	
	Для Инд = 0 По СтруктураПодключенияMS.Окружение.Users.count - 1 Цикл
		ТекущийПользователь = COMБазыMS.Окружение.Users.Item(Инд);
		СписокПользователейMS.Добавить(ТекущийПользователь.Id + ";" + ТекущийПользователь.Name, ТекущийПользователь.GroupId + ";" + ТекущийПользователь.GroupName);
	КонецЦикла;	
	
	ПользователиMSАдрес = ГлЯдро_ДеревоПользователейВоВременноеХранилище(СписокПользователейMS);
	
	ГлЯдро_ОбновитьМетаданныеПользователейMSВХранилище1С(СписокПользователейMS, ПользователиMSАдрес, АдресаПеременных);
	
	Возврат ?(ПользователиMSАдрес = Неопределено, "", ПользователиMSАдрес);
	
КонецФункции

Функция КомЯдро_УдалитьПользователейВSMARTS(ПараметрыПользователя, ТипБазы, АдресаПеременных)
	
	Если НЕ КомЯдро_ПодключитьсяКСерверуSMARTS(Ложь,ТипБазы,АдресаПеременных) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если ТипБазы = "Частная" Тогда
		СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("COMЧастнойБазыMS",АдресаПеременных);
	ИначеЕсли ТипБазы = "Временная" Тогда
		СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("COMВременнойБазыMS",АдресаПеременных);
	Иначе
		СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("COMБазыMS",АдресаПеременных);
	КонецЕсли;	
		
	Ответ = Новый Структура("Результат,ТекстОшибки", Истина, "");
		
	Попытка  	
		Users 		= СтруктураПодключенияMS.Окружение.Users;
		// Находим объект User по идентификатору
		CurrentUser = Users.FindById(ПараметрыПользователя["Ид"]);	
		
		// Если такой объект найден удаляем его из UserCollection, и выгружаем обновленную коллекцию
		Если CurrentUser <> Неопределено И CurrentUser <> Null Тогда			
			Users.Remove(CurrentUser);			
			СтруктураПодключенияMS.StorageConnector.SetUsers(Users); 	
			Сообщить("Пользователь """ + Строка(CurrentUser.Name) + """ удален из базы SMARTS.");				
		КонецЕсли;		
		
	Исключение
		
		Ответ.Результат 	=  Ложь;
		Ответ.ТекстОшибки 	= ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		
	КонецПопытки;    
	
	Возврат Ответ;
	
КонецФункции

Функция КомЯдро_УдалитьГруппыПользователейВSMARTS(ПараметрыГруппы, ТипБазы, АдресаПеременных)
			
	Если НЕ КомЯдро_ПодключитьсяКСерверуSMARTS(Ложь,ТипБазы,АдресаПеременных) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если ТипБазы = "Частная" Тогда
		СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("COMЧастнойБазыMS",АдресаПеременных);
	ИначеЕсли ТипБазы = "Временная" Тогда
		СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("COMВременнойБазыMS",АдресаПеременных);
	Иначе
		СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("COMБазыMS",АдресаПеременных);
	КонецЕсли;	
		
	Ответ = Новый Структура("Результат,ТекстОшибки", Истина, "");
		
	Попытка  	
		Groups 		= СтруктураПодключенияMS.Окружение.Groups;
		// Находим объект UserGroup по идентификатору
		CurrentGroup = Groups.FindById(ПараметрыГруппы["Ид"]);	
		
		// Если такой объект найден удаляем его из UserGroupCollection, и выгружаем обновленную коллекцию
		Если CurrentGroup <> Неопределено И CurrentGroup <> Null Тогда			
			Groups.Remove(CurrentGroup);			
			СтруктураПодключенияMS.StorageConnector.SetUserGroups(Groups); 	
			Сообщить("Группа """ + Строка(CurrentGroup.Name) + """ удалена из базы Mobile SMARTS.");
		КонецЕсли;		
		
	Исключение
		
		Ответ.Результат 	=  Ложь;
		Ответ.ТекстОшибки 	= ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		
	КонецПопытки;    
	
	Возврат Ответ;
	
КонецФункции

Функция КомЯдро_ПолучитьСписокРеквизитовСущностиMS(СущностьMS, ДополнительныйСписок = Неопределено)
	
	СписокРеквизитов = Новый Массив;
	Для Индекс = 0 По СущностьMS.Количество - 1 Цикл
		ДанныеРеквизита = СущностьMS.Элемент(Индекс);
		Если НЕ ДанныеРеквизита.ReadOnly Тогда
			СписокРеквизитов.Добавить(Новый Структура("Значение,Ключ,Uni",ДанныеРеквизита.ИмяПоля, ДанныеРеквизита.ИмяПоля, ГлЯдро_ПреобразоватьПервыйСимволВНижнийРегистр(ДанныеРеквизита.uni)));
		КонецЕсли;
	КонецЦикла;
	
	Если ДополнительныйСписок <> Неопределено Тогда
		Для Каждого ДополнительныйЭлемент Из ДополнительныйСписок Цикл
			СписокРеквизитов.Добавить(ДополнительныйЭлемент);
		КонецЦикла;
	КонецЕсли;
	
	Возврат СписокРеквизитов;
	
КонецФункции

Процедура КомЯдро_ОбновитьШаблоныВесовогоТовараMS(ТаблицаШаблонов,АдресаПеременных)
	
	Если НЕ КомЯдро_ПодключитьсяКСерверуSMARTS(Ложь,"Основная",АдресаПеременных) Тогда
		Возврат;
	КонецЕсли;
	
	СтруктураПодключенияБазыMS = КомЯдро_ПолучитьЗначениеПеременной("COMБазыMS",АдресаПеременных);
	
	Если НЕ СтруктураПодключенияБазыMS.Свойство("Окружение") ИЛИ СтруктураПодключенияБазыMS.Окружение = Неопределено Тогда
		СтруктураПодключенияБазыMS.Вставить("Окружение", СтруктураПодключенияБазыMS.TerminalConnector.ПолучитьСреду());
		пCOMБазыMS = СтруктураПодключенияБазыMS;
		КомЯдро_СохранитьЗначениеПеременной("COMБазыMS",пCOMБазыMS,АдресаПеременных);
	КонецЕсли;
	
	КоллекцияШаблонов = СтруктураПодключенияБазыMS.Окружение.ProductSchema.CommonTemplates;
	
	// Удаление существующих шаблонов
	КоличествоШаблоновКУдалению = КоллекцияШаблонов.Количество;
	Для Счетчик = -(КоличествоШаблоновКУдалению-1) По 0 Цикл
		ТекущийШаблон = КоллекцияШаблонов.Элемент(-Счетчик);
		Если Найти(ТекущийШаблон, "OneC:1") > 0 Тогда
			КоллекцияШаблонов.Удалить(ТекущийШаблон);
		КонецЕсли;
	КонецЦикла;
	
	// Добавление новых шаблонов
	Для Каждого Шаблон из ТаблицаШаблонов Цикл
		ЦелаяЧасть = Шаблон.ЦелаяЧасть - СтрДлина(Шаблон.Префикс);
		Если Шаблон.ПрефиксВключенВКод Тогда			
			КоллекцияШаблонов.Добавить("{Barcode:@" + Шаблон.Префикс + "[0-9]{" + Шаблон.ДлинаКодаВесовогоТовара + "}}{Quantity:" + ЦелаяЧасть + "." + Шаблон.ДробнаяЧасть + "}{OneC:1}");			
		Иначе
			КоллекцияШаблонов.Добавить(Шаблон.Префикс + "{Barcode:" + Шаблон.ДлинаКодаВесовогоТовара + "}{Quantity:" + ЦелаяЧасть + "." + Шаблон.ДробнаяЧасть + "}{OneC:1}");
		КонецЕсли;
	КонецЦикла;
	
	СтруктураПодключенияБазыMS.TerminalConnector.УстановитьСреду(СтруктураПодключенияБазыMS.Окружение);
	
КонецПроцедуры

Процедура КомЯдро_УстановитьПоискПоНаименованиюИАртикулу(УстановитьПоискПоНаименованиюИАртикулу,АдресаПеременных)
	
	Если НЕ КомЯдро_ПодключитьсяКСерверуSMARTS(Ложь,"Основная",АдресаПеременных) Тогда
		Возврат;
	КонецЕсли;
	пCOMБазыMS = КомЯдро_ПолучитьЗначениеПеременной("COMБазыMS",АдресаПеременных);
	пCOMБазыMS.TerminalConnector.УстановитьПоискПоНаименованиюИАртикулу(УстановитьПоискПоНаименованиюИАртикулу);		
КонецПроцедуры

Функция КомЯдро_ПолучитьСписокСправочниковВКонфигурацииSMARTS(АдресаПеременных)
	
	МассивСправочников = Новый Массив;
	
	//СтруктураПодключенияБазыMS = КомЯдро_ПолучитьЗначениеПеременной("COMБазыMS",АдресаПеременных);

	СтруктураМетаданных = КомЯдро_ПолучитьЗначениеПеременной("СтруктураМетаданных",АдресаПеременных);
	
	Для инд = 0 По СтруктураМетаданных.Tables.Количество() - 1 Цикл
		МассивСправочников.Добавить(СтруктураМетаданных.Tables.Получить(инд).Представление);		
	КонецЦикла;
	
	Возврат МассивСправочников;
	
КонецФункции

Функция КомЯдро_ПолучитьМобильныеУстройстваSMARTS(ТипБазы,АдресаПеременных)
	
	Если НЕ КомЯдро_ПодключитьсяКСерверуSMARTS(Ложь,ТипБазы,АдресаПеременных) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если ТипБазы = "Частная" Тогда
		СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("COMЧастнойБазыMS",АдресаПеременных);
	ИначеЕсли ТипБазы = "Временная" Тогда
		СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("COMВременнойБазыMS",АдресаПеременных);
	Иначе
		СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("COMБазыMS",АдресаПеременных);
	КонецЕсли;	
	
	Если НЕ СтруктураПодключенияMS.Свойство("Окружение") ИЛИ СтруктураПодключенияMS.Окружение = Неопределено Тогда
		СтруктураПодключенияMS.Вставить("Окружение", СтруктураПодключенияMS.TerminalConnector.ПолучитьСреду());
		
		Если ТипБазы = "Частная" Тогда
			пCOMЧастнойБазыMS = СтруктураПодключенияMS;
			КомЯдро_СохранитьЗначениеПеременной("COMЧастнойБазыMS",пCOMЧастнойБазыMS,АдресаПеременных);
		ИначеЕсли ТипБазы = "Временная" Тогда
			пCOMВременнойБазыMS = СтруктураПодключенияMS;
			КомЯдро_СохранитьЗначениеПеременной("COMВременнойБазыMS",пCOMВременнойБазыMS,АдресаПеременных);
		Иначе
			пCOMБазыMS = СтруктураПодключенияMS;
			КомЯдро_СохранитьЗначениеПеременной("COMБазыMS",пCOMБазыMS,АдресаПеременных);
		КонецЕсли; 
	КонецЕсли;
	
	Если СтруктураПодключенияMS.Окружение = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	СписокУстройствMS = Новый СписокЗначений;
	
	УстройстваMS = СтруктураПодключенияMS.StorageConnector.ПолучитьДанныеОТерминалах();
	Для Счетчик = 0 По УстройстваMS.Количество - 1 Цикл
		Pincode = СокрЛП(УстройстваMS.Item(Счетчик).pincode);
		DeviceId   = СокрЛП(УстройстваMS.Item(Счетчик).DeviceId);
		DeviceName = СокрЛП(УстройстваMS.Item(Счетчик).DeviceName);
		СписокУстройствMS.Добавить(Pincode + ";" + DeviceId + ";" + ?(НЕ ЗначениеЗаполнено(DeviceName), DeviceId, DeviceName + ", (" + DeviceId + ")") + ";");		
	КонецЦикла;
	
	УстройстваMS = Новый ДеревоЗначений;
	УстройстваMS.Колонки.Добавить("Выгружать", 			  	Новый ОписаниеТипов("Булево"), "Выгружать");
	УстройстваMS.Колонки.Добавить("ПинКод",   				Новый ОписаниеТипов("Строка"), "Пин-код");
	УстройстваMS.Колонки.Добавить("ГруппаПользователь",   	Новый ОписаниеТипов("Строка"), "Группа/пользователь");
	УстройстваMS.Колонки.Добавить("ИдГруппыПользователя", 	Новый ОписаниеТипов("Строка"), "Ид группы/пользователя");	
	
	Для Каждого Устройство из СписокУстройствMS Цикл
		
		ИдИИмяУстройства = ГлЯдро_РазложитьСтрокуВМассивПодстрок(Устройство.Значение, ";");
		
		ПинУстройства  	= ИдИИмяУстройства[0];
		ИдУстройства  	= ИдИИмяУстройства[1];
		ИмяУстройства 	= ИдИИмяУстройства[2];		
		
		СтрокаДерева 						= УстройстваMS.Строки.Добавить();
		СтрокаДерева.ИдГруппыПользователя 	= ИдУстройства;
		СтрокаДерева.ГруппаПользователь 	= ИмяУстройства;  
		СтрокаДерева.ПинКод 				= ПинУстройства;					
		
	КонецЦикла;
	
	Возврат ПоместитьВоВременноеХранилище(УстройстваMS, Новый УникальныйИдентификатор());
	
КонецФункции

#КонецОбласти

#Область КомпонентаMobileSMARTS_ДокументыSMARTS

Функция КомЯдро_СформироватьНовыйДокументSMARTS(ДанныеДокумента,НазначенныйПользователь = "", СпособНазначения = "")
	
	#Область НесовместимыйКодFresh
	ДокументSMARTS = Новый COMОбъект("Cleverence.Warehouse.Document");
	
	Для Каждого РеквизитДокумента Из ДанныеДокумента.ШапкаДокумента Цикл
		Попытка
			ДокументSMARTS.SetField(РеквизитДокумента.Ключ, РеквизитДокумента.Значение);
		Исключение
		КонецПопытки;
	КонецЦикла;
	
	Если НазначенныйПользователь <> "" Тогда
		Если СпособНазначения = "Устройству" Тогда
			ДокументSMARTS.SetField("Назначение", НазначенныйПользователь);
		Иначе
			ДокументSMARTS.SetField("Назначение", НазначенныйПользователь);
			ДокументSMARTS.SetField("Ид",ДокументSMARTS.Id+"#"+СтрЗаменить(НазначенныйПользователь,"|",""))
		КонецЕсли;
	КонецЕсли;
	
	Если ДанныеДокумента.Свойство("ТабличныеЧасти") И ДанныеДокумента.ТабличныеЧасти.Количество() > 0 Тогда
		Для Каждого ТабличнаяЧасть Из ДанныеДокумента.ТабличныеЧасти Цикл
			Если КомЯдро_ЭтоОсновнаяТаблица(ТабличнаяЧасть.Ключ) Тогда
				Для каждого СтрокаТЧ Из ТабличнаяЧасть.Значение Цикл												
					СтрокаДокументаSMARTS = Новый COMОбъект("Cleverence.Warehouse.DocumentItem");
					Для Каждого РеквизитСтроки Из СтрокаТЧ Цикл
						Попытка
							СтрокаДокументаSMARTS.SetField(РеквизитСтроки.Ключ, РеквизитСтроки.Значение);
						Исключение
						КонецПопытки;
					КонецЦикла;
					
					ДокументSMARTS[ТабличнаяЧасть.Ключ].Добавить(СтрокаДокументаSMARTS);					
				КонецЦикла; 
			Иначе
				ДопТаблицаSMARTS = Новый COMОбъект("Cleverence.Warehouse.Table");		
				ДопТаблицаSMARTS.Name = ТабличнаяЧасть.Ключ;
				
				Для каждого СтрокаТЧ Из ТабличнаяЧасть.Значение Цикл
					Row = Новый COMОбъект("Cleverence.Warehouse.Row");
					Для Каждого РеквизитСтроки Из СтрокаТЧ Цикл
						Попытка
							Row.SetField(РеквизитСтроки.Ключ, РеквизитСтроки.Значение);
						Исключение
						КонецПопытки;
					КонецЦикла;
					ДопТаблицаSMARTS.Rows.Add(Row);
				КонецЦикла;
				ДокументSMARTS.Tables.Add(ДопТаблицаSMARTS);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Возврат ДокументSMARTS;
	#КонецОбласти //НесовместимыйКодFresh
	
КонецФункции

Функция КомЯдро_ЭтоОсновнаяТаблица(ИмяТаблицы) 
	
	ОсновныеТЧ = Новый Массив;
	ОсновныеТЧ.Добавить("СтрокиПлан");
	ОсновныеТЧ.Добавить("СтрокиФакт");
	ОсновныеТЧ.Добавить("СовмещенныеСтроки");
	ОсновныеТЧ.Добавить("СерииПлан");
	ОсновныеТЧ.Добавить("СерииФакт");
	ОсновныеТЧ.Добавить("СерийныеНомераПлан");
	ОсновныеТЧ.Добавить("СерийныеНомераФакт");
	Если ОсновныеТЧ.Найти(ИмяТаблицы) <> Неопределено Тогда
		Возврат Истина;
	Иначе
		Возврат Ложь;
	КонецЕсли;
КонецФункции

Процедура КомЯдро_ЗаписатьДокументВБазуSMARTS(ДокументSMARTS, ТипБазы,АдресаПеременных)
	
	Если НЕ КомЯдро_ПодключитьсяКСерверуSMARTS(Ложь,ТипБазы,АдресаПеременных) Тогда
		Возврат;
	КонецЕсли;
	
	Если ТипБазы = "Частная" Тогда
		СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("COMЧастнойБазыMS",АдресаПеременных);
	ИначеЕсли ТипБазы = "Временная" Тогда
		СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("COMВременнойБазыMS",АдресаПеременных);
	Иначе
		СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("COMБазыMS",АдресаПеременных);
	КонецЕсли;
	
	СтруктураПодключенияMS.StorageConnector.ВыгрузитьДокумент(ДокументSMARTS);
	
КонецПроцедуры

Функция КомЯдро_ПолучитьСписокДокументовНаСервереSMARTS(ТаблицаДокументов, ТипБазы, РазмерВыборки = 0, ОтборПоПериоду = Неопределено, ОтборПоУзлу = Неопределено, АдресаПеременных)
	
	Если НЕ КомЯдро_ПодключитьсяКСерверуSMARTS(Ложь,ТипБазы, АдресаПеременных) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	СтруктураПодключенияMS = КомЯдро_ПолучитьСтруктуруПодключенияMS(ТипБазы, АдресаПеременных);
	Если СтруктураПодключенияMS = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
    СтруктураМетаданных = КомЯдро_ПолучитьЗначениеПеременной("СтруктураМетаданных", АдресаПеременных);
	ЕстьЧастнаяБаза 	= КомЯдро_ПолучитьЗначениеПеременной("ЕстьЧастнаяБаза", 	АдресаПеременных);
	ЕстьЧастнаяБаза 	= ?(ЕстьЧастнаяБаза = Истина, Истина, Ложь);
	
	// заполняем таблицу
	СписокДокументовSMARTS = СтруктураПодключенияMS.TerminalConnector.ПолучитьДокументы(Неопределено);
	
	КоличествоДокументов = СписокДокументовSMARTS.Количество;
	
	Если НЕ СписокДокументовSMARTS = Неопределено Тогда
		Для ИндексДокумента = 0 По КоличествоДокументов - 1 Цикл
			ТекущаяСтрокаТаблицы = Новый Структура("ДатаСоздания,
			|Имя,
			|Ид,
			|ИмяТипаДокумента,
			|СтрокиПланКоличество,
			|СтрокиФактКоличество,
			|ИмяПользователя,
			|ВОбработке,
			|Завершен,
			|НастройкаБизнесПроцесса,
			|СозданНаТСД,
			|ЕстьПереполнениеИлиНедобор,
			|ЕстьПереполнение,
			|ЕстьНедобор,
			|ДатаЗавершения,
			|КонтрольКоличества,
			|ИдИсходныхДокументов,
			|ИмяБП,
			|ИдУзла");
			ДокументSMARTS = СписокДокументовSMARTS.Элемент(ИндексДокумента);
			
			ИмяТипаДокумента = ГлЯдро_ПреобразованиеНаименованияДокументаБезПробелов(ДокументSMARTS.documentTypeName);
			
			// Новые типы документов, добавленные, например, вручную, и еще не инициализированные в текущих
			// настройках ядра, просто пропускаем
			Если Не СтруктураМетаданных.ДокументыMS.Свойство(ИмяТипаДокумента) Тогда
				Продолжить;
			КонецЕсли;
			
			ЗаполнитьЗначенияСвойств(ТекущаяСтрокаТаблицы, ДокументSMARTS);
			
			// Отбор по периоду
			Если ОтборПоПериоду <> Неопределено Тогда
				Если ТипЗнч(ТекущаяСтрокаТаблицы.ДатаСоздания) = Тип("Дата") Тогда
					
					ДатаСоздания = ТекущаяСтрокаТаблицы.ДатаСоздания;
					
					Если ДатаСоздания < ОтборПоПериоду.ДатаНачала Тогда
						Продолжить;
					КонецЕсли;
										
					Если ЗначениеЗаполнено(ОтборПоПериоду.ДатаОкончания) Тогда
						Если ДатаСоздания > ОтборПоПериоду.ДатаОкончания Тогда
							Продолжить;
						КонецЕсли;
					КонецЕсли;
					
				КонецЕсли;
			КонецЕсли;
			
			ТекущаяСтрокаТаблицы.ИдУзла = ДокументSMARTS.ПолучитьПоле("ИдУзла");
			
			// Отбор по узлу
			Если ОтборПоУзлу <> Неопределено Тогда
				Если ЗначениеЗаполнено(ТекущаяСтрокаТаблицы.ИдУзла)
					И ТекущаяСтрокаТаблицы.ИдУзла <> ОтборПоУзлу.ID_Узла Тогда
					Продолжить;
				КонецЕсли;
			КонецЕсли;
			
			ТекущаяСтрокаТаблицы.СтрокиПланКоличество = ДокументSMARTS.СтрокиПлан.Количество;
			ТекущаяСтрокаТаблицы.СтрокиФактКоличество = ДокументSMARTS.СтрокиФакт.Количество;
			ТекущаяСтрокаТаблицы.ИдИсходныхДокументов = ДокументSMARTS.ПолучитьПоле("ИдИсходныхДокументов");
			// убрать, когда все поля из платформы можно будет получать по ключу - []
			ТекущаяСтрокаТаблицы.НастройкаБизнесПроцесса = ДокументSMARTS.ПолучитьПоле("НастройкаБизнесПроцесса");
			ТекущаяСтрокаТаблицы.КонтрольКоличества 	 = ДокументSMARTS.ПолучитьПоле("КонтрольКолва");
			ТекущаяСтрокаТаблицы.ИмяБП 					 = ДокументSMARTS.ПолучитьПоле("ИмяБП");
			ТекущаяСтрокаТаблицы.ИмяТипаДокумента 		 = ИмяТипаДокумента;
			
			// Дополняем существующую таблицу реквизитами шапки документа
			СтруктураРеквизитов = КомЯдро_ПолучитьДанныеДокументаНаСервереSMARTS(
				ДокументSMARTS.id, 
				СтруктураМетаданных.ДокументыMS[ИмяТипаДокумента], 
				?(ЕстьЧастнаяБаза,"Частная","Основная"), 
				Неопределено,
				Истина,
				АдресаПеременных);
			СтруктураШапки = СтруктураРеквизитов.ШапкаДокумента;
			
			Для Каждого ЭлементСтруктуры Из СтруктураШапки Цикл
				Если ТекущаяСтрокаТаблицы.Свойство(ЭлементСтруктуры.Ключ) Тогда
					Продолжить;
				КонецЕсли;                                                                   			
				ТекущаяСтрокаТаблицы.Вставить(ЭлементСтруктуры.Ключ, ЭлементСтруктуры.Значение);			
			КонецЦикла;		
			
			ТаблицаДокументов.Добавить(ТекущаяСтрокаТаблицы);
			
			Если ЗначениеЗаполнено(РазмерВыборки) Тогда
				Если ТаблицаДокументов.Количество() > РазмерВыборки Тогда
					Прервать;
				КонецЕсли;
			КонецЕсли;
			
		КонецЦикла;
	КонецЕсли;

	Возврат ТаблицаДокументов;
	
КонецФункции

Функция КомЯдро_ПолучитьДанныеДокументаНаСервереSMARTS(ID_Документа, СтруктураДокументаMS, ТипБазы, ФильтрТЧПоИдДокумента = Неопределено, ТолькоШапка = Ложь, АдресаПеременных)
		
	Если НЕ КомЯдро_ПодключитьсяКСерверуSMARTS(Ложь,ТипБазы, АдресаПеременных) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если ТипБазы = "Частная" Тогда
		СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("COMЧастнойБазыMS",АдресаПеременных);
	ИначеЕсли ТипБазы = "Временная" Тогда
		СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("COMВременнойБазыMS",АдресаПеременных);
	Иначе
		СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("COMБазыMS",АдресаПеременных);
	КонецЕсли;	
	
	ДокументSMARTS = СтруктураПодключенияMS.StorageConnector.ПолучитьДокумент(ID_Документа);
	
	ДанныеДокументаMS = Новый Структура;
	
	// Шапка
	РеквизитыШапки = Новый Структура;
	Для Каждого РеквизитДокумента Из СтруктураДокументаMS.Реквизиты Цикл
		Попытка
			РеквизитыШапки.Вставить(РеквизитДокумента.Значение, ДокументSMARTS.ПолучитьПоле(РеквизитДокумента.Значение));
		Исключение
			Сообщить("Реквизит с именем [" + РеквизитДокумента.Значение + "] отсутствует в шапке документа");
		КонецПопытки; 		
	КонецЦикла;
	
	Попытка
		СтатусДокументаMS = ДокументSMARTS.Статусы.Элемент(0);
		РеквизитыШапки.Вставить("ВремяНачалаОбработки",	СтатусДокументаMS.ВремяНачалаОбработки);
		РеквизитыШапки.Вставить("ВремяИзменения",		СтатусДокументаMS.ВремяИзменения);	
		РеквизитыШапки.Вставить("ВремяЗавершения",		СтатусДокументаMS.ВремяЗавершения);	
	Исключение	
	КонецПопытки;	
	
	ДанныеДокументаMS.Вставить("ШапкаДокумента", РеквизитыШапки);
	
	Если ТолькоШапка Тогда
		Возврат ДанныеДокументаMS;
	КонецЕсли;
	
	// Подготовка табличных частей
	ТабличнаяЧастьФакт = Новый ТаблицаЗначений;
	ТабличнаяЧастьПлан = Новый ТаблицаЗначений;
	ТабличнаяЧастьСовмещенные = Новый ТаблицаЗначений;
	Для Каждого РеквизитТЧ Из СтруктураДокументаMS.РеквизитыТЧ Цикл
		ТабличнаяЧастьФакт.Колонки.Добавить(РеквизитТЧ.Значение);
		ТабличнаяЧастьПлан.Колонки.Добавить(РеквизитТЧ.Значение);
		ТабличнаяЧастьСовмещенные.Колонки.Добавить(РеквизитТЧ.Значение);
	КонецЦикла;
	
	Для Каждого РеквизитСерии Из СтруктураДокументаMS.РеквизитыСерии Цикл
		// данное поле будет добавлено при заполнении вычислимых полей
		Если Найти(ВРег(СокрЛП("Характеристика")), ВРег(СокрЛП(РеквизитСерии.Значение))) Тогда
			Продолжить;
		КонецЕсли;	
		Если ТабличнаяЧастьФакт.Колонки.Найти(РеквизитСерии.Значение) = Неопределено Тогда
			ТабличнаяЧастьФакт.Колонки.Добавить(РеквизитСерии.Значение);
		КонецЕсли;	
		Если ТабличнаяЧастьПлан.Колонки.Найти(РеквизитСерии.Значение) = Неопределено Тогда
			ТабличнаяЧастьПлан.Колонки.Добавить(РеквизитСерии.Значение);
		КонецЕсли;	
	КонецЦикла;
	
	Для Каждого РеквизитСерийныеНомера Из СтруктураДокументаMS.РеквизитыСерийныеНомера Цикл
		// данное поле будет добавлено при заполнении вычислимых полей
		Если Найти(ВРег(СокрЛП("Характеристика")), ВРег(СокрЛП(РеквизитСерийныеНомера.Значение))) Тогда
			Продолжить;
		КонецЕсли;	
		Если ТабличнаяЧастьФакт.Колонки.Найти(РеквизитСерийныеНомера.Значение) = Неопределено Тогда
			ТабличнаяЧастьФакт.Колонки.Добавить(РеквизитСерийныеНомера.Значение);
		КонецЕсли;
		Если ТабличнаяЧастьПлан.Колонки.Найти(РеквизитСерийныеНомера.Значение) = Неопределено Тогда
			ТабличнаяЧастьПлан.Колонки.Добавить(РеквизитСерийныеНомера.Значение);
		КонецЕсли;	
	КонецЦикла;	
	
	// План
	Для Индекс = 0 По ДокументSMARTS.СтрокиПлан.Количество - 1 Цикл
		// фильтр ТЧ если она была объединена из нескольких документов
		Если ЗначениеЗаполнено(ФильтрТЧПоИдДокумента) Тогда
			ИдДокументаВладелецСтроки = ДокументSMARTS.СтрокиПлан.Элемент(Индекс).ПолучитьПоле("ИдДокумента");
			Если ИдДокументаВладелецСтроки <> ФильтрТЧПоИдДокумента Тогда
				Продолжить;
			КонецЕсли;
		КонецЕсли;
		
		НоваяСтрока = ТабличнаяЧастьПлан.Добавить();
		Для Каждого РеквизитТЧ Из ТабличнаяЧастьПлан.Колонки Цикл
			Попытка
				НоваяСтрока[РеквизитТЧ.Имя] = ДокументSMARTS.СтрокиПлан.Элемент(Индекс).ПолучитьПоле(РеквизитТЧ.Имя);
			Исключение
			    Сообщить("Реквизит с именем [" + РеквизитТЧ.Имя + "] отсутствует в табличной части [СтрокиПлан]");
			КонецПопытки; 			
		КонецЦикла;
	КонецЦикла;
	ДанныеДокументаMS.Вставить("СтрокиПлан", ТабличнаяЧастьПлан);
	
	// Факт
	Для Индекс = 0 По ДокументSMARTS.СтрокиФакт.Количество - 1 Цикл
		// фильтр ТЧ если она была объединена из нескольких документов
		Если ЗначениеЗаполнено(ФильтрТЧПоИдДокумента) Тогда
			ИдДокументаВладелецСтроки = ДокументSMARTS.СтрокиФакт.Элемент(Индекс).ПолучитьПоле("ИдДокумента");
			// Если ИдДокумента пустой, но не неопределено, то возможно это старая конфа и можно поискать в BindedLine
			Если ИдДокументаВладелецСтроки = "" Тогда
				СвязаннаяСтрокаИзФакта = ДокументSMARTS.СтрокиФакт.Элемент(Индекс).ПолучитьПоле("СвязаннаяСтрока");
				Если Найти(ВРег(СвязаннаяСтрокаИзФакта), ВРег(СокрЛП("COMОбъект")))  Тогда
					ИдДокументаВладелецСтроки = СвязаннаяСтрокаИзФакта.ПолучитьПоле("ИдДокумента")
				КонецЕсли;
			КонецЕсли;
			Если ИдДокументаВладелецСтроки <> ФильтрТЧПоИдДокумента 
				И НЕ (ID_Документа = ФильтрТЧПоИдДокумента И ИдДокументаВладелецСтроки = "") // Это условие нужно для загрузки всех строк, которых не было по плану в первый документ
				Тогда 
				Продолжить;
			КонецЕсли;
		КонецЕсли;
		
		НоваяСтрока = ТабличнаяЧастьФакт.Добавить();
		Для Каждого РеквизитТЧ Из ТабличнаяЧастьФакт.Колонки Цикл
			Попытка
				
				ЗначениеРеквизита = ДокументSMARTS.СтрокиФакт.Элемент(Индекс).ПолучитьПоле(РеквизитТЧ.Имя);
				
				Если Найти(ВРег(СокрЛП("BindedLine/СвязаннаяСтрока")), ВРег(СокрЛП(РеквизитТЧ.Имя))) Тогда
					
					СвязаннаяСтрока = Новый Структура;
					
					Если ЗначениеРеквизита <> Неопределено Тогда
						
						Для Каждого РеквизитСвязаннойСтроки Из ТабличнаяЧастьФакт.Колонки Цикл
							
							ЗначениеРеквизитаСвязаннойСтроки = ЗначениеРеквизита.ПолучитьПоле(РеквизитСвязаннойСтроки.Имя);					
							
							Если НЕ Найти(ВРег(СокрЛП(ЗначениеРеквизитаСвязаннойСтроки)), ВРег(СокрЛП("COMОбъект"))) Тогда
								
								СвязаннаяСтрока.Вставить(РеквизитСвязаннойСтроки.Имя, ЗначениеРеквизитаСвязаннойСтроки);
								
							КонецЕсли;																			
							
						КонецЦикла;
						
					КонецЕсли;
					
					НоваяСтрока[РеквизитТЧ.Имя] = СвязаннаяСтрока;
					
				Иначе	
					
					НоваяСтрока[РеквизитТЧ.Имя] = ЗначениеРеквизита;
					
				КонецЕсли;	
											
			Исключение
			
			КонецПопытки; 			
		КонецЦикла;
	КонецЦикла;
	ДанныеДокументаMS.Вставить("СтрокиФакт", ТабличнаяЧастьФакт);
	
	// СовмещенныеСтроки
	Для Индекс = 0 По ДокументSMARTS.CombinedItems.Количество - 1 Цикл
		НоваяСтрока = ТабличнаяЧастьСовмещенные.Добавить();
		Для Каждого РеквизитТЧ Из ТабличнаяЧастьСовмещенные.Колонки Цикл
			Попытка
				
				ЗначениеРеквизита = ДокументSMARTS.CombinedItems.Элемент(Индекс).ПолучитьПоле(РеквизитТЧ.Имя);
				
				Если Найти(ВРег(СокрЛП("BindedLine/СвязаннаяСтрока")), ВРег(СокрЛП(РеквизитТЧ.Имя))) Тогда
					
					СвязаннаяСтрока = Новый Структура;
					
					Если ЗначениеРеквизита <> Неопределено Тогда
						
						Для Каждого РеквизитСвязаннойСтроки Из ТабличнаяЧастьСовмещенные.Колонки Цикл
							
							ЗначениеРеквизитаСвязаннойСтроки = ЗначениеРеквизита.ПолучитьПоле(РеквизитСвязаннойСтроки.Имя);					
							
							Если НЕ Найти(ВРег(СокрЛП(ЗначениеРеквизитаСвязаннойСтроки)), ВРег(СокрЛП("COMОбъект"))) Тогда
								
								СвязаннаяСтрока.Вставить(РеквизитСвязаннойСтроки.Имя, ЗначениеРеквизитаСвязаннойСтроки);
								
							КонецЕсли;																			
							
						КонецЦикла;
						
					КонецЕсли;
					
					НоваяСтрока[РеквизитТЧ.Имя] = СвязаннаяСтрока;
					
				Иначе	
					
					НоваяСтрока[РеквизитТЧ.Имя] = ЗначениеРеквизита;
					
				КонецЕсли;	
											
			Исключение
			
			КонецПопытки; 			
		КонецЦикла;
	КонецЦикла;
	ДанныеДокументаMS.Вставить("СовмещенныеСтроки", ТабличнаяЧастьСовмещенные);	
	
	СписокИменаДополнительныхТабличныхЧастей = Новый СписокЗначений;

	// Получение данных из доп.таблиц документа типа "ОплатыВозвраты", "Деньги" и т.д.
	Для каждого ДопТаблица Из СтруктураДокументаMS.ДополнительныеТаблицы Цикл		
		
		ИмяДопТаблицы			= ДопТаблица.Представление;
		СписокКолонокДопТаблицы = ДопТаблица.Значение;		
		ДопТабличнаяЧасть		= Новый ТаблицаЗначений;		
		
		СписокИменаДополнительныхТабличныхЧастей.Добавить(ИмяДопТаблицы);
		
		Для каждого Колонка Из СписокКолонокДопТаблицы Цикл
			ДопТабличнаяЧасть.Колонки.Добавить(Колонка.Значение);					
		КонецЦикла; 
		
		СтрокиДокументаMS = ДокументSMARTS.ПолучитьПоле(ИмяДопТаблицы).Rows;				
		
		Для Индекс = 0 по СтрокиДокументаMS.Количество - 1 Цикл
			
			ТекущаяСтрокаMS	= СтрокиДокументаMS.Элемент(Индекс);			
			НоваяСтрока 	= ДопТабличнаяЧасть.Добавить();						
			
			Для Каждого Колонка из СписокКолонокДопТаблицы Цикл
				
				Попытка					
					ЗначениеРеквизита = ТекущаяСтрокаMS.ПолучитьПоле(Колонка.Значение);
				Исключение
					Попытка
						ЗначениеРеквизита = ТекущаяСтрокаMS[Колонка.Значение];											
					Исключение
						ЗначениеРеквизита = Неопределено;						
					КонецПопытки; 					
				КонецПопытки;		
								
				НоваяСтрока[Колонка.Значение] = ЗначениеРеквизита;				
				
			КонецЦикла;
							
			ПоляТекущейСтрокиMS = ТекущаяСтрокаMS.Поля;
			
			Для ИндексПоля = 0 По ПоляТекущейСтрокиMS.Количество - 1 Цикл
				
				ИмяПоля = ПоляТекущейСтрокиMS.Элемент(ИндексПоля).ИмяПоля;
				
				Если ДопТабличнаяЧасть.Колонки.Найти(ИмяПоля) = Неопределено Тогда							
					ДопТабличнаяЧасть.Колонки.Добавить(ИмяПоля);
				КонецЕсли;	
					
				Попытка					
					ЗначениеРеквизита = ТекущаяСтрокаMS.ПолучитьПоле(ИмяПоля);
				Исключение
					Попытка
						ЗначениеРеквизита = ТекущаяСтрокаMS[ИмяПоля];											
					Исключение
						ЗначениеРеквизита = Неопределено;						
					КонецПопытки; 					
				КонецПопытки;		
								
				НоваяСтрока[ИмяПоля] = ЗначениеРеквизита;										
				
			КонецЦикла;									
			
		КонецЦикла;	
		
		ДанныеДокументаMS.Вставить(ИмяДопТаблицы, ДопТабличнаяЧасть);	
		
	КонецЦикла;	
	
    // Получение данных доп.таблиц, которые не определены в метаданных документа, но существуют у самого экземпляра документа
    Для ИндексТаблицы = 0 По ДокументSMARTS.Таблицы.Количество - 1 Цикл
        
        ДопТаблицаMS = ДокументSMARTS.Таблицы.Элемент(ИндексТаблицы);
		
		Если ДопТаблицаMS.Строки.Количество = 0 Тогда
			Продолжить;
		КонецЕсли;
		
		Если СписокИменаДополнительныхТабличныхЧастей.НайтиПоЗначению(ДопТаблицаMS["name"]) <> Неопределено Тогда
			Продолжить;
		КонецЕсли;

		ДопТабличнаяЧасть 	= Новый ТаблицаЗначений;		
		ТекущаяСтрокаMS 	= ДопТаблицаMS.Строки.Элемент(0);				
		
		Для ИндексПоля = 0 По ТекущаяСтрокаMS.Поля.Количество - 1 Цикл		
			ДопТабличнаяЧасть.Колонки.Добавить(ТекущаяСтрокаMS.Поля.Элемент(ИндексПоля).ИмяПоля);					
		КонецЦикла; 				        
        
        Для ИндексСтроки = 0 По ДопТаблицаMS.Строки.Количество - 1 Цикл
            
            ТекущаяСтрокаMS = ДопТаблицаMS.Строки.Элемент(ИндексСтроки);            
            НоваяСтрока 	= ДопТабличнаяЧасть.Добавить();
            
            Для ИндексПоля = 0 По ТекущаяСтрокаMS.Поля.Количество - 1 Цикл
                
                ИмяПоля = ТекущаяСтрокаMS.Поля.Элемент(ИндексПоля).ИмяПоля;
                
                Попытка
                    ЗначениеРеквизита = ТекущаяСтрокаMS.ПолучитьПоле(ИмяПоля);
                Исключение
                    Попытка
                        ЗначениеРеквизита = ТекущаяСтрокаMS[ИмяПоля];
                    Исключение
                        ЗначениеРеквизита = Неопределено;
                    КонецПопытки;                 
                КонецПопытки;         	
            // В первой строке таблицы могли быть заполнены не все поля, поэтому колонки может еще не существовать
	      	Если ДопТабличнаяЧасть.Колонки.Найти(ИмяПоля) = Неопределено Тогда
				ДопТабличнаяЧасть.Колонки.Добавить(ИмяПоля);	      
	        КонецЕсли;
               	НоваяСтрока[ИмяПоля] = ЗначениеРеквизита;
            КонецЦикла;                                         
            
        КонецЦикла; 
        
        ДанныеДокументаMS.Вставить(ДопТаблицаMS.Имя, ДопТабличнаяЧасть);   
        
    КонецЦикла;		
	
	Возврат ДанныеДокументаMS;
	
КонецФункции

Функция КомЯдро_УдалитьДокументНаСервереSMARTS(ID_Документа, ТипБазы, АдресаПеременных)
		
	Если НЕ КомЯдро_ПодключитьсяКСерверуSMARTS(Ложь,ТипБазы, АдресаПеременных) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если ТипБазы = "Частная" Тогда
		СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("COMЧастнойБазыMS",АдресаПеременных);
	ИначеЕсли ТипБазы = "Временная" Тогда
		СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("COMВременнойБазыMS",АдресаПеременных);
	Иначе
		СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("COMБазыMS",АдресаПеременных);
	КонецЕсли;
	
	СтруктураПодключенияMS.StorageConnector.УдалитьДокумент(ID_Документа);
	
	Возврат Истина;
	
КонецФункции

Функция КомЯдро_УстановитьСтатусДокументаНаСервереSMARTS(ID_Документа, ТипБазы, Статус, АдресаПеременных)
	
	Если НЕ КомЯдро_ПодключитьсяКСерверуSMARTS(Ложь,ТипБазы, АдресаПеременных) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если ТипБазы = "Частная" Тогда
		СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("COMЧастнойБазыMS",АдресаПеременных);
	ИначеЕсли ТипБазы = "Временная" Тогда
		СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("COMВременнойБазыMS",АдресаПеременных);
	Иначе
		СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("COMБазыMS",АдресаПеременных);
	КонецЕсли;
	
	ДокументSMARTS = СтруктураПодключенияMS.StorageConnector.ПолучитьДокумент(ID_Документа);			
	
	ДокументSMARTS.УстановитьПоле("Статус", Статус);
	ДокументSMARTS.Завершен = Ложь;
	ДокументSMARTS.ВОбработке = Ложь;
	
	Возврат Истина;
	
КонецФункции

#КонецОбласти

#Область КомпонентаMobileSMARTS_ТаблицыSMARTS

Функция КомЯдро_ВыгрузитьТаблицуНаСерверSMARTS(ИмяТаблицы, ДанныеДляВыгрузки, ТипБазы, ОчищатьСправочникПередВыгрузкой = Ложь, АдресаПеременных)
	
	РезультатВыгрузки = Новый Структура;
	РезультатВыгрузки.Вставить("Статус"		, Истина);																			 
	РезультатВыгрузки.Вставить("Сообщение"	, "Таблица [" + ИмяТаблицы + "] успешно выгружена. Выгружено:" 
												+ Символы.ВК + Символы.Таб + "- " + Формат(ДанныеДляВыгрузки.МассивыСтрок.Количество(), "ЧН=0; ЧГ=3,0") + " строк");
												
	Если ИмяТаблицы = "Номенклатура" Тогда											
		
		КоличествоРазличныхТоваров = ?(ДанныеДляВыгрузки.Свойство("КоличествоТоваров"),ДанныеДляВыгрузки.КоличествоТоваров,0);
		РезультатВыгрузки.Сообщение = РезультатВыгрузки.Сообщение 
										+ Символы.ВК + Символы.Таб + "- " + Формат(КоличествоРазличныхТоваров, "ЧН=0; ЧГ=3,0") + " товаров";
	КонецЕсли;	
	
	Если НЕ КомЯдро_ПодключитьсяКСерверуSMARTS(Ложь,ТипБазы, АдресаПеременных) Тогда
		Возврат Новый Структура("Сообщение,Статус", "База Mobile SMARTS недоступна!", Ложь);
	КонецЕсли;		
	
	Если ТипБазы = "Частная" Тогда
		СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("COMЧастнойБазыMS",АдресаПеременных);
	ИначеЕсли ТипБазы = "Временная" Тогда
		СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("COMВременнойБазыMS",АдресаПеременных);
	Иначе
		СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("COMБазыMS",АдресаПеременных);
	КонецЕсли;
	
	Если ИмяТаблицы = "Номенклатура" Тогда
		СтруктураПодключенияMS.TerminalConnector.ПерезаписыватьНоменклатуру(ОчищатьСправочникПередВыгрузкой);
		РезультатПопытки = СтруктураПодключенияMS.TerminalConnector.НачатьВыгрузкуТоваров(ДанныеДляВыгрузки.МассивИмен);
	ИначеЕсли ИмяТаблицы = "Ячейки" Тогда	
		РезультатПопытки = СтруктураПодключенияMS.TerminalConnector.НачатьВыгрузкуЯчеек("1", ДанныеДляВыгрузки.МассивИмен, ОчищатьСправочникПередВыгрузкой);
	Иначе
		РезультатПопытки = СтруктураПодключенияMS.TerminalConnector.НачатьВыгрузкуТаблицы(ИмяТаблицы, ДанныеДляВыгрузки.МассивИмен, ОчищатьСправочникПередВыгрузкой);
	КонецЕсли;
	
	Если НЕ РезультатПопытки Тогда
		ОписаниеОшибки = КомЯдро_ПолучитьОшибку(ТипБазы,АдресаПеременных);
		РезультатВыгрузки = Новый Структура("Сообщение,Статус", "Таблица [" + ИмяТаблицы + "] не выгружается!" + Символы.ВК + ОписаниеОшибки, Ложь);
	КонецЕсли;
	
	Если РезультатВыгрузки.Статус = Истина Тогда
		Для Каждого МассивСтрокиВыгрузки из ДанныеДляВыгрузки.МассивыСтрок Цикл
			Если ИмяТаблицы = "Номенклатура" Тогда
				РезультатПопытки = СтруктураПодключенияMS.TerminalConnector.ДобавитьВВыгрузкуТоваров(МассивСтрокиВыгрузки);
			ИначеЕсли ИмяТаблицы = "Ячейки" Тогда	
				РезультатПопытки = СтруктураПодключенияMS.TerminalConnector.ДобавитьВВыгрузкуЯчеек(МассивСтрокиВыгрузки);
			Иначе
				РезультатПопытки = СтруктураПодключенияMS.TerminalConnector.ДобавитьВВыгрузкуТаблицы(МассивСтрокиВыгрузки);
			КонецЕсли;
			Если НЕ РезультатПопытки Тогда
				ОписаниеОшибки = КомЯдро_ПолучитьОшибку(ТипБазы,АдресаПеременных);
				РезультатВыгрузки =  Новый Структура("Сообщение,Статус", "Ошибка выгрузки таблицы [" + ИмяТаблицы + "]." + Символы.ВК + ОписаниеОшибки, Ложь);				
				Если ИмяТаблицы = "Ячейки" Тогда
					СтруктураПодключенияMS.TerminalConnector.ПрерватьВыгрузкуЯчеек();	
				ИначеЕсли ИмяТаблицы <> "Номенклатура" Тогда	
					СтруктураПодключенияMS.TerminalConnector.ПрерватьВыгрузкуТаблицы();			
				КонецЕсли;	
				Прервать;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Если РезультатВыгрузки.Статус = Истина Тогда
		Если ИмяТаблицы = "Номенклатура" Тогда
			РезультатПопытки = СтруктураПодключенияMS.TerminalConnector.ЗавершитьВыгрузкуТоваров();	
		ИначеЕсли ИмяТаблицы = "Ячейки" Тогда	
			РезультатПопытки = СтруктураПодключенияMS.TerminalConnector.ЗавершитьВыгрузкуЯчеек();			
		Иначе
			РезультатПопытки = СтруктураПодключенияMS.TerminalConnector.ЗавершитьВыгрузкуТаблицы();	
		КонецЕсли;
		
		Если НЕ РезультатПопытки Тогда
			ОписаниеОшибки = КомЯдро_ПолучитьОшибку(ТипБазы,АдресаПеременных);
			РезультатВыгрузки =  Новый Структура("Сообщение,Статус", "Не удалось закончить выгрузку таблицы [" + ИмяТаблицы + "]." + Символы.ВК + ОписаниеОшибки, Ложь);
		КонецЕсли;
	КонецЕсли;

	СтруктураПодключенияMS.TerminalConnector.ОсвободитьРесурсы();
	
	Возврат РезультатВыгрузки;
	
КонецФункции

// Очищает таблицу на сервере Mobile Smarts
//
// Параметры:
//	ИмяТаблицы - Строка - имя очищаемой таблицы Mobile Smarts	
//	ТипБазы - Строка - "Частная", "Временная", "Основная"
//  АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
//
// Возвращаемое значение:
//	Структура - содержит:
//		* Сообщение - Строка - информационное сообщение о результате очистки таблицы
//		* Статус - Булево - флаг успешности очистки таблицы
Функция КомЯдро_ОчиститьТаблицуНаСервереSMARTS(ИмяТаблицы, ТипБазы, АдресаПеременных) Экспорт

	РезультатВыгрузки = Новый Структура("Сообщение,Статус", "Таблица [" + ИмяТаблицы + "] успешно очищена", Истина);
	
	Если НЕ КомЯдро_ПодключитьсяКСерверуSMARTS(Ложь,ТипБазы, АдресаПеременных) Тогда
		РезультатВыгрузки = Новый Структура("Сообщение,Статус", "Ошибка очистки таблицы [" + ИмяТаблицы + "]", Ложь);
		Возврат РезультатВыгрузки;
	КонецЕсли;
	
	Если ТипБазы = "Частная" Тогда
		СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("COMЧастнойБазыMS",АдресаПеременных);
	ИначеЕсли ТипБазы = "Временная" Тогда
		СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("COMВременнойБазыMS",АдресаПеременных);
	Иначе
		СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("COMБазыMS",АдресаПеременных);
	КонецЕсли;
		
	Если ИмяТаблицы = "Номенклатура" Тогда
		СтруктураПодключенияMS.StorageConnector.ОчиститьСправочникТоваров();
	ИначеЕсли ИмяТаблицы = "Ячейки" Тогда
		Попытка
    		СтруктураПодключенияMS.StorageConnector.GetTableAccessor(ИмяТаблицы).Clear();
		Исключение
			// При прямом подключении очищаем этой командой
			СтруктураПодключенияMS.StorageConnector.GetCellsAccesor(1).Clear();
		КонецПопытки;
	Иначе
		СтруктураПодключенияMS.StorageConnector.GetTableAccessor(ИмяТаблицы).Clear();
	КонецЕсли;
	
	Возврат РезультатВыгрузки;
	
КонецФункции

#КонецОбласти

#Область ВнешниеВызовы

// Вызывает процедуру полной инициализации из Mobile Smarts
//
// Параметры:
//	mXmlDoc - Строка - строка в формате JSON, содержащая информацию о текущей сессии Mobile Smarts (если в настройках Mobile Smarts установлен режим JSON)
//
// Возвращаемое значение:
//	Булево - признак успешности выполнения операции	
Функция ИнициализацияПодключенияСМАРТС(mXmlDoc = "") Экспорт
	
	НачалоСобытия = ТекущаяУниверсальнаяДатаВМиллисекундах();
	ИмяСобытия = "ИнициализацияПодключенияСМАРТС";
		
	АдресаПеременных = КомЯдро_СоздатьСтруктуруАдресаПеременных();
	
	Попытка
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Начало, Вызов полной инициализации из СМАРТС",НачалоСобытия,АдресаПеременных);
		
		НастройкиИнициализированы = КомЯдро_ПолучитьЗначениеПеременной("НастройкиИнициализированы", АдресаПеременных);
		НастройкиИзменились = ГлЯдро_НастройкиИзменились(АдресаПеременных);
		Если НастройкиИзменились
			ИЛИ НЕ НастройкиИнициализированы = Истина Тогда
			ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Предупреждение", "Переинициализация настроек. НастройкиИнициализированы = " + Строка(НастройкиИнициализированы) + ", НастройкиИзменились = " + Строка(НастройкиИзменились),, АдресаПеременных);
			ГлЯдро_Инициализация(ИмяСобытия, НастройкиИзменились, mXmlDoc, АдресаПеременных);
		ИначеЕсли НЕ ГлЯдро_ПроверитьАктуальностьКэшируемыхНастроекПриИнициализации(, АдресаПеременных) Тогда
			ГлЯдро_Инициализация(ИмяСобытия, Истина, mXmlDoc, АдресаПеременных);
		КонецЕсли;
		
		ТипИнтерфейса = ГлЯдро_ПолучитьДанныеИзХранилища1С("Cleverence_ТипИнтерфейса");
		
		Если ТипЗнч(mXmlDoc)=Тип("Строка") И Лев(mXmlDoc,5)="<?xml" ИЛИ ТипИнтерфейса <> "REST_API" Тогда
			Результат = "xml";
		ИначеЕсли mXmlDoc = "AutoSerialization" Тогда
			Результат = "json";
		Иначе
			Результат = Истина;
		КонецЕсли;
	Исключение
		ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Ошибка: " + ТекстОшибки + ", Вызов полной инициализации из СМАРТС", НачалоСобытия, АдресаПеременных);		
		Результат = Ложь;
	КонецПопытки;
	
	ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Конец, Вызов полной инициализации из СМАРТС",НачалоСобытия,АдресаПеременных);
	
	Возврат Результат;
	
КонецФункции

// Обрабатывает запрос сервера Mobile Smarts на выгрузку таблицы (кроме Номенклатуры)
//
// Параметры:
//	ЗапросXML - Строка - строка в формате XML или JSON, содержащая запрос для обработки
//	userId - Строка - идентификатор пользователя Mobile Smarts
//	mXmlDoc	- Строка - строка в формате XML или JSON, содержащая информацию о текущей сессии Mobile Smarts
//
// Возвращаемое значение:
//	    - COMSafeArray - данные выгружаемой таблицы, если тип интерфейса - COM
//      - Строка - данные выгружаемой таблицы в формате JSON, если тип интерфейса - REST_API
//		- Строка - текст ошибки выгрузки таблицы
//		- Неопределено - если не удалось установить соединение с базой Mobile Smarts
Функция ОбработатьЗапрос(ЗапросXML, userId, mXmlDoc = Неопределено, ПараметрыВыгрузки = Неопределено) Экспорт
	
	НачалоСобытия = ТекущаяУниверсальнаяДатаВМиллисекундах();
	ИмяСобытия = "ОбработатьЗапрос";
	
	Попытка
		ТипИнтерфейса = ГлЯдро_ПолучитьДанныеИзХранилища1С("Cleverence_ТипИнтерфейса");
		
		АдресаПеременных = КомЯдро_СоздатьСтруктуруАдресаПеременных();
		
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Начало, Ид пользователя: "+ Строка(UserId),,АдресаПеременных);	
		
		ГлЯдро_СохранитьДанныеВХранилище1С("Cleverence_ОписаниеОшибкиONLEX", Неопределено);
		
		НастройкиИнициализированы = КомЯдро_ПолучитьЗначениеПеременной("НастройкиИнициализированы",АдресаПеременных);
		НастройкиИзменились = ГлЯдро_НастройкиИзменились(АдресаПеременных);
		Если НастройкиИзменились
			ИЛИ НЕ НастройкиИнициализированы = Истина Тогда
			
			ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Предупреждение", "Переинициализация настроек. НастройкиИнициализированы = "+Строка(НастройкиИнициализированы)+", НастройкиИзменились = "+Строка(НастройкиИзменились),,АдресаПеременных);			
			ГлЯдро_Инициализация(ИмяСобытия,НастройкиИзменились,mXmlDoc,АдресаПеременных);
			
			//ОписаниеОшибки = ГлЯдро_ПроверитьНаличиеИсключительнойСитуацииONLEX();
			//Если ЗначениеЗаполнено(ОписаниеОшибки) Тогда
			//	Возврат "#" + ОписаниеОшибки;	
			//КонецЕсли;	
		КонецЕсли;
		
		ГлЯдро_УстановитьДанныеТекущегоУзла(mXmlDoc,,,ТипИнтерфейса,АдресаПеременных);
		
		ИспJSON_mXmlDoc = КомЯдро_ПолучитьЗначениеПеременной("ИспJSON_mXmlDoc",АдресаПеременных);
		Если ИспJSON_mXmlDoc = Истина
			ИЛИ (ИспJSON_mXmlDoc = Неопределено И ТипИнтерфейса = "REST_API") Тогда
			ТипИнтерфейса = "REST_API";
		Иначе
			ТипИнтерфейса = "COM";
		КонецЕсли;	
		
		ЕстьЧастнаяБаза = КомЯдро_ПолучитьЗначениеПеременной("ЕстьЧастнаяБаза",АдресаПеременных);
		ТипБазы = ?(ЕстьЧастнаяБаза=Истина,"Частная","Основная");
		
		Если НЕ ГлЯдро_ПроверитьСоединениеССерверомSMARTS(,,,,,,АдресаПеременных) = Истина Тогда
			ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Подключиться к серверу Mobile SMARTS не удалось, Ид пользователя: "+ Строка(UserId),,АдресаПеременных);
			
			//ОписаниеОшибки = ГлЯдро_ПроверитьНаличиеИсключительнойСитуацииONLEX();
			//Если ЗначениеЗаполнено(ОписаниеОшибки) Тогда
			//	Возврат "#" + ОписаниеОшибки;	
			//КонецЕсли;
			
			Возврат Неопределено;
		КонецЕсли;
		
		Если ЕстьЧастнаяБаза = Истина Тогда
			СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("COMЧастнойБазыMS",АдресаПеременных);
		Иначе
			СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("COMБазыMS",АдресаПеременных);
		КонецЕсли;
		
		ДанныеДляВыгрузки = Неопределено;
		
		Если ТипИнтерфейса = "REST_API" Тогда
			ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Перед ЗагрузитьИзJSON" + ", Ид пользователя: " + Строка(UserId),НачалоСобытия,АдресаПеременных);
			ОбъектЗапроса = ГлЯдро_ПолучитьСтруктуруИзСоответствия(ГлЯдро_ЗагрузитьИзJSON(ЗапросXML));
			ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "После ЗагрузитьИзJSON" + ", Ид пользователя: " + Строка(UserId),НачалоСобытия,АдресаПеременных);
		Иначе	
			ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Перед StorageConnector, ЗагрузитьОбъектИз_XML" + ", Ид пользователя: " + Строка(UserId),НачалоСобытия,АдресаПеременных);
			ОбъектЗапроса = СтруктураПодключенияMS.StorageConnector.ЗагрузитьОбъектИз_XML(ЗапросXML);
			ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "После StorageConnector, ЗагрузитьОбъектИз_XML" + ", Ид пользователя: " + Строка(UserId),НачалоСобытия,АдресаПеременных);
		КонецЕсли;
		ИмяТаблицы = ОбъектЗапроса.From;
		
		Если ИмяТаблицы = "Узлы" Тогда				
			ДанныеДляВыгрузки = Новый ТаблицаЗначений;
			ДанныеДляВыгрузки.Колонки.Добавить("Ид");
			ДанныеДляВыгрузки.Колонки.Добавить("Наименование");
			ДанныеДляВыгрузки.Колонки.Добавить("Код");
			ДанныеДляВыгрузки.Колонки.Добавить("ШК");
			ДанныеДляВыгрузки.Колонки.Добавить("ЭтоПапка");
			ДанныеДляВыгрузки.Колонки.Добавить("ИдРодителя");
			ДанныеДляВыгрузки.Колонки.Добавить("НаименованиеДляПоиска");		 
			ДанныеДляВыгрузки.Колонки.Добавить("Владелец");		 
			ТаблицаМагазинов = ГлЯдро_ПолучитьИзКэшаНастройкуSMARTS("Узлы",,АдресаПеременных);
			ТаблицаПользователейТСД = ГлЯдро_ПолучитьНастройкуНаСервереSMARTS("ПользователиТСД",,АдресаПеременных);
			Если ТипЗнч(ТаблицаМагазинов) = Тип("ТаблицаЗначений") ИЛИ ТипЗнч(ТаблицаМагазинов) = Тип("Массив") Тогда
				Для Каждого СтрокаТЗ из ТаблицаМагазинов Цикл
					Если ТипЗнч(СтрокаТЗ) = Тип("Структура") И СтрокаТЗ.Свойство("ЭтоТаблицаЗначений") И СтрокаТЗ.ЭтоТаблицаЗначений Тогда
						Продолжить;
					КонецЕсли;
					Если ТипЗнч(СтрокаТЗ) = Тип("Структура") И СтрокаТЗ.Свойство("Используется") И СтрокаТЗ.Используется = Ложь Тогда
						Продолжить;
					КонецЕсли;
					НовСтрока = ДанныеДляВыгрузки.Добавить();
					НовСтрока.Ид = СтрокаТЗ.ID_Узла;
					НовСтрока.Наименование = СтрокаТЗ.Наименование;
					НовСтрока.Код = СтрокаТЗ.ID_Узла;
					НовСтрока.ШК = "";
					НовСтрока.ЭтоПапка = Ложь;
					НовСтрока.ИдРодителя = "";
					НовСтрока.НаименованиеДляПоиска = НРег(СтрокаТЗ.Наименование);
					
					СтрокаПользователейИГрупп = "";
					Если ТипЗнч(ТаблицаПользователейТСД) = Тип("Массив") Тогда
						Для каждого Пользователь Из ТаблицаПользователейТСД Цикл							
							Если ТипЗнч(СтрокаТЗ) = Тип("Структура") И СтрокаТЗ.Свойство("ЭтоТаблицаЗначений") И СтрокаТЗ.ЭтоТаблицаЗначений Тогда
								Продолжить;
							КонецЕсли;							
							СимволВНачалеСтроки = ?(СтрокаПользователейИГрупп = "", "", ",");
							СтрокаПользователейИГрупп = СтрокаПользователейИГрупп + СимволВНачалеСтроки + """" + СокрЛП(Пользователь.ID_Пользователя) + """";			
						КонецЦикла; 										
					КонецЕсли;
					
					НовСтрока.Владелец = СтрокаПользователейИГрупп;
					
				КонецЦикла;
			КонецЕсли;
		ИначеЕсли ИмяТаблицы = "БизнесПроцессы" Тогда
			
			ГлЯдро_СобратьОбщуюСтруктуруБизнесПроцессов(АдресаПеременных);
			
			ДанныеДляВыгрузки = Новый ТаблицаЗначений;
			ДанныеДляВыгрузки.Колонки.Добавить("Ид");
			ДанныеДляВыгрузки.Колонки.Добавить("Наименование");
			ДанныеДляВыгрузки.Колонки.Добавить("ТипДокументаMobileSMARTS");
			ДанныеДляВыгрузки.Колонки.Добавить("ТипИсходногоДокумента");
			ДанныеДляВыгрузки.Колонки.Добавить("ТипРезультирующегоДокумента");
			ТаблицаБизнесПроцессов = ГлЯдро_ПолучитьИзКэшаНастройкуSMARTS("НастройкиБизнесПроцессов",,АдресаПеременных);
			Если ТипЗнч(ТаблицаБизнесПроцессов) = Тип("ТаблицаЗначений") ИЛИ ТипЗнч(ТаблицаБизнесПроцессов) = Тип("Массив") Тогда
				Для Каждого СтрокаТЗ из ТаблицаБизнесПроцессов Цикл
					Если ТипЗнч(СтрокаТЗ) = Тип("Структура") И СтрокаТЗ.Свойство("ЭтоТаблицаЗначений") И СтрокаТЗ.ЭтоТаблицаЗначений Тогда
						Продолжить;
					КонецЕсли;	
					Если Не СтрокаТЗ.Используется Тогда Продолжить; КонецЕсли;
					
					НовСтрока = ДанныеДляВыгрузки.Добавить();
					НовСтрока.Ид = СтрокаТЗ.ID_БизнесПроцесса;
					НовСтрока.Наименование = СтрокаТЗ.Название;
					НовСтрока.ТипДокументаMobileSMARTS = СтрокаТЗ.ТипДокументаMS;
					НовСтрока.ТипИсходногоДокумента = СтрокаТЗ.ТипИсходногоДокумента1С;
					НовСтрока.ТипРезультирующегоДокумента = СтрокаТЗ.ТипРезультирующегоДокумента1С;
				КонецЦикла;
			КонецЕсли;
		КонецЕсли;
		
		Если ДанныеДляВыгрузки = Неопределено Тогда
			СоответствиеСправочниковКлючамИспользования = ГлЯдро_СоответствиеСправочниковКлючамИспользованияПоУмолчанию(АдресаПеременных);
			КлючНастройкиПоУмолчанию 	= СоответствиеСправочниковКлючамИспользования.Получить(ИмяТаблицы);
			Если КлючНастройкиПоУмолчанию <> Неопределено Тогда
				ФлагИспользованиеСправочника 	= ГлЯдро_ПолучитьИзКэшаНастройкуSMARTS(КлючНастройкиПоУмолчанию,,АдресаПеременных);
		    Иначе
				Отбор = Новый Структура("Выгружать,ИмяТаблицы",Истина, ИмяТаблицы);
				ФлагИспользованиеСправочника = ГлЯдро_ПолучитьИзКэшаЗначениеТабличнойНастройкиSMARTS("НастройкиОбменаСправочников", Отбор, "Выгружать",АдресаПеременных);
			КонецЕсли;
			
			Если ФлагИспользованиеСправочника = Истина Тогда
				НастройкиКомпоновщика = "";
				Отбор = Новый Структура("ИмяТаблицы", ИмяТаблицы);
				НастройкаКомпоновщикаСтрокой = ГлЯдро_ПолучитьИзКэшаЗначениеТабличнойНастройкиSMARTS("НастройкиОбменаСправочников", Отбор, "НастройкаКомпоновщикаСтрокой",АдресаПеременных);
				Если ЗначениеЗаполнено(НастройкаКомпоновщикаСтрокой) Тогда
					НастройкиКомпоновщика = ГлЯдро_ЗначениеИзСтрокиXML(НастройкаКомпоновщикаСтрокой);
				КонецЕслИ;
				ПараметрыКомпоновщика = ГлЯдро_ПолучитьЗначенияГлобальныхПараметров(,,,АдресаПеременных);
				ПараметрыВыгрузки = ГлЯдро_ПолучитьЗаполнитьСтруктуруПараметровВыгрузкиСправочника(ИмяТаблицы, АдресаПеременных);
				ДанныеДляВыгрузки = ГлЯдро_ПолучитьДанныеТаблицыДляВыгрузкиНаСерверSMARTS(ИмяТаблицы, НастройкиКомпоновщика, ПараметрыКомпоновщика, ОбъектЗапроса.WhereRootElement,,ПараметрыВыгрузки,АдресаПеременных);
			Иначе
				ДанныеДляВыгрузки = Новый ТаблицаЗначений;
			КонецЕсли;
		КонецЕсли;
		
		Если ИспJSON_mXmlDoc = Истина Тогда
			Результат = REST_API_ТаблицаЗначенийВМассивСтруктур(ДанныеДляВыгрузки);
			Результат = ГлЯдро_ПолучитьJSON(Результат);
		Иначе
			Результат = ГлЯдро_ТаблицаЗначенийВCOMSafeArray(ДанныеДляВыгрузки);
		КонецЕсли;
		
	Исключение
		ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Имя таблицы:" + Строка(ИмяТаблицы) + ", Ошибка: "+ ТекстОшибки + ", Ид пользователя: " + Строка(UserId), НачалоСобытия, АдресаПеременных);
		Результат = "#Ошибка при выполнении запроса: " + Строка(ИмяТаблицы) + ТекстОшибки;		
	КонецПопытки;
	
	ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Конец, ИмяТаблицы = " + Строка(ИмяТаблицы) + ", Ид пользователя: " + Строка(UserId), НачалоСобытия, АдресаПеременных);
		
	Возврат Результат;
		
КонецФункции

// Обрабатывает запрос сервера Mobile Smarts на получение списка документов
//
// Параметры:
//	userId - Строка - идентификатор пользователя Mobile Smarts		
//  ТипДокумента - Строка - тип документа Mobile Smarts
//  mXmlDoc	- Строка - строка в формате XML или JSON, содержащая информацию о текущей сессии Mobile Smarts
//  АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
//
// Возвращаемое значение:
//	    - Строка - данные списка документов в формате XML, если тип интерфейса - COM
//      - Строка - данные списка документов в формате JSON, если тип интерфейса - REST_API
//		- Строка - текст ошибки получения списка документов
//		- Неопределено - если не удалось установить соединение с базой Mobile Smarts
Функция ПолучитьСписокДокументов(UserId = Неопределено, ТипДокумента = Неопределено, mXmlDoc = Неопределено,АдресаПеременных = Неопределено) Экспорт
	
	НачалоСобытия = ТекущаяУниверсальнаяДатаВМиллисекундах();
	ИмяСобытия = "ПолучитьСписокДокументов";
	
	Попытка
		
		ТипИнтерфейса = ГлЯдро_ПолучитьДанныеИзХранилища1С("Cleverence_ТипИнтерфейса");
		
		Если АдресаПеременных = Неопределено Тогда
			АдресаПеременных = КомЯдро_СоздатьСтруктуруАдресаПеременных();
		КонецЕсли;
		НастройкиИнициализированы = КомЯдро_ПолучитьЗначениеПеременной("НастройкиИнициализированы",АдресаПеременных);
		
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Начало, Тип документа: "+ Строка(ТипДокумента) +", Ид пользователя: "+ Строка(UserId),НачалоСобытия,АдресаПеременных);

		ГлЯдро_СохранитьДанныеВХранилище1С("Cleverence_ОписаниеОшибкиONLEX", Неопределено);
		
		НастройкиИзменились = ГлЯдро_НастройкиИзменились(АдресаПеременных);
		Если НастройкиИзменились
			ИЛИ НЕ НастройкиИнициализированы = Истина Тогда
			ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Предупреждение", "Переинициализация настроек. НастройкиИнициализированы = "+Строка(НастройкиИнициализированы)+", НастройкиИзменились = "+Строка(НастройкиИзменились),,АдресаПеременных);
			ГлЯдро_Инициализация(ИмяСобытия,НастройкиИзменились,mXmlDoc,АдресаПеременных);
			
			ТекстОшибки = ГлЯдро_ПроверитьНаличиеИсключительнойСитуацииONLEX();
			Если ЗначениеЗаполнено(ТекстОшибки) Тогда
				Возврат "#" + ТекстОшибки;	
			КонецЕсли;
		КонецЕсли;
		
		Если НЕ ГлЯдро_ПроверитьСоединениеССерверомSMARTS(,,,,,,АдресаПеременных) = Истина Тогда
			ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Подключиться к серверу Mobile SMARTS не удалось, Тип документа: "+ Строка(ТипДокумента) +", Ид пользователя: "+ Строка(UserId),,АдресаПеременных);
			
			ТекстОшибки = ГлЯдро_ПроверитьНаличиеИсключительнойСитуацииONLEX();
			Если ЗначениеЗаполнено(ТекстОшибки) Тогда
				Возврат "#" + ТекстОшибки;	
			КонецЕсли;
			
			Возврат Неопределено;
		КонецЕсли;
		
		ГлЯдро_УстановитьДанныеТекущегоУзла(mXmlDoc,,,ТипИнтерфейса,АдресаПеременных);
		
		ID_Узла = "";
		ДанныеТекущегоУзла = КомЯдро_ПолучитьЗначениеПеременной("ДанныеТекущегоУзла", АдресаПеременных);
		Если ТипЗнч(ДанныеТекущегоУзла) = Тип("Структура") И ДанныеТекущегоУзла.Свойство("ID_Узла") Тогда
			ID_Узла = ДанныеТекущегоУзла.ID_Узла;		
		КонецЕсли;
		
		СтруктураНастроек = Новый Структура;
		НастройкиБП = ГлЯдро_ПолучитьИзКэшаНастройкуSMARTS("НастройкиБизнесПроцессов",,АдресаПеременных);
		
		СтруктураНастроек.Вставить("БизнесПроцессы", НастройкиБП);
		НастройкиОтборов = ГлЯдро_ПолучитьИзКэшаНастройкуSMARTS("НастройкиОтборовУзлов_Онлайн",,АдресаПеременных);
		Если ТипЗнч(НастройкиОтборов) <> Тип("ТаблицаЗначений")
			И ТипЗнч(НастройкиОтборов) <> Тип("Массив") Тогда
			НастройкиОтборов = ГлЯдро_ПолучитьНастройкуНаСервереSMARTS("НастройкиОтборовУзлов_Онлайн", ID_Узла, АдресаПеременных);
		КонецЕсли;
		СтруктураНастроек.Вставить("НастройкиОтборов", НастройкиОтборов);
		ЗначенияПараметров = ГлЯдро_ПолучитьЗначенияГлобальныхПараметров(,,,АдресаПеременных);
		СтруктураНастроек.Вставить("ПараметрыУзлов", ЗначенияПараметров);
		
		// При запросе списка документов с ТСД ограничиваем их количество
		СтруктураНастроек.Вставить("РазмерВыборки", 50);
		ОтобранныеДокументы = ГлЯдро_ПолучитьСписокДокументов1С(СтруктураНастроек, ТипДокумента,,АдресаПеременных);

		ТекстКоличествоДокументов = "[Неопределено]";
		Если ОтобранныеДокументы <> Неопределено Тогда
			ТекстКоличествоДокументов = " (" + Строка(Макс(ОтобранныеДокументы.Количество() - 1, 0)) + " шт.)";
		КонецЕсли;
		
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Список документов в 1С получен: "+ Строка(ОтобранныеДокументы) + ТекстКоличествоДокументов + ", Тип документа: " + Строка(ТипДокумента) + ", Ид пользователя: " + Строка(UserId),НачалоСобытия,АдресаПеременных);
		
		КэшНастроекБизнесПроцессов = Новый Соответствие;
		
		Если ОтобранныеДокументы <> Неопределено Тогда
			ИспJSON_mXmlDoc = КомЯдро_ПолучитьЗначениеПеременной("ИспJSON_mXmlDoc",АдресаПеременных);
			//Если ТипИнтерфейса = "REST_API" Тогда
			Если ИспJSON_mXmlDoc = Истина
				ИЛИ (ИспJSON_mXmlDoc = Неопределено И ТипИнтерфейса = "REST_API") Тогда
				ДокМассив = Новый Массив;
				Для Каждого СтрокаДок из ОтобранныеДокументы Цикл
					Если СтрокаДок.Свойство("ЭтоТаблицаЗначений") Тогда
						Продолжить;
					КонецЕсли;
					
					ДокИнфо = Новый Структура;
					ДокИнфо.Вставить("Id", XMLСтрока(СтрокаДок.Ссылка));
					ДокИнфо.Вставить("Name", Строка(СтрокаДок.Ссылка));
					ДокИнфо.Вставить("DocumentTypeName", ТипДокумента);
					ДокИнфо.Вставить("НастройкаБизнесПроцесса", СтрокаДок.НастройкаБизнесПроцесса);
					ДокИнфо.Вставить("ТипДокумента1С", СтрокаДок.ТипДокумента1С);
					Если ЗначениеЗаполнено(СтрокаДок.НастройкаБизнесПроцесса)   Тогда
						ID_БизнесПроцесса = СтрокаДок.НастройкаБизнесПроцесса;
						
						НастройкаБП = КэшНастроекБизнесПроцессов.Получить(ID_БизнесПроцесса);
						Если НастройкаБП = Неопределено Тогда
							СтрокаБП = ГлЯдро_СкопироватьМассив(НастройкиБП, Новый Структура("ID_БизнесПроцесса", ID_БизнесПроцесса))[0];
							НастройкаБП = Новый Структура;
							НастройкаБП.Вставить("ЗаменитьПредставлениеДокументаПриВыгрузке", ?(СтрокаБП.Свойство("ЗаменитьПредставлениеДокументаПриВыгрузке") И СтрокаБП.ЗаменитьПредставлениеДокументаПриВыгрузке = Истина, Истина, Ложь));
							НастройкаБП.Вставить("НастройкаПредставленийРеквизитовДокумента", СтрокаБП.НастройкаПредставленийРеквизитовДокумента);
							НастройкаБП.Вставить("КопияДокументаДляКаждогоПользователя",	  СтрокаБП.КопияДокументаДляКаждогоПользователя);
							КэшНастроекБизнесПроцессов.Вставить(ID_БизнесПроцесса, НастройкаБП);
						КонецЕсли;
						
						Если НастройкаБП.ЗаменитьПредставлениеДокументаПриВыгрузке Тогда				
							ДокИнфо.Вставить("ПредставлениеИмениДокумента", ГлЯдро_ПолучитьПредставлениеДокументаПоНастройкам(СтрокаДок.Ссылка, НастройкаБП.НастройкаПредставленийРеквизитовДокумента));	
						КонецЕсли;
						Если НастройкаБП.КопияДокументаДляКаждогоПользователя Тогда
							ДокИнфо.Вставить("Id", XMLСтрока(СтрокаДок.Ссылка)+"#"+UserId);
						КонецЕсли;
					КонецЕсли;
					Попытка					
						ДокИнфо.Вставить("ИмяБП", ?(ЗначениеЗаполнено(СтрокаДок.БизнесПроцесс),Строка(СтрокаДок.БизнесПроцесс),Строка(СтрокаДок.ИмяБП)));									
					Исключение
					КонецПопытки;				
					Попытка					
						ДокИнфо.Вставить("ИмяКонтрагента", Строка(СтрокаДок.ИмяКонтрагента));					
					Исключение
					КонецПопытки;				
					Попытка					
						ДокИнфо.Вставить("ИмяСклада", Строка(СтрокаДок.ИмяСклада));					
					Исключение
					КонецПопытки;				
					Попытка					
						ДокИнфо.Вставить("ИмяСкладаКуда", Строка(СтрокаДок.ИмяСкладаКуда));					
					Исключение
					КонецПопытки;	
					
					ДокМассив.Добавить(ДокИнфо);
				КонецЦикла;
				
				// Добавляем служебный "хвост" к ограниченному списку документов
				Если ДокМассив.Количество() >= СтруктураНастроек.РазмерВыборки Тогда					
					ДопДокИнфо = Новый Структура("Id,Name,DocumentTypeName,НастройкаБизнесПроцесса,ТипДокумента1С");
					ЗаполнитьЗначенияСвойств(ДопДокИнфо, ДокИнфо);
					ДопДокИнфо.Id 	= "11111111-2222-3333-4444-555555555555";
					ДопДокИнфо.Name = "#1CEDWR001. Документов для отображения слишком много, настройте отборы документов в основной " + 
					"обработке Клеверенс для данного типа документа Mobile SMARTS или выполните поиск по штрихкоду или коду документа.";
					
					ДокМассив.Добавить(ДопДокИнфо);
				КонецЕсли;
			
				Результат = ГлЯдро_ПолучитьJSON(ДокМассив);
				
			Иначе
				#Область НесовместимыйКодFresh
				DocDescrs = Новый COMОбъект("Cleverence.Warehouse.DocumentDescriptionCollection");
				Для Каждого СтрокаДок из ОтобранныеДокументы Цикл
					Если СтрокаДок.Свойство("ЭтоТаблицаЗначений") Тогда
						Продолжить;
					КонецЕсли;
					DocDescr = Новый COMОбъект("Cleverence.Warehouse.DocumentDescription");
					DocDescr.Id = XMLСтрока(СтрокаДок.Ссылка);
					DocDescr.Name = Строка(СтрокаДок.Ссылка);
					DocDescr.DocumentTypeName = ТипДокумента;
					DocDescr.SetField("НастройкаБизнесПроцесса",СтрокаДок.НастройкаБизнесПроцесса);			
					DocDescr.SetField("ТипДокумента1С",СтрокаДок.ТипДокумента1С);
					Если ЗначениеЗаполнено(СтрокаДок.НастройкаБизнесПроцесса)   Тогда
						ID_БизнесПроцесса = СтрокаДок.НастройкаБизнесПроцесса;
						
						НастройкаБП = КэшНастроекБизнесПроцессов.Получить(ID_БизнесПроцесса);
						Если НастройкаБП = Неопределено Тогда
							СтрокаБП = ГлЯдро_СкопироватьМассив(НастройкиБП, Новый Структура("ID_БизнесПроцесса", ID_БизнесПроцесса))[0];
							НастройкаБП = Новый Структура;
							НастройкаБП.Вставить("ЗаменитьПредставлениеДокументаПриВыгрузке", ?(СтрокаБП.Свойство("ЗаменитьПредставлениеДокументаПриВыгрузке") И СтрокаБП.ЗаменитьПредставлениеДокументаПриВыгрузке = Истина, Истина, Ложь));
							НастройкаБП.Вставить("НастройкаПредставленийРеквизитовДокумента", СтрокаБП.НастройкаПредставленийРеквизитовДокумента);
							НастройкаБП.Вставить("КопияДокументаДляКаждогоПользователя",	  СтрокаБП.КопияДокументаДляКаждогоПользователя);
							КэшНастроекБизнесПроцессов.Вставить(ID_БизнесПроцесса, НастройкаБП);
						КонецЕсли;
						
						Если НастройкаБП.ЗаменитьПредставлениеДокументаПриВыгрузке Тогда				
							DocDescr.SetField("ПредставлениеИмениДокумента", ГлЯдро_ПолучитьПредставлениеДокументаПоНастройкам(СтрокаДок.Ссылка, НастройкаБП.НастройкаПредставленийРеквизитовДокумента));	
						КонецЕсли;
						Если НастройкаБП.КопияДокументаДляКаждогоПользователя Тогда
							DocDescr.Id = XMLСтрока(СтрокаДок.Ссылка)+"#"+UserId;
						КонецЕсли;
					КонецЕсли;
					Попытка					
						DocDescr.SetField("ИмяБП", Строка(СтрокаДок.ИмяБП));									
					Исключение
					КонецПопытки;				
					Попытка					
						DocDescr.SetField("ИмяКонтрагента", Строка(СтрокаДок.ИмяКонтрагента));					
					Исключение
					КонецПопытки;				
					Попытка					
						DocDescr.SetField("ИмяСклада", Строка(СтрокаДок.ИмяСклада));					
					Исключение
					КонецПопытки;				
					Попытка					
						DocDescr.SetField("ИмяСкладаКуда", Строка(СтрокаДок.ИмяСкладаКуда));					
					Исключение
					КонецПопытки;				
					DocDescrs.Add(DocDescr);
				КонецЦикла;
				ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Постобработка списка документов закончена, кладем в XML: "+ Строка(ОтобранныеДокументы) + ", Тип документа: " + Строка(ТипДокумента) + ", Ид пользователя: " + Строка(UserId),НачалоСобытия,АдресаПеременных);
				СтруктураПодключенияБазыMS = КомЯдро_ПолучитьЗначениеПеременной("COMБазыMS",АдресаПеременных);
				СписокДокументов = СтруктураПодключенияБазыMS.StorageConnector.СохранитьОбъектВ_XML(DocDescrs);
				Результат = СписокДокументов;
				ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Сохранили в XML, получили список документов на отправку" + ", Тип документа: " + Строка(ТипДокумента) + ", Ид пользователя: " + Строка(UserId),НачалоСобытия,АдресаПеременных);
				#КонецОбласти //НесовместимыйКодFresh
			КонецЕсли;
		Иначе
			ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Нет документов учавствующих в отборе для типа документа: "+ Строка(ТипДокумента) +", Ид пользователя: "+ Строка(UserId),НачалоСобытия,АдресаПеременных);
			Возврат Неопределено;
		КонецЕсли;
		
	Исключение
		ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Ошибка: " + ТекстОшибки + ", Тип документа: " + Строка(ТипДокумента) + ", Ид пользователя: " + Строка(UserId), НачалоСобытия, АдресаПеременных);
		Результат = "#Ошибка при получения списка документов: " + ТекстОшибки;		
	КонецПопытки;
	
	ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Конец, Тип документа: "+ Строка(ТипДокумента) +", Ид пользователя: "+ Строка(UserId),НачалоСобытия,АдресаПеременных);
	
	Возврат Результат; 
		
КонецФункции

// Обрабатывает запрос сервера Mobile Smarts на получение документа
//
// Параметры:
//	userId - Строка - идентификатор пользователя Mobile Smarts		
//  КодДокумента - Строка - идентификатор документа
//  ОперацияТСД - Строка - тип документа Mobile Smarts
//	Режим - Число - режим получения документа
//  mXmlDoc	- Строка - строка в формате XML или JSON, содержащая информацию о текущей сессии Mobile Smarts
//
// Возвращаемое значение:
//	    - Строка - данные документа в формате XML, если тип интерфейса - COM
//      - Строка - данные документа в формате JSON, если тип интерфейса - REST_API
//		- Строка - текст ошибки получения документа
//		- Неопределено - если не удалось установить соединение с базой Mobile Smarts
Функция ПолучитьДокумент(UserId, КодДокумента, ОперацияТСД, Режим, mXmlDoc = Неопределено) Экспорт
	
	НачалоСобытия = ТекущаяУниверсальнаяДатаВМиллисекундах();
	ИмяСобытия = "ПолучитьДокумент";
	
	// Сделаем проверку на служебный УИД - пользователь пытается получить весь список документов, но технически пока невозможно
	Если КодДокумента = "11111111-2222-3333-4444-555555555555" Тогда		
		Возврат "#1CEDWR001. Документов для отображения слишком много, настройте отборы документов в основной " + 
			"обработке Клеверенс для данного типа документа Mobile SMARTS или выполните поиск по штрихкоду или коду документа.";		
	КонецЕсли;
	
	Попытка
		ТипИнтерфейса = ГлЯдро_ПолучитьДанныеИзХранилища1С("Cleverence_ТипИнтерфейса");
		
		АдресаПеременных = КомЯдро_СоздатьСтруктуруАдресаПеременных();
		
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Начало, Тип документа: "+ Строка(ОперацияТСД) +", Режим: "+ Строка(Режим) +", Код документа: "+Строка(КодДокумента)+", Ид пользователя: "+ Строка(UserId),НачалоСобытия,АдресаПеременных);
		
		ГлЯдро_СохранитьДанныеВХранилище1С("Cleverence_ОписаниеОшибкиONLEX", Неопределено);
		
		НастройкиИнициализированы = КомЯдро_ПолучитьЗначениеПеременной("НастройкиИнициализированы",АдресаПеременных);
		НастройкиИзменились = ГлЯдро_НастройкиИзменились(АдресаПеременных);
		Если НастройкиИзменились
			ИЛИ НЕ НастройкиИнициализированы = Истина Тогда
			ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Предупреждение", "Переинициализация настроек. НастройкиИнициализированы = "+Строка(НастройкиИнициализированы)+", НастройкиИзменились = "+Строка(НастройкиИзменились),,АдресаПеременных);
			ГлЯдро_Инициализация(ИмяСобытия,НастройкиИзменились,mXmlDoc,АдресаПеременных);
			
			ТекстОшибки = ГлЯдро_ПроверитьНаличиеИсключительнойСитуацииONLEX();
			Если ЗначениеЗаполнено(ТекстОшибки) Тогда
				Возврат "#" + ТекстОшибки;	
			КонецЕсли;		
		КонецЕсли;
		
		Если НЕ ГлЯдро_ПроверитьСоединениеССерверомSMARTS(,,,,,,АдресаПеременных) = Истина Тогда
			ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Подключиться к серверу Mobile SMARTS не удалось, Тип документа: "+ Строка(ОперацияТСД) +", Режим: "+ Строка(Режим) +", Код документа: "+Строка(КодДокумента)+", Ид пользователя: "+ Строка(UserId),НачалоСобытия,АдресаПеременных);
			
			ТекстОшибки = ГлЯдро_ПроверитьНаличиеИсключительнойСитуацииONLEX();
			Если ЗначениеЗаполнено(ТекстОшибки) Тогда
				Возврат "#" + ТекстОшибки;	
			КонецЕсли;
			
			Возврат Неопределено;
		КонецЕсли;	
		
		ГлЯдро_УстановитьДанныеТекущегоУзла(mXmlDoc,,,ТипИнтерфейса,АдресаПеременных);
		
		Результат = Неопределено;
		
		СтруктураПодключенияБазыMS = КомЯдро_ПолучитьЗначениеПеременной("COMБазыMS",АдресаПеременных);
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Перед Обработкой получения документа, Тип документа: " + Строка(ОперацияТСД) + ", Режим: " + Строка(Режим) + ", Код документа: " + Строка(КодДокумента) + ", Ид пользователя: " + Строка(UserId),НачалоСобытия,АдресаПеременных);
		Если Режим = 0 Тогда
			
			ИспJSON_mXmlDoc = КомЯдро_ПолучитьЗначениеПеременной("ИспJSON_mXmlDoc",АдресаПеременных);
			//Если ТипИнтерфейса = "REST_API" Тогда
			Если ИспJSON_mXmlDoc = Истина
				ИЛИ (ИспJSON_mXmlDoc = Неопределено И ТипИнтерфейса = "REST_API") Тогда
				SessionSMARTS = ГлЯдро_ЗагрузитьИзJSON(mXmlDoc);
				ID_БизнесПроцесса = SessionSMARTS["DeviceInfo"]["Document"]["НастройкаБизнесПроцесса"];
			Иначе
				SessionSMARTS 		= СтруктураПодключенияБазыMS.StorageConnector.ЗагрузитьОбъектИз_XML(mXmlDoc);
				ID_БизнесПроцесса 	= SessionSMARTS.DeviceInfo.Document.ПолучитьПоле("НастройкаБизнесПроцесса");
			КонецЕсли;
			
			Если НЕ ЗначениеЗаполнено(ID_БизнесПроцесса) Тогда
				ID_БизнесПроцесса = "";
				Возврат "#Не выбран бизнес-процесс! Проверьте, выгружены ли бизнес-процессы на ТСД.";	
			КонецЕсли;			
			
			Результат = ГлЯдро_ПолучитьДокумент1СДляВыгрузкиОнлайн(КодДокумента, ОперацияТСД, ID_БизнесПроцесса, ТипИнтерфейса, АдресаПеременных);
			
		ИначеЕсли Режим = 1 Тогда
			
			Результат = ГлЯдро_ПолучитьДокументПоШтрихкоду(UserId, КодДокумента, ОперацияТСД, mXmlDoc, ИмяСобытия, ТипИнтерфейса, АдресаПеременных);		
			
		Иначе
			
			Результат =  "#Задан неверный режим получения документа: " + Режим;
			
		КонецЕсли;
		
	Исключение
		ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Ошибка: " + ТекстОшибки + ", Тип документа: " + Строка(ОперацияТСД) + ", Режим: " + Строка(Режим) + ", Код документа: " + Строка(КодДокумента) + ", Ид пользователя: " + Строка(UserId), НачалоСобытия, АдресаПеременных);
		Результат = "#Ошибка при получения документа: " + ТекстОшибки;		
	КонецПопытки;
	ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Конец, Тип документа: "+ Строка(ОперацияТСД) +", Режим: "+ Строка(Режим) +", Код документа: "+Строка(КодДокумента)+", Ид пользователя: "+ Строка(UserId),НачалоСобытия,АдресаПеременных);
	Возврат Результат; 
	
КонецФункции

// Обрабатывает событие сервера Mobile Smarts о завершении документа
//
// Параметры:
//	ID_Документа - Строка - идентификатор документа
//  mXmlDoc	- Строка - строка в формате XML или JSON, содержащая информацию о текущей сессии Mobile Smarts
//
// Возвращаемое значение:
//	- Булево - флаг успешности формирования, записи и проведения документа в базе 1С и удаления документа в базе Mobile Smarts
//	- Неопределено - если не удалось установить соединение с базой Mobile Smarts
Функция ДокументЗавершен(ID_Документа, mXmlDoc) Экспорт
	
	НачалоСобытия = ТекущаяУниверсальнаяДатаВМиллисекундах();
	ИмяСобытия = "ДокументЗавершен";
	
	Попытка
		
		АдресаПеременных = КомЯдро_СоздатьСтруктуруАдресаПеременных();
		ТипИнтерфейса = ГлЯдро_ПолучитьДанныеИзХранилища1С("Cleverence_ТипИнтерфейса");
		КомЯдро_СохранитьЗначениеПеременной("ТипИнтерфейса",ТипИнтерфейса,АдресаПеременных);
		
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Начало, Документ: "+ Строка(ID_Документа),НачалоСобытия,АдресаПеременных);
		НастройкиИнициализированы = КомЯдро_ПолучитьЗначениеПеременной("НастройкиИнициализированы",АдресаПеременных);
		НастройкиИзменились = ГлЯдро_НастройкиИзменились(АдресаПеременных);
		Если НастройкиИзменились
			ИЛИ НЕ НастройкиИнициализированы = Истина Тогда
			ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Предупреждение", "Переинициализация настроек. НастройкиИнициализированы = "+Строка(НастройкиИнициализированы)+", НастройкиИзменились = "+Строка(НастройкиИзменились),,АдресаПеременных);			
			ГлЯдро_Инициализация(ИмяСобытия,НастройкиИзменились,mXmlDoc,АдресаПеременных);
		КонецЕсли;     
		
		Если НЕ ГлЯдро_ПроверитьСоединениеССерверомSMARTS(,,,,,,АдресаПеременных) = Истина Тогда
			ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Подключится к серверу Mobile SMARTS не удалось, Документ: "+ Строка(ID_Документа),НачалоСобытия,АдресаПеременных);
			Возврат Ложь;
		КонецЕсли;
		
		ГлЯдро_УстановитьДанныеТекущегоУзла(mXmlDoc,,,ТипИнтерфейса,АдресаПеременных);
		
		СтруктураПодключенияБазыMS = КомЯдро_ПолучитьЗначениеПеременной("COMБазыMS",АдресаПеременных);
		СтруктураМетаданных = КомЯдро_ПолучитьЗначениеПеременной("СтруктураМетаданных",АдресаПеременных);
		
		СтатусДокумента = "";
		НастройкаБизнесПроцесса = "";
		Если ТипИнтерфейса = "REST_API" Тогда
			СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной("REST_API_СтруктураПодключенияБазыMS",АдресаПеременных);
			
			СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключенияMS,Новый Структура("HTTPМетод,Метод,ВернутьСтруктуру,ТипЗапроса","GET","Docs('"+ID_Документа+"')",Истина,"ПолучениеШапкиДокумента"),,АдресаПеременных);
			Если СтруктураОтвета.КодСостояния <> 200 Тогда
				Возврат Неопределено;
			КонецЕсли;
			ДокументSMARTS = СтруктураОтвета.ОтветСервера;
			Если ТипЗнч(ДокументSMARTS) = Тип("Структура")
				И ДокументSMARTS.Свойство("Status") Тогда
				СтатусДокумента = ДокументSMARTS.Status;
			КонецЕсли;
			
			Если ТипЗнч(ДокументSMARTS) = Тип("Структура")
				И ДокументSMARTS.Свойство("nastrojkaBiznesProcessa") Тогда
				НастройкаБизнесПроцесса = ДокументSMARTS.nastrojkaBiznesProcessa;
			КонецЕсли;
			ИмяТипаДокумента = ГлЯдро_ПреобразованиеНаименованияДокументаБезПробелов(ДокументSMARTS.documentTypeName);
			ИмяДокумента = ДокументSMARTS.name;
			
			СтруктураДокумента = СтруктураМетаданных.ДокументыMS[ИмяТипаДокумента];
			
			Если СтатусДокумента = "Отменен" Тогда
				// Если документ к удалению - удаляем
				РезультатЗаписи = ГлЯдро_УдалитьДокументНаСервереSMARTS(ID_Документа, "Основная", Новый Структура("ИмяДокумента", ИмяДокумента), АдресаПеременных);
				СообщениеНаСТД = Новый Структура("text,sender,appointment",РезультатЗаписи.Сообщение,"",ДокументSMARTS.userId);
				REST_API_ВыполнитьМетод(СтруктураПодключенияMS,Новый Структура("HTTPМетод,Метод","POST","Messages"),СообщениеНаСТД,АдресаПеременных);
				ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Удаление документа из Mobile SMARTS, Документ: "+ Строка(ID_Документа),НачалоСобытия,АдресаПеременных);
				Возврат РезультатЗаписи.Статус;
			КонецЕсли;

		Иначе
			ДокументSMARTS = СтруктураПодключенияБазыMS.StorageConnector.ПолучитьДокумент(ID_Документа);
			ИмяТипаДокумента = ГлЯдро_ПреобразованиеНаименованияДокументаБезПробелов(ДокументSMARTS.documentTypeName);
			СтруктураДокумента = СтруктураМетаданных.ДокументыMS[ИмяТипаДокумента];			
			ИмяТипаДокумента = ДокументSMARTS.ИмяТипаДокумента;
			ИмяДокумента = ДокументSMARTS.Имя;
			Попытка 
				СтатусДокумента = ДокументSMARTS.ПолучитьПоле("Статус");
				НастройкаБизнесПроцесса = ДокументSMARTS.ПолучитьПоле("НастройкаБизнесПроцесса");	
			Исключение
			КонецПопытки;
			Если СтатусДокумента = "Отменен" Тогда
				// Если документ к удалению - удаляем
				РезультатЗаписи = ГлЯдро_УдалитьДокументНаСервереSMARTS(ID_Документа, "Основная", Новый Структура("ИмяДокумента", ИмяДокумента), АдресаПеременных);
				СтруктураПодключенияБазыMS.StorageConnector.ОтправитьСообщение(РезультатЗаписи.Сообщение, "", ДокументSMARTS.ИдПользователя); 
				ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Удаление документа из Mobile SMARTS, Документ: "+ Строка(ID_Документа),НачалоСобытия,АдресаПеременных);
				Возврат РезультатЗаписи.Статус;
			КонецЕсли;	
		КонецЕсли;
		
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Перед записью документа в 1С" + ", Документ: " + Строка(ID_Документа),НачалоСобытия,АдресаПеременных);
		РезультатЗаписи = ГлЯдро_СформироватьИЗаписатьДокументВБазу1С_ПоID(ID_Документа, СтруктураДокумента, НастройкаБизнесПроцесса,, "Основная", , , Истина,,Ложь,АдресаПеременных);		
		
		РезультатЗаписи = ГлЯдро_ЗаписатьИПровестиДокумент1С(РезультатЗаписи, НастройкаБизнесПроцесса, ИмяТипаДокумента, ИмяДокумента,АдресаПеременных); 
		
		ПользовательТСД = РезультатЗаписи.Дополнение;
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "После записи документа и перед отправкой сообщения на ТСД, Статус: "+Строка(РезультатЗаписи.Статус) + ", Документ: " + Строка(ID_Документа),НачалоСобытия,АдресаПеременных);
		
		Если ТипИнтерфейса = "REST_API" Тогда
			СообщениеНаСТД = Новый Структура("text,sender,appointment",РезультатЗаписи.Сообщение,"",ПользовательТСД);
			REST_API_ВыполнитьМетод(СтруктураПодключенияMS,Новый Структура("HTTPМетод,Метод","POST","Messages"),СообщениеНаСТД,АдресаПеременных); 
		Иначе			
			СтруктураПодключенияБазыMS.StorageConnector.ОтправитьСообщение(РезультатЗаписи.Сообщение, "", ПользовательТСД); 
		КонецЕсли;
		Если РезультатЗаписи.Статус = Истина Тогда
			Результат = ГлЯдро_УдалитьДокументНаСервереSMARTS(ID_Документа, "Основная", Новый Структура("ИмяДокумента", ИмяДокумента), АдресаПеременных);
		Иначе
			Результат = ГлЯдро_УстановитьСтатусДокументаНаСервереSMARTS(ID_Документа, "Основная", "ОшибкаЗаписи",АдресаПеременных);
		КонецЕсли;
		
		Результат = РезультатЗаписи.Статус;
		
	Исключение
		ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Ошибка: " + ТекстОшибки + ", Документ: " + Строка(ID_Документа), НачалоСобытия, АдресаПеременных);		
		Результат = Неопределено;	
	КонецПопытки;
	
	ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Конец, Документ: "+ Строка(ID_Документа),НачалоСобытия,АдресаПеременных);
	Возврат Результат;
	
КонецФункции

// Обрабатывает запрос сервера Mobile Smarts на получение номенклатуры по части наименования
//
// Параметры:
//	ПараметрНоменклатуры - Строка - часть наименование, артикула, кода номенклатуры, по которому производится поиск		
//  userId - Строка - идентификатор пользователя Mobile Smarts		
//  mXmlDoc	- Строка - строка в формате XML или JSON, содержащая информацию о текущей сессии Mobile Smarts
//
// Возвращаемое значение:
//	- Строка - данные таблицы отобранных товаров в формате XML, если тип интерфейса - COM
//	- Строка - данные таблицы отобранных товаров в формате JSON, если тип интерфейса - REST_API
//	- Неопределено - если не удалось установить соединение с базой Mobile Smarts
Функция НайтиНоменклатуруПоЧастиНаименования(ПараметрНоменклатуры, userId, mXmlDoc=Неопределено) Экспорт
	
	ИмяСобытия = "НайтиНоменклатуруПоЧастиНаименования";
	
	Возврат ПолучитьТовар(ПараметрНоменклатуры, "", UserId, 5, mXmlDoc, ИмяСобытия);
	
КонецФункции

// Обрабатывает запрос сервера Mobile Smarts на получение списка номенклатуры
//
// Параметры:
//	ПараметрНоменклатуры - Строка - идентификатор номенклатуры/группы номенклатуры для отбора
//  userId - Строка - идентификатор пользователя Mobile Smarts		
//  mXmlDoc	- Строка - строка в формате XML или JSON, содержащая информацию о текущей сессии Mobile Smarts
//	Режим - Число - режим поиска номенклатуры
//
// Возвращаемое значение:
//	- Строка - данные таблицы отобранных товаров в формате XML, если тип интерфейса - COM
//	- Строка - данные таблицы отобранных товаров в формате JSON, если тип интерфейса - REST_API
//	- Неопределено - если не удалось установить соединение с базой Mobile Smarts
Функция ПолучитьСписокНоменклатуры(ПараметрНоменклатуры, userId, mXmlDoc=Неопределено, Режим = 0) Экспорт
	
	ИмяСобытия = "ПолучитьСписокНоменклатуры";	
	
	Возврат ПолучитьТовар(ПараметрНоменклатуры, "", UserId, 6, mXmlDoc, ИмяСобытия);
	
КонецФункции

// Обрабатывает запрос сервера Mobile Smarts на получение списка номенклатуры по массивам номенклатуры и упаковок
//
// Параметры:
//	ПараметрНоменклатуры - COMSafeArray из Строка - идентификаторы номенклатуры для отбора
//	ПараметрУпаковки - COMSafeArray из Строка - идентификаторы упаковок для отбора
//  userId - Строка - идентификатор пользователя Mobile Smarts		
//  mXmlDoc	- Строка - строка в формате XML или JSON, содержащая информацию о текущей сессии Mobile Smarts
//
// Возвращаемое значение:
//	- Строка - данные таблицы отобранных товаров в формате XML, если тип интерфейса - COM
//	- Строка - данные таблицы отобранных товаров в формате JSON, если тип интерфейса - REST_API
//	- Неопределено - если не удалось установить соединение с базой Mobile Smarts
Функция ПолучитьТовары(ПараметрНоменклатуры, ПараметрУпаковки, UserId, mXmlDoc) Экспорт
	
	ИмяСобытия = "ПолучитьТовары";
	
	Возврат	ПолучитьТовар(ПараметрНоменклатуры, ПараметрУпаковки, UserId, 4, mXmlDoc, ИмяСобытия);
	
КонецФункции

// Обрабатывает запрос сервера Mobile Smarts на получение номенклатуры
//
// Параметры:
//	ПараметрНоменклатуры - Строка - идентификатор номенклатуры
//                       - Строка - штрихкод, код, алкокод, артикул номенклатуры
//                       - COMSafeArray из Строка - массив идентификаторов номенклатуры
//  ПараметрУпаковки - Строка - идентификатор упаковки
//                   - COMSafeArray из Строка - массив идентификаторов упаковок
//					 - Неопределено - если поиск по упаковкам не требуется
//  userId - Строка - идентификатор пользователя Mobile Smarts
//  Режим - Число - режим поиска номенклатуры
//  mXmlDoc	- Строка - строка в формате XML или JSON, содержащая информацию о текущей сессии Mobile Smarts
//	ИмяСобытия - Строка - имя события сервера Mobile Smarts
//  АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
//
// Возвращаемое значение:
//	- Строка - данные таблицы отобранных товаров в формате XML, если тип интерфейса - COM
//	- Строка - данные таблицы отобранных товаров в формате JSON, если тип интерфейса - REST_API
//	- Неопределено - если не удалось установить соединение с базой Mobile Smarts
Функция ПолучитьТовар(ПараметрНоменклатуры, ПараметрУпаковки, UserId, Режим = 0, mXmlDoc = Неопределено, ИмяСобытия = "ПолучитьТовар",АдресаПеременных=Неопределено) Экспорт
	
	НачалоСобытия = ТекущаяУниверсальнаяДатаВМиллисекундах();
	Попытка
		
		ТипИнтерфейса = ГлЯдро_ПолучитьДанныеИзХранилища1С("Cleverence_ТипИнтерфейса");
		
		Если АдресаПеременных = Неопределено Тогда
			АдресаПеременных = КомЯдро_СоздатьСтруктуруАдресаПеременных();
		КонецЕсли;
		НастройкиИнициализированы = КомЯдро_ПолучитьЗначениеПеременной("НастройкиИнициализированы",АдресаПеременных);
		
		ПредставлениеПараметров = ГлЯдро_ПолучитьТекстовоеПредставлениеПараметров(Новый Структура("ПараметрНоменклатуры, ПараметрУпаковки", ПараметрНоменклатуры, ПараметрУпаковки));
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Начало, Режим: " + Строка(Режим) + ", Ид пользователя: " + Строка(UserId) + ПредставлениеПараметров, , АдресаПеременных);
		
		Если Режим = 6 Тогда
			ГлЯдро_СохранитьДанныеВХранилище1С("Cleverence_ОписаниеОшибкиONLEX", Неопределено);
		КонецЕсли;
		
		НастройкиИзменились = ГлЯдро_НастройкиИзменились(АдресаПеременных);
		Если НастройкиИзменились
			ИЛИ НЕ НастройкиИнициализированы = Истина Тогда
			ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Предупреждение", "Переинициализация настроек. НастройкиИнициализированы = "+Строка(НастройкиИнициализированы)+", НастройкиИзменились = "+Строка(НастройкиИзменились),,АдресаПеременных);
			ГлЯдро_Инициализация(ИмяСобытия,НастройкиИзменились,mXmlDoc,АдресаПеременных);
			
			Если Режим = 6 Тогда	
				ТекстОшибки = ГлЯдро_ПроверитьНаличиеИсключительнойСитуацииONLEX();
				Если ЗначениеЗаполнено(ТекстОшибки) Тогда
					Возврат "#" + ТекстОшибки;	
				КонецЕсли;
			КонецЕсли;	
		КонецЕсли;
		
		Если НЕ ГлЯдро_ПроверитьСоединениеССерверомSMARTS(,,,,,,АдресаПеременных) = Истина Тогда
			ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Подключиться к серверу Mobile SMARTS не удалось, Режим: "+ Строка(Режим) +", Ид пользователя: "+ Строка(UserId),,АдресаПеременных);
			
			Если Режим = 6 Тогда
				ТекстОшибки = ГлЯдро_ПроверитьНаличиеИсключительнойСитуацииONLEX();
				Если ЗначениеЗаполнено(ТекстОшибки) Тогда
					Возврат "#" + ТекстОшибки;	
				КонецЕсли;
			КонецЕсли;
			
			Возврат Неопределено;
		КонецЕсли;
		
		ГлЯдро_УстановитьДанныеТекущегоУзла(mXmlDoc,,,ТипИнтерфейса,АдресаПеременных);
		
		СтруктураШтрихкода = Неопределено;
		
		Если Режим = 0 Тогда
			Режим = "ПоискПоНоменклатуре";
		ИначеЕсли Режим = 1 Тогда
			Режим = "ПоискПоАртикулуКодуШК";
		ИначеЕсли Режим = 2 ИЛИ Режим = 3 Тогда
			Режим = "ПоискПоНоменклатуреУпаковке";
		ИначеЕсли Режим = 4 Тогда
			Режим = "ПоискПоМассивамНоменклатурыУпаковки";
		ИначеЕсли Режим = 5 Тогда
			Режим = "ПоискПоЧастиНаименования";
		ИначеЕсли Режим = 6 Тогда
			Режим = "СписокНоменклатуры";
		Иначе
			Режим = "";
		КонецЕсли;	
		
		Если Режим = "ПоискПоАртикулуКодуШК" Тогда
			ПозицииGTIN = Новый Массив;
			ПозицииGTIN.Добавить("(01)");
			ПозицииGTIN.Добавить("(02)");
			Для каждого ПозицияGTIN ИЗ ПозицииGTIN Цикл
				ПозицияВхождения = ГлЯдро_СтрНайти(ПараметрНоменклатуры, ПозицияGTIN);
				Если ПозицияВхождения Тогда
					ПараметрНоменклатуры = Сред(ПараметрНоменклатуры, ПозицияВхождения + 4, 14);
					Прервать;
				КонецЕсли;
			КонецЦикла;
			
			СтруктураШтрихкода = ГлЯдро_ПолучитьСтруктуруШтрихкодаEAN13(ПараметрНоменклатуры, АдресаПеременных);	
		КонецЕсли;
		
		НастройкиКомпоновщика = "";
		Отбор = Новый Структура("ИмяТаблицы", "Номенклатура");
		НастройкаКомпоновщикаСтрокой = ГлЯдро_ПолучитьИзКэшаЗначениеТабличнойНастройкиSMARTS("НастройкиОбменаСправочников", Отбор, "НастройкаКомпоновщикаСтрокой",АдресаПеременных);
		Если ЗначениеЗаполнено(НастройкаКомпоновщикаСтрокой) Тогда
			НастройкиКомпоновщика = ГлЯдро_ЗначениеИзСтрокиXML(НастройкаКомпоновщикаСтрокой);
		КонецЕслИ;
		
		// Данные получаем по ID упаковки без постфикса, результат возвращаем - с постфиксом
		ПерезаполнитьПараметрУпаковки = Ложь;
		Если Режим = "ПоискПоНоменклатуреУпаковке" Тогда
			Если ЗначениеЗаполнено(ПараметрУпаковки) И ТипЗнч(ПараметрУпаковки) = Тип("Строка") Тогда
				ПараметрУпаковкиСПостфиксом = ПараметрУпаковки;
				ГлЯдро_УдалитьПостфиксыУпаковок(ПараметрУпаковки);
				Если ПараметрУпаковкиСПостфиксом <> ПараметрУпаковки Тогда 
					ПерезаполнитьПараметрУпаковки = Истина;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		
		ПараметрыУзлов = ГлЯдро_ПолучитьЗначенияГлобальныхПараметров(,,,АдресаПеременных);
		ПараметрыОнлайн = Новый Структура("ПараметрНоменклатуры,ПараметрУпаковки,Режим,СтруктураШтрихкода", ПараметрНоменклатуры, ПараметрУпаковки, Режим, СтруктураШтрихкода);
		
		// Перенес из ГлЯдро_УстановитьПараметрыСКДДляНоменклатуры
		Если Режим = "СписокНоменклатуры" Тогда
			МетаданныеНСИ = ГлЯдро_ПолучитьМетаданныеНСИ(АдресаПеременных);
			ИмяСправочникаНоменклатуры = МетаданныеНСИ.Номенклатура.ИмяСправочника;
			СсылкаНоменклатуры = ГлЯдро_ПолучитьЗначениеСправочникаПоID(ИмяСправочникаНоменклатуры, ПараметрыОнлайн.ПараметрНоменклатуры);
			ПараметрыОнлайн.Вставить("СсылкаНоменклатуры",СсылкаНоменклатуры);
			
			Если СсылкаНоменклатуры.ЭтоГруппа ИЛИ НЕ ЗначениеЗаполнено(СсылкаНоменклатуры) Тогда // если заходим в корень справочника, то родитель будет пустой ссылкой
				Режим = "СписокНоменклатурыДляГрупп";
			Иначе
				Режим = "СписокУпаковокДляНоменклатуры";
			КонецЕсли;
			ПараметрыОнлайн.Вставить("Режим",Режим);
		КонецЕсли;
		
		РаботаБезАлкоголя = ГлЯдро_ПолучитьИзКэшаНастройкуSMARTS("РаботаБезАлкоголя",,АдресаПеременных);		
		ПараметрыВыгрузки = ГлЯдро_ПолучитьЗаполнитьСтруктуруПараметровВыгрузкиСправочника("Номенклатура", АдресаПеременных);
		
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "1. Получение таблицы товаров в 1С " + Строка(ПараметрыУзлов) + ", Режим: "+ Строка(Режим) + ", Ид пользователя: " + Строка(UserId),НачалоСобытия,АдресаПеременных);
		
		Если Режим = "ПоискПоАртикулуКодуШК"
			И СтрДлина(ПараметрНоменклатуры) = 14 Тогда
			ТаблицаТоваров = ГлЯдро_ПолучитьДанныеТаблицыПоАртикулуКодуШК(ПараметрНоменклатуры, НастройкиКомпоновщика, ПараметрыУзлов, ПараметрыОнлайн, РаботаБезАлкоголя, ПараметрыВыгрузки, АдресаПеременных);
		Иначе
			ТаблицаТоваров = ГлЯдро_ПолучитьДанныеТаблицыДляВыгрузкиНаСерверSMARTS("Номенклатура", НастройкиКомпоновщика, ПараметрыУзлов, ПараметрыОнлайн, РаботаБезАлкоголя, ПараметрыВыгрузки, АдресаПеременных);
		КонецЕсли;
		
		ТекстКоличествоСтрок = " (" + Строка(ТаблицаТоваров.Количество()) + " стр.)";
		
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "2. Таблица товаров в 1С получена " + Строка(ТаблицаТоваров) + ТекстКоличествоСтрок + ", Режим: "+ Строка(Режим) + ", Ид пользователя: " + Строка(UserId),НачалоСобытия,АдресаПеременных);
		
		Если СтруктураШтрихкода <> Неопределено И СтруктураШтрихкода.ЭтоВесовойТовар Тогда
			ТаблицаТоваров.Колонки.Добавить("Quantity");
			ТаблицаТоваров.ЗаполнитьЗначения(СтруктураШтрихкода.КоличествоТовара, "Quantity");	
		КонецЕсли;
		
		КолонкиТаблицыТоваров = ТаблицаТоваров.Колонки;
			
		// При онлайн запросе надо очистить BasePackingId что бы не приходило с сервера запроса уточняющего за данными в BasePackingId 
		//Возможны проблемы в работе без него		
		//Если КолонкиТаблицыТоваров.Найти("Product_BasePackingId") <> Неопределено Тогда
		//	ТаблицаТоваров.ЗаполнитьЗначения("", "Product_BasePackingId");
		//КонецЕсли;
		
		// При запросе через "ПоискПоНоменклатуреУпаковке" и "ПоискПоМассивамНоменклатурыУпаковки" Поля: ИмяХарактеристики, ИдХарактеристики, ИмяСерии, ИдСерии - очистить
		Если Режим = "ПоискПоНоменклатуреУпаковке" 
			ИЛИ Режим = "ПоискПоМассивамНоменклатурыУпаковки" Тогда
			Если КолонкиТаблицыТоваров.Найти("Product_BasePackingId") <> Неопределено Тогда
				ТаблицаТоваров.ЗаполнитьЗначения("", "Product_BasePackingId");
			КонецЕсли;
			Если КолонкиТаблицыТоваров.Найти("Packing_Barcode") <> Неопределено Тогда
				ТаблицаТоваров.ЗаполнитьЗначения("", "Packing_Barcode");
			КонецЕсли;				
			Если КолонкиТаблицыТоваров.Найти("Packing_price") <> Неопределено Тогда
				ТаблицаТоваров.ЗаполнитьЗначения(0, "Packing_price");
			КонецЕсли;
			Если КолонкиТаблицыТоваров.Найти("Packing_qty") <> Неопределено Тогда
				ТаблицаТоваров.ЗаполнитьЗначения(0, "Packing_qty");
			КонецЕсли;
			Если КолонкиТаблицыТоваров.Найти("Packing_ИмяХарактеристики") <> Неопределено Тогда
				ТаблицаТоваров.ЗаполнитьЗначения("", "Packing_ИмяХарактеристики");
			КонецЕсли;	
			Если КолонкиТаблицыТоваров.Найти("Packing_ИдХарактеристики") <> Неопределено Тогда
				ТаблицаТоваров.ЗаполнитьЗначения("", "Packing_ИдХарактеристики");
			КонецЕсли;	
			Если КолонкиТаблицыТоваров.Найти("Packing_ИмяСерии") <> Неопределено Тогда
				ТаблицаТоваров.ЗаполнитьЗначения("", "Packing_ИмяСерии");
			КонецЕсли;	
			Если КолонкиТаблицыТоваров.Найти("Packing_ИдСерии") <> Неопределено Тогда
				ТаблицаТоваров.ЗаполнитьЗначения("", "Packing_ИдСерии");
			КонецЕсли;
			Если КолонкиТаблицыТоваров.Найти("Packing_ИсходныйGTIN") <> Неопределено Тогда
				ТаблицаТоваров.ЗаполнитьЗначения("", "Packing_ИсходныйGTIN");
			КонецЕсли;
			
			// Нужно восстановить Packing_Id с постфиксом
			Если КолонкиТаблицыТоваров.Найти("Packing_Id") <> Неопределено И ПерезаполнитьПараметрУпаковки Тогда
				ТаблицаТоваров.ЗаполнитьЗначения(ПараметрУпаковкиСПостфиксом, "Packing_Id");
			КонецЕсли;	
		ИначеЕсли Режим = "ПоискПоАртикулуКодуШК" Тогда
			Если КолонкиТаблицыТоваров.Найти("Product_BasePackingId") <> Неопределено Тогда
				ТаблицаТоваров.ЗаполнитьЗначения("", "Product_BasePackingId");
			КонецЕсли;
		КонецЕсли;						
		
		Если ТаблицаТоваров <> Неопределено Тогда
			ГлЯдро_СвернутьТаблицуЗначений(ТаблицаТоваров);			
			ТекстКоличествоСтрок = " (" + Строка(ТаблицаТоваров.Количество()) + " стр.)";
		КонецЕсли;
		
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "3. Закончена пост обработка " + Строка(ТаблицаТоваров) + ТекстКоличествоСтрок + ", Режим: "+ Строка(Режим) + ", Ид пользователя: " + Строка(UserId),НачалоСобытия,АдресаПеременных);
	
	Исключение
		ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Ошибка: " + ТекстОшибки + ", Режим: " + Строка(Режим) + ", Ид пользователя: " + Строка(UserId), НачалоСобытия, АдресаПеременных);		
		Результат = Неопределено;	
	КонецПопытки;
	
	Если ТаблицаТоваров <> Неопределено Тогда
		//Если ТипИнтерфейса = "REST_API" Тогда
		ИспJSON_mXmlDoc = КомЯдро_ПолучитьЗначениеПеременной("ИспJSON_mXmlDoc",АдресаПеременных);
		Если ИспJSON_mXmlDoc = Истина
			ИЛИ (ИспJSON_mXmlDoc = Неопределено И ТипИнтерфейса = "REST_API") Тогда
			Результат = REST_API_ТаблицаЗначенийВМассивСтруктур(ТаблицаТоваров);
			Результат = ГлЯдро_ПолучитьJSON(Результат);
		Иначе
			Результат = ГлЯдро_ТаблицаЗначенийВCOMSafeArray(ТаблицаТоваров);	
		КонецЕсли; 
	КонецЕсли; 
	
	ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Конец, Режим: "+ Строка(Режим) +", Ид пользователя: "+ Строка(UserId),НачалоСобытия,АдресаПеременных);
	
	Возврат Результат;
	
КонецФункции

Функция ПолучитьЯчейкуПоИд(Ид, ИдСклада, userId, mXmlDoc=Неопределено) Экспорт
	
	НачалоСобытия = ТекущаяУниверсальнаяДатаВМиллисекундах();
	ИмяСобытия = "ПолучитьЯчейкуПоИд";
	///////////////////////////////
	ТипИнтерфейса = ГлЯдро_ПолучитьДанныеИзХранилища1С("Cleverence_ТипИнтерфейса");		
	АдресаПеременных = КомЯдро_СоздатьСтруктуруАдресаПеременных();	
	НастройкиИнициализированы = КомЯдро_ПолучитьЗначениеПеременной("НастройкиИнициализированы",АдресаПеременных);						
	
	ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Начало, Ид: "+ Строка(Ид) +", ИдСклада: " + Строка(ИдСклада) +", Ид пользователя: " + Строка(UserId), , АдресаПеременных);
	
	НастройкиИзменились = ГлЯдро_НастройкиИзменились(АдресаПеременных);
	Если НастройкиИзменились
		ИЛИ НЕ НастройкиИнициализированы = Истина Тогда
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Предупреждение", "Переинициализация настроек. НастройкиИнициализированы = "+Строка(НастройкиИнициализированы)+", НастройкиИзменились = "+Строка(НастройкиИзменились),,АдресаПеременных);
		ГлЯдро_Инициализация(ИмяСобытия,НастройкиИзменились,,АдресаПеременных);		
	КонецЕсли;		
	///////////////////////////////
	
	МетаданныеНСИ = ГлЯдро_ПолучитьМетаданныеНСИ(АдресаПеременных);
	Если МетаданныеНСИ.Свойство("Ячейки") И МетаданныеНСИ.Ячейки.Свойство("ИмяСправочника") И ЗначениеЗаполнено(МетаданныеНСИ.Ячейки.ИмяСправочника) Тогда
		ИмяСправочникаЯчейки = МетаданныеНСИ.Ячейки.ИмяСправочника;			
	Иначе
		Возврат "";	
	КонецЕсли;	
	
	Попытка
		Ячейка = Справочники[ИмяСправочникаЯчейки].ПолучитьСсылку(Новый УникальныйИдентификатор(Ид)); 	
		Если Не ГлЯдро_СсылкаСуществует(Ячейка) Тогда
			Ячейка = Неопределено;
		КонецЕсли;
	Исключение
		Возврат "";
	КонецПопытки; 

	Возврат ПолучитьДанныеЯчейки(Ячейка); 
	
КонецФункции

Функция ПолучитьЯчейкуПоШтрихкоду(ШК, ИдСклада, userId, mXmlDoc=Неопределено) Экспорт	
			
	НачалоСобытия = ТекущаяУниверсальнаяДатаВМиллисекундах();
	ИмяСобытия = "ПолучитьЯчейкуПоШтрихкоду";
	
	///////////////////////////////	
	АдресаПеременных = КомЯдро_СоздатьСтруктуруАдресаПеременных();	
	НастройкиИнициализированы = КомЯдро_ПолучитьЗначениеПеременной("НастройкиИнициализированы",АдресаПеременных);						
	
	ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Начало, ШК: "+ Строка(ШК) +", ИдСклада: " + Строка(ИдСклада) +", Ид пользователя: " + Строка(UserId), , АдресаПеременных);
	
	Если СтрДлина(ШК) = 36 Тогда
	ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Вместо штрихкода пришел GUID ячейки, выполняем получение по GUID: "+ Строка(ШК) +", ИдСклада: " + Строка(ИдСклада) +", Ид пользователя: " + Строка(UserId), , АдресаПеременных);	
		Возврат ПолучитьЯчейкуПоИд(ШК, ИдСклада, userId, mXmlDoc);
	КонецЕсли;
	
	НастройкиИзменились = ГлЯдро_НастройкиИзменились(АдресаПеременных);
	Если НастройкиИзменились
		ИЛИ НЕ НастройкиИнициализированы = Истина Тогда
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Предупреждение", "Переинициализация настроек. НастройкиИнициализированы = "+Строка(НастройкиИнициализированы)+", НастройкиИзменились = "+Строка(НастройкиИзменились),,АдресаПеременных);
		ГлЯдро_Инициализация(ИмяСобытия,НастройкиИзменились,,АдресаПеременных);		
	КонецЕсли;		
	///////////////////////////////
	
	МетаданныеНСИ = ГлЯдро_ПолучитьМетаданныеНСИ(АдресаПеременных);
	Если МетаданныеНСИ.Свойство("Ячейки") И МетаданныеНСИ.Ячейки.Свойство("ИмяСправочника") И ЗначениеЗаполнено(МетаданныеНСИ.Ячейки.ИмяСправочника) Тогда
		ИмяСправочникаЯчейки = МетаданныеНСИ.Ячейки.ИмяСправочника;			
	Иначе
		Возврат "";	
	КонецЕсли; 	
	
	Ячейка = Неопределено;
	
	Попытка         
		КодЯчейки10 = Число(ШК);
		КодЯчейки16 = ГлЯдро_ПреобразоватьДесятичноеЧислоВШестнадцатиричнуюСистемуСчисления(КодЯчейки10);
		
		Пока СтрДлина(КодЯчейки16) < 32 Цикл
			КодЯчейки16 = "0" + КодЯчейки16;
		КонецЦикла;
		
		Если СтрДлина(КодЯчейки16) = 32 Тогда
			Guid = Лев(КодЯчейки16, 8) + "-" + 
				Сред(КодЯчейки16, 9, 4) + "-" + Сред(КодЯчейки16, 13, 4) + "-" + Сред(КодЯчейки16, 17, 4) + "-" + Сред(КодЯчейки16, 21, 12);
								
			Ячейка = Справочники[ИмяСправочникаЯчейки].ПолучитьСсылку(Новый УникальныйИдентификатор(Guid));
			Если Не ГлЯдро_СсылкаСуществует(Ячейка) Тогда
				Ячейка = Неопределено;
			КонецЕсли;
		КонецЕсли;
	Исключение
	КонецПопытки;
		
	Если Не ЗначениеЗаполнено(Ячейка) Тогда
		Ячейка = Справочники[ИмяСправочникаЯчейки].НайтиПоКоду(ШК);
	КонецЕсли;	
	
	ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Конец, Ячейка: "+ Строка(Ячейка) +", Ид пользователя: "+ Строка(UserId),НачалоСобытия,АдресаПеременных);
	Возврат ПолучитьДанныеЯчейки(Ячейка);
	
КонецФункции

Функция ПолучитьДанныеЯчейки(Ячейка)
	
	Если Не ЗначениеЗаполнено(Ячейка) Тогда
		Возврат "";
	КонецЕсли;
	
	Результат = "";
	ТипИнтерфейса = ГлЯдро_ПолучитьДанныеИзХранилища1С("Cleverence_ТипИнтерфейса");		
	АдресаПеременных = КомЯдро_СоздатьСтруктуруАдресаПеременных();
	СтруктураПодключенияБазыMS = КомЯдро_ПолучитьЗначениеПеременной("COMБазыMS",АдресаПеременных);

	ИспJSON_mXmlDoc = КомЯдро_ПолучитьЗначениеПеременной("ИспJSON_mXmlDoc",АдресаПеременных);
	Если ИспJSON_mXmlDoc = Истина ИЛИ (ИспJSON_mXmlDoc = Неопределено И ТипИнтерфейса = "REST_API") Тогда
		 Cell = Новый Структура;
		 Cell.Вставить("Id", XmlСтрока(Ячейка));
		 Cell.Вставить("Name", Ячейка.Код);
		 Cell.Вставить("Barcode", ГлЯдро_ЧисловойКодПоСсылке(Ячейка));

		 Результат = ГлЯдро_ПолучитьJSON(Cell);
	Иначе
		#Область НесовместимыйКодFresh
		Cell = Новый COMОбъект("Cleverence.Warehouse.Cell");
		Cell.Id = XmlСтрока(Ячейка);
		Cell.Name = Ячейка.Код;
		Cell.Barcode = ГлЯдро_ЧисловойКодПоСсылке(Ячейка);
		
		Результат = СтруктураПодключенияБазыMS.StorageConnector.СохранитьОбъектВ_XML(Cell);	
		#КонецОбласти //НесовместимыйКодFresh
	КонецЕсли;
	
	Возврат Результат;

	
КонецФункции

// Обрабатывает запрос сервера Mobile Smarts на вызов пользовательской экспортной функции из интеграционной обработки
//
// Параметры:
//	ИмяФункции - Строка - Наименование функции в интеграционной обработке
//	ТипВозвращаемогоЗначения - Строка - Тип объекта MS
//  Параметр1..Параметр10 - Произвольный - Параметры, передаваемые из Mobile Smarts в 1С.
//  АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
//
// Возвращаемое значение:
//	    - Произвольный - данные, возвращаемые пользовательской функцией
//      - Строка - Текст ошибки в случае исключения
Функция ВызовПроизвольнойФункции(ИмяФункции, ТипВозвращаемогоЗначения = "",  
											Параметр1 = Неопределено,
											Параметр2 = Неопределено,
											Параметр3 = Неопределено,
											Параметр4 = Неопределено,
											Параметр5 = Неопределено,
											Параметр6 = Неопределено,
											Параметр7 = Неопределено,
											Параметр8 = Неопределено,
											Параметр9 = Неопределено,
											Параметр10 = Неопределено, АдресаПеременных = Неопределено) Экспорт	
	
	НачалоСобытия = ТекущаяУниверсальнаяДатаВМиллисекундах();
	ИмяСобытия = "ВызовПроизвольнойФункции";	
	
	ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Начало, Выполнение вызова произвольной функции: " + Строка(ИмяФункции), , АдресаПеременных);	
	///////////////////////////////
	ТипИнтерфейса = ГлЯдро_ПолучитьДанныеИзХранилища1С("Cleverence_ТипИнтерфейса");
		
	Если АдресаПеременных = Неопределено Тогда
		АдресаПеременных = КомЯдро_СоздатьСтруктуруАдресаПеременных();
	КонецЕсли;
	НастройкиИнициализированы = КомЯдро_ПолучитьЗначениеПеременной("НастройкиИнициализированы",АдресаПеременных);						
	
	НастройкиИзменились = ГлЯдро_НастройкиИзменились(АдресаПеременных);
	Если НастройкиИзменились
		ИЛИ НЕ НастройкиИнициализированы = Истина Тогда
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Предупреждение", "Переинициализация настроек. НастройкиИнициализированы = "+Строка(НастройкиИнициализированы)+", НастройкиИзменились = "+Строка(НастройкиИзменились),,АдресаПеременных);
		ГлЯдро_Инициализация(ИмяСобытия,НастройкиИзменились,,АдресаПеременных);		
	КонецЕсли;		
	///////////////////////////////
	СтруктураИО = КомЯдро_ПолучитьЗначениеПеременной("ИнтеграционнаяОбработка",АдресаПеременных);
		
	Если (СтруктураИО = Неопределено
		ИЛИ НЕ ТипЗнч(СтруктураИО) = Тип("Структура")
		ИЛИ НЕ СтруктураИО.Свойство("ИнтеграционнаяОбработка")
		ИЛИ СтруктураИО.ИнтеграционнаяОбработка = Неопределено)
		И НЕ ГлЯдро_ПересоздатьИнтеграционнуюОбработку(АдресаПеременных) Тогда
			ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Конец, Выполнение вызова произвольной функции: " + Строка(ИмяФункции), НачалоСобытия, АдресаПеременных);
		Возврат Неопределено;
	КонецЕсли;
	
	СтруктураИО = КомЯдро_ПолучитьЗначениеПеременной("ИнтеграционнаяОбработка",АдресаПеременных);
	ИнтеграционнаяОбработка = СтруктураИО.ИнтеграционнаяОбработка;
	
	СтруктураПараметров = Новый Структура;
	СтруктураПараметров.Вставить("Параметр1", Параметр1);
	СтруктураПараметров.Вставить("Параметр2", Параметр2);
	СтруктураПараметров.Вставить("Параметр3", Параметр3);
	СтруктураПараметров.Вставить("Параметр4", Параметр4);
	СтруктураПараметров.Вставить("Параметр5", Параметр5);
	СтруктураПараметров.Вставить("Параметр6", Параметр6);
	СтруктураПараметров.Вставить("Параметр7", Параметр7);
	СтруктураПараметров.Вставить("Параметр8", Параметр8);
	СтруктураПараметров.Вставить("Параметр9", Параметр9);
	СтруктураПараметров.Вставить("Параметр10", Параметр10);
	
	//////////////////////////////
	СтрокаПараметров = "";
	Инд = 10;	
	Пока Инд > 0 Цикл
		ИмяПараметра = "Параметр"+Строка(Инд);
		СтрокаВызова = "Параметры." + ИмяПараметра; 
		Параметр= ГлЯдро_ВычислитьВБезопасномРежиме(СтрокаВызова, СтруктураПараметров);
		Если Параметр <> Неопределено Тогда
			СтрокаПараметров = ","+ "Параметры." + ИмяПараметра + СтрокаПараметров;
		ИначеЕсли СтрокаПараметров <> "" Тогда
			СтрокаПараметров = ","+СтрокаПараметров;
		КонецЕсли;
		Инд = Инд - 1;
	КонецЦикла;
	Если Лев(СтрокаПараметров,1) = "," Тогда
		СтрокаПараметров = Прав(СтрокаПараметров, СтрДлина(СтрокаПараметров)-1);
	КонецЕсли;
	
	Если ИнтеграционнаяОбработка <> Неопределено Тогда
		Попытка
			СтрокаВызова = "Параметры.ИнтеграционнаяОбработка."+ИмяФункции+"("+СтрокаПараметров+")";
			СтруктураПараметров.Вставить("ИнтеграционнаяОбработка", ИнтеграционнаяОбработка);
			Результат = ГлЯдро_ВычислитьВБезопасномРежиме(СтрокаВызова, СтруктураПараметров);
			Если ТипЗнч(Результат) = Тип("ТаблицаЗначений") Тогда
				Результат = REST_API_ТаблицаЗначенийВМассивСтруктур(Результат);
			КонецЕсли;
			
			ЕстьСостав = Ложь;
			Если ЗначениеЗаполнено(ТипВозвращаемогоЗначения) Тогда
				Если ГлЯдро_СтрНайти(ТипВозвращаемогоЗначения,"Collection") > 0 Тогда
					ЕстьСостав = Истина;
				КонецЕсли;
			КонецЕсли;
			
			Результат = ГлЯдро_ПолучитьJSON(Результат, ТипВозвращаемогоЗначения, ЕстьСостав);
		Исключение			
			ТекстОшибки = "Ошибка при вызове функции: "+ Строка(ИмяФункции) +", "+ ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
			ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", ТекстОшибки, , АдресаПеременных);
			Результат = "#" + ТекстОшибки;
		КонецПопытки;	
	Иначе
		Результат = Неопределено;
	КонецЕсли;
	
	ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Конец, Выполнение вызова произвольной функции: " + Строка(ИмяФункции), НачалоСобытия, АдресаПеременных);
	
	Возврат Результат;
	
КонецФункции

Функция ПроверитьСоединение(Пауза = 0) Экспорт
	
	ИмяСобытия = "ПроверитьСоединение";
	НачалоСобытия = ТекущаяУниверсальнаяДатаВМиллисекундах();
	
	///////////////////////////////
	АдресаПеременных = КомЯдро_СоздатьСтруктуруАдресаПеременных();
	ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Начало", НачалоСобытия, АдресаПеременных);
	
	НастройкиИнициализированы = КомЯдро_ПолучитьЗначениеПеременной("НастройкиИнициализированы", АдресаПеременных);
	НастройкиИзменились = ГлЯдро_НастройкиИзменились(АдресаПеременных);
	Если НастройкиИзменились
		ИЛИ НЕ НастройкиИнициализированы = Истина Тогда
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Предупреждение", "Переинициализация настроек. НастройкиИнициализированы = " + Строка(НастройкиИнициализированы) + ", НастройкиИзменились = " + Строка(НастройкиИзменились), НачалоСобытия, АдресаПеременных);
		ГлЯдро_Инициализация(ИмяСобытия, НастройкиИзменились,, АдресаПеременных);
	КонецЕсли;
	///////////////////////////////
	
	ГлЯдро_Пауза(Пауза);
	ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Конец", НачалоСобытия, АдресаПеременных);
	
	Возврат Истина;
	
КонецФункции

Функция ОбновитьКешСессии(Пауза = 0) Экспорт
	
	ИмяСобытия = "ОбновитьКешСессии";
	НачалоСобытия = ТекущаяУниверсальнаяДатаВМиллисекундах();
	
	///////////////////////////////
	АдресаПеременных = КомЯдро_СоздатьСтруктуруАдресаПеременных();
	ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Начало", НачалоСобытия, АдресаПеременных);
	
	НастройкиИзменились = ГлЯдро_НастройкиИзменились(АдресаПеременных);
	ГлЯдро_Инициализация(ИмяСобытия, НастройкиИзменились,, АдресаПеременных);
	
	ГлЯдро_Пауза(Пауза);
	ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Конец", НачалоСобытия, АдресаПеременных);
	
	Возврат Истина;
	
КонецФункции

#КонецОбласти

#Область ВнешниеВызовы_ВспомогательныеМеханизмы

Функция ГлЯдро_ПроверитьНаличиеИсключительнойСитуацииONLEX()

	ОписаниеОшибки = ГлЯдро_ПолучитьДанныеИзХранилища1С("Cleverence_ОписаниеОшибкиONLEX");
	
	Если НЕ ТипЗнч(ОписаниеОшибки) = Тип("Структура") Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	КодОшибкиONLEX = Неопределено;
	Если ОписаниеОшибки.Свойство("КодОшибкиONLEX") И ЗначениеЗаполнено(ОписаниеОшибки.КодОшибкиONLEX) Тогда
		КодОшибкиONLEX = ОписаниеОшибки.КодОшибкиONLEX;	
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(КодОшибкиONLEX) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	СтруктураПараметровONLEX = Неопределено;
	Если ОписаниеОшибки.Свойство("СтруктураПараметровONLEX") И ЗначениеЗаполнено(ОписаниеОшибки.СтруктураПараметровONLEX) Тогда
		СтруктураПараметровONLEX = ОписаниеОшибки.СтруктураПараметровONLEX;	
	КонецЕсли;
	
	ГлЯдро_СохранитьДанныеВХранилище1С("Cleverence_ОписаниеОшибкиONLEX", Неопределено);
	
	Возврат ГлЯдро_ПолучитьТекстОшибкиONLEX(КодОшибкиONLEX, СтруктураПараметровONLEX);
	
КонецФункции

Функция ГлЯдро_ПолучитьТекстОшибкиONLEX(КодОшибки, СтруктураПараметров)

	ОписаниеОшибки = "Неизвестная ошибка";
	
	Если НЕ ЗначениеЗаполнено(КодОшибки) Тогда
		Возврат ОписаниеОшибки;
	КонецЕсли;
	
	СтрокаПодключения  	= "[не удалось определить строку подключения к базе Mobile SMARTS]";
	ИмяПользователяВ1С 	= "[не удалось определить имя пользователя]";
	ОшибкаПодключенияИО = "";
	
	Если ТипЗнч(СтруктураПараметров) = Тип("Структура") Тогда
		Если СтруктураПараметров.Свойство("СтрокаПодключения") И ЗначениеЗаполнено(СтруктураПараметров.СтрокаПодключения) Тогда
			СтрокаПодключения = СтруктураПараметров.СтрокаПодключения;
		КонецЕсли;	
		Если СтруктураПараметров.Свойство("ИмяПользователяВ1С") И ЗначениеЗаполнено(СтруктураПараметров.ИмяПользователяВ1С) Тогда
			ИмяПользователяВ1С = СтруктураПараметров.ИмяПользователяВ1С;
		КонецЕсли;
		Если СтруктураПараметров.Свойство("ОшибкаПодключенияИО") И ЗначениеЗаполнено(СтруктураПараметров.ОшибкаПодключенияИО) Тогда
			ОшибкаПодключенияИО = СтруктураПараметров.ОшибкаПодключенияИО;
			ЗавершающийСимвол = Прав(ОшибкаПодключенияИО, 1);
			Если НЕ (ЗавершающийСимвол = "." ИЛИ ЗавершающийСимвол = "!") Тогда
				ОшибкаПодключенияИО = ОшибкаПодключенияИО + ".";
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	КодыОшибок = Новый Структура;
	КодыОшибок.Вставить("ONLEX001", "Код ошибки: #ONLEX001. Загрузка данного документа в учетную систему - не произведена по причине отсутствия бизнес-процесса для него. Проверьте настройки бизнес-процессов в обработке для 1С общие или для выбранного торгового объекта - если используется. Подробнее смотрите на сайте по коду ошибки!");
	КодыОшибок.Вставить("ONLEX002", "Код ошибки: #ONLEX002. " + ?(ЗначениеЗаполнено(ОшибкаПодключенияИО), ОшибкаПодключенияИО, "Не подключена интеграционная обработка.") + " Подробнее смотрите на сайте по коду ошибки!");
	КодыОшибок.Вставить("ONLEX003", "Код ошибки: #ONLEX003. Не удалось подключиться к базе Mobile SMARTS: " + СтрокаПодключения + " по настройкам подключения в обработке КлеверенсТСД_ОсновнаяОбработка, пользователь: """ + ИмяПользователяВ1С + """! Подробнее смотрите на сайте по коду ошибки!");
	КодыОшибок.Вставить("ONLEX004", "Код ошибки: #ONLEX004. Не удалось распознать JSON во входящем параметре mXmlDoc. Возможно, в настройках базы Mobile SMARTS установлен режим XML. Проверьте настройки подключения в основной обработке и перезапустите сервер Mobile SMARTS. Подробнее смотрите на сайте по коду ошибки!");
	КодыОшибок.Вставить("ONLEX005", "Код ошибки: #ONLEX005. Серверу 1С не удается создать COM-компоненту Mobile SMARTS (StorageConnector) в расширении CleverenceWebExtension. Подробнее смотрите на сайте по коду ошибки!");
	
	Если КодыОшибок.Свойство(КодОшибки) Тогда
		ОписаниеОшибки = КодыОшибок[КодОшибки];
		
		// Экранирование символов
		ОписаниеОшибки = СтрЗаменить(ОписаниеОшибки, "\", "\\");
	КонецЕсли;
	
	Возврат ОписаниеОшибки;
	
КонецФункции

Функция ГлЯдро_ПолучитьТекстовоеПредставлениеПараметров(СтруктураПараметров)
	
	ПредставлениеПараметров	= "";
	
	ПараметрНоменклатуры 	= Неопределено;
	ПараметрУпаковки 		= Неопределено;
	
	Если СтруктураПараметров.Свойство("ПараметрНоменклатуры", ПараметрНоменклатуры) И ЗначениеЗаполнено(ПараметрНоменклатуры) Тогда
		ТекстПараметрНоменклатуры = "";
		Если ТипЗнч(ПараметрНоменклатуры) = Тип("Строка") Тогда
			ТекстПараметрНоменклатуры = ПараметрНоменклатуры;
		ИначеЕсли ТипЗнч(ПараметрНоменклатуры) = Тип("Массив") И ПараметрНоменклатуры.Количество() Тогда
			КоличествоЭлементов = ПараметрНоменклатуры.Количество();
			КоличествоВыводить = Мин(КоличествоЭлементов - 1, 1);
			
			Для Индекс = 0 ПО КоличествоВыводить Цикл
				Номенклатура = ПараметрНоменклатуры.Получить(Индекс);
				ТекстПараметрНоменклатуры = ТекстПараметрНоменклатуры + ?(Индекс = 0, "", " ,") + СокрЛП(Номенклатура);
			КонецЦикла;
			ТекстПараметрНоменклатуры = ТекстПараметрНоменклатуры 
				+ ?(КоличествоЭлементов > КоличествоВыводить + 1, "...", "") 
				+ " (" + Формат(КоличествоЭлементов, "ЧГ=0") + " шт.)";
		ИначеЕсли ТипЗнч(ПараметрНоменклатуры) = Тип("COMSafeArray") И ПараметрНоменклатуры.GetLength() Тогда
			КоличествоЭлементов = ПараметрНоменклатуры.GetLength();
			КоличествоВыводить = Мин(КоличествоЭлементов - 1, 1);
			
			Для Индекс = 0 ПО КоличествоВыводить Цикл
				Номенклатура = ПараметрНоменклатуры.GetValue(Индекс);
				ТекстПараметрНоменклатуры = ТекстПараметрНоменклатуры + ?(Индекс = 0, "", " ,") + СокрЛП(Номенклатура);
			КонецЦикла;
			ТекстПараметрНоменклатуры = ТекстПараметрНоменклатуры 
				+ ?(КоличествоЭлементов > КоличествоВыводить + 1, "...", "") 
				+ " (" + Формат(КоличествоЭлементов, "ЧГ=0") + " шт.)";
		ИначеЕсли ТипЗнч(ПараметрНоменклатуры) = Тип("Соответствие") Тогда 
			МассивНоменклатуры = ПараметрНоменклатуры.Получить("$values");
			
			КоличествоЭлементов = МассивНоменклатуры.Количество();
			КоличествоВыводить = Мин(КоличествоЭлементов - 1, 1);
			
			Если КоличествоЭлементов Тогда
				Для Индекс = 0 ПО КоличествоВыводить Цикл
					Номенклатура = МассивНоменклатуры.Получить(Индекс);
					ТекстПараметрНоменклатуры = ТекстПараметрНоменклатуры + ?(Индекс = 0, "", " ,") + СокрЛП(Номенклатура);
				КонецЦикла;
				ТекстПараметрНоменклатуры = ТекстПараметрНоменклатуры 
					+ ?(КоличествоЭлементов > КоличествоВыводить + 1, "...", "") 
					+ " (" + Формат(КоличествоЭлементов, "ЧГ=0") + " шт.)";
			КонецЕсли;
		КонецЕсли;
		Если ЗначениеЗаполнено(ТекстПараметрНоменклатуры) Тогда
			ПредставлениеПараметров = ПредставлениеПараметров + ", ПараметрНоменклатуры: " + ТекстПараметрНоменклатуры;
		КонецЕсли;
	КонецЕсли;
	
	Если СтруктураПараметров.Свойство("ПараметрУпаковки", ПараметрУпаковки) И ЗначениеЗаполнено(ПараметрУпаковки) Тогда
		ТекстПараметрУпаковки = "";
		Если ТипЗнч(ПараметрУпаковки) = Тип("Строка") Тогда
			ТекстПараметрУпаковки = ПараметрУпаковки;
		ИначеЕсли ТипЗнч(ПараметрУпаковки) = Тип("Массив") И ПараметрУпаковки.Количество() Тогда
			КоличествоЭлементов = ПараметрУпаковки.Количество();
			КоличествоВыводить = Мин(КоличествоЭлементов - 1, 1);
			
			Для Индекс = 0 ПО КоличествоВыводить Цикл
				Упаковка = ПараметрУпаковки.Получить(Индекс);
				ТекстПараметрУпаковки = ТекстПараметрУпаковки + ?(Индекс = 0, "", " ,") + СокрЛП(Упаковка);
			КонецЦикла;
			ТекстПараметрУпаковки = ТекстПараметрУпаковки
				+ ?(КоличествоЭлементов > КоличествоВыводить + 1, "...", "") 
				+ " (" + Формат(КоличествоЭлементов, "ЧГ=0") + " шт.)";
		ИначеЕсли ТипЗнч(ПараметрУпаковки) = Тип("COMSafeArray") И ПараметрУпаковки.GetLength() Тогда
			КоличествоЭлементов = ПараметрУпаковки.GetLength();
			КоличествоВыводить = Мин(КоличествоЭлементов - 1, 1);
			
			Для Индекс = 0 ПО КоличествоВыводить Цикл
				Упаковка = ПараметрУпаковки.GetValue(Индекс);
				ТекстПараметрУпаковки = ТекстПараметрУпаковки + ?(Индекс = 0, "", " ,") + СокрЛП(Упаковка);
			КонецЦикла;
			ТекстПараметрУпаковки = ТекстПараметрУпаковки
				+ ?(КоличествоЭлементов > КоличествоВыводить + 1, "...", "") 
				+ " (" + Формат(КоличествоЭлементов, "ЧГ=0") + " шт.)";
		ИначеЕсли ТипЗнч(ПараметрУпаковки) = Тип("Соответствие") Тогда 
			МассивУпаковок = ПараметрУпаковки.Получить("$values");
			
			КоличествоЭлементов = МассивУпаковок.Количество();
			КоличествоВыводить = Мин(КоличествоЭлементов - 1, 1);
			
			Если КоличествоЭлементов Тогда
				Для Индекс = 0 ПО КоличествоВыводить Цикл
					Упаковка = МассивУпаковок.Получить(Индекс);
					ТекстПараметрУпаковки = ТекстПараметрУпаковки + ?(Индекс = 0, "", " ,") + СокрЛП(Упаковка);
				КонецЦикла;
				ТекстПараметрУпаковки = ТекстПараметрУпаковки
					+ ?(КоличествоЭлементов > КоличествоВыводить + 1, "...", "") 
					+ " (" + Формат(КоличествоЭлементов, "ЧГ=0") + " шт.)";
			КонецЕсли;
		КонецЕсли;
		Если ЗначениеЗаполнено(ТекстПараметрУпаковки) Тогда
			ПредставлениеПараметров = ПредставлениеПараметров + ", ПараметрУпаковки: " + ТекстПараметрУпаковки;
		КонецЕсли;
	КонецЕсли;	
	
	Возврат ПредставлениеПараметров;
	
КонецФункции

// Представление имени типа документа Mobile SMARTS с пробелами в виде, доступном для использования в 1С
// Пример: "Документ с некорректным именем" преобразуется в "ДокументСНекорректнымИменем"
//
Функция ГлЯдро_ПреобразованиеНаименованияДокументаБезПробелов(ИмяДокумента)
	
	МассивЭлементовИмени = ГлЯдро_РазложитьСтрокуВМассивПодстрок(ИмяДокумента, " ");
	Если МассивЭлементовИмени.Количество() = 1 Тогда
		Возврат ИмяДокумента;
	КонецЕсли;
	
	НовоеНаименование = "";
	
	Для Каждого Слово Из МассивЭлементовИмени Цикл
		ПерваяБуква = Лев(Слово, 1);
		ОстальнаяЧастьСлова = Прав(Слово, СтрДлина(Слово) - 1);
		НовоеНаименование = НовоеНаименование + ВРег(ПерваяБуква) + ОстальнаяЧастьСлова;
	КонецЦикла;
	
	Возврат НовоеНаименование;
	
КонецФункции

Процедура ГлЯдро_УдалитьПостфиксыУпаковок(ПараметрУпаковки)

	Если НЕ ЗначениеЗаполнено(ПараметрУпаковки) Тогда
		Возврат;
	КонецЕсли;
	
	Если ТипЗнч(ПараметрУпаковки) = Тип("Строка") Тогда
		ПозицияПодчеркивания = ГлЯдро_СтрНайти(ПараметрУпаковки, "_");
		Если ПозицияПодчеркивания > 0 Тогда
			ПараметрУпаковки = Лев(ПараметрУпаковки, ПозицияПодчеркивания - 1);
		КонецЕсли;
	ИначеЕсли ТипЗнч(ПараметрУпаковки) = Тип("Массив") Тогда
		Для каждого Упаковка ИЗ ПараметрУпаковки Цикл
			ПозицияПодчеркивания = ГлЯдро_СтрНайти(Упаковка, "_");
			Если ПозицияПодчеркивания > 0 Тогда
				Упаковка = Лев(Упаковка, ПозицияПодчеркивания - 1);
			КонецЕсли;					
		КонецЦикла;
	ИначеЕсли ТипЗнч(ПараметрУпаковки) = Тип("COMSafeArray") Тогда
		КоличествоЭлементов = ПараметрУпаковки.GetLength();
		Для Индекс = 0 ПО КоличествоЭлементов - 1 Цикл
			Упаковка = ПараметрУпаковки.GetValue(Индекс);
			ПозицияПодчеркивания = ГлЯдро_СтрНайти(Упаковка, "_");
			Если ПозицияПодчеркивания > 0 Тогда
				Упаковка = Лев(Упаковка, ПозицияПодчеркивания - 1);
				ПараметрУпаковки.SetValue(Индекс, Упаковка);
			КонецЕсли;					
		КонецЦикла;
	ИначеЕсли ТипЗнч(ПараметрУпаковки) = Тип("Соответствие") Тогда 
		МассивУпаковок = ПараметрУпаковки.Получить("$values");
		Для каждого Упаковка ИЗ МассивУпаковок Цикл
			ПозицияПодчеркивания = ГлЯдро_СтрНайти(Упаковка, "_");
			Если ПозицияПодчеркивания > 0 Тогда
				Упаковка = Лев(Упаковка, ПозицияПодчеркивания - 1);
			КонецЕсли;					
		КонецЦикла;
		ПараметрУпаковки.Вставить("$values", МассивУпаковок);
	КонецЕсли;

КонецПроцедуры

Функция ГлЯдро_ПолучитьДанныеТаблицыПоАртикулуКодуШК(ПараметрНоменклатуры, НастройкиКомпоновщика, ПараметрыУзлов, ПараметрыОнлайн, РаботаБезАлкоголя, ПараметрыВыгрузки, АдресаПеременных)
	
	Если СтрДлина(ПараметрНоменклатуры) <> 14 Тогда
		Возврат Новый ТаблицаЗначений;
	КонецЕсли;
			
	Если Лев(ПараметрНоменклатуры, 1) <> "0" Тогда
		ТаблицаТоваров = ГлЯдро_ПолучитьДанныеТаблицыДляВыгрузкиНаСерверSMARTS("Номенклатура", НастройкиКомпоновщика, ПараметрыУзлов, ПараметрыОнлайн, РаботаБезАлкоголя, ПараметрыВыгрузки, АдресаПеременных);
		Если ТаблицаТоваров.Количество() Тогда
			Возврат ТаблицаТоваров;
		Иначе
			ПараметрНоменклатуры = ГлЯдро_ПреобразоватьGTIN_В_EAN(ПараметрНоменклатуры);
			СтруктураШтрихкода 	 = ГлЯдро_ПолучитьСтруктуруШтрихкодаEAN13(ПараметрНоменклатуры, АдресаПеременных);
			
			ПараметрыОнлайн.Вставить("ПараметрНоменклатуры", ПараметрНоменклатуры);
			ПараметрыОнлайн.Вставить("СтруктураШтрихкода",   СтруктураШтрихкода);
		КонецЕсли;				
	КонецЕсли;			
			
	// При сканировании кода маркировки может прийти 14-значный GTIN с 0 впереди, а в 1С храниться только 8-значный EAN8 или 13-значный EAN13		
	Количество0 = 0;
	Если Лев(ПараметрНоменклатуры, 6) = "000000" Тогда
		Количество0 = 6;
	ИначеЕсли Лев(ПараметрНоменклатуры, 1) = "0" Тогда
		Количество0 = 1;
	КонецЕсли;

	КодСтрока = ПараметрыОнлайн.СтруктураШтрихкода.КодСтрока;
	
	Если Количество0 Тогда
		ПараметрНоменклатурыБез0 = Прав(ПараметрНоменклатуры, 14 - Количество0);
		ПараметрыОнлайн.Вставить("ПараметрНоменклатуры", ПараметрНоменклатурыБез0);
		ПараметрыОнлайн.СтруктураШтрихкода.Вставить("КодСтрока", ПараметрНоменклатурыБез0);
					
		ТаблицаТоваров = ГлЯдро_ПолучитьДанныеТаблицыДляВыгрузкиНаСерверSMARTS("Номенклатура", НастройкиКомпоновщика, ПараметрыУзлов, ПараметрыОнлайн, РаботаБезАлкоголя, ПараметрыВыгрузки, АдресаПеременных);
		
		Если НЕ ТаблицаТоваров.Количество() Тогда
			ПараметрыОнлайн.Вставить("ПараметрНоменклатуры", ПараметрНоменклатуры);
			ПараметрыОнлайн.СтруктураШтрихкода.Вставить("КодСтрока", КодСтрока);
						
			ТаблицаТоваров = ГлЯдро_ПолучитьДанныеТаблицыДляВыгрузкиНаСерверSMARTS("Номенклатура", НастройкиКомпоновщика, ПараметрыУзлов, ПараметрыОнлайн, РаботаБезАлкоголя, ПараметрыВыгрузки, АдресаПеременных);	
		КонецЕсли;
	Иначе				
		ТаблицаТоваров = ГлЯдро_ПолучитьДанныеТаблицыДляВыгрузкиНаСерверSMARTS("Номенклатура", НастройкиКомпоновщика, ПараметрыУзлов, ПараметрыОнлайн, РаботаБезАлкоголя, ПараметрыВыгрузки, АдресаПеременных);	
	КонецЕсли;
	
	Возврат ТаблицаТоваров;	

КонецФункции

#КонецОбласти

#Область REST_API

Функция REST_API_ПолучитьОписаниеБазы(ТипБазы,АдресаПеременных)
	
	ИмяСобытия = "REST_API_ПолучитьОписаниеБазы";
	
	Если ТипБазы = "Частная" Тогда
		КлючПеременной = "REST_API_СтруктураПодключенияЧастнойБазыMS";
	ИначеЕсли ТипБазы = "Временная" Тогда
		КлючПеременной = "REST_API_СтруктураПодключенияВременнойБазыMS";
	Иначе
		КлючПеременной = "REST_API_СтруктураПодключенияБазыMS";
	КонецЕсли;
	
	СтруктураПодключения = КомЯдро_ПолучитьЗначениеПеременной(КлючПеременной,АдресаПеременных); 
	
	Если СтруктураПодключения = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключения,Новый Структура("HTTPМетод,Метод,ТипЗапроса","GET","BaseInfo","ПолучениеМетаданных"),,АдресаПеременных);
	
	Если СтруктураОтвета.КодСостояния <> 200 Тогда
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Запрос: GET, BaseInfo. Получен некорректный ответ от сервера, Код состояния: " + Строка(СтруктураОтвета.КодСостояния)+ ". Содержание ошибки: " + Строка(СтруктураОтвета.ТекстОшибки),,АдресаПеременных);
		Возврат Неопределено;
	КонецЕсли;
	
	Если НЕ СтруктураОтвета.Свойство("ОтветСервера") Тогда
		ТекстОшибки = "Произошла ошибка при подключении к базе Mobile SMARTS. Подробности см. в журнале регистрации";
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Запрос: GET, BaseInfo. " + ТекстОшибки,, АдресаПеременных);
		Возврат Неопределено;
	КонецЕсли;
	
	СтрокаПодключения = СтруктураПодключения.СтрокаПодключенияСМАРТС;
	
	ОписаниеБазы = СтруктураОтвета.ОтветСервера;	
	СтруктураДанныеБазы = Новый Структура;
	
	СтруктураДанныеБазы.Вставить("Ид", ОписаниеБазы.Получить("id"));
	СтруктураДанныеБазы.Вставить("Имя", ОписаниеБазы.Получить("name"));
	СтруктураДанныеБазы.Вставить("Комментарий", ОписаниеБазы.Получить("comment"));
	СтруктураДанныеБазы.Вставить("СтрокаПодключения", СтрокаПодключения);
	СтруктураДанныеБазы.Вставить("РабочийКаталог", ОписаниеБазы.Получить("folder"));
	СтруктураДанныеБазы.Вставить("ИдПриложения", ОписаниеБазы.Получить("appId"));		
	СтруктураДанныеБазы.Вставить("ИмяПриложения", ОписаниеБазы.Получить("appName"));
	СтруктураДанныеБазы.Вставить("УровеньПриложения", 100);//ОписаниеБазы.Получить("appLevel")); Пока не реализованно
	СтруктураДанныеБазы.Вставить("ИдОсновногоПриложения", Неопределено);//ОписаниеБазы.Приложение.ParentId); Пока не реализованно
	СтруктураДанныеБазы.Вставить("ПапкаОбмена", "");//НастройкиБазыСМАРТС.ПолучитьТекущуюПапкуОбмена()); Пока не реализованно
	ИнформацияОПродукте = ГлЯдро_ПолучитьИнформациюОПродукте(СтруктураДанныеБазы.ИдПриложения,СтруктураДанныеБазы.ИдОсновногоПриложения);
	СтруктураДанныеБазы.Вставить("УровеньПриложенияСтрокой",	?(ЗначениеЗаполнено(ИнформацияОПродукте.УровеньПриложения), ИнформацияОПродукте.УровеньПриложения, ГлЯдро_ПолучитьУровеньПриложения(СтруктураДанныеБазы.УровеньПриложения)));
	СтруктураДанныеБазы.Вставить("ТипУстановленногоПродукта",	ИнформацияОПродукте.ТипУстановленногоПродукта);
	СтруктураДанныеБазы.Вставить("АвторизацияВключена", 		Ложь);
	СтруктураДанныеБазы.Вставить("АвторизацияЛогин", 			"");
	СтруктураДанныеБазы.Вставить("АвторизацияТокен", 			"");
	СтруктураДанныеБазы.Вставить("АвторизацияРефрешТокен",		"");
	СтруктураДанныеБазы.Вставить("СтрокаПодключенияСМАРТС",		СтрокаПодключения);
	СтруктураДанныеБазы.Вставить("IdBaseSMARTS", 				ОписаниеБазы.Получить("id"));
	СтруктураДанныеБазы.Вставить("QR", 							ОписаниеБазы.Получить("connectionQRCode"));
	СтруктураДанныеБазы.Вставить("ВерсияПриложения", 			ОписаниеБазы.Получить("appDescription").Получить("appVersion"));
	СтруктураДанныеБазы.Вставить("ВерсияКонфигурацииSMARTS",	ОписаниеБазы.Получить("configurationVersion"));
	
	Если НЕ ЗначениеЗаполнено(СтруктураДанныеБазы.ИмяПриложения) Тогда
		СтруктураДанныеБазы.Вставить("ИмяПриложения", ОписаниеБазы.Получить("appDescription").Получить("appName"));	
	КонецЕсли;
	
	appInstanceSettings = ОписаниеБазы.Получить("appInstanceSettings");
	Если appInstanceSettings <> Неопределено Тогда
		// СтруктураДанныеБазы.АвторизацияВключена = appInstanceSettings.Получить("hasServerAuth"); // Устаревшее свойство
		mode = appInstanceSettings.Получить("mode");
		СтруктураДанныеБазы.Вставить("РаботаСУстройствомНапрямую", mode = "Device");
		СтруктураДанныеБазы.Вставить("РаботаСКаталогом", mode = "Folder");
		СтруктураДанныеБазы.Вставить("РаботаССервером", mode = "Server");
		СтруктураДанныеБазы.Вставить("РаботаСЛокальнымСервером", Неопределено);
		СтруктураДанныеБазы.Вставить("РаботаСУдаленнымСервером", Неопределено);
	КонецЕсли;
	
	Если СтруктураПодключения.Свойство("АвторизацияВключена")
		И СтруктураПодключения.АвторизацияВключена = Истина Тогда
		СтруктураДанныеБазы.АвторизацияВключена = Истина;
		Если СтруктураПодключения.Свойство("АвторизацияЛогин") Тогда
			СтруктураДанныеБазы.АвторизацияЛогин = СтруктураПодключения.АвторизацияЛогин;
		КонецЕсли;
		Если СтруктураПодключения.Свойство("АвторизацияТокен") Тогда
			СтруктураДанныеБазы.АвторизацияТокен = СтруктураПодключения.АвторизацияТокен;
		КонецЕсли;
		Если СтруктураПодключения.Свойство("АвторизацияРефрешТокен") Тогда
			СтруктураДанныеБазы.АвторизацияРефрешТокен = СтруктураПодключения.АвторизацияРефрешТокен;
		КонецЕсли;
	КонецЕсли;
	
	СтруктураНастроек = Новый Структура;
	СтруктураНастроек.Вставить("ИмяИнтеграционнойОбработкиКонфигурации1С", 	Неопределено);
	СтруктураНастроек.Вставить("ПутьИнтеграционнойОбработкиКонфигурации1С", Неопределено);
	СтруктураНастроек.Вставить("ТипОбработки", 								Неопределено);
	СтруктураНастроек.Вставить("ПутьОсновнойОбработки", 					Неопределено);
	СтруктураНастроек.Вставить("ТипОсновнойОбработки", 						Неопределено);
	
	REST_API_ЗаполнитьНастройкиSMARTS(СтруктураНастроек, Новый Массив,,, СтруктураПодключения, АдресаПеременных);
	
	ИмяИнтеграционнойОбработки 	= СтруктураНастроек.ИмяИнтеграционнойОбработкиКонфигурации1С;
	ПутьИнтеграционнойОбработки = СтруктураНастроек.ПутьИнтеграционнойОбработкиКонфигурации1С;
	ТипОбработки 				= СтруктураНастроек.ТипОбработки;
	ПутьОсновнойОбработки 		= СтруктураНастроек.ПутьОсновнойОбработки;
	ТипОсновнойОбработки 		= СтруктураНастроек.ТипОсновнойОбработки;
		
	Если ТипОбработки = "СправочникСсылка" Тогда
		Попытка
			ПутьИО = ГлЯдро_ЗначениеИзСтрокиXML(ПутьИнтеграционнойОбработки);
		Исключение
			ПутьИО = Неопределено;
		КонецПопытки;
	Иначе
		ПутьИО = ПутьИнтеграционнойОбработки;
	КонецЕсли;
	
	//Заплатка
	Если ТипЗнч(ПутьИО) = Тип("COMОбъект") Тогда
		ПутьИО = Неопределено;
	КонецЕсли;
	
	СтруктураДанныеБазы.Вставить("ТипОбработки",				ТипОбработки);
	СтруктураДанныеБазы.Вставить("ИмяИнтеграционнойОбработки", 	?(НЕ ЗначениеЗаполнено(ИмяИнтеграционнойОбработки), "", ИмяИнтеграционнойОбработки));
	СтруктураДанныеБазы.Вставить("ПутьИнтеграционнойОбработки", ?(НЕ ЗначениеЗаполнено(ИмяИнтеграционнойОбработки),"\Обработки 1С\Обработки интеграции\", ПутьИО));		
	
	Если ТипОсновнойОбработки = "СправочникСсылка" Тогда
		Попытка
			ПутьОО = ГлЯдро_ЗначениеИзСтрокиXML(ПутьОсновнойОбработки);
		Исключение
			ПутьОО = Неопределено;
		КонецПопытки;
	Иначе
		ПутьОО = ПутьОсновнойОбработки;
	КонецЕсли;
	
	//Заплатка
	Если ТипЗнч(ПутьОО) = Тип("COMОбъект") Тогда
		ПутьОО = Неопределено;
	КонецЕсли;
	
	СтруктураДанныеБазы.Вставить("ТипОсновнойОбработки", 	ТипОсновнойОбработки);
	СтруктураДанныеБазы.Вставить("ПутьОсновнойОбработки", 	ПутьОО);		
	
	Возврат СтруктураДанныеБазы;
	
КонецФункции

Функция REST_API_ПолучитьЗначениеНастройкиБазыSMARTS(СтруктураПодключения,КлючНастройки,АдресаПеременных)
	
	СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключения,Новый Структура("HTTPМетод,Метод,ТипЗапроса","GET",?(ЗначениеЗаполнено(КлючНастройки),"CustomSettings('"+КлючНастройки+"')","CustomSettings"),"ПолучениеСохранениеНастроек"),,АдресаПеременных);
	
	Если СтруктураОтвета.КодСостояния <> 200 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат СтруктураОтвета.ОтветСервера.Получить("value");	
	
КонецФункции

Функция REST_API_ЗаполнитьНастройкиSMARTS(СтруктураНастроек, УзловыеНастройки, ID_Узла = "", ТипБазы = "Основная", СтруктураПодключения = Неопределено, АдресаПеременных)
	
	ИмяСобытия = "REST_API_ЗаполнитьНастройкиSMARTS";
	
	Если СтруктураПодключения = Неопределено Тогда
		Если ТипБазы = "Частная" Тогда
			КлючПеременной = "REST_API_СтруктураПодключенияЧастнойБазыMS";
		ИначеЕсли ТипБазы = "Временная" Тогда
			КлючПеременной = "REST_API_СтруктураПодключенияВременнойБазыMS";
		Иначе
			КлючПеременной = "REST_API_СтруктураПодключенияБазыMS";
		КонецЕсли;
		
		СтруктураПодключения = КомЯдро_ПолучитьЗначениеПеременной(КлючПеременной,АдресаПеременных); 
	КонецЕсли;
	
	Если СтруктураПодключения = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	//Пока не реализованно получение настроек по умолчанию
	Если Ложь И СтруктураНастроек.Количество() > 3 Тогда
		СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключения,Новый Структура("HTTPМетод,Метод,ТипЗапроса","GET","CustomSettings","ПолучениеСохранениеНастроек"),,АдресаПеременных);
		
		Если СтруктураОтвета.КодСостояния <> 200 Тогда
			ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Запрос: GET, CustomSettings. Получен некорректный ответ от сервера, Код состояния: " + Строка(СтруктураОтвета.КодСостояния)+ ". Содержание ошибки: " + Строка(СтруктураОтвета.ТекстОшибки),,АдресаПеременных);
			Возврат Неопределено;
		КонецЕсли;
		
		МассивНастроек = СтруктураОтвета.ОтветСервера.Получить("value");	
		Для каждого СоответствиеНастройка Из МассивНастроек Цикл
			ИтоговыйКлючНастройки = СоответствиеНастройка.Получить("name");
			Если УзловыеНастройки.Найти(ИтоговыйКлючНастройки) <> Неопределено Тогда
				ИтоговыйКлючНастройки = ИтоговыйКлючНастройки + ?(ID_Узла = "", "", "_"+ ID_Узла);
			КонецЕсли;
			
			Если СтруктураНастроек.Свойство(ИтоговыйКлючНастройки) Тогда
				ЗначениеНастройки = СоответствиеНастройка.Получить("value");
				// Для совместимости со старыми настройками
				Если ЗначениеНастройки = Неопределено 
					И Найти(ИтоговыйКлючНастройки,"ПроизвольныеКоды_")  > 0  Тогда
					ЗначениеНастройки = REST_API_ПолучитьЗначениеНастройкиБазыSMARTS(СтруктураПодключения,СтрЗаменить(ИтоговыйКлючНастройки,"ПроизвольныеКоды_","ПроизвольныйКод_"),АдресаПеременных);
				КонецЕсли;			
				// Для совместимости со старыми настройками
				Если ЗначениеНастройки = "Да" Тогда
					ЗначениеНастройки = Истина;
				ИначеЕсли ЗначениеНастройки = "Нет" Тогда
					ЗначениеНастройки = Ложь;	
				КонецЕсли;
				СтруктураНастроек.Вставить(ИтоговыйКлючНастройки,ЗначениеНастройки);	
			КонецЕсли;
		КонецЦикла;
	ИначеЕсли СтруктураНастроек.Количество() > 3 Тогда
		//Получение настроек по фильтру
		СтрокаФильтра = "?$filter=";
		ПервыйПараметр = Истина;
		Икс=0;
		МассивНастроек = Новый Массив;
		Для Каждого Настройка Из СтруктураНастроек Цикл
			ИтоговыйКлючНастройки = Настройка.Ключ;
			Если УзловыеНастройки.Найти(Настройка.Ключ) <> Неопределено Тогда
				ИтоговыйКлючНастройки = ИтоговыйКлючНастройки + ?(ID_Узла = "", "", "_"+ ID_Узла);
			КонецЕсли;
			СтрокаФильтра = СтрокаФильтра + ?(НЕ ПервыйПараметр ," or ", "") + "name eq '"+ ИтоговыйКлючНастройки + "'";
			Если ПервыйПараметр Тогда
				ПервыйПараметр = Ложь;
			КонецЕсли;
			Икс=Икс+1;
			Если Икс = 10 ИЛИ Икс = СтруктураНастроек.Количество() Тогда
				Если СтрокаФильтра = "?$filter=" Тогда
					ПервыйПараметр = Истина;
					Икс = 0;	
					Продолжить;
				КонецЕсли;
				СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключения,Новый Структура("HTTPМетод,Метод,ТипЗапроса","GET","CustomSettings"+СтрокаФильтра,"ПолучениеСохранениеНастроек"),,АдресаПеременных);
				СтрокаФильтра = "?$filter=";
				ПервыйПараметр = Истина;
				Икс=0;
				Если СтруктураОтвета.КодСостояния <> 200 Тогда
					Продолжить;
				КонецЕсли;
				МассивРезультат = СтруктураОтвета.ОтветСервера.Получить("value");
				Для каждого Настройка из МассивРезультат Цикл
					МассивНастроек.Добавить(Настройка);
				КонецЦикла;
			КонецЕсли;
		КонецЦикла;
		
		Если СтрокаФильтра <> "?$filter=" Тогда
			СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключения,Новый Структура("HTTPМетод,Метод,ТипЗапроса","GET","CustomSettings"+СтрокаФильтра, "ПолучениеСохранениеНастроек"),,АдресаПеременных);
			
			Если СтруктураОтвета.КодСостояния <> 200 Тогда
				ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Запрос: GET, CustomSettings" + СтрокаФильтра + ". Получен некорректный ответ от сервера, Код состояния: " + Строка(СтруктураОтвета.КодСостояния)+ ". Содержание ошибки: " + Строка(СтруктураОтвета.ТекстОшибки),,АдресаПеременных);
				//Возврат Неопределено;
			Иначе
				МассивРезультат = СтруктураОтвета.ОтветСервера.Получить("value");
				Для каждого Настройка из МассивРезультат Цикл
					МассивНастроек.Добавить(Настройка);
				КонецЦикла;	
			КонецЕсли;
		КонецЕсли;
		
		Для каждого СоответствиеНастройка Из МассивНастроек Цикл
			ИтоговыйКлючНастройки = СоответствиеНастройка.Получить("name");
			//Если УзловыеНастройки.Найти(ИтоговыйКлючНастройки) <> Неопределено Тогда
			//	ИтоговыйКлючНастройки = ИтоговыйКлючНастройки + ?(ID_Узла = "", "", "_"+ ID_Узла);
			//КонецЕсли;
			Если ID_Узла <> "" Тогда
				ИтоговыйКлючНастройки = СтрЗаменить(ИтоговыйКлючНастройки, "_"+ ID_Узла, "");
			КонецЕсли;
			
			Если СтруктураНастроек.Свойство(ИтоговыйКлючНастройки) Тогда
				ЗначениеНастройки = СоответствиеНастройка.Получить("value");
				// Для совместимости со старыми настройками
				Если ЗначениеНастройки = Неопределено 
					И Найти(ИтоговыйКлючНастройки,"ПроизвольныеКоды_")  > 0  Тогда
					ЗначениеНастройки = REST_API_ПолучитьЗначениеНастройкиБазыSMARTS(СтруктураПодключения,СтрЗаменить(ИтоговыйКлючНастройки,"ПроизвольныеКоды_","ПроизвольныйКод_"),АдресаПеременных);
				КонецЕсли;			
				// Для совместимости со старыми настройками
				Если ЗначениеНастройки = "Да" Тогда
					ЗначениеНастройки = Истина;
				ИначеЕсли ЗначениеНастройки = "Нет" Тогда
					ЗначениеНастройки = Ложь;	
				КонецЕсли;
				СтруктураНастроек.Вставить(ИтоговыйКлючНастройки, ЗначениеНастройки);
			КонецЕсли;
		КонецЦикла;
	Иначе
		Для Каждого Настройка Из СтруктураНастроек Цикл
			ИтоговыйКлючНастройки = Настройка.Ключ;
			Если УзловыеНастройки.Найти(Настройка.Ключ) <> Неопределено Тогда
				ИтоговыйКлючНастройки = ИтоговыйКлючНастройки + ?(ID_Узла = "", "", "_"+ ID_Узла);
			КонецЕсли;
			ЗначениеНастройки = REST_API_ПолучитьЗначениеНастройкиБазыSMARTS(СтруктураПодключения,ИтоговыйКлючНастройки,АдресаПеременных);
			// Для совместимости со старыми настройками
			Если ЗначениеНастройки = Неопределено 
				И Найти(ИтоговыйКлючНастройки,"ПроизвольныеКоды_")  > 0  Тогда
				ЗначениеНастройки = REST_API_ПолучитьЗначениеНастройкиБазыSMARTS(СтруктураПодключения,СтрЗаменить(ИтоговыйКлючНастройки,"ПроизвольныеКоды_","ПроизвольныйКод_"),АдресаПеременных);
			КонецЕсли;			
			// Для совместимости со старыми настройками
			Если ЗначениеНастройки = "Да" Тогда
				ЗначениеНастройки = Истина;
			ИначеЕсли ЗначениеНастройки = "Нет" Тогда
				ЗначениеНастройки = Ложь;	
			КонецЕсли;	
			СтруктураНастроек.Вставить(Настройка.Ключ, ?(ЗначениеНастройки = Неопределено, Ложь, ЗначениеНастройки));
		КонецЦикла;
	КонецЕсли;
	
	Возврат СтруктураНастроек;
	
КонецФункции

Функция REST_API_ПолучитьТокенSMARTS(СтрокаПодключения,Логин,Пароль,ТипБазы,АдресаПеременных)
	
	ИмяСобытия = "REST_API_ПолучитьТокенSMARTS";
	
	СтруктураURI = REST_API_ПолучитьСтруктуруURIИзСтроки(СтрокаПодключения);
	
	СтруктураПодключения = Новый Структура;
	СтруктураПодключения.Вставить("СтрокаПодключенияСМАРТС", СтрокаПодключения);
	
	Заголовки = Новый Соответствие();
	Заголовки.Вставить("Content-Type", "application/x-www-form-urlencoded");
	
	СтруктураЗапроса = Новый Структура;
	СтруктураЗапроса.Вставить("HTTPМетод", 		"POST");
	СтруктураЗапроса.Вставить("Метод", 	   		"connect/token");
	СтруктураЗапроса.Вставить("Заголовки", 		Заголовки);
	СтруктураЗапроса.Вставить("ВерсияAPI", 		"");
	СтруктураЗапроса.Вставить("СтрокаЗапроса",	"<Авторизация Mobile SMARTS>");
	
	ОтправляемыеДанные = "scope=all offline_access&username=" + Логин + "&password=" + Пароль + "&grant_type=password&client_id=ext_client&client_secret=ext_client_secret";
	
	СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключения,СтруктураЗапроса,ОтправляемыеДанные,АдресаПеременных);
	
	Если СтруктураОтвета <> Ложь И СтруктураОтвета.Свойство("ТекстОшибки") И ЗначениеЗаполнено(СтруктураОтвета.ТекстОшибки) Тогда
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации("REST_API_ВыполнитьМетод", "Ошибка", СтруктураОтвета.ТекстОшибки, , АдресаПеременных);
	КонецЕсли;
	
	ТокенПолучен = Истина;
	Если СтруктураОтвета = Ложь
		ИЛИ СтруктураОтвета.КодСостояния <> 200 Тогда
		ТокенПолучен = Ложь;
	КонецЕсли;
	
	Если НЕ ТокенПолучен Тогда
		Заголовки = Новый Соответствие();
		Заголовки.Вставить("Content-Type", "application/json");
		
		СтруктураЗапроса = Новый Структура;
		СтруктураЗапроса.Вставить("HTTPМетод", 		"GET");
		СтруктураЗапроса.Вставить("Метод", 	   		"session?username=" + Логин + "&password=" + Пароль);
		СтруктураЗапроса.Вставить("Заголовки", 		Заголовки);
		СтруктураЗапроса.Вставить("СтрокаЗапроса",	"<Авторизация Mobile SMARTS>");
		
		СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключения, СтруктураЗапроса,, АдресаПеременных);
		
		Если СтруктураОтвета <> Ложь И СтруктураОтвета.Свойство("ТекстОшибки") И ЗначениеЗаполнено(СтруктураОтвета.ТекстОшибки) Тогда
			ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации("REST_API_ВыполнитьМетод", "Ошибка", СтруктураОтвета.ТекстОшибки, , АдресаПеременных);
		КонецЕсли;
		
		Если СтруктураОтвета = Ложь
			ИЛИ СтруктураОтвета.КодСостояния <> 200 Тогда
			Возврат Ложь;
		КонецЕсли;	
	КонецЕсли;
	
	Если ТипЗнч(СтруктураОтвета) <> Тип("Структура")
		ИЛИ НЕ СтруктураОтвета.Свойство("ОтветСервера") Тогда
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Произошла ошибка при получении токена авторизации. Подробности см. в журнале регистрации.",, АдресаПеременных);
		Возврат Ложь;
	КонецЕсли;
	
	REST_API_session = СтруктураОтвета.ОтветСервера;
	REST_API_session.Вставить("Логин",Логин);
	КомЯдро_СохранитьЗначениеПеременной("API_session_"+СтрЗаменить(СтрЗаменить(СтруктураURI.Хост,".","_"),"-","_")+"_"+Формат(СтруктураURI.Порт,"ЧГ=")+"_"+СтрЗаменить(СтруктураURI.ПутьНаСервере,"-",""),СтруктураОтвета.ОтветСервера,АдресаПеременных);
	
	Access_token = СтруктураОтвета.ОтветСервера.Получить("Access_token");
	Если Access_token = Неопределено Тогда
		Access_token = СтруктураОтвета.ОтветСервера.Получить("access_token");
	КонецЕсли;
	Refresh_token = СтруктураОтвета.ОтветСервера.Получить("Refresh_token"); 
	Если Refresh_token = Неопределено Тогда
		Refresh_token = СтруктураОтвета.ОтветСервера.Получить("refresh_token"); 		
	КонецЕсли;
	
	СтруктураВозврата = Новый Структура("АвторизацияТокен, АвторизацияРефрешТокен", Access_token, Refresh_token);
	
	Возврат СтруктураВозврата;
	
КонецФункции

Функция REST_API_ОбновитьТокенSMARTS(СтрокаПодключения, REST_API_Session = Неопределено, Refresh_token = "", АдресаПеременных)
	
	ИмяСобытия = "REST_API_ОбновитьТокенSMARTS";
	
	Если REST_API_session = Неопределено
		И ПустаяСтрока(Refresh_token) Тогда
		Возврат Неопределено;	
	КонецЕсли;
	
	Логин = "";
	Если REST_API_Session <> Неопределено Тогда
		Refresh_token = REST_API_session.Получить("Refresh_token");
		Если Refresh_token = Неопределено Тогда
			Refresh_token = REST_API_session.Получить("refresh_token");	
		КонецЕсли;
		Логин = REST_API_session.Получить("Логин");
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(Refresh_token) Тогда
		Возврат Неопределено;		
	КонецЕсли;
	
	СтруктураПодключения = Новый Структура;
	СтруктураПодключения.Вставить("СтрокаПодключенияСМАРТС", СтрокаПодключения);
	
	Заголовки = Новый Соответствие();
	Заголовки.Вставить("Content-Type", "application/x-www-form-urlencoded");
	
	СтруктураЗапроса = Новый Структура;
	СтруктураЗапроса.Вставить("HTTPМетод", 		"POST");
	СтруктураЗапроса.Вставить("Метод", 	   		"connect/token");
	СтруктураЗапроса.Вставить("Заголовки", 		Заголовки);
	СтруктураЗапроса.Вставить("ВерсияAPI", 		"");
	СтруктураЗапроса.Вставить("СтрокаЗапроса",	"<Авторизация Mobile SMARTS>");
	
	ОтправляемыеДанные = "scope=refresh_token offline_access&refresh_token=" + Refresh_token + "&grant_type=refresh_token&client_id=ext_client&client_secret=ext_client_secret";
	
	СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключения, СтруктураЗапроса, ОтправляемыеДанные, АдресаПеременных);          
	
	Если СтруктураОтвета = Ложь
		ИЛИ СтруктураОтвета.КодСостояния <> 200 Тогда
		Возврат Неопределено; // Не удалось обновить токен
	КонецЕсли;
	
	Если ТипЗнч(СтруктураОтвета) <> Тип("Структура")
		ИЛИ НЕ СтруктураОтвета.Свойство("ОтветСервера") Тогда
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Произошла ошибка при обновлении токена авторизации. Подробности см. в журнале регистрации.",, АдресаПеременных);
		Возврат Неопределено;
	КонецЕсли;
	
	СтруктураURI = REST_API_ПолучитьСтруктуруURIИзСтроки(СтрокаПодключения);
	
	// Обновляем REST_API_session
	REST_API_session = СтруктураОтвета.ОтветСервера;
	REST_API_session.Вставить("Логин", Логин);
	КомЯдро_СохранитьЗначениеПеременной("API_session_" + СтрЗаменить(СтрЗаменить(СтруктураURI.Хост, ".", "_"), "-", "_") + "_" + Формат(СтруктураURI.Порт, "ЧГ=") + "_" + СтрЗаменить(СтруктураURI.ПутьНаСервере, "-", ""), СтруктураОтвета.ОтветСервера, АдресаПеременных);
	
	Access_token = СтруктураОтвета.ОтветСервера.Получить("Access_token");
	Если Access_token = Неопределено Тогда
		Access_token = СтруктураОтвета.ОтветСервера.Получить("access_token");
	КонецЕсли;
	Refresh_token = СтруктураОтвета.ОтветСервера.Получить("Refresh_token"); 
	Если Refresh_token = Неопределено Тогда
		Refresh_token = СтруктураОтвета.ОтветСервера.Получить("refresh_token"); 		
	КонецЕсли;
	
	// Пересохранение настроек подключения
	ПараметрыПодключенияMS = ГлЯдро_ПолучитьДанныеИзХранилища1С("Cleverence_ПараметрыПодключенияMS");
	Если ТипЗнч(ПараметрыПодключенияMS) = Тип("Структура")
		И ПараметрыПодключенияMS.СтрокаПодключения = СтрокаПодключения Тогда
		ПараметрыПодключенияMS.Вставить("АвторизацияТокен", 	  Access_token);
		ПараметрыПодключенияMS.Вставить("АвторизацияРефрешТокен", Refresh_token);
		
		ГлЯдро_СохранитьДанныеВХранилище1С("Cleverence_ПараметрыПодключенияMS", ПараметрыПодключенияMS);
		КомЯдро_СохранитьЗначениеПеременной("ПараметрыПодключенияMS", ПараметрыПодключенияMS, АдресаПеременных);
	КонецЕсли;
	
	СтруктураВозврата = Новый Структура("АвторизацияТокен, АвторизацияРефрешТокен", Access_token, Refresh_token);
	
	Возврат СтруктураВозврата;
	
КонецФункции

// Выполняет подключение к базе Mobile Smarts при работе с типом интерфейса REST_API
//
// Параметры:
//	СтруктураПодключения - Структура - структура подключения к базе Mobile Smarts
//  Интерактивно - Булево - флаг работы в интерактивном режиме
//	НеПроверятьАвторизацию - Булево - признак необходимости проверки авторизации
//  АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
//
// Возвращаемое значение:
//	- Структура - если требуется авторизация в интерактивном режиме - содержит:
//  	* Статус - Строка	
//      * СтрокаПодключения - Строка
//      * ИмяБазы - Строка
//      * Логин - Строка
//      * ТипБазы - Строка
//      * ДопПараметры - Структура - содержит:
//			** СтрокаПодключения - Строка
//          ** ТипБазы - Строка
//          ** СтруктураПодключения - Структура - структура подключения к базе Mobile Smarts
//          ** СохранятьАвторизацию - Булево
//          ** ИмяБазы - Строка
//          ** Логин - Строка
//	- Булево - флаг успешности подключения к базе Mobile Smarts
Функция REST_API_ПодключитьсяКБазеSMARTS(СтруктураПодключения, Интерактивно, НеПроверятьАвторизацию = Ложь, АдресаПеременных) Экспорт
	
	ЭтоВнешнееСоединение = Ложь;
	
	#Если ВнешнееСоединение Тогда
		ЭтоВнешнееСоединение = Истина;	
	#КонецЕсли
	
	Если ЭтоВнешнееСоединение ИЛИ ЭтоWebСервис Тогда
		ДатаАктуальностиСоединения = ГлЯдро_ПолучитьДанныеИзХранилища1С("Cleverence_REST_API_ДатаАктуальностиСоединения");
		Если ТипЗнч(ДатаАктуальностиСоединения) = Тип("Дата") 
			И ТекущаяДата() - ДатаАктуальностиСоединения < 3600 Тогда //Если настройки не устарели то не проверяем подключение, 1ч.
			Возврат Истина;
		КонецЕсли;
	КонецЕсли;	
	
	ИмяСобытия = "REST_API_ПодключитьсяКБазеSMARTS";
	
	СтрокаПодключения = "";
	Если ТипЗнч(СтруктураПодключения) = Тип("Структура") Тогда
		Если НЕ СтруктураПодключения.Свойство("СтрокаПодключенияСМАРТС")
			И НЕ СтруктураПодключения.Свойство("СтрокаПодключения") Тогда
			Возврат Ложь;
		Иначе
			СтрокаПодключения = ?(СтруктураПодключения.Свойство("СтрокаПодключенияСМАРТС"), СтруктураПодключения.СтрокаПодключенияСМАРТС, СтруктураПодключения.СтрокаПодключения);
		КонецЕсли;
	КонецЕсли;
	
	СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключения,Новый Структура("HTTPМетод,Метод,ТипЗапроса","GET","","ПроверкаСоединения"),,АдресаПеременных);
	
	КодСостояния = Истина;
	Если ТипЗнч(СтруктураОтвета) = Тип("Структура")	И СтруктураОтвета.Свойство("КодСостояния") Тогда
		// Если вернулся КодСостояния = Неопределено, значит, подключиться к базе не удалось
		КодСостояния = СтруктураОтвета.КодСостояния;
	КонецЕсли;
	
	Если СтруктураОтвета = Ложь	ИЛИ НЕ ТипЗнч(СтруктураПодключения) = Тип("Структура") ИЛИ КодСостояния = Неопределено Тогда
		Если ЭтоВнешнееСоединение ИЛИ ЭтоWebСервис Тогда
			СтруктураПараметровONLEX = Новый Структура;
			СтруктураПараметровONLEX.Вставить("ИмяПользователяВ1С", ГлЯдро_ПолучитьНаименованиеТекущегоПользователя());
			СтруктураПараметровONLEX.Вставить("СтрокаПодключения",  СтрокаПодключения);
			
			ОписаниеОшибкиONLEX = Новый Структура;
			ОписаниеОшибкиONLEX.Вставить("КодОшибкиONLEX", "ONLEX003");
			ОписаниеОшибкиONLEX.Вставить("СтруктураПараметровONLEX", СтруктураПараметровONLEX);
			
			ГлЯдро_СохранитьДанныеВХранилище1С("Cleverence_ОписаниеОшибкиONLEX", ОписаниеОшибкиONLEX);
		КонецЕсли;
		
		Возврат Ложь;
	КонецЕсли;
		
	ДопПараметры = Новый Структура("СтрокаПодключения,ТипБазы,СтруктураПодключения,СохранятьАвторизацию,ИмяБазы,Логин",СтрокаПодключения,СтруктураПодключения.ТипБазы,СтруктураПодключения,?(СтруктураПодключения.Свойство("СохранятьАвторизацию"),СтруктураПодключения.СохранятьАвторизацию,Ложь),"REST API",?(СтруктураПодключения.Свойство("АвторизацияЛогин"),СтруктураПодключения.АвторизацияЛогин,""));
	
	ТребуетсяАвторизация = Ложь;

	Если СтруктураОтвета.КодСостояния = 401 Тогда
		ТребуетсяАвторизация = Истина;		
	КонецЕсли;
	
	Если СтруктураОтвета.КодСостояния = 200 Тогда
		Если Не НеПроверятьАвторизацию Тогда
			// Проверяем, нужна ли авторизация
			СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключения, Новый Структура("HTTPМетод,Метод,ТипЗапроса","GET","Warehouses","ПолучениеМетаданных"),,АдресаПеременных);	
			Если СтруктураОтвета.КодСостояния = 401 Тогда
				ТребуетсяАвторизация = Истина;
			ИначеЕсли СтруктураОтвета.КодСостояния = 403 Тогда
				ТребуетсяАвторизация = Истина;
				ТекстОшибки = "У данного пользователя Mobile SMARTS недостаточно прав для подключения к базе!
				|Пользователь должен находиться в группе ""Администраторы"" или ""Внешние подключения"".";
			Иначе
				Если ЭтоВнешнееСоединение ИЛИ ЭтоWebСервис Тогда
					ГлЯдро_СохранитьДанныеВХранилище1С("Cleverence_REST_API_ДатаАктуальностиСоединения", ТекущаяДата());
				КонецЕсли;
				Возврат Истина;			
			КонецЕсли;
		Иначе
			Возврат Истина;
		КонецЕсли;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ТекстОшибки) Тогда
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", ТекстОшибки,, АдресаПеременных);	
	КонецЕсли;	
	
	Если ТребуетсяАвторизация Тогда
		// Сохраняем в структуре подключения информацию о том, что в базе включена авторизация
		СтруктураПодключения.Вставить("АвторизацияВключена", Истина);
		
		Если СтруктураПодключения.ТипБазы = "Частная" Тогда
			КлючПеременной = "REST_API_СтруктураПодключенияЧастнойБазыMS";
		ИначеЕсли СтруктураПодключения.ТипБазы = "Временная" Тогда
			КлючПеременной = "REST_API_СтруктураПодключенияВременнойБазыMS";
		Иначе
			КлючПеременной = "REST_API_СтруктураПодключенияБазыMS";
		КонецЕсли;
		СтруктураПодключенияБазыMS = КомЯдро_ПолучитьЗначениеПеременной(КлючПеременной, АдресаПеременных);
		СохранятьДанныеАвторизации = ТипЗнч(СтруктураПодключенияБазыMS) = Тип("Структура");
		
		// Если в строке подключения передан tempuid для упрощенной авторизации, пробуем получить токен по нему
		ПолученТокенПоTempUid = Ложь;
		ТекстОшибкиTempUid	  = "";
		TempUid = "";
		Если НЕ НеПроверятьАвторизацию
			И СтруктураПодключения.Свойство("TempUid", TempUid)
			И НЕ ПустаяСтрока(TempUid) Тогда
			СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключения, Новый Структура("HTTPМетод,Метод,ТипЗапроса","GET","Warehouses","ПолучениеМетаданных"),, АдресаПеременных);
			Если СтруктураОтвета.КодСостояния = 200 Тогда
				ПолученТокенПоTempUid = Истина;
				Если СохранятьДанныеАвторизации Тогда
					СтруктураПодключенияБазыMS.Вставить("АвторизацияТокен", 	  ?(СтруктураПодключения.Свойство("АвторизацияТокен"), 		 СтруктураПодключения.АвторизацияТокен, 	  ""));
					СтруктураПодключенияБазыMS.Вставить("АвторизацияРефрешТокен", ?(СтруктураПодключения.Свойство("АвторизацияРефрешТокен"), СтруктураПодключения.АвторизацияРефрешТокен, ""));
				КонецЕсли;
			Иначе
				ТекстОшибкиTempUid = "Ссылка для подключения устарела. Получите новую ссылку и попробуйте еще раз.";
			КонецЕсли;
		КонецЕсли;
		
		Если СохранятьДанныеАвторизации Тогда
			СтруктураПодключенияБазыMS.Вставить("АвторизацияВключена", Истина);
			КомЯдро_СохранитьЗначениеПеременной(КлючПеременной, СтруктураПодключенияБазыMS, АдресаПеременных);
		КонецЕсли;
		
		Если НеПроверятьАвторизацию Тогда
			Возврат Истина;
		ИначеЕсли ПолученТокенПоTempUid Тогда	
            Возврат Истина;
		ИначеЕсли Интерактивно
			И НЕ ПустаяСтрока(ТекстОшибкиTempUid) Тогда
			Возврат ТекстОшибкиTempUid;
		ИначеЕсли Интерактивно Тогда
			// Определяем имя базы
			СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключения,Новый Структура("HTTPМетод,Метод,ТипЗапроса","GET","BaseInfo","ПроверкаСоединения"),, АдресаПеременных);
	        ИмяБазы = "<Не удалось определить...>";
			Если СтруктураОтвета.КодСостояния = 200 Тогда
				ИмяБазы = СтруктураОтвета.ОтветСервера.Получить("name");
				Если ИмяБазы = Неопределено Тогда
					ИмяБазы = "<Не удалось определить...>";
				КонецЕсли;
			ИначеЕсли СтруктураПодключенияБазыMS.Свойство("Имя")
				И ЗначениеЗаполнено(СтруктураПодключенияБазыMS.Имя) Тогда
				ИмяБазы = СтруктураПодключенияБазыMS.Имя;
			ИначеЕсли ЗначениеЗаполнено(СтрокаПодключения) Тогда
				ИмяБазы = СтрокаПодключения;
			КонецЕсли;
			
			СтруктураВозврата = Новый Структура;
			СтруктураВозврата.Вставить("Статус", 			"ОшибкаАвторизации");
			СтруктураВозврата.Вставить("СтрокаПодключения", СтрокаПодключения);
			СтруктураВозврата.Вставить("ИмяБазы", 			ИмяБазы);
			СтруктураВозврата.Вставить("Логин", 			?(СтруктураПодключения.Свойство("АвторизацияЛогин"), СтруктураПодключения.АвторизацияЛогин, ""));
			СтруктураВозврата.Вставить("ТипБазы", 			СтруктураПодключения.ТипБазы);
			СтруктураВозврата.Вставить("ДопПараметры", 		ДопПараметры);
			СтруктураВозврата.Вставить("ТекстОшибки", 		ТекстОшибки);
			
			Возврат СтруктураВозврата;
		Иначе
			Если ЭтоВнешнееСоединение ИЛИ ЭтоWebСервис Тогда
				СтруктураПараметровONLEX = Новый Структура;
				СтруктураПараметровONLEX.Вставить("ИмяПользователяВ1С", ГлЯдро_ПолучитьНаименованиеТекущегоПользователя());
				СтруктураПараметровONLEX.Вставить("СтрокаПодключения",  СтрокаПодключения);
				
				ОписаниеОшибкиONLEX = Новый Структура;
				ОписаниеОшибкиONLEX.Вставить("КодОшибкиONLEX", "ONLEX003");
				ОписаниеОшибкиONLEX.Вставить("СтруктураПараметровONLEX", СтруктураПараметровONLEX);
				
				ГлЯдро_СохранитьДанныеВХранилище1С("Cleverence_ОписаниеОшибкиONLEX", ОписаниеОшибкиONLEX);
			КонецЕсли;
			
			Возврат Ложь;
		КонецЕсли;
	КонецЕсли;
	
КонецФункции

Функция REST_API_ПолучитьМетаданныеДокументовMS(ТипБазы, ИмяПеременнойНастройки, АдресаПеременных)
	
	ИмяСобытия = "REST_API_ПолучитьМетаданныеДокументовMS";
	
	Если ТипБазы = "Частная" Тогда
		КлючПеременной = "REST_API_СтруктураПодключенияЧастнойБазыMS";
	ИначеЕсли ТипБазы = "Временная" Тогда
		КлючПеременной = "REST_API_СтруктураПодключенияВременнойБазыMS";
	Иначе
		КлючПеременной = "REST_API_СтруктураПодключенияБазыMS";
	КонецЕсли;
	
	СтруктураПодключения = КомЯдро_ПолучитьЗначениеПеременной(КлючПеременной,АдресаПеременных);
	
	СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключения,Новый Структура("HTTPМетод,Метод,ТипЗапроса","GET","DocTypes?$expand=tables","ПолучениеМетаданных"),,АдресаПеременных);
	Если СтруктураОтвета.КодСостояния <> 200 Тогда
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Запрос: GET, DocTypes?$expand=tables, получен некорректный ответ от сервера, Код состояния: " + Строка(СтруктураОтвета.КодСостояния)+ ". Содержание ошибки: " + Строка(СтруктураОтвета.ТекстОшибки),,АдресаПеременных);	
		DocumentTypes = Неопределено;
	Иначе
		DocumentTypes = СтруктураОтвета.ОтветСервера.Получить("value");
	КонецЕсли;
	
	СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключения,Новый Структура("HTTPМетод,Метод,ТипЗапроса","GET","TablesInfo?$expand=fields","ПолучениеМетаданных"),,АдресаПеременных);	
	Если СтруктураОтвета.КодСостояния <> 200 Тогда
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Запрос: GET, TablesInfo?$expand=fields. Получен некорректный ответ от сервера, Код состояния: " + Строка(СтруктураОтвета.КодСостояния)+ ". Содержание ошибки: " + Строка(СтруктураОтвета.ТекстОшибки),,АдресаПеременных);
		Tables = Неопределено;	
	Иначе
		Tables = СтруктураОтвета.ОтветСервера.Получить("value");	
	КонецЕсли;
		
	СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключения,Новый Структура("HTTPМетод,Метод,ТипЗапроса","GET","Users","ПолучениеМетаданных"),,АдресаПеременных);	
	Если СтруктураОтвета.КодСостояния <> 200 Тогда
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Запрос: GET, Users. Получен некорректный ответ от сервера, Код состояния: " + Строка(СтруктураОтвета.КодСостояния)+ ". Содержание ошибки: " + Строка(СтруктураОтвета.ТекстОшибки),,АдресаПеременных);	
		Users = Неопределено;	
	Иначе
		Users = СтруктураОтвета.ОтветСервера.Получить("value");	
	КонецЕсли;
		
	СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключения,Новый Структура("HTTPМетод,Метод,ТипЗапроса","GET","Devices","ПолучениеМетаданных"),,АдресаПеременных);	
	Если СтруктураОтвета.КодСостояния <> 200 Тогда
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Запрос: GET, Devices. Получен некорректный ответ от сервера, Код состояния: " + Строка(СтруктураОтвета.КодСостояния)+ ". Содержание ошибки: " + Строка(СтруктураОтвета.ТекстОшибки),,АдресаПеременных);	
		Devices = Неопределено;
	Иначе
		Devices = СтруктураОтвета.ОтветСервера.Получить("value");	
	КонецЕсли;	
		
	МетаданныеДокументовMS = Новый Структура;
	
	СписокОбязательныхПолей = Новый Массив;
	СписокОбязательныхПолей.Добавить(Новый Структура("Значение,Ключ,Uni","Ид", "Идентификатор","id"));
	СписокОбязательныхПолей.Добавить(Новый Структура("Значение,Ключ,Uni","СозданНаТСД", "Создан на ТСД","createdOnPDA"));
	СписокОбязательныхПолей.Добавить(Новый Структура("Значение,Ключ,Uni","Имя", "Имя","name"));
	СписокОбязательныхПолей.Добавить(Новый Структура("Значение,Ключ,Uni","Назначение", "Назначение", "appointment"));
	СписокОбязательныхПолей.Добавить(Новый Структура("Значение,Ключ,Uni","ДатаСоздания", "Дата создания", "createDate"));
	СписокОбязательныхПолей.Добавить(Новый Структура("Значение,Ключ,Uni","ИмяТипаДокумента", "Имя типа документа", "documentTypeName"));
	СписокОбязательныхПолей.Добавить(Новый Структура("Значение,Ключ,Uni","ИдСклада", "Идентификатор склада", "warehouseId"));
	СписокОбязательныхПолей.Добавить(Новый Структура("Значение,Ключ,Uni","Штрихкод", "Штрихкод", "barcode"));
	СписокОбязательныхПолей.Добавить(Новый Структура("Значение,Ключ,Uni","Приоритет", "Приоритет", "priority"));
	СписокОбязательныхПолей.Добавить(Новый Структура("Значение,Ключ,Uni","Описание", "Описание", "description"));
	СписокОбязательныхПолей.Добавить(Новый Структура("Значение,Ключ,Uni","ВыдаватьПоШтрихкоду", "Выдавать по штрихкоду", "DistributeByBarcode"));
	СписокОбязательныхПолей.Добавить(Новый Структура("Значение,Ключ,Uni","ИсполняемыйНаСервере", "Исполняемый на сервере", "serverHosted"));
	СписокОбязательныхПолей.Добавить(Новый Структура("Значение,Ключ,Uni","Завершен", "Завершен", "finished"));
	СписокОбязательныхПолей.Добавить(Новый Структура("Значение,Ключ,Uni","ВОбработке", "В обработке", "inProcess"));
	СписокОбязательныхПолей.Добавить(Новый Структура("Значение,Ключ,Uni","Изменен", "Изменен", "modified"));
	СписокОбязательныхПолей.Добавить(Новый Структура("Значение,Ключ,Uni","ИдПользователя", "Идентификатор пользователя", "userId"));
	СписокОбязательныхПолей.Добавить(Новый Структура("Значение,Ключ,Uni","DeviceId", "ИдУстройства", "deviceId"));
	СписокОбязательныхПолей.Добавить(Новый Структура("Значение,Ключ,Uni","UserName", "ИмяПользователя", "userName"));
	СписокОбязательныхПолей.Добавить(Новый Структура("Значение,Ключ,Uni","Underloaded", "Underloaded", "Underloaded"));
	СписокОбязательныхПолей.Добавить(Новый Структура("Значение,Ключ,Uni","Overloaded", "Overloaded", "Overloaded"));
	СписокОбязательныхПолей.Добавить(Новый Структура("Значение,Ключ,Uni","UnderloadedOrOverloaded","UnderloadedOrOverloaded","UnderloadedOrOverloaded"));
	
	СписокОбязательныхПолейТЧ = Новый Массив;
	СписокОбязательныхПолейТЧ.Добавить(Новый Структура("Значение,Ключ,Uni","ИдТовара", "ИдТовара", "productId"));
	СписокОбязательныхПолейТЧ.Добавить(Новый Структура("Значение,Ключ,Uni","ИдУпаковки", "ИдУпаковки", "packingId"));
	СписокОбязательныхПолейТЧ.Добавить(Новый Структура("Значение,Ключ,Uni","КоличествоПлан", "Количество (План)", "declaredQuantity"));
	СписокОбязательныхПолейТЧ.Добавить(Новый Структура("Значение,Ключ,Uni","КоличествоФакт", "Количество (Факт)", "currentQuantity"));
	СписокОбязательныхПолейТЧ.Добавить(Новый Структура("Значение,Ключ,Uni","ИдПервогоМеста", "Ид первого места", "firstStorageId"));
	СписокОбязательныхПолейТЧ.Добавить(Новый Структура("Значение,Ключ,Uni","ИдВторогоМеста", "Ид второго места", "secondStorageId"));
	СписокОбязательныхПолейТЧ.Добавить(Новый Структура("Значение,Ключ,Uni","ДатаРегистрации", "Дата регистрации", "registrationDate"));
	СписокОбязательныхПолейТЧ.Добавить(Новый Структура("Значение,Ключ,Uni","СрокГодности", "Срок годности", "expiredDate"));
	СписокОбязательныхПолейТЧ.Добавить(Новый Структура("Значение,Ключ,Uni","Переполнение", "Переполнение",ГлЯдро_СтрокуВТранслитENG("Переполнение")));
	СписокОбязательныхПолейТЧ.Добавить(Новый Структура("Значение,Ключ,Uni","Недобор", "Недобор",ГлЯдро_СтрокуВТранслитENG("Недобор")));
	СписокОбязательныхПолейТЧ.Добавить(Новый Структура("Значение,Ключ,Uni","ЕстьНедоборИлиПереполнение", "Есть недобор или переполнение",ГлЯдро_СтрокуВТранслитENG("ЕстьНедоборИлиПереполнение")));
	СписокОбязательныхПолейТЧ.Добавить(Новый Структура("Значение,Ключ,Uni","Остаток", "Остаток",ГлЯдро_СтрокуВТранслитENG("Остаток")));
	СписокОбязательныхПолейТЧ.Добавить(Новый Структура("Значение,Ключ,Uni","СвязаннаяСтрока", "Связанная строка", "bindedLineUid"));
	СписокОбязательныхПолейТЧ.Добавить(Новый Структура("Значение,Ключ,Uni","SSCC", "SSCC", "SSCC"));
	
	РеквизитыСерии = Новый Массив;
	РеквизитыСерии.Добавить(Новый Структура("Значение,Ключ,Uni","ИдСерии", "Идентификатор Серии","IdSerii"));
	РеквизитыСерии.Добавить(Новый Структура("Значение,Ключ,Uni","ИмяСерии", "Имя серии","ImyaSerii"));
	РеквизитыСерии.Добавить(Новый Структура("Значение,Ключ,Uni","ИдТовара", "ИдТовара", "productId"));
	РеквизитыСерии.Добавить(Новый Структура("Значение,Ключ,Uni","КоличествоФакт", "Количество (Факт)", "currentQuantity"));
	РеквизитыСерии.Добавить(Новый Структура("Значение,Ключ,Uni","Характеристика", "Характеристика","Harakteristika"));
	РеквизитыСерии.Добавить(Новый Структура("Значение,Ключ,Uni","АлкоКод", "АлкоКод","AlkoKod"));
	РеквизитыСерии.Добавить(Новый Структура("Значение,Ключ,Uni","ФормаА", "ФормаА",ГлЯдро_СтрокуВТранслитENG("ФормаА")));
	РеквизитыСерии.Добавить(Новый Структура("Значение,Ключ,Uni","КлючСерии", "КлючСерии","KlyuchSerij"));
	РеквизитыСерии.Добавить(Новый Структура("Значение,Ключ,Uni","АлкоНаим", "АлкоНаим","AlkoNaim"));
	РеквизитыСерии.Добавить(Новый Структура("Значение,Ключ,Uni","ДатаРозлива", "ДатаРозлива",ГлЯдро_СтрокуВТранслитENG("ДатаРозлива")));
	РеквизитыСерии.Добавить(Новый Структура("Значение,Ключ,Uni","НаименованиеДляПоиска", "НаименованиеДляПоиска","NaimenovanieDlyaPoiska"));
	РеквизитыСерии.Добавить(Новый Структура("Значение,Ключ,Uni","ДатаСерии", "ДатаСерии","DataSerii"));
	РеквизитыСерии.Добавить(Новый Структура("Значение,Ключ,Uni","ИндексСорт", "ИндексСорт","IndeksSort"));
	РеквизитыСерии.Добавить(Новый Структура("Значение,Ключ,Uni","Код", "Код","Kod"));
	РеквизитыСерии.Добавить(Новый Структура("Значение,Ключ,Uni","Штрихкод", "Штрихкод","Shtrihkod"));
	РеквизитыСерии.Добавить(Новый Структура("Значение,Ключ,Uni","Номер", "Номер","Nomer"));
	РеквизитыСерии.Добавить(Новый Структура("Значение,Ключ,Uni","Ид", "Ид","Id"));
	РеквизитыСерии.Добавить(Новый Структура("Значение,Ключ,Uni","Дополнительно", "Дополнительно","Dopolnitelno"));
	
	РеквизитыСерийныеНомера = Новый Массив;
	РеквизитыСерийныеНомера.Добавить(Новый Структура("Значение,Ключ,Uni","СН", "Серийный номер","sn"));
	РеквизитыСерийныеНомера.Добавить(Новый Структура("Значение,Ключ,Uni","ИдСерии", "Идентификатор Серии","IdSerii"));
	РеквизитыСерийныеНомера.Добавить(Новый Структура("Значение,Ключ,Uni","ИдТовара", "ИдТовара", "productId"));
	РеквизитыСерийныеНомера.Добавить(Новый Структура("Значение,Ключ,Uni","КоличествоФакт", "Количество (факт)", "currentQuantity"));
	РеквизитыСерийныеНомера.Добавить(Новый Структура("Значение,Ключ,Uni","Характеристика", "Характеристика","Harakteristika"));
	
	ГлЯдро_ПреобразоватьUni(СписокОбязательныхПолей);
	ГлЯдро_ПреобразоватьUni(СписокОбязательныхПолейТЧ);
	ГлЯдро_ПреобразоватьUni(РеквизитыСерии);
	ГлЯдро_ПреобразоватьUni(РеквизитыСерийныеНомера);
	
	Если DocumentTypes <> Неопределено Тогда
		Для Каждого ТипДокумента из DocumentTypes Цикл
			
			Если ТипДокумента.Получить("virtual") Тогда // Виртуальный
				Продолжить;
			КонецЕсли;
			
			СтруктураДокумента = Новый Структура();
			СтруктураДокумента.Вставить("uni", ГлЯдро_ПреобразоватьПервыйСимволВНижнийРегистр(ТипДокумента.Получить("uni")) );
			СтруктураДокумента.Вставить("Имя", ТипДокумента.Получить("name"));
			СтруктураДокумента.Вставить("Синоним", ТипДокумента.Получить("alias"));
			// реквизиты документа
			СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключения,Новый Структура("HTTPМетод,Метод,ТипЗапроса","GET","DocTypes('" + СтруктураДокумента.uni + "')?$expand=fields","ПолучениеМетаданных"),,АдресаПеременных);
			Если СтруктураОтвета.КодСостояния <> 200 Тогда
				ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Запрос: GET, DocTypes('" + Строка(СтруктураДокумента.uni) + "')?$expand=fields. Получен некорректный ответ от сервера, Код состояния: " + Строка(СтруктураОтвета.КодСостояния)+ ". Содержание ошибки: " + Строка(СтруктураОтвета.ТекстОшибки),,АдресаПеременных);	
				Fields = Неопределено;	
			Иначе
				Fields = СтруктураОтвета.ОтветСервера.Получить("fields");	
			КонецЕсли;
			
			Если Fields <> Неопределено Тогда
				СписокРеквизитов = REST_API_ПолучитьСписокРеквизитовСущностиMS(Fields, СписокОбязательныхПолей);
				СтруктураДокумента.Вставить("Реквизиты", СписокРеквизитов);
			Иначе	
				СтруктураДокумента.Вставить("Реквизиты", Новый СписокЗначений());
			КонецЕсли;
			
			// реквизиты табличной части
			СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключения,Новый Структура("HTTPМетод,Метод,ТипЗапроса","GET","DocTypes('" + СтруктураДокумента.uni + "')?$expand=columns","ПолучениеМетаданных"),,АдресаПеременных);
			Если СтруктураОтвета.КодСостояния <> 200 Тогда
				ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Запрос: GET, DocTypes('" + Строка(СтруктураДокумента.uni) + "')?$expand=columns. Получен некорректный ответ от сервера, Код состояния: " + Строка(СтруктураОтвета.КодСостояния)+ ". Содержание ошибки: " + Строка(СтруктураОтвета.ТекстОшибки),,АдресаПеременных);	
				Columns = Неопределено;	
			Иначе
				Columns = СтруктураОтвета.ОтветСервера.Получить("columns");	
			КонецЕсли;
			
			Если Columns <> Неопределено Тогда
				СписокРеквизитов = REST_API_ПолучитьСписокРеквизитовСущностиMS(Columns, СписокОбязательныхПолейТЧ);
				СтруктураДокумента.Вставить("РеквизитыТЧ", СписокРеквизитов);
			Иначе
				СтруктураДокумента.Вставить("РеквизитыТЧ", Новый СписокЗначений());
			КонецЕсли;
			
			// серии и серийные номера
			СтруктураДокумента.Вставить("РеквизитыСерии", РеквизитыСерии);
			СтруктураДокумента.Вставить("РеквизитыСерийныеНомера", РеквизитыСерийныеНомера);
			
			// Дополнительные таблицы
			СписокДополнительныхТаблиц = Новый СписокЗначений();
			СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключения,Новый Структура("HTTPМетод,Метод,ТипЗапроса","GET","DocTypes('" + СтруктураДокумента.uni + "')?$expand=tables($expand=fields)","ПолучениеМетаданных"),,АдресаПеременных);
			Если СтруктураОтвета.КодСостояния <> 200 Тогда
				ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Запрос: GET, DocTypes('" + Строка(СтруктураДокумента.uni) + "')?$expand=tables($expand=fields). Получен некорректный ответ от сервера, Код состояния: " + Строка(СтруктураОтвета.КодСостояния)+ ". Содержание ошибки: " + Строка(СтруктураОтвета.ТекстОшибки),,АдресаПеременных);	
				DocTables = Неопределено;	
			Иначе
				DocTables = СтруктураОтвета.ОтветСервера.Получить("tables");	
			КонецЕсли;
			
			Если DocTables <> Неопределено Тогда
				Для каждого ДопТаблица из DocTables Цикл
					СписокПолейДопТаблицы = REST_API_ПолучитьСписокРеквизитовСущностиMS(ДопТаблица.Получить("fields"));	
					СписокДополнительныхТаблиц.Добавить(СписокПолейДопТаблицы, ДопТаблица.Получить("name"));
				КонецЦикла;
			КонецЕсли;
										
			СтруктураДокумента.Вставить("ДополнительныеТаблицы", СписокДополнительныхТаблиц);									
			
			ИмяТипаДокумента = ГлЯдро_ПреобразованиеНаименованияДокументаБезПробелов(ТипДокумента.Получить("name"));
			МетаданныеДокументовMS.Вставить(ИмяТипаДокумента, СтруктураДокумента);
			
		КонецЦикла;
	КонецЕсли;
	
	Таблицы = Новый СписокЗначений;	
	Если Tables <> Неопределено Тогда
		Для Каждого ДопТаблица ИЗ Tables Цикл
			
			// Реквизиты таблицы
			Fields = ДопТаблица.Получить("fields");
			Если Fields = Неопределено Тогда
				СписокРеквизитов = Новый Массив;
			Иначе
				СписокРеквизитов = REST_API_ПолучитьСписокРеквизитовСущностиMS(Fields,, Истина);
			КонецЕсли;
			
			Таблицы.Добавить(СписокРеквизитов, ДопТаблица.Получить("name"));
				
		КонецЦикла;
	КонецЕсли;
		
	СписокПользователейMS = Новый СписокЗначений;
	
	СписокПользователейMS.Добавить("Выгружать всем;Выгружать всем"); 	
	СписокПользователейMS.Добавить("Спрашивать при выгрузке;Спрашивать при выгрузке");	
	Если Users <> Неопределено Тогда
		Для Каждого ТекущийПользователь ИЗ Users Цикл
			СписокПользователейMS.Добавить(ТекущийПользователь.Получить("id") + ";" + ТекущийПользователь.Получить("name"), ТекущийПользователь.Получить("groupId") + ";" + ТекущийПользователь.Получить("groupName"));
		КонецЦикла;	
	КонецЕсли;
	
	ПризнакЛегкогоОблака = ГлЯдро_ПолучитьНастройкиНаСервереSMARTS(Новый Структура("InternetGateOption"), 
		ГлЯдро_ПолучитьКатегорииНастроекMS().УзловыеНастройки,
		, 
		АдресаПеременных);
	Если ТипЗнч(ПризнакЛегкогоОблака) = Тип("Структура") И ПризнакЛегкогоОблака.Свойство("InternetGateOption") Тогда
		InternetGateOption = ПризнакЛегкогоОблака.InternetGateOption;
	Иначе
		InternetGateOption = Ложь;
	КонецЕсли;
	
	Если InternetGateOption <> Ложь И ВРег(InternetGateOption) = "AVAILABLE" Тогда
		флЛегкоеОблако = Истина;
	Иначе
		флЛегкоеОблако = Ложь;
	КонецЕсли;
	
	// Устройства MS
	СписокУстройствMS = Новый СписокЗначений;
	Если Не флЛегкоеОблако Тогда
		СписокУстройствMS.Добавить("Выгружать всем;Выгружать всем"); 	
		СписокУстройствMS.Добавить("Спрашивать при выгрузке;Спрашивать при выгрузке");	
	КонецЕсли;
	
	Если Devices <> Неопределено Тогда
		Для Каждого ТекущееУстройство ИЗ Devices Цикл                  
			Если флЛегкоеОблако Тогда
				Pincode    = СокрЛП(ТекущееУстройство.Получить("pincode"));
			КонецЕсли;
			DeviceId   = СокрЛП(ТекущееУстройство.Получить("deviceId"));
			DeviceName = СокрЛП(ТекущееУстройство.Получить("deviceName"));
			Если флЛегкоеОблако Тогда
				СписокУстройствMS.Добавить(Pincode + ";" + DeviceId + ";" + ?(НЕ ЗначениеЗаполнено(DeviceName), DeviceId, DeviceName + ", (" + DeviceId + ")") + ";");
			Иначе
				СписокУстройствMS.Добавить(DeviceId + ";" + ?(НЕ ЗначениеЗаполнено(DeviceName), DeviceId, DeviceName + ", (" + DeviceId + ")") + ";");
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	СоответствиеПолейНоменклатуры = Новый Соответствие;
	СоответствиеПолейНоменклатуры.Вставить("ИмяСерии","serial");
	СоответствиеПолейНоменклатуры.Вставить("Колво","qty");
	СоответствиеПолейНоменклатуры.Вставить("Цена","price");
	СоответствиеПолейНоменклатуры.Вставить("ИмяХарактеристики","descr");
	СоответствиеПолейНоменклатуры.Вставить("ПоСН","withsn");
	СоответствиеПолейНоменклатуры.Вставить("ПоСериям","withserial");
	СоответствиеПолейНоменклатуры.Вставить("Весовой","Vesovoj");
	СоответствиеПолейНоменклатуры.Вставить("КлючСерий","KlyuchSerij");
	СоответствиеПолейНоменклатуры.Вставить("ВидНоменклатуры","VidNomenklatury");
	СоответствиеПолейНоменклатуры.Вставить("ИдСерии","serialId");
	СоответствиеПолейНоменклатуры.Вставить("Алко","Alko");
	СоответствиеПолейНоменклатуры.Вставить("АлкоВидЛиц","AlkoVidLic");
	СоответствиеПолейНоменклатуры.Вставить("АлкоМарк","AlkoMark");
	СоответствиеПолейНоменклатуры.Вставить("АлкоКодВ","AlkoKodV");
	СоответствиеПолейНоменклатуры.Вставить("АлкоНаимВ","AlkoNaimV");
	СоответствиеПолейНоменклатуры.Вставить("АлкоОбъем","AlkoObem");
	СоответствиеПолейНоменклатуры.Вставить("АлкоКрепость","AlkoKrepost");
	СоответствиеПолейНоменклатуры.Вставить("АлкоПроизводитель","AlkoProizvoditel");
	СоответствиеПолейНоменклатуры.Вставить("АлкоПроизвИНН","AlkoProizvINN");
	СоответствиеПолейНоменклатуры.Вставить("АлкоПроизвКПП","AlkoProizvKPP");
	СоответствиеПолейНоменклатуры.Вставить("АлкоКод","AlkoKod");
	СоответствиеПолейНоменклатуры.Вставить("ЭтоГруппа","EtoGruppa");
	СоответствиеПолейНоменклатуры.Вставить("Продавец","sellerName");
	СоответствиеПолейНоменклатуры.Вставить("АдресПродавца","sellerAddress");
	СоответствиеПолейНоменклатуры.Вставить("АдресПроизв","producerAddress");
	СоответствиеПолейНоменклатуры.Вставить("СтранаПроизв","producerCountry");
	СоответствиеПолейНоменклатуры.Вставить("Поставщик","supplierName");
	СоответствиеПолейНоменклатуры.Вставить("АдресПоставщика","supplierAddress");
	СоответствиеПолейНоменклатуры.Вставить("ДопИнфо","AdditionInfo");
	СоответствиеПолейНоменклатуры.Вставить("КлючХарактеристик","KlyuchHarakteristik");
	СоответствиеПолейНоменклатуры.Вставить("ПоХарактеристикам","PoHarakteristikam");
	СоответствиеПолейНоменклатуры.Вставить("Серия","Seriya");
	СоответствиеПолейНоменклатуры.Вставить("Характеристика","Harakteristika");
	СоответствиеПолейНоменклатуры.Вставить("ИдХарактеристики","descrId");
	СоответствиеПолейНоменклатуры.Вставить("ИдЕдиницыИзмерения","unitId");
	СоответствиеПолейНоменклатуры.Вставить("КИЗ","KIZ");
	СоответствиеПолейНоменклатуры.Вставить("АлкоНаим","AlkoNaim");
	СоответствиеПолейНоменклатуры.Вставить("ШК","barcode");
	
	ГлЯдро_ПреобразоватьUni(СоответствиеПолейНоменклатуры);	
		
	МассивВыгружаемыхПолейНоменклатурыMS = ГлЯдро_ПолучитьМассивВыгружаемыхПолейНоменклатурыMS(АдресаПеременных);
	
	СтрРезультат = Новый Структура;
	СтрРезультат.Вставить("ДокументыMS",					МетаданныеДокументовMS);
	СтрРезультат.Вставить("Tables",							Таблицы);
	СтрРезультат.Вставить("ПользователиMS",					СписокПользователейMS);
	СтрРезультат.Вставить("УстройстваMS",					СписокУстройствMS);
	СтрРезультат.Вставить("UniПолейНоменклатуры",			СоответствиеПолейНоменклатуры);
	СтрРезультат.Вставить("ВыгружаемыеПоляНоменклатурыMS", 	МассивВыгружаемыхПолейНоменклатурыMS);
	
	ГлЯдро_СохранитьДанныеВХранилище1С(ИмяПеременнойНастройки, СтрРезультат);
	
	ПользователиMSАдрес = ГлЯдро_ДеревоПользователейВоВременноеХранилище(СписокПользователейMS);
	УстройстваMSАдрес 	= ГлЯдро_ДеревоУстройствВоВременноеХранилище(СписокУстройствMS, флЛегкоеОблако);
	
	СтрРезультат.Вставить("ПользователиMS", ПользователиMSАдрес);
	СтрРезультат.Вставить("УстройстваMS",	УстройстваMSАдрес);
	
	Возврат СтрРезультат;
	
КонецФункции

Функция REST_API_ПолучитьМетаданныеMSИзХранилища1С(ТипБазы, ИмяПеременнойНастройки, АдресаПеременных)
	
	ИмяСобытия = "REST_API_ПолучитьМетаданныеMSИзХранилища1С";
	
	пСтруктураМетаданных = ГлЯдро_ПолучитьДанныеИзХранилища1С(ИмяПеременнойНастройки);
	Если ТипЗнч(пСтруктураМетаданных) <> Тип("Структура") Тогда
		Возврат Неопределено;		
	КонецЕсли;
	
	КатегорииНастроекMS = КомЯдро_ПолучитьЗначениеПеременной("КатегорииНастроекMS", АдресаПеременных);
	Если КатегорииНастроекMS = Неопределено Тогда
		КатегорииНастроекMS = ГлЯдро_ПолучитьКатегорииНастроекMS();
	КонецЕсли;	
	
	ПризнакЛегкогоОблака = ГлЯдро_ПолучитьНастройкиНаСервереSMARTS(Новый Структура("InternetGateOption"), КатегорииНастроекMS.УзловыеНастройки,, АдресаПеременных);
	Если ТипЗнч(ПризнакЛегкогоОблака) = Тип("Структура") И ПризнакЛегкогоОблака.Свойство("InternetGateOption") Тогда
		InternetGateOption = ПризнакЛегкогоОблака.InternetGateOption;
	Иначе
		InternetGateOption = Ложь;
	КонецЕсли;
	
	Если InternetGateOption <> Ложь И ВРег(InternetGateOption) = "AVAILABLE" Тогда
		флЛегкоеОблако = Истина;
	Иначе
		флЛегкоеОблако = Ложь;
	КонецЕсли;
	
	ЭтоВнешнееСоединение = Ложь;
	#Если ВнешнееСоединение Тогда
		ЭтоВнешнееСоединение = Истина;	
	#КонецЕсли
	ИспользоватьКэш = ЭтоWebСервис ИЛИ ЭтоВнешнееСоединение;
	
	СписокПользователейMS = пСтруктураМетаданных.ПользователиMS;
	СписокУстройствMS 	  = пСтруктураМетаданных.УстройстваMS;
	
	ОбновитьСписокПользователей = ТипЗнч(СписокПользователейMS) <> Тип("СписокЗначений");
    ОбновитьСписокУстройств		= (флЛегкоеОблако И НЕ ИспользоватьКэш) ИЛИ ТипЗнч(СписокУстройствMS) <> Тип("СписокЗначений");
	
	Если ОбновитьСписокПользователей ИЛИ ОбновитьСписокУстройств Тогда
		Если ТипБазы = "Частная" Тогда
			КлючПеременной = "REST_API_СтруктураПодключенияЧастнойБазыMS";
		ИначеЕсли ТипБазы = "Временная" Тогда
			КлючПеременной = "REST_API_СтруктураПодключенияВременнойБазыMS";
		Иначе
			КлючПеременной = "REST_API_СтруктураПодключенияБазыMS";
		КонецЕсли;
		
		СтруктураПодключения = КомЯдро_ПолучитьЗначениеПеременной(КлючПеременной, АдресаПеременных);
	КонецЕсли;
	
	// ***

	Если ОбновитьСписокПользователей Тогда
		СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключения,Новый Структура("HTTPМетод,Метод,ТипЗапроса","GET","Users","ПолучениеМетаданных"),,АдресаПеременных);	
		Если СтруктураОтвета.КодСостояния <> 200 Тогда
			ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Запрос: GET, Users. Получен некорректный ответ от сервера, Код состояния: " + Строка(СтруктураОтвета.КодСостояния)+ ". Содержание ошибки: " + Строка(СтруктураОтвета.ТекстОшибки),,АдресаПеременных);	
			Users = Неопределено;	
		Иначе
			Users = СтруктураОтвета.ОтветСервера.Получить("value");	
		КонецЕсли;
			
		СписокПользователейMS = Новый СписокЗначений;
		СписокПользователейMS.Добавить("Выгружать всем;Выгружать всем"); 	
		СписокПользователейMS.Добавить("Спрашивать при выгрузке;Спрашивать при выгрузке");	
		Если Users <> Неопределено Тогда
			Для Каждого ТекущийПользователь ИЗ Users Цикл
				СписокПользователейMS.Добавить(ТекущийПользователь.Получить("id") + ";" + ТекущийПользователь.Получить("name"), ТекущийПользователь.Получить("groupId") + ";" + ТекущийПользователь.Получить("groupName"));
			КонецЦикла;	
		КонецЕсли;
		
		пСтруктураМетаданных.Вставить("ПользователиMS", СписокПользователейMS);
	КонецЕсли;
	
	// ***
	
	Если ОбновитьСписокУстройств Тогда
		СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключения,Новый Структура("HTTPМетод,Метод,ТипЗапроса","GET","Devices","ПолучениеМетаданных"),,АдресаПеременных);	
		Если СтруктураОтвета.КодСостояния <> 200 Тогда
			ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Запрос: GET, Devices. Получен некорректный ответ от сервера, Код состояния: " + Строка(СтруктураОтвета.КодСостояния)+ ". Содержание ошибки: " + Строка(СтруктураОтвета.ТекстОшибки),,АдресаПеременных);	
			Devices = Неопределено;
		Иначе
			Devices = СтруктураОтвета.ОтветСервера.Получить("value");	
		КонецЕсли;
	    
		СписокУстройствMS = Новый СписокЗначений;
		Если НЕ флЛегкоеОблако Тогда
			СписокУстройствMS.Добавить("Выгружать всем;Выгружать всем"); 	
			СписокУстройствMS.Добавить("Спрашивать при выгрузке;Спрашивать при выгрузке");	
		КонецЕсли;
		
		Если Devices <> Неопределено Тогда
			Для Каждого ТекущееУстройство ИЗ Devices Цикл                  
				Если флЛегкоеОблако Тогда
					Pincode    = СокрЛП(ТекущееУстройство.Получить("pincode"));
				КонецЕсли;
				DeviceId   = СокрЛП(ТекущееУстройство.Получить("deviceId"));
				DeviceName = СокрЛП(ТекущееУстройство.Получить("deviceName"));
				Если флЛегкоеОблако Тогда
					СписокУстройствMS.Добавить(Pincode + ";" + DeviceId + ";" + ?(НЕ ЗначениеЗаполнено(DeviceName), DeviceId, DeviceName + ", (" + DeviceId + ")") + ";");
				Иначе
					СписокУстройствMS.Добавить(DeviceId + ";" + ?(НЕ ЗначениеЗаполнено(DeviceName), DeviceId, DeviceName + ", (" + DeviceId + ")") + ";");
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
			
		пСтруктураМетаданных.Вставить("УстройстваMS", СписокУстройствMS);
	КонецЕсли;	

	Если ОбновитьСписокПользователей ИЛИ ОбновитьСписокУстройств Тогда
		ГлЯдро_СохранитьДанныеВХранилище1С(ИмяПеременнойНастройки, пСтруктураМетаданных);
	КонецЕсли;
	
	ПользователиMSАдрес = ГлЯдро_ДеревоПользователейВоВременноеХранилище(СписокПользователейMS);
	УстройстваMSАдрес 	= ГлЯдро_ДеревоУстройствВоВременноеХранилище(СписокУстройствMS, флЛегкоеОблако);
	
	пСтруктураМетаданных.Вставить("ПользователиMS", ПользователиMSАдрес);
	пСтруктураМетаданных.Вставить("УстройстваMS",	УстройстваMSАдрес);
	
	Возврат пСтруктураМетаданных;
	
КонецФункции

Функция REST_API_ОбновитьМетаданныеТаблицMS(ТипБазы, АдресаПеременных)
	
	ИмяСобытия = "REST_API_ПолучитьМетаданныеДокументовMS";
	
	Если ТипБазы = "Частная" Тогда
		КлючПеременной = "REST_API_СтруктураПодключенияЧастнойБазыMS";
	ИначеЕсли ТипБазы = "Временная" Тогда
		КлючПеременной = "REST_API_СтруктураПодключенияВременнойБазыMS";
	Иначе
		КлючПеременной = "REST_API_СтруктураПодключенияБазыMS";
	КонецЕсли;
	
	СтруктураПодключения = КомЯдро_ПолучитьЗначениеПеременной(КлючПеременной, АдресаПеременных);
	
	СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключения, Новый Структура("HTTPМетод,Метод,ТипЗапроса", "GET", "TablesInfo?$expand=fields", "ПолучениеМетаданных"),, АдресаПеременных);
	Если СтруктураОтвета.КодСостояния <> 200 Тогда
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Запрос: GET, TablesInfo?$expand=fields. Получен некорректный ответ от сервера, Код состояния: " + Строка(СтруктураОтвета.КодСостояния) + ". Содержание ошибки: " + Строка(СтруктураОтвета.ТекстОшибки),, АдресаПеременных);
		Tables = Неопределено;	
	Иначе
		Tables = СтруктураОтвета.ОтветСервера.Получить("value");	
	КонецЕсли;
		
	Таблицы = Новый СписокЗначений;	
	Если Tables <> Неопределено Тогда
		Для Каждого ДопТаблица ИЗ Tables Цикл
			
			// Реквизиты таблицы
			Fields = ДопТаблица.Получить("fields");
			Если Fields = Неопределено Тогда
				СписокРеквизитов = Новый Массив;
			Иначе
				СписокРеквизитов = REST_API_ПолучитьСписокРеквизитовСущностиMS(Fields,, Истина);
			КонецЕсли;
			
			Таблицы.Добавить(СписокРеквизитов, ДопТаблица.Получить("name"));
				
		КонецЦикла;
	КонецЕсли;
		
	Возврат Таблицы;
	
КонецФункции

Функция REST_API_ПолучитьПользователейSMARTS(ТипБазы, АдресаПеременных)
	
	ИмяСобытия = "REST_API_ПолучитьПользователейSMARTS";
	
	Если ТипБазы = "Частная" Тогда
		КлючПеременной = "REST_API_СтруктураПодключенияЧастнойБазыMS";
	ИначеЕсли ТипБазы = "Временная" Тогда
		КлючПеременной = "REST_API_СтруктураПодключенияВременнойБазыMS";
	Иначе
		КлючПеременной = "REST_API_СтруктураПодключенияБазыMS";
	КонецЕсли;
	
	СтруктураПодключения = КомЯдро_ПолучитьЗначениеПеременной(КлючПеременной,АдресаПеременных);
	
	СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключения,Новый Структура("HTTPМетод,Метод,ТипЗапроса","GET","Users","ПолучениеМетаданных"),,АдресаПеременных);	
	Если СтруктураОтвета.КодСостояния <> 200 Тогда
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Запрос: GET, Users. Получен некорректный ответ от сервера, Код состояния: " + Строка(СтруктураОтвета.КодСостояния)+ ". Содержание ошибки: " + Строка(СтруктураОтвета.ТекстОшибки),,АдресаПеременных);	
		Users = Неопределено;	
	Иначе
		Users = СтруктураОтвета.ОтветСервера.Получить("value");	
	КонецЕсли;
		
	МассивПользователейMS = Новый Массив;
	
	Если Users <> Неопределено Тогда
		
		Для Каждого ТекущийПользователь ИЗ Users Цикл
			
			стрПользователиMS = Новый Структура("Ид,Имя,ИдГруппы,ИмяГруппы,Пароль,Описание,Штрихкод,ИдСкладов");
			стрПользователиMS.Ид 		= ТекущийПользователь.Получить("id");
			стрПользователиMS.Имя 		= ТекущийПользователь.Получить("name");
			стрПользователиMS.ИдГруппы 	= ТекущийПользователь.Получить("groupId");
			стрПользователиMS.ИмяГруппы = ТекущийПользователь.Получить("groupName");
			стрПользователиMS.Описание 	= ТекущийПользователь.Получить("description");			
			стрПользователиMS.Пароль 	= ТекущийПользователь.Получить("password");			
			стрПользователиMS.Штрихкод 	= ТекущийПользователь.Получить("barcode");   			
			
			СписокСкладов = Новый СписокЗначений;
			Warehouses = ТекущийПользователь.Получить("warehouseIds");                     
			Если Warehouses <> Неопределено Тогда 
				Для Каждого Warehouse Из Warehouses Цикл
					СписокСкладов.Добавить(Warehouse);
				КонецЦикла;
			КонецЕсли;
			
			стрПользователиMS.ИдСкладов = СписокСкладов;
			
			МассивПользователейMS.Добавить(стрПользователиMS);
			
		КонецЦикла;	 		
		
	КонецЕсли;
			
	Возврат ПоместитьВоВременноеХранилище(МассивПользователейMS, Новый УникальныйИдентификатор());
	
КонецФункции

Функция REST_API_ПолучитьСкладыSMARTS(ТипБазы, АдресаПеременных)
	
	ИмяСобытия = "REST_API_ПолучитьСкладыSMARTS";
	
	Если ТипБазы = "Частная" Тогда
		КлючПеременной = "REST_API_СтруктураПодключенияЧастнойБазыMS";
	ИначеЕсли ТипБазы = "Временная" Тогда
		КлючПеременной = "REST_API_СтруктураПодключенияВременнойБазыMS";
	Иначе
		КлючПеременной = "REST_API_СтруктураПодключенияБазыMS";
	КонецЕсли;
	
	СтруктураПодключения = КомЯдро_ПолучитьЗначениеПеременной(КлючПеременной,АдресаПеременных);
	
	СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключения,Новый Структура("HTTPМетод,Метод,ТипЗапроса","GET","Warehouses","ПолучениеМетаданных"),,АдресаПеременных);	
	Если СтруктураОтвета.КодСостояния <> 200 Тогда
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Запрос: GET, Warehouses. Получен некорректный ответ от сервера, Код состояния: " + Строка(СтруктураОтвета.КодСостояния)+ ". Содержание ошибки: " + Строка(СтруктураОтвета.ТекстОшибки),,АдресаПеременных);	
		Warehouses = Неопределено;	
	Иначе
		Warehouses = СтруктураОтвета.ОтветСервера.Получить("value");	
	КонецЕсли;
		
	МассивСкладовMS = Новый Массив;
	
	Если Warehouses <> Неопределено Тогда
		
		Для Каждого ТекущийСклад ИЗ Warehouses Цикл
			
			стрСкладыMS = Новый Структура("Ид,Имя");
			стрСкладыMS.Ид  = ТекущийСклад.Получить("id");
			стрСкладыMS.Имя = ТекущийСклад.Получить("name");			
			
			МассивСкладовMS.Добавить(стрСкладыMS);
			
		КонецЦикла;	 		
		
	КонецЕсли;
			
	Возврат ПоместитьВоВременноеХранилище(МассивСкладовMS, Новый УникальныйИдентификатор());
	
КонецФункции

Функция REST_API_ПолучитьГруппыПользователейSMARTS(ТипБазы, АдресаПеременных)
	
	ИмяСобытия = "REST_API_ПолучитьГруппыПользователейSMARTS";
	
	Если ТипБазы = "Частная" Тогда
		КлючПеременной = "REST_API_СтруктураПодключенияЧастнойБазыMS";
	ИначеЕсли ТипБазы = "Временная" Тогда
		КлючПеременной = "REST_API_СтруктураПодключенияВременнойБазыMS";
	Иначе
		КлючПеременной = "REST_API_СтруктураПодключенияБазыMS";
	КонецЕсли;
	
	СтруктураПодключения = КомЯдро_ПолучитьЗначениеПеременной(КлючПеременной,АдресаПеременных);                              
	
	СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключения,Новый Структура("HTTPМетод,Метод,ТипЗапроса","GET","UserGroups?$select=id,name,role,documentTypeNames","ПолучениеМетаданных"),,АдресаПеременных);	
	Если СтруктураОтвета.КодСостояния <> 200 Тогда
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Запрос: GET, Users. Получен некорректный ответ от сервера, Код состояния: " + Строка(СтруктураОтвета.КодСостояния)+ ". Содержание ошибки: " + Строка(СтруктураОтвета.ТекстОшибки),,АдресаПеременных);	
		UserGroups = Неопределено;	
	Иначе
		UserGroups = СтруктураОтвета.ОтветСервера.Получить("value");	
	КонецЕсли;
		
	МассивГруппПользователейMS = Новый Массив;      	
	                  
	Если UserGroups <> Неопределено Тогда
		
		Для Каждого ТекущаяГруппа ИЗ UserGroups Цикл
			
			стрГруппыПользователейMS = Новый Структура("Ид,Имя,Роль,ТипыДокументов");
			стрГруппыПользователейMS.Ид		= ТекущаяГруппа.Получить("id");
			стрГруппыПользователейMS.Имя 	= ТекущаяГруппа.Получить("name");			
			
			ТекРоль = ТекущаяГруппа.Получить("role");			
			Если ТипЗнч(ТекРоль) = Тип("Число") Тогда
				Если ТекРоль = 3 Тогда 
					РольСтрока = "User";				
				ИначеЕсли ТекРоль = 2 Тогда 
					РольСтрока = "Administrator";
				Иначе
					РольСтрока = "MobileDeviceUser";
				КонецЕсли;
			Иначе     
				РольСтрока = ТекРоль;
			КонецЕсли;
			стрГруппыПользователейMS.Роль 	= РольСтрока;
		
			documentTypeNames = ТекущаяГруппа.Получить("documentTypeNames");
			Если documentTypeNames <> Неопределено Тогда
				стрГруппыПользователейMS.ТипыДокументов = documentTypeNames;
			Иначе
				стрГруппыПользователейMS.ТипыДокументов = Новый Массив;				
			КонецЕсли;
			
			МассивГруппПользователейMS.Добавить(стрГруппыПользователейMS);
						
		КонецЦикла;	 		
		
	КонецЕсли;
			
	Возврат ПоместитьВоВременноеХранилище(МассивГруппПользователейMS, Новый УникальныйИдентификатор());
	
КонецФункции

Функция REST_API_ЗагрузитьПользователейВSMARTS(ПараметрыПользователя, ТипБазы, АдресаПеременных)
	
	ИмяСобытия = "REST_API_ЗагрузитьПользователейВSMARTS";
	
	ТипЗапроса = "POST";   
	Метод = "Users";
	Если ПараметрыПользователя.Получить("ТолькоРедактирование") <> Неопределено Тогда 
		Если ПараметрыПользователя["ТолькоРедактирование"] Тогда
			ТипЗапроса = "PATCH";
			Метод = "Users('" + ПараметрыПользователя["id"] + "')";
		КонецЕсли;
		ПараметрыПользователя.Удалить("ТолькоРедактирование");
	КонецЕсли;
	
	Возврат REST_API_ЗагрузкаПользователей_ВыполнитьЗапрос(ПараметрыПользователя, ТипБазы, АдресаПеременных, ТипЗапроса, Метод, "ВыгрузкаШапкиДокумента", ИмяСобытия); 	
	
КонецФункции

Функция REST_API_ЗагрузитьГруппыПользователейВSMARTS(ПараметрыГруппы, ТипБазы, АдресаПеременных)
			
	ИмяСобытия = "REST_API_ЗагрузитьГруппыПользователейВSMARTS";

	Возврат REST_API_ЗагрузкаПользователей_ВыполнитьЗапрос(ПараметрыГруппы, ТипБазы, АдресаПеременных, "POST", "UserGroups", "ВыгрузкаШапкиДокумента", ИмяСобытия); 		
				
КонецФункции

Функция REST_API_УдалитьПользователейВSMARTS(ПараметрыПользователя, ТипБазы, АдресаПеременных)
	
	ИмяСобытия = "REST_API_УдалитьПользователейВSMARTS";
	
	Возврат REST_API_ЗагрузкаПользователей_ВыполнитьЗапрос(ПараметрыПользователя, ТипБазы, АдресаПеременных, "DELETE", "Users('" + ПараметрыПользователя.Ид + "')", "ВыгрузкаШапкиДокумента", ИмяСобытия); 		
	
КонецФункции

Функция REST_API_УдалитьГруппыПользователейВSMARTS(ПараметрыГруппы, ТипБазы, АдресаПеременных)
			
	ИмяСобытия = "REST_API_УдалитьГруппыПользователейВSMARTS";
	
	Возврат REST_API_ЗагрузкаПользователей_ВыполнитьЗапрос(ПараметрыГруппы, ТипБазы, АдресаПеременных, "DELETE", "UserGroups('" + ПараметрыГруппы.Ид + "')", "ВыгрузкаШапкиДокумента", ИмяСобытия); 		
		
КонецФункции

Функция REST_API_ЗагрузкаПользователей_ВыполнитьЗапрос(ПараметрыЭлемента, ТипБазы, АдресаПеременных, HTTPМетод, Метод, ТипЗапроса, ИмяСобытия)
	
	// Получаем настройки подключения
	Если ТипБазы = "Частная" Тогда
		КлючПеременной = "REST_API_СтруктураПодключенияЧастнойБазыMS";
	ИначеЕсли ТипБазы = "Временная" Тогда
		КлючПеременной = "REST_API_СтруктураПодключенияВременнойБазыMS";
	Иначе
		КлючПеременной = "REST_API_СтруктураПодключенияБазыMS";
	КонецЕсли;
	
	СтруктураПодключения = КомЯдро_ПолучитьЗначениеПеременной(КлючПеременной,АдресаПеременных);
	
	// Посылаем запрос на сервер
	СтруктураОтвета = REST_API_ВыполнитьМетод(
		СтруктураПодключения, 
		Новый Структура("HTTPМетод,Метод,ТипЗапроса", HTTPМетод, Метод, ТипЗапроса), 
		ПараметрыЭлемента, 
		АдресаПеременных);	
		
	Ответ = Новый Структура("Результат,ТекстОшибки", Истина, "");
		
	// Обрабатываем ответ сервера
	Если СтруктураОтвета.КодСостояния < 200 или СтруктураОтвета.КодСостояния >= 300 Тогда
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Запрос: " + HTTPМетод + ", " + Метод + ". Получен некорректный ответ от сервера, Код состояния: " + Строка(СтруктураОтвета.КодСостояния)+ ". Содержание ошибки: " + Строка(СтруктураОтвета.ТекстОшибки),,АдресаПеременных);	
		Ответ.Результат 	=  Ложь;
		
		ТекстОшибки = "";		
		
		error = СтруктураОтвета.ОтветСервера.Получить("error");
		Если error <> Неопределено И ТипЗнч(error) = Тип("Соответствие") Тогда    
			innererror = error.Получить("innererror");
			Если innererror <> Неопределено И ТипЗнч(innererror) = Тип("Соответствие") Тогда    			
				ТекстОшибки = "{" + innererror.Получить("message") + "}";	
			Иначе                                                      
				ТекстОшибки = СтруктураОтвета.ОтветСервераНеРасшифрованный;
			КонецЕсли;
		Иначе
			ТекстОшибки = СтруктураОтвета.ОтветСервераНеРасшифрованный;
		КонецЕсли; 	                     	
		Ответ.ТекстОшибки 	= ТекстОшибки;
	КонецЕсли;   
	
	Возврат Ответ;
	
КонецФункции

Функция REST_API_ПолучитьСписокСлужебныхДокументовMS(ТипБазы, АдресаПеременных)
	
	// Получаем настройки подключения
	Если ТипБазы = "Частная" Тогда
		КлючПеременной = "REST_API_СтруктураПодключенияЧастнойБазыMS";
	ИначеЕсли ТипБазы = "Временная" Тогда
		КлючПеременной = "REST_API_СтруктураПодключенияВременнойБазыMS";
	Иначе
		КлючПеременной = "REST_API_СтруктураПодключенияБазыMS";
	КонецЕсли;
	
	СтруктураПодключения = КомЯдро_ПолучитьЗначениеПеременной(КлючПеременной,АдресаПеременных);
	
	// Посылаем запрос на сервер
	СтруктураОтвета = REST_API_ВыполнитьМетод(
		СтруктураПодключения, 
		Новый Структура("HTTPМетод,Метод,ТипЗапроса", "GET", "DocTypes?$expand=tables", "ПолучениеМетаданных"), 
		, 
		АдресаПеременных);	
		
	Если СтруктураОтвета.КодСостояния <> 200 Тогда
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации("REST_API_ПолучитьСписокСлужебныхДокументовMS", "Ошибка", "Запрос: GET, DocTypes?$expand=tables, получен некорректный ответ от сервера, Код состояния: " + Строка(СтруктураОтвета.КодСостояния)+ ". Содержание ошибки: " + Строка(СтруктураОтвета.ТекстОшибки),, АдресаПеременных);
		DocumentTypes = Неопределено;	
	Иначе
		DocumentTypes = СтруктураОтвета.ОтветСервера.Получить("value");
	КонецЕсли;
	
	СлужебныеДокументыMS = Новый СписокЗначений;
	
	Если DocumentTypes <> Неопределено Тогда
		Для Каждого ТипДокумента из DocumentTypes Цикл			
			
			Если Не ТипДокумента.Получить("virtual") Тогда
				Продолжить;
			КонецЕсли;                                		
			
			СлужебныеДокументыMS.Добавить(ТипДокумента.Получить("name"), ТипДокумента.Получить("displayName"));
			
		КонецЦикла;		
	КонецЕсли;	
	
	Возврат СлужебныеДокументыMS;
	
КонецФункции

Функция REST_API_ОбновитьМетаданныеПользователейMS(ТипБазы, АдресаПеременных)
	
	// Получаем настройки подключения
	Если ТипБазы = "Частная" Тогда
		КлючПеременной = "REST_API_СтруктураПодключенияЧастнойБазыMS";
	ИначеЕсли ТипБазы = "Временная" Тогда
		КлючПеременной = "REST_API_СтруктураПодключенияВременнойБазыMS";
	Иначе
		КлючПеременной = "REST_API_СтруктураПодключенияБазыMS";
	КонецЕсли;
	
	СтруктураПодключения = КомЯдро_ПолучитьЗначениеПеременной(КлючПеременной,АдресаПеременных);
	
	СтруктураОтвета = REST_API_ВыполнитьМетод(
		СтруктураПодключения,
		Новый Структура("HTTPМетод,Метод,ТипЗапроса", "GET", "Users", "ПолучениеМетаданных"),
		,
		АдресаПеременных);	
		
	Если СтруктураОтвета.КодСостояния <> 200 Тогда
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации("REST_API_ОбновитьМетаданныеПользователейMS", "Ошибка", "Запрос: GET, Users. Получен некорректный ответ от сервера, Код состояния: " + Строка(СтруктураОтвета.КодСостояния)+ ". Содержание ошибки: " + Строка(СтруктураОтвета.ТекстОшибки),, АдресаПеременных);
		Users = Неопределено;	
	Иначе
		Users = СтруктураОтвета.ОтветСервера.Получить("value");
	КонецЕсли;
	
	СписокПользователейMS = Новый СписокЗначений;
	
	СписокПользователейMS.Добавить("Выгружать всем;Выгружать всем"); 	
	СписокПользователейMS.Добавить("Спрашивать при выгрузке;Спрашивать при выгрузке");	
	Если Users <> Неопределено Тогда
		Для Каждого ТекущийПользователь ИЗ Users Цикл
			Попытка
				СписокПользователейMS.Добавить(ТекущийПользователь.Получить("id") + ";" + ТекущийПользователь.Получить("name"), ТекущийПользователь.Получить("groupId") + ";" + ТекущийПользователь.Получить("groupName"));
			Исключение
				ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации("REST_API_ОбновитьМетаданныеПользователейMS", "Ошибка", ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()),, АдресаПеременных);
			КонецПопытки;
		КонецЦикла;	
	КонецЕсли;
	
	ПользователиMSАдрес = ГлЯдро_ДеревоПользователейВоВременноеХранилище(СписокПользователейMS);
	
	ГлЯдро_ОбновитьМетаданныеПользователейMSВХранилище1С(СписокПользователейMS, ПользователиMSАдрес, АдресаПеременных);
	
	Возврат ?(ПользователиMSАдрес = Неопределено, "", ПользователиMSАдрес);
		
КонецФункции

Функция REST_API_ПолучитьСписокРеквизитовСущностиMS(СущностьMS, ДополнительныйСписок = Неопределено, ИсключатьВычисляемые = Ложь)
	
	СписокРеквизитов = Новый Массив;
	
	Для Каждого ДанныеРеквизита ИЗ СущностьMS Цикл 
		Если НЕ ДанныеРеквизита.Получить("readOnly") = Истина Тогда
			Если ИсключатьВычисляемые
				И ЗначениеЗаполнено(ДанныеРеквизита.Получить("valueTemplate")) Тогда
				Продолжить;
			КонецЕсли;
			СписокРеквизитов.Добавить(Новый Структура("Значение,Ключ,Uni",ДанныеРеквизита.Получить("fieldName"), ДанныеРеквизита.Получить("fieldName"), ГлЯдро_ПреобразоватьПервыйСимволВНижнийРегистр(ДанныеРеквизита.Получить("uni"))));
		КонецЕсли;
	КонецЦикла;
	
	Если ДополнительныйСписок <> Неопределено Тогда
		Для Каждого ДополнительныйЭлемент Из ДополнительныйСписок Цикл
			СписокРеквизитов.Добавить(ДополнительныйЭлемент);
		КонецЦикла;
	КонецЕсли;
	
	Возврат СписокРеквизитов;
	
КонецФункции

Процедура REST_API_ЗаписатьНастройкиSMARTS(СтруктураНастроек, УзловыеНастройки, ID_Узла = "",АдресаПеременных)
	
	ИмяСобытия = "REST_API_ЗаписатьНастройкиSMARTS (ГлЯдро)";
	
	Если СтруктураНастроек.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	//Обновляем дату актуальности настроек, чтобы при последующем онлайн-вызове были получены сохраненные настройки.
	ИзменилисьКлючевыеНастройки = Ложь;
	МассивИсключений = Новый Массив;
	МассивИсключений.Добавить("НастройкиОтборовУзлов_Онлайн");
	МассивИсключений.Добавить("НастройкиБизнесПроцессов_Пользовательские");
	МассивИсключений.Добавить("НастройкиОбменаСправочников");
	МассивИсключений.Добавить("ИспользоватьШаблоныВесовогоТовара");
	МассивИсключений.Добавить("ПрефиксКодаВесовогоТовара");
	МассивИсключений.Добавить("ЧислоЗнаковПослеЗапятойВесТовара");
	МассивИсключений.Добавить("ДлинаКодаВесовогоТовара");
	МассивИсключений.Добавить("ПрефиксВключенВКодВесовогоТовара");
	МассивИсключений.Добавить("ВыгружатьНоменклатуруДокументаПередВыгрузкойДокумента");
	МассивИсключений.Добавить("ЗначенияПараметровУзлов");
	МассивИсключений.Добавить("ГлобальныеПараметры_Значения");
	МассивИсключений.Добавить("ГлобальныеПараметры");
	МассивИсключений.Добавить("ГлобальныеПараметры_Пользовательские");
	МассивИсключений.Добавить("НастройкиБизнесПроцессов_ПользовательскиеНастройки");
	
	ИзменилисьКэшируемыеНастройки = Ложь;
	МассивИсключенийКэшируемыеНастройки = Новый Массив; // Ключевые настройки для оффлайна в дополнение к МассивИсключений
	МассивИсключенийКэшируемыеНастройки.Добавить("НастройкиОтборовУзлов_Интерактивный");
	
	СтруктураПодключения = КомЯдро_ПолучитьЗначениеПеременной("REST_API_СтруктураПодключенияБазыMS",АдресаПеременных);
	
	Для Каждого Настройка Из СтруктураНастроек Цикл
		ОтправляемыеДанные = Новый Соответствие;
		ИтоговыйКлючНастройки = Настройка.Ключ;
		
		// Если мы пытаемся отключить сжатие данных, саму настройку уже нужно сохранять без сжатия данных
		Если Настройка.Ключ = "ОтключитьСжатиеДанных"
			И Настройка.Значение = Истина Тогда
			ГлЯдро_ЗаписатьВКэшНастройкуSMARTS("ОтключитьСжатиеДанных", Истина, АдресаПеременных);
		КонецЕсли;
		
		Если НЕ ИзменилисьКлючевыеНастройки
			И МассивИсключений.Найти(Настройка.Ключ) <> Неопределено Тогда
			ИзменилисьКлючевыеНастройки = Истина;
			ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Изменение ключевых настроек, изменена настройка: " + ИтоговыйКлючНастройки,, АдресаПеременных);
		КонецЕсли;
		
		Если НЕ ИзменилисьКэшируемыеНастройки
			И (ИзменилисьКлючевыеНастройки ИЛИ МассивИсключенийКэшируемыеНастройки.Найти(Настройка.Ключ) <> Неопределено) Тогда
			ИзменилисьКэшируемыеНастройки = Истина;
			ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Изменение кэшируемых настроек, изменена настройка: " + ИтоговыйКлючНастройки,, АдресаПеременных);
		КонецЕсли;
		
		Если УзловыеНастройки.Найти(Настройка.Ключ) <> Неопределено Тогда
			ИтоговыйКлючНастройки = ИтоговыйКлючНастройки + ?(ID_Узла = "", "", "_"+ ID_Узла);
		КонецЕсли;
		
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Запись настройки в CustomSettings: "+ИтоговыйКлючНастройки,,АдресаПеременных);
		
		ОтправляемыеДанные.Вставить("name", ИтоговыйКлючНастройки);
		ОтправляемыеДанные.Вставить("value", Настройка.Значение);
		REST_API_ВыполнитьМетод(СтруктураПодключения,Новый Структура("HTTPМетод,Метод,ТипЗапроса","POST","CustomSettings","ПолучениеСохранениеНастроек"),ОтправляемыеДанные,АдресаПеременных);
	КонецЦикла;
	
	Если ИзменилисьКлючевыеНастройки ИЛИ ИзменилисьКэшируемыеНастройки Тогда
		Если СтруктураПодключения.Свойство("IdBaseSMARTS") Тогда
			ПостфиксБазы = СтрЗаменить(СтруктураПодключения.IdBaseSMARTS,"-","_");
		Иначе
			ПостфиксБазы = "";
		КонецЕсли;
		ДатаАктуальности = ТекущаяДата();

		Если ИзменилисьКлючевыеНастройки Тогда
			ГлЯдро_СохранитьДанныеВХранилище1С("Cleverence_ДатаАктуальностиНастроек_" + ПостфиксБазы, ТекущаяДата());
			ГлЯдро_СохранитьДанныеВХранилище1С("Cleverence_REST_API_ДатаАктуальностиСоединения", Неопределено);
			ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Сброшена дата актуальности настроек, постфикс базы: " + ?(ПостфиксБазы = "", "<нет>", ПостфиксБазы),, АдресаПеременных);
		КонецЕсли;	
			
		Если ИзменилисьКэшируемыеНастройки Тогда
			ГлЯдро_СохранитьНастройкуВБазеSMARTS("ДатаАктуальностиКэшируемыхНастроек", ДатаАктуальности,, АдресаПеременных);
			ГлЯдро_СохранитьДанныеВХранилище1С("Cleverence_ДатаАктуальностиКэшируемыхНастроек_" + ПостфиксБазы, ДатаАктуальности);
		КонецЕсли;			
	КонецЕсли;
	
КонецПроцедуры

Процедура REST_API_УдалитьНастройкиSMARTS(СтруктураНастроек, УзловыеНастройки, ID_Узла = "",АдресаПеременных)
		
	СтруктураПодключения = КомЯдро_ПолучитьЗначениеПеременной("REST_API_СтруктураПодключенияБазыMS",АдресаПеременных);
		
	Для Каждого Настройка Из СтруктураНастроек Цикл
		ИтоговыйКлючНастройки = Настройка.Ключ;
		Если УзловыеНастройки.Найти(Настройка.Ключ) <> Неопределено Тогда
			ИтоговыйКлючНастройки = ИтоговыйКлючНастройки + ?(ID_Узла = "", "", "_"+ ID_Узла);
		КонецЕсли;
		REST_API_ВыполнитьМетод(СтруктураПодключения,Новый Структура("HTTPМетод,Метод,ТипЗапроса","DELETE","CustomSettings('"+ИтоговыйКлючНастройки+"')","ПолучениеСохранениеНастроек"),,АдресаПеременных);
	КонецЦикла;
	
КонецПроцедуры

Функция REST_API_ВыгрузитьТаблицуНаСерверSMARTS(ИмяТаблицы, ДанныеДляВыгрузки, ТипБазы, ОчищатьСправочникПередВыгрузкой = Ложь, АдресаПеременных)
	
	РезультатВыгрузки = Новый Структура;
	РезультатВыгрузки.Вставить("Статус"		, Истина);																			 
	РезультатВыгрузки.Вставить("Сообщение"	, "Таблица [" + ИмяТаблицы + "] успешно выгружена. Выгружено:" 
												+ Символы.ВК + Символы.Таб + "- " + Формат(?(ИмяТаблицы = "Номенклатура",ДанныеДляВыгрузки.МассивыСтрок.Количество(),ДанныеДляВыгрузки.Количество()), "ЧН=0; ЧГ=3,0") + " строк");
												
	Если ИмяТаблицы = "Номенклатура" Тогда											
		
		КоличествоРазличныхТоваров = ?(ДанныеДляВыгрузки.Свойство("КоличествоТоваров"),ДанныеДляВыгрузки.КоличествоТоваров,0);
		РезультатВыгрузки.Сообщение = РезультатВыгрузки.Сообщение 
										+ Символы.ВК + Символы.Таб + "- " + Формат(КоличествоРазличныхТоваров, "ЧН=0; ЧГ=3,0") + " товаров";
	КонецЕсли;											
	ИмяТаблицыENG = ГлЯдро_СтрокуВТранслитENG(ИмяТаблицы);
	
	Если ТипБазы = "Частная" Тогда
		КлючПеременной = "REST_API_СтруктураПодключенияЧастнойБазыMS";
	ИначеЕсли ТипБазы = "Временная" Тогда
		КлючПеременной = "REST_API_СтруктураПодключенияВременнойБазыMS";
	Иначе
		КлючПеременной = "REST_API_СтруктураПодключенияБазыMS";
	КонецЕсли;
	
	СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной(КлючПеременной,АдресаПеременных);
	
	РезультатПопытки = Истина;
	
	СтруктураПараметровМетода = Новый Структура;
	СтруктураПараметровМетода.Вставить("ИмяТаблицы", ИмяТаблицы);
	СтруктураПараметровМетода.Вставить("СтруктураПодключенияMS",СтруктураПодключенияMS);
	Если ИмяТаблицы = "Номенклатура" Тогда
		ПакетДляОтправки = Новый Структура();
		ПакетДляОтправки.Вставить("lschema",					ДанныеДляВыгрузки.МассивИмен);
		ПакетДляОтправки.Вставить("rewriteProductsBook",		ОчищатьСправочникПередВыгрузкой);
		ПакетДляОтправки.Вставить("useFullTextSearch",			Истина);
		СтруктураПараметровМетода.Вставить("ПакетДляОтправки", 	ПакетДляОтправки);
		
	ИначеЕсли ИмяТаблицы = "Ячейки" Тогда	
		СтруктураПараметровМетода.Вставить("ВызываемыйМетод",	?(ОчищатьСправочникПередВыгрузкой, "Overwrite", "Update"));
		
	Иначе
		СтруктураПараметровМетода.Вставить("ИмяТаблицыENG", 	ИмяТаблицыENG);
		СтруктураПараметровМетода.Вставить("ВызываемыйМетод",	?(ОчищатьСправочникПередВыгрузкой, "Overwrite", "Update"));
		
	КонецЕсли;
	
	// Первая попытка начать выгрузку
	РезультатОтвет = REST_API_ВыгрузкаТаблицыНаСерверSMARTS_Начало(СтруктураПараметровМетода, АдресаПеременных);
	РезультатПопытки = РезультатПопытки И РезультатОтвет.КодСостояния = 204;	
	
	Если НЕ РезультатПопытки Тогда
		// Если при начале выгрузки возвращается ошибка, возможно на сервере не была завершена предыдущая выгрузка. Попытаемся сбросить и повторить начало выгрузки
		РезультатСброса = REST_API_ВыгрузкаТаблицыНаСерверSMARTS_СбросВыгрузки(СтруктураПараметровМетода, АдресаПеременных);
		Если РезультатСброса.КодСостояния = 204 Тогда
			// Вторая попытка начать выгрузку
			РезультатОтвет = REST_API_ВыгрузкаТаблицыНаСерверSMARTS_Начало(СтруктураПараметровМетода, АдресаПеременных);
			РезультатПопытки = РезультатОтвет.КодСостояния = 204;
		КонецЕсли;
		Если НЕ РезультатПопытки Тогда
			ОписаниеОшибки = РезультатОтвет.ТекстОшибки;
			РезультатВыгрузки = Новый Структура("Сообщение,Статус", "Таблица [" + ИмяТаблицы + "] не выгружается!" + Символы.ВК + ОписаниеОшибки, Ложь);
		КонецЕсли;
	КонецЕсли;
	
	Если РезультатВыгрузки.Статус = Истина Тогда
		КоличествоСтрок = ДанныеДляВыгрузки.Количество();
		МассивОтправляемыхЗначений = Новый Массив;
		Если ИмяТаблицы = "Номенклатура" Тогда
			МассивДанныхДляВыгрузки = ДанныеДляВыгрузки.МассивыСтрок;
		Иначе
			МассивДанныхДляВыгрузки = ДанныеДляВыгрузки;
		КонецЕсли;
		
		Икс = 0;МассивСтрокиВыгрузки = Новый Массив;
		Для Каждого СтрокаВыгрузки из МассивДанныхДляВыгрузки Цикл
			Икс = Икс +1;
			Если Икс%5000 = 0 Тогда
				МассивОтправляемыхЗначений.Добавить(МассивСтрокиВыгрузки);					
				МассивСтрокиВыгрузки = Новый Массив;
			КонецЕсли;
			МассивСтрокиВыгрузки.Добавить(СтрокаВыгрузки);
		КонецЦикла;
		МассивОтправляемыхЗначений.Добавить(МассивСтрокиВыгрузки);
		
		Для Каждого МассивСтрокиВыгрузки из МассивОтправляемыхЗначений Цикл
			
			Если ИмяТаблицы = "Номенклатура" Тогда
				
				СовмещенныйМассив = Новый Массив();
				Для каждого МассивСтроки Из МассивСтрокиВыгрузки Цикл 
					Для каждого Строка Из МассивСтроки Цикл
						СовмещенныйМассив.Добавить(XMLСтрока(Строка));
					КонецЦикла;
				КонецЦикла;
				ОтправляемыеДанные = Новый Структура();
				ОтправляемыеДанные.Вставить("flds",СовмещенныйМассив);
				
			ИначеЕсли ИмяТаблицы = "Ячейки" Тогда
				ОтправляемыеДанные = Новый Соответствие;
				ОтправляемыеДанные.Вставить("value",МассивСтрокиВыгрузки);
				
			Иначе
				ОтправляемыеДанные = Новый Соответствие;
				ОтправляемыеДанные.Вставить("value",МассивСтрокиВыгрузки);
				
			КонецЕсли;
			
			СтруктураПараметровМетода.Вставить("ОтправляемыеДанные",ОтправляемыеДанные);
			
			РезультатОтвет = REST_API_ВыгрузкаТаблицыНаСерверSMARTS_ОтправкаЗначений(СтруктураПараметровМетода,АдресаПеременных);
			РезультатПопытки = РезультатПопытки И НЕ ЗначениеЗаполнено(РезультатОтвет.ТекстОшибки);
	
			Если НЕ РезультатПопытки Тогда
				ОписаниеОшибки = РезультатОтвет.ТекстОшибки;
				РезультатВыгрузки =  Новый Структура("Сообщение,Статус", "Ошибка выгрузки таблицы [" + ИмяТаблицы + "]." + Символы.ВК + ОписаниеОшибки, Ложь);
				
				// Если при отправке данных произошла ошибка, попытаемся сбросить выгрузку, чтоб сервер дальше не ждал от нас новую порцию
				РезультатСброса = REST_API_ВыгрузкаТаблицыНаСерверSMARTS_СбросВыгрузки(СтруктураПараметровМетода, АдресаПеременных);								
				Прервать;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Если РезультатВыгрузки.Статус = Истина Тогда
		
		РезультатОтвет = REST_API_ВыгрузкаТаблицыНаСерверSMARTS_Завершение(СтруктураПараметровМетода, АдресаПеременных);
		РезультатПопытки = РезультатПопытки И НЕ ЗначениеЗаполнено(РезультатОтвет.ТекстОшибки);
		
		Если НЕ РезультатПопытки Тогда
			ОписаниеОшибки = РезультатОтвет.ТекстОшибки;
			РезультатВыгрузки =  Новый Структура("Сообщение,Статус", "Не удалось закончить выгрузку таблицы [" + ИмяТаблицы + "]." + Символы.ВК + ОписаниеОшибки, Ложь);
		КонецЕсли;
	КонецЕсли;
	
	Возврат РезультатВыгрузки;
	
КонецФункции

Функция REST_API_ВыгрузкаТаблицыНаСерверSMARTS_Начало(СтруктураПараметровМетода, АдресаПеременных)
	
	ИмяТаблицы 				= СтруктураПараметровМетода.ИмяТаблицы;
	СтруктураПодключенияMS 	= СтруктураПараметровМетода.СтруктураПодключенияMS;
	
	Если ИмяТаблицы = "Номенклатура" Тогда
		ПакетДляОтправки = СтруктураПараметровМетода.ПакетДляОтправки;				
		РезультатОтвет = REST_API_ВыполнитьМетод(СтруктураПодключенияMS,Новый Структура("HTTPМетод,Метод,ТипЗапроса","POST","Products/BeginUploadProducts","НачалоВыгрузкиТаблицы"),ПакетДляОтправки,АдресаПеременных);
	
	ИначеЕсли ИмяТаблицы = "Ячейки" Тогда	
		ВызываемыйМетод = СтруктураПараметровМетода.ВызываемыйМетод;
		РезультатОтвет = REST_API_ВыполнитьМетод(СтруктураПодключенияMS,Новый Структура("HTTPМетод,Метод,ТипЗапроса","POST","Cells/Begin"+ВызываемыйМетод,"НачалоВыгрузкиТаблицы"),Новый Структура("warehouseId","1"),АдресаПеременных);
		//РезультатОтвет = REST_API_ВыполнитьМетод(СтруктураПодключенияMS,Новый Структура("HTTPМетод,Метод,ТипЗапроса","POST","Cells/BeginUpdate","НачалоВыгрузкиТаблицы"),Новый Структура("warehouseId","1"),АдресаПеременных);				
		
	Иначе
		ИмяТаблицыENG 	= СтруктураПараметровМетода.ИмяТаблицыENG;
		ВызываемыйМетод = СтруктураПараметровМетода.ВызываемыйМетод;
		РезультатОтвет = REST_API_ВыполнитьМетод(СтруктураПодключенияMS,Новый Структура("HTTPМетод,Метод,ТипЗапроса","POST","Tables/"+ИмяТаблицыENG+"/Begin"+ВызываемыйМетод,"НачалоВыгрузкиТаблицы"),,АдресаПеременных);
		//РезультатОтвет = REST_API_ВыполнитьМетод(СтруктураПодключенияMS,Новый Структура("HTTPМетод,Метод,ТипЗапроса","POST","Tables/"+ИмяТаблицыENG+"/BeginOverwrite","НачалоВыгрузкиТаблицы"),,АдресаПеременных);
		
	КонецЕсли;
	
	Возврат РезультатОтвет;
КонецФункции

Функция REST_API_ВыгрузкаТаблицыНаСерверSMARTS_ОтправкаЗначений(СтруктураПараметровМетода, АдресаПеременных)
	
	ИмяТаблицы 				= СтруктураПараметровМетода.ИмяТаблицы;
	СтруктураПодключенияMS 	= СтруктураПараметровМетода.СтруктураПодключенияMS;
	ОтправляемыеДанные 		= СтруктураПараметровМетода.ОтправляемыеДанные;
	
	Если ИмяТаблицы = "Номенклатура" Тогда	
		РезультатОтвет = REST_API_ВыполнитьМетод(СтруктураПодключенияMS,Новый Структура("HTTPМетод,Метод,ТипЗапроса","POST","Products/AddProductsToUpload","ВыгрузкаТаблицы"),ОтправляемыеДанные,АдресаПеременных);
		
	ИначеЕсли ИмяТаблицы = "Ячейки" Тогда		
		РезультатОтвет = REST_API_ВыполнитьМетод(СтруктураПодключенияMS,Новый Структура("HTTPМетод,Метод,ТипЗапроса","POST","Cells","ВыгрузкаТаблицы"),ОтправляемыеДанные,АдресаПеременных);
		
	Иначе
		ИмяТаблицыENG = СтруктураПараметровМетода.ИмяТаблицыENG;
		РезультатОтвет = REST_API_ВыполнитьМетод(СтруктураПодключенияMS,Новый Структура("HTTPМетод,Метод,ТипЗапроса","POST","Tables/"+ИмяТаблицыENG,"ВыгрузкаТаблицы"),ОтправляемыеДанные,АдресаПеременных);
		
	КонецЕсли;
	
	Возврат РезультатОтвет;
	
КонецФункции

Функция REST_API_ВыгрузкаТаблицыНаСерверSMARTS_Завершение(СтруктураПараметровМетода, АдресаПеременных)
	
	ИмяТаблицы 				= СтруктураПараметровМетода.ИмяТаблицы;
	СтруктураПодключенияMS 	= СтруктураПараметровМетода.СтруктураПодключенияMS;
	
	Если ИмяТаблицы = "Номенклатура" Тогда
		РезультатОтвет = REST_API_ВыполнитьМетод(СтруктураПодключенияMS,Новый Структура("HTTPМетод,Метод,ТипЗапроса","POST","Products/EndUploadProducts","КонецВыгрузкиТаблицы"),,АдресаПеременных);		
		
	ИначеЕсли ИмяТаблицы = "Ячейки" Тогда	
		ВызываемыйМетод = СтруктураПараметровМетода.ВызываемыйМетод;
		РезультатОтвет = REST_API_ВыполнитьМетод(СтруктураПодключенияMS,Новый Структура("HTTPМетод,Метод,ТипЗапроса","POST","Cells/End"+ВызываемыйМетод,"КонецВыгрузкиТаблицы"),Новый Структура("warehouseId","1"),АдресаПеременных);		
		//РезультатОтвет = REST_API_ВыполнитьМетод(СтруктураПодключенияMS,Новый Структура("HTTPМетод,Метод,ТипЗапроса","POST","Cells/EndUpdate","КонецВыгрузкиТаблицы"),Новый Структура("warehouseId","1"),АдресаПеременных);		
		
	Иначе
		ИмяТаблицыENG 	= СтруктураПараметровМетода.ИмяТаблицыENG;
		ВызываемыйМетод = СтруктураПараметровМетода.ВызываемыйМетод;
		РезультатОтвет = REST_API_ВыполнитьМетод(СтруктураПодключенияMS,Новый Структура("HTTPМетод,Метод,ТипЗапроса","POST","Tables/"+ИмяТаблицыENG+"/End"+ВызываемыйМетод,"КонецВыгрузкиТаблицы"),,АдресаПеременных);
		//РезультатОтвет = REST_API_ВыполнитьМетод(СтруктураПодключенияMS,Новый Структура("HTTPМетод,Метод,ТипЗапроса","POST","Tables/"+ИмяТаблицыENG+"/EndOverwrite","КонецВыгрузкиТаблицы"),,АдресаПеременных);
		
	КонецЕсли;
	
	Возврат РезультатОтвет;
	
КонецФункции

Функция REST_API_ВыгрузкаТаблицыНаСерверSMARTS_СбросВыгрузки(СтруктураПараметровМетода, АдресаПеременных)
	
	ИмяТаблицы 				= СтруктураПараметровМетода.ИмяТаблицы;
	СтруктураПодключенияMS 	= СтруктураПараметровМетода.СтруктураПодключенияMS;
	
	Если ИмяТаблицы = "Номенклатура" Тогда	                                                          
		СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключенияMS,Новый Структура("HTTPМетод,Метод,ТипЗапроса","POST","Products/ResetUploadProducts","НачалоВыгрузкиТаблицы"),,АдресаПеременных);
	ИначеЕсли ИмяТаблицы = "Ячейки" Тогда
		ВызываемыйМетод = СтруктураПараметровМетода.ВызываемыйМетод;
		СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключенияMS,Новый Структура("HTTPМетод,Метод,ТипЗапроса","POST","Cells/Reset"+ВызываемыйМетод,"НачалоВыгрузкиТаблицы"),Новый Структура("warehouseId","1"),АдресаПеременных);
		//СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключенияMS,Новый Структура("HTTPМетод,Метод,ТипЗапроса","POST","Cells/ResetUpdate","НачалоВыгрузкиТаблицы"),Новый Структура("warehouseId","1"),АдресаПеременных);			
	Иначе
		ИмяТаблицыENG 	= СтруктураПараметровМетода.ИмяТаблицыENG;
		ВызываемыйМетод = СтруктураПараметровМетода.ВызываемыйМетод;
		СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключенияMS,Новый Структура("HTTPМетод,Метод,ТипЗапроса","POST","Tables/"+ИмяТаблицыENG+"/Reset"+ВызываемыйМетод,"НачалоВыгрузкиТаблицы"),,АдресаПеременных);
		//СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключенияMS,Новый Структура("HTTPМетод,Метод,ТипЗапроса","POST","Tables/"+ИмяТаблицыENG+"/ResetOverwrite","НачалоВыгрузкиТаблицы"),,АдресаПеременных);		
	КонецЕсли;
	
	Возврат СтруктураОтвета;
	
КонецФункции

// Выполняет очистку таблицы на сервере Mobile Smarts при работе с типом интерфейса REST_API
//
// Параметры:
//	ИмяТаблицы - Строка - имя таблицы Mobile Smarts, которую необходимо очистить
//  ТипБазы - Строка - "Частная", "Временная", "Основная"
//	АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
//
// Возвращаемое значение:
//	Структура - содержит:
//		* Сообщение - Строка - информационное сообщение о результате очистки таблицы
//		* Статус - Булево - флаг успешности очистки таблицы
Функция REST_API_ОчиститьТаблицуНаСервереSMARTS(ИмяТаблицы, ТипБазы, АдресаПеременных) Экспорт
	
	Если ТипБазы = "Частная" Тогда
		КлючПеременной = "REST_API_СтруктураПодключенияЧастнойБазыMS";
	ИначеЕсли ТипБазы = "Временная" Тогда
		КлючПеременной = "REST_API_СтруктураПодключенияВременнойБазыMS";
	Иначе
		КлючПеременной = "REST_API_СтруктураПодключенияБазыMS";
	КонецЕсли;
	
	СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной(КлючПеременной,АдресаПеременных);
	ИмяТаблицыENG = ГлЯдро_СтрокуВТранслитENG(ИмяТаблицы);
	РезультатПопытки = Истина;
	// Во всех случаях ТипЗапроса устанавливается = "НачалоВыгрузкиТаблицы", т.к. не выгружаем данные и завершение апдейта не должно долго выполняться
	Если ИмяТаблицы = "Номенклатура" Тогда
		РезультатОтвет = REST_API_ВыполнитьМетод(СтруктураПодключенияMS,Новый Структура("HTTPМетод,Метод,ТипЗапроса","POST","Products/BeginOverwrite","НачалоВыгрузкиТаблицы"),,АдресаПеременных);
		РезультатПопытки = РезультатПопытки И РезультатОтвет.КодСостояния = 204;
		РезультатОтвет = REST_API_ВыполнитьМетод(СтруктураПодключенияMS,Новый Структура("HTTPМетод,Метод,ТипЗапроса","POST","Products/EndOverwrite","НачалоВыгрузкиТаблицы"),,АдресаПеременных);
		РезультатПопытки = РезультатПопытки И РезультатОтвет.КодСостояния = 204;
	ИначеЕсли ИмяТаблицы = "Ячейки" Тогда
		МассивСтрокиВыгрузки = Новый Соответствие;
		МассивСтрокиВыгрузки.Вставить("warehouseId","1");
		РезультатОтвет = REST_API_ВыполнитьМетод(СтруктураПодключенияMS,Новый Структура("HTTPМетод,Метод,ТипЗапроса","POST","Cells/BeginOverwrite","НачалоВыгрузкиТаблицы"),МассивСтрокиВыгрузки,АдресаПеременных);
		РезультатПопытки = РезультатПопытки И НЕ ЗначениеЗаполнено(РезультатОтвет.ТекстОшибки);
		РезультатОтвет = REST_API_ВыполнитьМетод(СтруктураПодключенияMS,Новый Структура("HTTPМетод,Метод,ТипЗапроса","POST","Cells/EndOverwrite","НачалоВыгрузкиТаблицы"),МассивСтрокиВыгрузки,АдресаПеременных);
		РезультатПопытки = РезультатПопытки И НЕ ЗначениеЗаполнено(РезультатОтвет.ТекстОшибки);
	Иначе
		РезультатОтвет = REST_API_ВыполнитьМетод(СтруктураПодключенияMS,Новый Структура("HTTPМетод,Метод,ТипЗапроса","POST","Tables/"+ИмяТаблицыENG+"/BeginOverwrite","НачалоВыгрузкиТаблицы"),,АдресаПеременных);
		РезультатПопытки = РезультатПопытки И РезультатОтвет.КодСостояния = 204;
		РезультатОтвет = REST_API_ВыполнитьМетод(СтруктураПодключенияMS,Новый Структура("HTTPМетод,Метод,ТипЗапроса","POST","Tables/"+ИмяТаблицыENG+"/EndOverwrite","НачалоВыгрузкиТаблицы"),,АдресаПеременных);
		РезультатПопытки = РезультатПопытки И РезультатОтвет.КодСостояния = 204;
	КонецЕсли;
	
	Если РезультатПопытки = Истина Тогда
		РезультатВыгрузки = Новый Структура("Сообщение,Статус", "Таблица [" + ИмяТаблицы + "] успешно очищена", Истина);
	Иначе
		РезультатВыгрузки = Новый Структура("Сообщение,Статус", "Ошибка при очистке таблицы [" + ИмяТаблицы + "]", Ложь);
	КонецЕсли;
	
	Возврат РезультатВыгрузки;
	
КонецФункции

Функция REST_API_ПолучитьСписокДокументовНаСервереSMARTS(ТаблицаДокументов, ТипБазы, РазмерВыборки = 0, ОтборПоПериоду = Неопределено, ОтборПоУзлу = Неопределено, АдресаПеременных)
	
	ИмяСобытия = "REST_API_ПолучитьСписокДокументовНаСервереSMARTS";
	
	Если ТипБазы = "Частная" Тогда
		КлючПеременной = "REST_API_СтруктураПодключенияЧастнойБазыMS";
	ИначеЕсли ТипБазы = "Временная" Тогда
		КлючПеременной = "REST_API_СтруктураПодключенияВременнойБазыMS";
	Иначе
		КлючПеременной = "REST_API_СтруктураПодключенияБазыMS";
	КонецЕсли;
	
	СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной(КлючПеременной,АдресаПеременных);
	СтруктураМетаданных = КомЯдро_ПолучитьЗначениеПеременной("СтруктураМетаданных", АдресаПеременных);
	
	СтрокаФильтра 	= "";
	ФильтрПоПериоду = "";
	ФильтрПоУзлу	= "";
	
	Если ОтборПоПериоду <> Неопределено Тогда
		ДатаНачала 		= ОтборПоПериоду.ДатаНачала;                                      	
		Если ЗначениеЗаполнено(ДатаНачала) Тогда                                          
			ГодНачалаПериода 	= Формат(Год(ДатаНачала), "ЧГ=");
			МесяцНачалаПериода 	= Месяц(ДатаНачала);
			ФильтрПоПериоду = ФильтрПоПериоду + "((year(createDate) eq " + ГодНачалаПериода + " and month(createDate) gt " + МесяцНачалаПериода + ") " +
				"or (year(createDate) eq " + ГодНачалаПериода + " and month(createDate) eq " + МесяцНачалаПериода + " and day(createDate) ge " + День(ДатаНачала) + ") " + 
					"or (year(createDate) gt " + ГодНачалаПериода + "))";
		КонецЕсли;            		
		ДатаОкончания 	= ОтборПоПериоду.ДатаОкончания;
		Если ЗначениеЗаполнено(ДатаОкончания) Тогда     
			ГодКонцаПериода 	= Формат(Год(ДатаОкончания), "ЧГ=");
			МесяцКонцаПериода 	= Месяц(ДатаОкончания);
			ФильтрПоПериоду = ФильтрПоПериоду + ?(ЗначениеЗаполнено(ДатаНачала), " and ", "") + "((year(createDate) eq " + ГодКонцаПериода + " and month(createDate) lt " + МесяцКонцаПериода + ") " +
				"or (year(createDate) eq " + ГодКонцаПериода + " and month(createDate) eq " + МесяцКонцаПериода + " and day(createDate) lt " + День(ДатаОкончания) + ") " + 
					"or (year(createDate) lt " + ГодКонцаПериода + "))";
		КонецЕсли;		                                                                                          
	КонецЕсли;
	
	Если ОтборПоУзлу <> Неопределено Тогда
		ФильтрПоУзлу = ?(НЕ ПустаяСтрока(ФильтрПоПериоду), " and ", "") + "(idUzla eq '" + ОтборПоУзлу.ID_Узла + "' or idUzla eq NULL)";
	КонецЕсли;
	
	Если НЕ ПустаяСтрока(ФильтрПоПериоду)
		ИЛИ НЕ ПустаяСтрока(ФильтрПоУзлу) Тогда
		СтрокаФильтра = "&$filter=" + ФильтрПоПериоду + ФильтрПоУзлу;
	КонецЕсли;
	
	ДопОтбор = ?(ЗначениеЗаполнено(РазмерВыборки), "&$top=" + РазмерВыборки, "");
	
	// заполняем таблицу
	СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключенияMS,Новый Структура("HTTPМетод,Метод,ТипЗапроса","GET","Docs?$expand=declaredItems($count=true;$top=0),currentItems($count=true;$top=0),extendedFields" + СтрокаФильтра + ДопОтбор,"ПолучениеСпискаДокументов"),,АдресаПеременных);
	Если СтруктураОтвета.КодСостояния <> 200 Тогда
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Запрос: GET, Docs?$expand=declaredItems($count=true;$top=0),currentItems($count=true;$top=0),extendedFields" + СтрокаФильтра + ДопОтбор + ". Получен некорректный ответ от сервера, Код состояния: " + Строка(СтруктураОтвета.КодСостояния)+ ". Содержание ошибки: " + Строка(СтруктураОтвета.ТекстОшибки),,АдресаПеременных);
		Возврат Неопределено;
	КонецЕсли;
	
	СписокДокументовSMARTS = СтруктураОтвета.ОтветСервера.Получить("value");	
	Для Каждого ДокументSMARTS Из СписокДокументовSMARTS Цикл
		
		КоличествоПлан = ДокументSMARTS.Получить("declaredItems@odata.count");		
		Если КоличествоПлан = Неопределено Тогда
			СтрокиПлан = ДокументSMARTS.Получить("declaredItems");
			КоличествоПлан = ?(СтрокиПлан=Неопределено,0,СтрокиПлан.Количество());
		КонецЕсли;
		
		КоличествоФакт = ДокументSMARTS.Получить("currentItems@odata.count");
		Если КоличествоФакт = Неопределено Тогда
			СтрокиФакт = ДокументSMARTS.Получить("currentItems");
			КоличествоФакт = ?(СтрокиФакт=Неопределено,0,СтрокиФакт.Количество());
		КонецЕсли;
		
		extendedFields = ДокументSMARTS.Получить("extendedFields");
		
		ИмяТипаДокумента = ГлЯдро_ПреобразованиеНаименованияДокументаБезПробелов(ДокументSMARTS.Получить("documentTypeName"));
		
		// Новые типы документов, добавленные, например, вручную, и еще не инициализированные в текущих
		// настройках ядра, просто пропускаем
		Если Не СтруктураМетаданных.ДокументыMS.Свойство(ИмяТипаДокумента) Тогда
			Продолжить;
		КонецЕсли;
		
		ТекущаяСтрокаТаблицы = Новый Структура(
		"ДатаСоздания,
		|Имя,
		|Ид,
		|ИмяТипаДокумента,
		|СтрокиПланКоличество,
		|СтрокиФактКоличество,
		|ИмяПользователя,
		|ВОбработке,
		|Завершен,
		|НастройкаБизнесПроцесса,
		|СозданНаТСД,
		|ЕстьПереполнениеИлиНедобор,
		|ЕстьПереполнение,
		|ЕстьНедобор,
		|ДатаЗавершения,
		|КонтрольКоличества,
		|ИдИсходныхДокументов,
		|ИмяБП,
		|ИдУзла"
		,ДокументSMARTS.Получить("createDate")
		,ДокументSMARTS.Получить("name")
		,ДокументSMARTS.Получить("id")
		,ИмяТипаДокумента
		,КоличествоПлан
		,КоличествоФакт
		,ДокументSMARTS.Получить("userName")
		,ДокументSMARTS.Получить("inProcess")
		,ДокументSMARTS.Получить("finished")
		,ДокументSMARTS.Получить("nastrojkaBiznesProcessa")
		,ДокументSMARTS.Получить("createdOnPDA")
		,?(extendedFields<>Неопределено,extendedFields.Получить("underloadedOrOverloaded"),Ложь)
		,?(extendedFields<>Неопределено,extendedFields.Получить("overloaded"),Ложь)
		,?(extendedFields<>Неопределено,extendedFields.Получить("underloaded"),Ложь)
		,ДокументSMARTS.Получить("lastChangeDate")
		,ДокументSMARTS.Получить("kontrolKolva")
		,ДокументSMARTS.Получить("idIshodnyhDokumentov")
		,ДокументSMARTS.Получить("imyaBP")
		,ДокументSMARTS.Получить("idUzla"));
		
		// Дополняем существующую таблицу реквизитами шапки документа
		МассивРеквизитов = СтруктураМетаданных.ДокументыMS[ИмяТипаДокумента].Реквизиты;
		Для Каждого СтрокаРеквизит Из МассивРеквизитов Цикл
			Если ТекущаяСтрокаТаблицы.Свойство(СтрокаРеквизит.Значение) Тогда
				Продолжить;
			КонецЕсли;                                                                   			
			ТекущаяСтрокаТаблицы.Вставить(СтрокаРеквизит.Значение, ДокументSMARTS.Получить(СтрокаРеквизит.Uni));			
		КонецЦикла;		
		
		ТаблицаДокументов.Добавить(ТекущаяСтрокаТаблицы);
	КонецЦикла;
	
	Для Каждого СтрокаТаблицы Из ТаблицаДокументов Цикл
		Если СтрокаТаблицы.Свойство("ЭтоТаблицаЗначений") Тогда
			Продолжить;
		КонецЕсли;
		
		Попытка
			Если ТипЗнч(СтрокаТаблицы.ДатаСоздания) = Тип("Строка") Тогда
				#Если Не ВебКлиент тогда
				СтрокаТаблицы.ДатаСоздания = ПрочитатьДатуJSON(СтрокаТаблицы.ДатаСоздания, ФорматДатыJSON.ISO);
				СтрокаТаблицы.ДатаЗавершения = ПрочитатьДатуJSON(СтрокаТаблицы.ДатаЗавершения, ФорматДатыJSON.ISO);
				#КонецЕсли
			КонецЕсли;
		Исключение
			Прервать; // не будем продолжать, если дата не ISO
		КонецПопытки;  		
	КонецЦикла;	
	
	Возврат ТаблицаДокументов;
	
КонецФункции

Функция REST_API_ПолучитьДанныеДокументаНаСервереSMARTS(ID_Документа, СтруктураДокументаMS, ТипБазы, ФильтрТЧПоИдДокумента = Неопределено, ЗапрашиватьCombinedItems = Истина, АдресаПеременных)
		
	ИмяСобытия = "REST_API_ПолучитьДанныеДокументаНаСервереSMARTS";
	
	Если ТипБазы = "Частная" Тогда
		КлючПеременной = "REST_API_СтруктураПодключенияЧастнойБазыMS";
	ИначеЕсли ТипБазы = "Временная" Тогда
		КлючПеременной = "REST_API_СтруктураПодключенияВременнойБазыMS";
	Иначе
		КлючПеременной = "REST_API_СтруктураПодключенияБазыMS";
	КонецЕсли;
	
	СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной(КлючПеременной,АдресаПеременных);

	Если ЗапрашиватьCombinedItems Тогда
		СтрокаExpand = "expand=declaredItems,currentItems,combinedItems,extendedFields,tables($expand=rows)";
	Иначе
		СтрокаExpand = "expand=declaredItems,currentItems,extendedFields,tables($expand=rows)";
	КонецЕсли;
	
	UniДокумента = СтруктураДокументаMS.uni;
	СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключенияMS,Новый Структура("HTTPМетод,Метод,ВернутьСтруктуру,ТипЗапроса","GET","Docs/"+UniДокумента+"('"+ID_Документа+"')?$"+СтрокаExpand,Истина,"ПолучениеПолногоДокумента"),,АдресаПеременных);
	Если СтруктураОтвета.КодСостояния <> 200 Тогда
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Запрос: GET, Docs/" + UniДокумента + "('" + ID_Документа + "')?$" + СтрокаExpand + ". Получен некорректный ответ от сервера, Код состояния: " + Строка(СтруктураОтвета.КодСостояния)+ ". Содержание ошибки: " + Строка(СтруктураОтвета.ТекстОшибки),,АдресаПеременных);
		Возврат Неопределено;
	КонецЕсли;
	ДокументSMARTS = СтруктураОтвета.ОтветСервера;
	
	ДанныеДокументаMS = Новый Структура;
	
	КешТранслитерацииПолей = Новый Соответствие;
	
	// Шапка
	РеквизитыШапки = Новый Структура;
	Для Каждого РеквизитДокумента Из СтруктураДокументаMS.Реквизиты Цикл
		Попытка
			ИмяПоля = РеквизитДокумента.Uni;
			
			Если ЗначениеЗаполнено(ИмяПоля) И ДокументSMARTS.Свойство(ИмяПоля) Тогда
				ЗначениеРеквизита = ДокументSMARTS[ИмяПоля];
			Иначе	
				ИмяТранслит = КешТранслитерацииПолей.Получить(РеквизитДокумента.Значение);
				Если ИмяТранслит = Неопределено Тогда
					ИмяПоля = ГлЯдро_СтрокуВТранслитENG(РеквизитДокумента.Значение);	
					КешТранслитерацииПолей.Вставить(РеквизитДокумента.Значение, ИмяПоля);
				Иначе
					ИмяПоля = ИмяТранслит;
				КонецЕсли;
				Если ЗначениеЗаполнено(ИмяПоля) И ДокументSMARTS.Свойство(ИмяПоля) Тогда
					ЗначениеРеквизита = ДокументSMARTS[ИмяПоля];
				Иначе
					ЗначениеРеквизита = Неопределено;
				КонецЕсли;
			КонецЕсли;
			
			РеквизитыШапки.Вставить(РеквизитДокумента.Значение, ЗначениеРеквизита);
		Исключение
			Сообщить("Реквизит с именем [" + РеквизитДокумента.Значение + "] отсутствует в шапке документа");
		КонецПопытки; 		
	КонецЦикла;
	
	Попытка
		Если ДокументSMARTS.Свойство("states") 
			И ТипЗнч(ДокументSMARTS.states) = Тип("Массив")
			И ДокументSMARTS.states.Количество() > 0 Тогда
			СтатусДокументаMS = ДокументSMARTS["states"][0];
			РеквизитыШапки.Вставить("ВремяНачалаОбработки",	СтатусДокументаMS["inProcessDate"]);
			РеквизитыШапки.Вставить("ВремяИзменения",		СтатусДокументаMS["modifiedDate"]);	
			РеквизитыШапки.Вставить("ВремяЗавершения",		СтатусДокументаMS["finishedDate"]);
		КонецЕсли;
	Исключение	
	КонецПопытки;
	
	Если ДокументSMARTS.Свойство("extendedFields") И ТипЗнч(ДокументSMARTS.extendedFields) = Тип("Структура") Тогда
		ExtendedFields = ДокументSMARTS["extendedFields"];
		РеквизитыШапки.Вставить("Overloaded",			 	?(ExtendedFields.Свойство("overloaded"), ExtendedFields["overloaded"], Ложь));	
		РеквизитыШапки.Вставить("Underloaded",				?(ExtendedFields.Свойство("underloaded"), ExtendedFields["underloaded"], Ложь));
		РеквизитыШапки.Вставить("UnderloadedOrOverloaded",	?(ExtendedFields.Свойство("underloadedOrOverloaded"), ExtendedFields["underloadedOrOverloaded"], Ложь));
	Иначе
		РеквизитыШапки.Вставить("Overloaded",			 	Ложь);	
		РеквизитыШапки.Вставить("Underloaded",				Ложь);
		РеквизитыШапки.Вставить("UnderloadedOrOverloaded",	Ложь);
	КонецЕсли;
	
	ДанныеДокументаMS.Вставить("ШапкаДокумента", РеквизитыШапки);
	
	// Подготовка табличных частей
	ТабличнаяЧастьФакт = Новый ТаблицаЗначений;МассивКолонокФакт = Новый Массив;
	ТабличнаяЧастьПлан = Новый ТаблицаЗначений;МассивКолонокПлан = Новый Массив;
	ТабличнаяЧастьСовмещенные = Новый ТаблицаЗначений;МассивКолонокСовмещенные = Новый Массив;
	Для Каждого РеквизитТЧ Из СтруктураДокументаMS.РеквизитыТЧ Цикл
		ТабличнаяЧастьФакт.Колонки.Добавить(РеквизитТЧ.Значение);
		ТабличнаяЧастьПлан.Колонки.Добавить(РеквизитТЧ.Значение);
		ТабличнаяЧастьСовмещенные.Колонки.Добавить(РеквизитТЧ.Значение);
		
		МассивКолонокФакт.Добавить(РеквизитТЧ);
		МассивКолонокПлан.Добавить(РеквизитТЧ);
		МассивКолонокСовмещенные.Добавить(РеквизитТЧ);
	КонецЦикла;
	
	Для Каждого РеквизитСерии Из СтруктураДокументаMS.РеквизитыСерии Цикл
		// данное поле будет добавлено при заполнении вычислимых полей
		Если Найти(ВРег(СокрЛП("Характеристика")), ВРег(СокрЛП(РеквизитСерии.Значение))) Тогда
			Продолжить;
		КонецЕсли;	
		Если ТабличнаяЧастьФакт.Колонки.Найти(РеквизитСерии.Значение) = Неопределено Тогда
			ТабличнаяЧастьФакт.Колонки.Добавить(РеквизитСерии.Значение);
			МассивКолонокФакт.Добавить(РеквизитСерии);
		КонецЕсли;	
		Если ТабличнаяЧастьПлан.Колонки.Найти(РеквизитСерии.Значение) = Неопределено Тогда
			ТабличнаяЧастьПлан.Колонки.Добавить(РеквизитСерии.Значение);
			МассивКолонокПлан.Добавить(РеквизитСерии);
		КонецЕсли;	
	КонецЦикла;
	
	Для Каждого РеквизитСерийныеНомера Из СтруктураДокументаMS.РеквизитыСерийныеНомера Цикл
		// данное поле будет добавлено при заполнении вычислимых полей
		Если Найти(ВРег(СокрЛП("Характеристика")), ВРег(СокрЛП(РеквизитСерийныеНомера.Значение))) Тогда
			Продолжить;
		КонецЕсли;	
		Если ТабличнаяЧастьФакт.Колонки.Найти(РеквизитСерийныеНомера.Значение) = Неопределено Тогда
			ТабличнаяЧастьФакт.Колонки.Добавить(РеквизитСерийныеНомера.Значение);
			МассивКолонокФакт.Добавить(РеквизитСерийныеНомера);
		КонецЕсли;
		Если ТабличнаяЧастьПлан.Колонки.Найти(РеквизитСерийныеНомера.Значение) = Неопределено Тогда
			ТабличнаяЧастьПлан.Колонки.Добавить(РеквизитСерийныеНомера.Значение);
			МассивКолонокПлан.Добавить(РеквизитСерийныеНомера);
		КонецЕсли;	
	КонецЦикла;
	
	СтруктураМетаданных = КомЯдро_ПолучитьЗначениеПеременной("СтруктураМетаданных", АдресаПеременных);
	Если ТипЗнч(СтруктураМетаданных) = Тип("Структура") И СтруктураМетаданных.Свойство("UniПолейНоменклатуры") Тогда 
		UniПолейНоменклатуры = СтруктураМетаданных.UniПолейНоменклатуры;
	Иначе
		UniПолейНоменклатуры = Новый Соответствие();
	КонецЕсли;
	
	СоответствиеИменПолейDeclaredItems = Новый Соответствие;
	СоответствиеИменПолейCurrentItems  = Новый Соответствие;
	СоответствиеИменПолейCombinedItems = Новый Соответствие;
	
	// План
	Если ДокументSMARTS.Свойство("declaredItems") И ТипЗнч(ДокументSMARTS["declaredItems"]) = Тип("Массив") Тогда
		Для Каждого СтрокаТЧ из ДокументSMARTS["declaredItems"] Цикл
			
			// фильтр ТЧ если она была объединена из нескольких документов
			Если ЗначениеЗаполнено(ФильтрТЧПоИдДокумента) 
				И СтрокаТЧ.Свойство("idDokumenta") Тогда                           
				ИдДокументаВладелецСтроки = СтрокаТЧ["idDokumenta"];
				Если ИдДокументаВладелецСтроки <> ФильтрТЧПоИдДокумента Тогда
					Продолжить;
				КонецЕсли;
			КонецЕсли;
			
			НоваяСтрока = ТабличнаяЧастьПлан.Добавить();
			Для Каждого РеквизитТЧ Из МассивКолонокПлан Цикл
				Попытка
					ИмяПоля = СоответствиеИменПолейDeclaredItems.Получить(РеквизитТЧ.Uni);
					Если ИмяПоля = Неопределено Тогда
						ИмяПоля = РеквизитТЧ.Uni;
						Если ЗначениеЗаполнено(ИмяПоля) И СтрокаТЧ.Свойство(ИмяПоля) Тогда
							ЗначениеРеквизита = СтрокаТЧ[ИмяПоля];
							СоответствиеИменПолейDeclaredItems.Вставить(РеквизитТЧ.Uni, ИмяПоля);
						Иначе
							ИмяТранслит = КешТранслитерацииПолей.Получить(РеквизитТЧ.Значение);
							Если ИмяТранслит = Неопределено Тогда
								ИмяПоля = ГлЯдро_СтрокуВТранслитENG(РеквизитТЧ.Значение);	
								КешТранслитерацииПолей.Вставить(РеквизитТЧ.Значение,ИмяПоля);
							Иначе
								ИмяПоля = ИмяТранслит;
							КонецЕсли;
							Если ЗначениеЗаполнено(ИмяПоля) И СтрокаТЧ.Свойство(ИмяПоля) Тогда
								ЗначениеРеквизита = СтрокаТЧ[ИмяПоля];
								СоответствиеИменПолейDeclaredItems.Вставить(РеквизитТЧ.Uni, ИмяПоля);
							Иначе
								ИмяПоля = UniПолейНоменклатуры.Получить(РеквизитТЧ.Значение);
								Если ЗначениеЗаполнено(ИмяПоля) И СтрокаТЧ.Свойство(ИмяПоля) Тогда
									ЗначениеРеквизита = СтрокаТЧ[ИмяПоля];
									СоответствиеИменПолейDeclaredItems.Вставить(РеквизитТЧ.Uni, ИмяПоля);
								Иначе
									ЗначениеРеквизита = Неопределено;
								КонецЕсли;
							КонецЕсли;
						КонецЕсли;
					ИначеЕсли СтрокаТЧ.Свойство(ИмяПоля) Тогда
						ЗначениеРеквизита = СтрокаТЧ[ИмяПоля];
					Иначе
						ЗначениеРеквизита = Неопределено;
					КонецЕсли;
					НоваяСтрока[РеквизитТЧ.Значение] = ЗначениеРеквизита;
				Исключение
					Сообщить("Реквизит с именем [" + РеквизитДокумента.Имя + "] отсутствует в табличной части [СтрокиПлан]");
				КонецПопытки; 			
			КонецЦикла;
		КонецЦикла;
	КонецЕсли;
	ДанныеДокументаMS.Вставить("СтрокиПлан", ТабличнаяЧастьПлан);
	
	// Факт
	Если ДокументSMARTS.Свойство("currentItems") И ТипЗнч(ДокументSMARTS["currentItems"]) = Тип("Массив") Тогда
		Для Каждого СтрокаТЧ из ДокументSMARTS["currentItems"] Цикл
			
			// фильтр ТЧ если она была объединена из нескольких документов
			Если ЗначениеЗаполнено(ФильтрТЧПоИдДокумента) Тогда
				Если СтрокаТЧ.Свойство("bindedLineUid")
					И ЗначениеЗаполнено(СтрокаТЧ.bindedLineUid) Тогда
					СвязаннаяСтрока = ГлЯдро_НайтиПоЗначениюВМассивеСтруктур(ДокументSMARTS["declaredItems"],"uid",СтрокаТЧ.bindedLineUid);
					Если СвязаннаяСтрока <> Неопределено
						И СвязаннаяСтрока.Свойство("idDokumenta") Тогда 
						СтрокаТЧ.Вставить("idDokumenta",СвязаннаяСтрока.IdDokumenta);
					КонецЕсли;
				КонецЕсли;
				ИдДокументаВладелецСтроки = "";
				Если СтрокаТЧ.Свойство("idDokumenta") Тогда                           
					ИдДокументаВладелецСтроки = СтрокаТЧ["idDokumenta"];
				КонецЕсли;
				Если ИдДокументаВладелецСтроки <> ФильтрТЧПоИдДокумента
					И НЕ (ID_Документа = ФильтрТЧПоИдДокумента И ИдДокументаВладелецСтроки = "") // Это условие нужно для загрузки всех строк, которых не было по плану, в первый документ
					Тогда
					Продолжить;
				КонецЕсли;
			КонецЕсли;
			
			НоваяСтрока = ТабличнаяЧастьФакт.Добавить();
			Для Каждого РеквизитТЧ Из МассивКолонокФакт Цикл
				Попытка
					ИмяПоля = СоответствиеИменПолейCurrentItems.Получить(РеквизитТЧ.Uni);
					Если ИмяПоля = Неопределено Тогда
						ИмяПоля = РеквизитТЧ.Uni;
						Если ЗначениеЗаполнено(ИмяПоля) И СтрокаТЧ.Свойство(ИмяПоля) Тогда
							ЗначениеРеквизита = СтрокаТЧ[ИмяПоля];
							Если ИмяПоля = "bindedLineUid" Тогда
								СвязаннаяСтрока = ГлЯдро_НайтиПоЗначениюВМассивеСтруктур(ДокументSMARTS["declaredItems"],"uid",СтрокаТЧ[ИмяПоля]);
								Если СвязаннаяСтрока <> Неопределено Тогда
							 		// +++ Преобразуем имена полей связанной строки
									Если СвязаннаяСтрока.Количество() > 0 Тогда
										Для Каждого РеквизитТЧПлан Из МассивКолонокПлан Цикл
											Попытка
												ИмяПоляСС = СоответствиеИменПолейDeclaredItems.Получить(РеквизитТЧПлан.Uni);
												Если ИмяПоляСС = Неопределено Тогда
													ИмяПоляСС = РеквизитТЧПлан.Uni;
													Если ЗначениеЗаполнено(ИмяПоляСС) И СвязаннаяСтрока.Свойство(ИмяПоляСС) Тогда
														ЗначениеРеквизитаСвязаннойСтроки = СвязаннаяСтрока[ИмяПоляСС];
														СоответствиеИменПолейDeclaredItems.Вставить(РеквизитТЧПлан.Uni, ИмяПоляСС);	
													Иначе	
														ИмяТранслит = КешТранслитерацииПолей.Получить(РеквизитТЧПлан.Значение);
														Если ИмяТранслит = Неопределено Тогда
															ИмяПоляСС = ГлЯдро_СтрокуВТранслитENG(РеквизитТЧПлан.Значение);
															КешТранслитерацииПолей.Вставить(РеквизитТЧПлан.Значение,ИмяПоляСС);
														Иначе
															ИмяПоляСС = ИмяТранслит;
														КонецЕсли;
														Если ЗначениеЗаполнено(ИмяПоляСС) И СвязаннаяСтрока.Свойство(ИмяПоляСС) Тогда
															ЗначениеРеквизитаСвязаннойСтроки = СвязаннаяСтрока[ИмяПоляСС];
															СоответствиеИменПолейDeclaredItems.Вставить(РеквизитТЧПлан.Uni, ИмяПоляСС);	
														Иначе
															ИмяПоляСС = UniПолейНоменклатуры.Получить(РеквизитТЧПлан.Значение);
															Если ЗначениеЗаполнено(ИмяПоляСС) И СвязаннаяСтрока.Свойство(ИмяПоляСС) Тогда
																ЗначениеРеквизитаСвязаннойСтроки = СвязаннаяСтрока[ИмяПоляСС];
																СоответствиеИменПолейDeclaredItems.Вставить(РеквизитТЧПлан.Uni, ИмяПоляСС);	
															Иначе
																ЗначениеРеквизитаСвязаннойСтроки = Неопределено;
															КонецЕсли;
														КонецЕсли;
													КонецЕсли;
												ИначеЕсли СвязаннаяСтрока.Свойство(ИмяПоляСС) Тогда
													ЗначениеРеквизитаСвязаннойСтроки = СвязаннаяСтрока[ИмяПоляСС];
												Иначе
													ЗначениеРеквизитаСвязаннойСтроки = Неопределено;	
												КонецЕсли;
												СвязаннаяСтрока.Вставить(РеквизитТЧПлан.Значение,ЗначениеРеквизитаСвязаннойСтроки);
											Исключение
												
											КонецПопытки;	
										КонецЦикла;											
									КонецЕсли;
									ЗначениеРеквизита = СвязаннаяСтрока;
									// ---
								КонецЕсли;
							Иначе
								СоответствиеИменПолейCurrentItems.Вставить(РеквизитТЧ.Uni, ИмяПоля);
							КонецЕсли;
						Иначе
							ИмяТранслит = КешТранслитерацииПолей.Получить(РеквизитТЧ.Значение);
							Если ИмяТранслит = Неопределено Тогда
								ИмяПоля = ГлЯдро_СтрокуВТранслитENG(РеквизитТЧ.Значение);	
								КешТранслитерацииПолей.Вставить(РеквизитТЧ.Значение,ИмяПоля);
							Иначе
								ИмяПоля = ИмяТранслит;
							КонецЕсли;
							Если ЗначениеЗаполнено(ИмяПоля) И СтрокаТЧ.Свойство(ИмяПоля) Тогда
								ЗначениеРеквизита = СтрокаТЧ[ИмяПоля];
								СоответствиеИменПолейCurrentItems.Вставить(РеквизитТЧ.Uni, ИмяПоля);
							Иначе
								ИмяПоля = UniПолейНоменклатуры.Получить(РеквизитТЧ.Значение);
								Если ЗначениеЗаполнено(ИмяПоля) И СтрокаТЧ.Свойство(ИмяПоля) Тогда
									ЗначениеРеквизита = СтрокаТЧ[ИмяПоля];
									СоответствиеИменПолейCurrentItems.Вставить(РеквизитТЧ.Uni, ИмяПоля);
								Иначе
									ЗначениеРеквизита = Неопределено;
								КонецЕсли;
							КонецЕсли;
						КонецЕсли;
					ИначеЕсли СтрокаТЧ.Свойство(ИмяПоля) Тогда						
						ЗначениеРеквизита = СтрокаТЧ[ИмяПоля];
					Иначе
						ЗначениеРеквизита = Неопределено;	
					КонецЕсли;
					НоваяСтрока[РеквизитТЧ.Значение] = ЗначениеРеквизита;
				Исключение
				
				КонецПопытки; 			
			КонецЦикла;
		КонецЦикла;
	КонецЕсли;
	ДанныеДокументаMS.Вставить("СтрокиФакт", ТабличнаяЧастьФакт);
	
	// СовмещенныеСтроки
	Если ДокументSMARTS.Свойство("combinedItems") И ТипЗнч(ДокументSMARTS["combinedItems"]) = Тип("Массив") Тогда
		Для Каждого СтрокаТЧ из ДокументSMARTS["combinedItems"] Цикл
			НоваяСтрока = ТабличнаяЧастьСовмещенные.Добавить();
			Для Каждого РеквизитТЧ Из МассивКолонокСовмещенные Цикл
				Попытка
					ИмяПоля = СоответствиеИменПолейCombinedItems.Получить(РеквизитТЧ.Uni);
					Если ИмяПоля = Неопределено Тогда
						ИмяПоля = РеквизитТЧ.Uni;
						Если ЗначениеЗаполнено(ИмяПоля) И СтрокаТЧ.Свойство(ИмяПоля) Тогда
							ЗначениеРеквизита = СтрокаТЧ[ИмяПоля];
							СоответствиеИменПолейCombinedItems.Вставить(РеквизитТЧ.Uni, ИмяПоля);
						Иначе
							ИмяТранслит = КешТранслитерацииПолей.Получить(РеквизитТЧ.Значение);
							Если ИмяТранслит = Неопределено Тогда
								ИмяПоля = ГлЯдро_СтрокуВТранслитENG(РеквизитТЧ.Значение);	
								КешТранслитерацииПолей.Вставить(РеквизитТЧ.Значение,ИмяПоля);
							Иначе
								ИмяПоля = ИмяТранслит;
							КонецЕсли;
							Если ЗначениеЗаполнено(ИмяПоля) И СтрокаТЧ.Свойство(ИмяПоля) Тогда
								ЗначениеРеквизита = СтрокаТЧ[ИмяПоля];
								СоответствиеИменПолейCombinedItems.Вставить(РеквизитТЧ.Uni, ИмяПоля);
							Иначе
								ИмяПоля = UniПолейНоменклатуры.Получить(РеквизитТЧ.Значение);
								Если ЗначениеЗаполнено(ИмяПоля) И СтрокаТЧ.Свойство(ИмяПоля) Тогда
									ЗначениеРеквизита = СтрокаТЧ[ИмяПоля];
									СоответствиеИменПолейCombinedItems.Вставить(РеквизитТЧ.Uni, ИмяПоля);
								Иначе
									ЗначениеРеквизита = Неопределено;
								КонецЕсли;
							КонецЕсли;
						КонецЕсли;
					ИначеЕсли СтрокаТЧ.Свойство(ИмяПоля) Тогда
						ЗначениеРеквизита = СтрокаТЧ[ИмяПоля];
					Иначе
						ЗначениеРеквизита = Неопределено;	
					КонецЕсли;
					НоваяСтрока[РеквизитТЧ.Значение] = ЗначениеРеквизита;	
				Исключение
				
				КонецПопытки; 			
			КонецЦикла;
		КонецЦикла;
	КонецЕсли;
	ДанныеДокументаMS.Вставить("СовмещенныеСтроки", ТабличнаяЧастьСовмещенные);	
	
	СписокИменаДополнительныхТабличныхЧастей = Новый СписокЗначений;
	
	// Получение данных из доп.таблиц документа типа "ОплатыВозвраты", "Деньги" и т.д.
	Для каждого ДопТаблица Из СтруктураДокументаMS.ДополнительныеТаблицы Цикл		
		
		ИмяДопТаблицы			= ДопТаблица.Представление;
		СписокКолонокДопТаблицы = ДопТаблица.Значение;		
		ДопТабличнаяЧасть		= Новый Массив;
		СписокПолей 			= "";
		
		СписокИменаДополнительныхТабличныхЧастей.Добавить(ИмяДопТаблицы);
		
		Для Каждого Колонка из СписокКолонокДопТаблицы Цикл
			СписокПолей = СписокПолей + Колонка.Значение + ",";
		КонецЦикла;
		
		Попытка
			СтрокиДокументаMS = ДокументSMARTS.ПолучитьПоле(ИмяДопТаблицы).Rows;
		Исключение
			СтрокиДокументаMS = Новый Массив;
		
			ДопТаблицы = ДокументSMARTS["tables"];
			Для каждого ДополнительнаяТаблица ИЗ ДопТаблицы Цикл
				Если ДополнительнаяТаблица["name"] = ИмяДопТаблицы Тогда
					СтрокиДокументаMS = ДополнительнаяТаблица["rows"];
					Прервать;
				КонецЕсли;
			КонецЦикла;
		КонецПопытки;
		
		Для Индекс = 0 по СтрокиДокументаMS.Количество() - 1 Цикл
			
			Попытка
				ТекущаяСтрокаMS	= СтрокиДокументаMS.Элемент(Индекс);
			Исключение
				ТекущаяСтрокаMS = СтрокиДокументаMS[Индекс];
			КонецПопытки;
			НоваяСтрока 	= Новый Структура;
			
			Для Каждого Колонка из СписокКолонокДопТаблицы Цикл
								
				Попытка
					
					ИмяПоля = Колонка.Uni;
					
					Если ЗначениеЗаполнено(ИмяПоля) И ТекущаяСтрокаMS.Свойство(ИмяПоля) Тогда
						ЗначениеРеквизита = ТекущаяСтрокаMS[ИмяПоля];
					Иначе
						ИмяТранслит = КешТранслитерацииПолей.Получить(Колонка.Значение);
						Если ИмяТранслит = Неопределено Тогда
							ИмяПоля = ГлЯдро_СтрокуВТранслитENG(Колонка.Значение);	
							КешТранслитерацииПолей.Вставить(Колонка.Значение,ИмяПоля);
						Иначе
							ИмяПоля = ИмяТранслит;
						КонецЕсли;
						Если ЗначениеЗаполнено(ИмяПоля) И ТекущаяСтрокаMS.Свойство(ИмяПоля) Тогда
							ЗначениеРеквизита = ТекущаяСтрокаMS[ИмяПоля];
						Иначе
							ИмяПоля = UniПолейНоменклатуры.Получить(Колонка.Значение);
							ЗначениеРеквизита = ?(ЗначениеЗаполнено(ИмяПоля) И ТекущаяСтрокаMS.Свойство(ИмяПоля), ТекущаяСтрокаMS[ИмяПоля], Неопределено);
						КонецЕсли;
					КонецЕсли;
					
					НоваяСтрока.Вставить(Колонка.Значение, ЗначениеРеквизита);
										
				Исключение	
						
				КонецПопытки;
				
			КонецЦикла;
						
			ДопТабличнаяЧасть.Добавить(НоваяСтрока);
			
		КонецЦикла;
		
		СписокПолей = Лев(СписокПолей, СтрДлина(СписокПолей) - 1);
		
		ДопТабличнаяЧасть.Вставить(0, Новый Структура("ЭтоТаблицаЗначений, КолонкиТаблицыЗначений", Истина, СписокПолей));
		
		ДанныеДокументаMS.Вставить(ИмяДопТаблицы, ДопТабличнаяЧасть);	
		
	КонецЦикла;	
	
    // Получение данных доп.таблиц, которые не определены в метаданных документа, но существуют у самого экземпляра документа
	Если ДокументSMARTS.Свойство("tables") И ТипЗнч(ДокументSMARTS["tables"]) = Тип("Массив") Тогда
		Для Каждого ДопТаблицаMS из ДокументSMARTS["tables"] Цикл
			
			Если СписокИменаДополнительныхТабличныхЧастей.НайтиПоЗначению(ДопТаблицаMS["name"]) <> Неопределено Тогда
				Продолжить;
			КонецЕсли;
			
			Если НЕ ДопТаблицаMS.Свойство("rows") Тогда
				Продолжить;
			КонецЕсли;
			
			СтрокиДопТаблицыMS = ДопТаблицаMS["rows"];
			
			Если СтрокиДопТаблицыMS.Количество() = 0 Тогда
				Продолжить;
			КонецЕсли;
			
			ДопТабличнаяЧасть 	= Новый Массив;		
			СписокПолей 		= "";								        

			РеквизитыДопТаблицыMS = Неопределено;
			
			//Если есть структура реквизита доп таблицы, то используем ее
			Если СтруктураДокументаMS.Свойство("Реквизиты" + ДопТаблицаMS.name, РеквизитыДопТаблицыMS) Тогда
				
				Для Каждого Колонка из РеквизитыДопТаблицыMS Цикл
					СписокПолей = СписокПолей + Колонка.Значение + ",";
				КонецЦикла; 
				
				Для Индекс = 0 по СтрокиДопТаблицыMS.Количество() - 1 Цикл
					
					Попытка
						ТекущаяСтрокаMS	= СтрокиДопТаблицыMS.Элемент(Индекс);
					Исключение
						ТекущаяСтрокаMS = СтрокиДопТаблицыMS[Индекс];
					КонецПопытки;
					
					НоваяСтрока = Новый Структура;						
					
					Для Каждого Колонка из РеквизитыДопТаблицыMS Цикл
						
						Попытка
							
							ИмяПоля = Колонка.Uni;
							
							Если ЗначениеЗаполнено(ИмяПоля) И ТекущаяСтрокаMS.Свойство(ИмяПоля) Тогда
								ЗначениеРеквизита = ТекущаяСтрокаMS[ИмяПоля];
							Иначе
								ИмяПоля = ГлЯдро_СтрокуВТранслитENG(РеквизитТЧ.Значение);
								Если ЗначениеЗаполнено(ИмяПоля) И СтрокаТЧ.Свойство(ИмяПоля) Тогда
									ЗначениеРеквизита = СтрокаТЧ[ИмяПоля];
								Иначе
									ИмяПоля = UniПолейНоменклатуры.Получить(РеквизитТЧ.Значение);
									ЗначениеРеквизита = ?(ЗначениеЗаполнено(ИмяПоля) И СтрокаТЧ.Свойство(ИмяПоля), СтрокаТЧ[ИмяПоля], Неопределено);
								КонецЕсли;
							КонецЕсли;
							
							НоваяСтрока.Вставить(Колонка.Значение, ЗначениеРеквизита);
							
						Исключение	
							
						КонецПопытки;
						
					КонецЦикла;
					
					ДопТабличнаяЧасть.Добавить(НоваяСтрока);
					
				КонецЦикла;
				
			Иначе //Если нет структуры доп таблицы, то записываем данные как есть
				
				Для Каждого ТекущаяСтрокаMS Из СтрокиДопТаблицыMS Цикл
					
					НоваяСтрока = Новый Структура;
					
					Для Каждого КлючЗначение из ТекущаяСтрокаMS Цикл
						
						НоваяСтрока.Вставить(КлючЗначение.Ключ, КлючЗначение.Значение);
						
					КонецЦикла;
					
					ДопТабличнаяЧасть.Добавить(НоваяСтрока);
					
				КонецЦикла; 

			КонецЕсли; 
  
			СписокПолей = Лев(СписокПолей, СтрДлина(СписокПолей) - 1);
			
			ДопТабличнаяЧасть.Вставить(0, Новый Структура("ЭтоТаблицаЗначений, КолонкиТаблицыЗначений", Истина, СписокПолей));		
			
			ДанныеДокументаMS.Вставить(ДопТаблицаMS["name"], ДопТабличнаяЧасть);
			
		КонецЦикла;		
	КонецЕсли;
	Возврат ДанныеДокументаMS;
	
КонецФункции

Функция REST_API_СформироватьНовыйДокументSMARTS(ДанныеДокумента,НазначенныйПользователь = "", АдресаПеременных, ИспользоватьUni=Истина, ДобавлятьТип=Ложь, СпособНазначения = "")
	
	СтруктураМетаданных = КомЯдро_ПолучитьЗначениеПеременной("СтруктураМетаданных",АдресаПеременных);
	
	ИмяТипаДокумента = ГлЯдро_ПреобразованиеНаименованияДокументаБезПробелов(ДанныеДокумента.ШапкаДокумента.ИмяТипаДокумента);
	МетаданныеДокументаMS = СтруктураМетаданных.ДокументыMS[ИмяТипаДокумента];
	
	ДокументSMARTS = Новый Структура;
	
	Для Каждого РеквизитДокумента Из ДанныеДокумента.ШапкаДокумента Цикл
		РеквизитMS = Неопределено;
		Для Каждого СтрокаРеквизита Из МетаданныеДокументаMS.Реквизиты Цикл
			Если НРег(СтрокаРеквизита.Значение) = НРег(РеквизитДокумента.Ключ) Тогда
				РеквизитMS = СтрокаРеквизита;
				Прервать;
			КонецЕсли;
		КонецЦикла;
		Если РеквизитMS = Неопределено Тогда
			РеквизитMS = Новый Структура("Ключ,Значение,Uni",РеквизитДокумента.Ключ,РеквизитДокумента.Ключ,РеквизитДокумента.Ключ);
		КонецЕсли;
		ЗначениеРеквизита = РеквизитДокумента.Значение;
		Если ТипЗнч(ЗначениеРеквизита) = Тип("Дата") Тогда
			Если ЗначениеЗаполнено(ЗначениеРеквизита) Тогда
				ЗначениеРеквизита = REST_API_ФорматДаты(ЗначениеРеквизита);	
			Иначе
				
				ЗначениеРеквизита = Неопределено;
			КонецЕсли;
		КонецЕсли;
		ДокументSMARTS.Вставить(?(ИспользоватьUni,ГлЯдро_СтрокуВТранслитENG(РеквизитMS.Uni),РеквизитMS.Ключ),ЗначениеРеквизита);
	КонецЦикла;
	
	Если ДанныеДокумента.Свойство("Name") Тогда
		ДокументSMARTS.Вставить("name",ДанныеДокумента.Name); // обязательно с маленькой буквы
	КонецЕсли;
	
	ДокументSMARTS.Вставить("documentTypeName",ИмяТипаДокумента);
	Если НазначенныйПользователь <> "" Тогда 
		Если СпособНазначения = "Устройству" Тогда
			ДокументSMARTS.Вставить("appointment", НазначенныйПользователь);
		Иначе
			ДокументSMARTS.Вставить("appointment", НазначенныйПользователь);
			ДокументSMARTS.Вставить("id",ДокументSMARTS.Id+"#"+СтрЗаменить(НазначенныйПользователь,"|",""));
		КонецЕсли;		
	КонецЕсли;
	
	UniОсновняхТабличныхЧастей = Новый Соответствие;
	UniОсновняхТабличныхЧастей.Вставить("СтрокиПлан","declaredItems");
	UniОсновняхТабличныхЧастей.Вставить("СтрокиФакт","currentItems");
	UniОсновняхТабличныхЧастей.Вставить("СовмещенныеСтроки","combinedItems");
	UniОсновняхТабличныхЧастей.Вставить("СерииПлан","");
	UniОсновняхТабличныхЧастей.Вставить("СерииФакт","");
	UniОсновняхТабличныхЧастей.Вставить("СерийныеНомераПлан","");
	UniОсновняхТабличныхЧастей.Вставить("СерийныеНомераФакт","");
	МассивДопТаблиц = Новый Массив;	
	
	РеквизитыТЧ = МетаданныеДокументаMS.РеквизитыТЧ;
	
	Если ДанныеДокумента.Свойство("ТабличныеЧасти") И ДанныеДокумента.ТабличныеЧасти.Количество() > 0 Тогда
		Для Каждого ТабличнаяЧасть Из ДанныеДокумента.ТабличныеЧасти Цикл
			МассивСтрокТЧ = Новый Массив;
			UniТЧ = ?(ИспользоватьUni,UniОсновняхТабличныхЧастей.Получить(ТабличнаяЧасть.Ключ),Неопределено);
			Если UniТЧ <> Неопределено Тогда
				Если ТабличнаяЧасть.Ключ = "СовмещенныеСтроки" Тогда
					Продолжить;
				КонецЕсли;
				СписокРеквизитов = Новый Соответствие;
				Если ТабличнаяЧасть.Значение.Количество() > 0 Тогда
					Для каждого КлючЗначение из ТабличнаяЧасть.Значение[0] Цикл
						REST_API_ДополнитьСписокРеквизитов(СписокРеквизитов, КлючЗначение.Ключ, РеквизитыТЧ);
					КонецЦикла;
				КонецЕсли;
				
				Для каждого СтрокаТЧ Из ТабличнаяЧасть.Значение Цикл
					СтрокаДокументаSMARTS = Новый Структура;
					Для Каждого РеквизитСтроки Из СтрокаТЧ Цикл
						ЗначениеРеквизита = РеквизитСтроки.Значение;
						Если ТипЗнч(ЗначениеРеквизита) = Тип("Дата") Тогда
							Если ЗначениеЗаполнено(ЗначениеРеквизита) Тогда
								ЗначениеРеквизита = REST_API_ФорматДаты(ЗначениеРеквизита);	
							Иначе
								ЗначениеРеквизита = Неопределено;
							КонецЕсли;
						КонецЕсли;
						Если ЗначениеЗаполнено(ЗначениеРеквизита) Тогда
							КлючРеквизита = СписокРеквизитов.Получить(РеквизитСтроки.Ключ);
							Если КлючРеквизита = Неопределено Тогда
								// Список реквизитов определен по первой строке таблицы ТабличнаяЧасть.
								// В случае, когда выгрузка производится из нескольких документов в один, в последующих строках
								// может быть больше колонок, чем в первой (например, если в первом документе нет маркированной
								// продукции, а во втором - есть).
								// Нужно предусмотреть дополнение списка реквизитов при необходимости.
								REST_API_ДополнитьСписокРеквизитов(СписокРеквизитов, РеквизитСтроки.Ключ, РеквизитыТЧ);
								
								КлючРеквизита = СписокРеквизитов.Получить(РеквизитСтроки.Ключ);
							КонецЕсли;
							
							СтрокаДокументаSMARTS.Вставить(КлючРеквизита, ЗначениеРеквизита);
						КонецЕсли;
					КонецЦикла;
					
					МассивСтрокТЧ.Добавить(СтрокаДокументаSMARTS);					
				КонецЦикла;
				ДокументSMARTS.Вставить(UniТЧ,МассивСтрокТЧ);
			Иначе
				ДопТаблицаSMARTS = Новый Соответствие;		
				ДопТаблицаSMARTS.Вставить("name",ТабличнаяЧасть.Ключ);
				СписокРеквизитов = Новый Соответствие;
								
				Если ТабличнаяЧасть.Значение.Количество() > 0 Тогда
					Для каждого КлючЗначение из ТабличнаяЧасть.Значение[0] Цикл
						РеквизитMS = Неопределено;
						Для Каждого СтрокаРеквизита Из МетаданныеДокументаMS.РеквизитыТЧ Цикл
							Если НРег(СтрокаРеквизита.Значение) = НРег(КлючЗначение.Ключ) Тогда
								РеквизитMS = СтрокаРеквизита;
								Прервать;
							КонецЕсли;
						КонецЦикла;
						Если РеквизитMS = Неопределено Тогда
							РеквизитMS = Новый Структура("Ключ,Значение,Uni",КлючЗначение.Ключ,КлючЗначение.Ключ,КлючЗначение.Ключ);
						КонецЕсли;
						СписокРеквизитов.Вставить(РеквизитMS.Значение,РеквизитMS.Uni);
						// Для табличной части МаркиДокумента не нужно заменять IdTovara на ProductId
						// Если выяснится, что для всех табличных частей имена реквизитов заменять не нужно,
						// убрать это условие и отменить выше поиск в МетаданныеДокументаMS
						Если НРег(ТабличнаяЧасть.Ключ) = "маркидокумента" И НРег(КлючЗначение.Ключ) = "идтовара" Тогда
							СписокРеквизитов.Вставить(РеквизитMS.Значение,КлючЗначение.Ключ);
						КонецЕсли;
					КонецЦикла;
				КонецЕсли;
				
				Для каждого СтрокаТЧ Из ТабличнаяЧасть.Значение Цикл
					Row = Новый Соответствие;
					Для Каждого РеквизитСтроки Из СтрокаТЧ Цикл
						ЗначениеРеквизита = РеквизитСтроки.Значение;
						Если ТипЗнч(ЗначениеРеквизита) = Тип("Дата") Тогда
							Если ЗначениеЗаполнено(ЗначениеРеквизита) Тогда
								ЗначениеРеквизита = REST_API_ФорматДаты(ЗначениеРеквизита);	
							Иначе
								ЗначениеРеквизита = Неопределено;
							КонецЕсли;
						КонецЕсли;
						Row.Вставить(СписокРеквизитов.Получить(РеквизитСтроки.Ключ), ЗначениеРеквизита);
					КонецЦикла;
					МассивСтрокТЧ.Добавить(Row);
				КонецЦикла;
				
				ДопТаблицаSMARTS.Вставить("rows",МассивСтрокТЧ);
				МассивДопТаблиц.Добавить(ДопТаблицаSMARTS);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Если МассивДопТаблиц.Количество() > 0 Тогда
		ДокументSMARTS.Вставить("tables",МассивДопТаблиц);	
	КонецЕсли;
	
	Возврат ДокументSMARTS;
	
КонецФункции

Функция REST_API_ЗаписатьДокументВБазуSMARTS(ДокументSMARTS, ТипБазы,АдресаПеременных)
	
	СтруктураМетаданных = КомЯдро_ПолучитьЗначениеПеременной("СтруктураМетаданных",АдресаПеременных);
	
	ИмяТипаДокумента = ГлЯдро_ПреобразованиеНаименованияДокументаБезПробелов(ДокументSMARTS.documentTypeName);
	МассивСтрокТЧ = Новый Массив;
	Если ДокументSMARTS.Свойство("declaredItems") Тогда
		МассивСтрокТЧ = ДокументSMARTS.declaredItems;
		ДокументSMARTS.Удалить("declaredItems");
	КонецЕсли;
	МетаданныеДокументаMS = СтруктураМетаданных.ДокументыMS[ИмяТипаДокумента];
	
	Если ТипБазы = "Частная" Тогда
		КлючПеременной = "REST_API_СтруктураПодключенияЧастнойБазыMS";
	ИначеЕсли ТипБазы = "Временная" Тогда
		КлючПеременной = "REST_API_СтруктураПодключенияВременнойБазыMS";
	Иначе
		КлючПеременной = "REST_API_СтруктураПодключенияБазыMS";
	КонецЕсли;
	
	СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной(КлючПеременной,АдресаПеременных);
	Результат = Истина;
	UniДокумента = МетаданныеДокументаMS.uni;
	idДокумента = ДокументSMARTS.Id;
	СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключенияMS,Новый Структура("HTTPМетод,Метод,ВернутьСтруктуру,ТипЗапроса","POST","Docs",Истина,"ВыгрузкаШапкиДокумента"),ДокументSMARTS,АдресаПеременных);
	
	Если СтруктураОтвета.КодСостояния < 200 или СтруктураОтвета.КодСостояния >= 300 Тогда
		Результат =  Ложь;
	КонецЕсли;
	
	Если МассивСтрокТЧ.Количество() > 0 Тогда
		Если Результат = Истина Тогда
			ПакетСтрок = Новый Массив;	
			Икс = 0; ЭтоПерваяСтрока=Истина;
			Для каждого СтрокаТЧ Из МассивСтрокТЧ Цикл
				Если Икс%1000 = 0 И Не ЭтоПерваяСтрока Тогда
					ПакетДляОтправки = Новый Соответствие;
					ПакетДляОтправки.Вставить("value",ПакетСтрок);
					СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключенияMS,Новый Структура("HTTPМетод,Метод,ВернутьСтруктуру,ТипЗапроса","POST","Docs('"+idДокумента+"')/declaredItems",Истина,"ВыгрузкаСтрокДокумента"),ПакетДляОтправки,АдресаПеременных);
					Если СтруктураОтвета.КодСостояния < 200 или СтруктураОтвета.КодСостояния >= 300 Тогда
						СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключенияMS,Новый Структура("HTTPМетод,Метод,ТипЗапроса","DELETE","Docs('"+idДокумента+"')","ВыгрузкаШапкиДокумента"),,АдресаПеременных);
						Результат = Ложь;
						Прервать;
					КонецЕсли;
					ПакетСтрок = Новый Массив;	
				КонецЕсли;
				НовоеСоответствие = Новый Соответствие;
				Для каждого КлючЗначение Из СтрокаТЧ Цикл
					НовоеСоответствие.Вставить(КлючЗначение.Ключ,КлючЗначение.Значение);	
				КонецЦикла;			
				
				ПакетСтрок.Добавить(НовоеСоответствие);
				ЭтоПерваяСтрока = Ложь;
				Икс = Икс+1;
			КонецЦикла;
			
			Если ПакетСтрок.Количество() > 0 Тогда
				ПакетДляОтправки = Новый Соответствие;
				ПакетДляОтправки.Вставить("value",ПакетСтрок);
				СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключенияMS,Новый Структура("HTTPМетод,Метод,ВернутьСтруктуру,ТипЗапроса","POST","Docs('"+idДокумента+"')/declaredItems",Истина,"ВыгрузкаСтрокДокумента"),ПакетДляОтправки,АдресаПеременных);
				Если СтруктураОтвета.КодСостояния < 200 или СтруктураОтвета.КодСостояния >= 300 Тогда
					СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключенияMS,Новый Структура("HTTPМетод,Метод,ТипЗапроса","DELETE","Docs('"+idДокумента+"')","ВыгрузкаШапкиДокумента"),,АдресаПеременных);
					Результат = Ложь;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		
	КонецЕсли;
	
	Если Результат = Истина Тогда
		СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключенияMS,Новый Структура("HTTPМетод,Метод,ТипЗапроса","POST","Docs('"+idДокумента+"')/EndUpdate","ВыгрузкаСтрокДокумента"),,АдресаПеременных);
		Если СтруктураОтвета.КодСостояния < 200 или СтруктураОтвета.КодСостояния >= 300 Тогда
			Результат =  Ложь;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

Функция REST_API_УдалитьДокументНаСервереSMARTS(ID_Документа, ТипБазы, АдресаПеременных)
	
	Если ТипБазы = "Частная" Тогда
		КлючПеременной = "REST_API_СтруктураПодключенияЧастнойБазыMS";
	ИначеЕсли ТипБазы = "Временная" Тогда
		КлючПеременной = "REST_API_СтруктураПодключенияВременнойБазыMS";
	Иначе
		КлючПеременной = "REST_API_СтруктураПодключенияБазыMS";
	КонецЕсли;
	
	СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной(КлючПеременной,АдресаПеременных);
	
	РезультатОтвет = REST_API_ВыполнитьМетод(СтруктураПодключенияMS,Новый Структура("HTTPМетод,Метод,ТипЗапроса","DELETE","Docs('"+ID_Документа+"')","ВыгрузкаШапкиДокумента"),,АдресаПеременных);
	РезультатПопытки = РезультатОтвет.КодСостояния = 204;
	
	Возврат РезультатПопытки;
	
КонецФункции

Функция REST_API_ФорматДаты(пДата)
	
	Смещение = СмещениеСтандартногоВремени();
	Если Смещение < 0 Тогда
		Смещение = Смещение *-1;
		Знак="-";
	Иначе		
		Знак="+";
	КонецЕсли;
	GTM = Прав("0"+Строка(Цел(Смещение/3600)),2)+":"+Прав("0"+Строка(Цел(Смещение%3600/60)),2);
	Возврат Формат(пДата,"ДФ=yyyy-MM-ddTHH:mm:ss")+".0000000"+Знак+GTM; // Формат(УниверсальноеВремя(пДата,ЧасовойПояс()),"ДФ=yyyy-MM-ddThh:mm:ss")+".0000000"+Знак+GTM;
	
КонецФункции

Функция REST_API_ТаблицаЗначенийВМассивСтруктур(ТаблицаЗначений)
	Результат = Новый Массив;
	
	Для каждого Строка Из ТаблицаЗначений Цикл	
		СтрокаРезультата = Новый Структура;
		
		Для каждого Колонка Из ТаблицаЗначений.Колонки Цикл
			
			ЗначениеРеквизита = Строка[Колонка.Имя];
			Если ТипЗнч(ЗначениеРеквизита) = Тип("Дата") Тогда
				Если ЗначениеЗаполнено(ЗначениеРеквизита) Тогда
					ЗначениеРеквизита = REST_API_ФорматДаты(ЗначениеРеквизита);	
				Иначе
					ЗначениеРеквизита = Неопределено;
				КонецЕсли;
			КонецЕсли;
			
			СтрокаРезультата.Вставить(Колонка.Имя, ?(ЗначениеЗаполнено(ЗначениеРеквизита), ЗначениеРеквизита, "")); 
		КонецЦикла;
		
		Результат.Добавить(СтрокаРезультата);
	 КонецЦикла;
	Возврат Результат;
КонецФункции

Функция REST_API_УстановитьСтатусДокументаНаСервереSMARTS(ID_Документа, ТипБазы, Статус, АдресаПеременных)
	
	Если ТипБазы = "Частная" Тогда
		КлючПеременной = "REST_API_СтруктураПодключенияЧастнойБазыMS";
	ИначеЕсли ТипБазы = "Временная" Тогда
		КлючПеременной = "REST_API_СтруктураПодключенияВременнойБазыMS";
	Иначе
		КлючПеременной = "REST_API_СтруктураПодключенияБазыMS";
	КонецЕсли;
	
	СтруктураПодключения = КомЯдро_ПолучитьЗначениеПеременной(КлючПеременной,АдресаПеременных);
	
	ОтправляемыеДанные = Новый Соответствие;
	ОтправляемыеДанные.Вставить("Status", Статус);
	СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключения,Новый Структура("HTTPМетод,Метод,ТипЗапроса","PATCH","Docs('"+ID_Документа+"')","ВыгрузкаШапкиДокумента"),ОтправляемыеДанные,АдресаПеременных);
	
	Возврат СтруктураОтвета.КодСостояния = 204;
	
КонецФункции

Функция REST_API_ОбработатьЗначениеДляВыгрузки(ЗначениеДляВыгрузки)

	Если НЕ ЗначениеЗаполнено(ЗначениеДляВыгрузки) Тогда
		Возврат "";
	КонецЕсли;	
	
	Возврат ЗначениеДляВыгрузки;
	
КонецФункции

// Функция преобразования особых типов источника (приведенной к строке даты) в тип 1С
//
// Параметры:
//  Источник - Реквизит объекта-источника (MS)
//  Приемник - Реквизит объекта-приемника (1С)
// 
// Возвращаемое значение:
//   ЗначениеПриемника - Преобразованное значение для записи в реквизит приемника
//
Функция REST_API_ПреобразованиеЗначенияРеквизитаИсточникаВТип1С(Источник, Приемник)
	
	// Если имеется реквизит MS типа "DateTime" в виде строкового представления, необходимо перед проверкой конвертировать его в тип 1С "Дата"
	СравниваемоеЗначениеТипаДата = ТипЗнч(Приемник) = Тип("Дата") И ТипЗнч(Источник) = Тип("Строка");
	Если СравниваемоеЗначениеТипаДата Тогда
		ЗначениеПриемника = REST_API_ПреобразоватьКДате(Источник)
	Иначе
		ЗначениеПриемника = Источник;
	КонецЕсли;
	
	Возврат ЗначениеПриемника;
	
КонецФункции

// Функция обратного преобразования даты из форматированного представления определенного формата в тип Дата
//
// Параметры:
// 		ДатаСтрокой	 - Строка - Представление даты в формате "ДФ=yyyy-MM-ddTHH:mm:ss.0000000+HH:mm"
// 
// Возвращаемое значение:
// 		ДатаВФормате - Дата, Строка - Преобразованное значение даты, либо если что-то пошло не так, исходное значение
//
// Пример:
// 		ДатаСтрокой  = "2021-03-09T08:09:24.0000000+03:00";
//		ДатаВФормате = <09.03.2021  8:09:24>
//
Функция REST_API_ПреобразоватьКДате(ДатаСтрокой)
	
	// Возьмем данный разделить даты/времени за признак корректного формата
	Если ГлЯдро_СтрНайти(ДатаСтрокой, "T") = 0 Тогда
		Возврат ДатаСтрокой;
	КонецЕсли;
	
	МассивРазделеннойДаты = ГлЯдро_СтрРазделить(ДатаСтрокой, "T", Ложь);
	
	Если МассивРазделеннойДаты.Количество() <> 2 Тогда
		Возврат ДатаСтрокой;
	КонецЕсли;
	
	СтрДата		= REST_API_УбратьНечисловыеСимволы(МассивРазделеннойДаты[0]);
	СтрВремя 	= Лев(REST_API_УбратьНечисловыеСимволы(МассивРазделеннойДаты[1]), 6);
	
	Попытка
		ДатаВФормате = Дата(СтрДата + СтрВремя);						
	Исключение		
		ЗаписьЖурналаРегистрации(
			НСтр("ru = 'КлеверенсТСД.REST_API_ПреобразоватьКДате'"),
			УровеньЖурналаРегистрации.Ошибка,
			,
			,
			ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		ДатаВФормате = ДатаСтрокой;
	КонецПопытки;
	
	Возврат ДатаВФормате;	
	
КонецФункции

// Функция очистки строковой переменной от нечисловых символов для дальнейшей обработки
//
// Параметры:
// 		Стр 	  - Строка - Строка, в которой необходимо оставить только числовые символы
// 
// Возвращаемое значение:
// 		Результат - Строка - Преобразованная строка
//
// Пример:
//		Стр 	  = "2021-03-09T08:09:24";
//      Результат = "20210309080924"
//
Функция REST_API_УбратьНечисловыеСимволы(Стр)
	
	Результат = "";
	
	Если ТипЗнч(Стр) <> Тип("Строка") Тогда
		Возврат Результат;
	КонецЕсли;
	
	Если СтрДлина(Стр) = 0 Тогда
		Возврат Результат;
	КонецЕсли;
	
	СтрокаПроверки = СокрЛП(Стр);
	
	Для Инд = 1 По СтрДлина(СтрокаПроверки) Цикл
		
		Символ = Сред(СтрокаПроверки, Инд, 1);
		
		Если Найти("0123456789", Символ) = 0 Тогда
			Продолжить;
		КонецЕсли;
		
		Результат = Результат + Символ;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Процедура REST_API_ДополнитьСписокРеквизитов(СписокРеквизитов, Ключ, РеквизитыТЧ)

	РеквизитMS = Неопределено;
	Для Каждого СтрокаРеквизита Из РеквизитыТЧ Цикл
		Если НРег(СтрокаРеквизита.Значение) = НРег(Ключ) Тогда
			РеквизитMS = СтрокаРеквизита;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	Если РеквизитMS = Неопределено Тогда
		РеквизитMS = Новый Структура("Ключ, Значение, Uni", Ключ, Ключ, Ключ);
	КонецЕсли;
	
	СписокРеквизитов.Вставить(РеквизитMS.Значение, РеквизитMS.Uni);
	
КонецПроцедуры

#Область REST_API_Транспорт

Функция REST_API_ВыполнитьМетод(СтруктураПодключения,СтруктураЗапроса,ОтправляемыеДанные,АдресаПеременных)
	
	Перем ОтветHTTP,ТекстОшибки;
		
	СтруктураОтвета = Новый Структура;	
	
	Если ТипЗнч(СтруктураПодключения) = Тип("Строка") Тогда
		СтрокаПодключения = СтруктураПодключения;
	Иначе
		Если НЕ ТипЗнч(СтруктураПодключения) = Тип("Структура")
			ИЛИ НЕ СтруктураПодключения.Свойство("СтрокаПодключенияСМАРТС")
			ИЛИ НЕ ЗначениеЗаполнено(СтруктураПодключения.СтрокаПодключенияСМАРТС) Тогда
			
			СтруктураОтвета.Вставить("ТекстОшибки","Не заполнено значение ""Строка подключения""");
			СтруктураОтвета.Вставить("КодСостояния",Неопределено);

			Возврат СтруктураОтвета;
		КонецЕсли;
		СтрокаПодключения = СтруктураПодключения.СтрокаПодключенияСМАРТС;
	КонецЕсли;
	
	СтруктураURI = REST_API_ПолучитьСтруктуруURIИзСтроки(СтрокаПодключения);
	
	Если НЕ СтруктураЗапроса.Свойство("Заголовки")
		ИЛИ НЕ СтруктураЗапроса.Заголовки <> Неопределено Тогда				
		СтруктураЗапроса.Вставить("Заголовки",Новый Соответствие());
		СтруктураЗапроса.Заголовки.Вставить("Content-Type", "application/json");
		СтруктураЗапроса.Заголовки.Вставить("Accept-Encoding", "gzip");		
	КонецЕсли;
													
	РезультатыАвторизации = REST_API_ЗаполнитьДанныеАвторизацииHTTPЗапроса(СтрокаПодключения, СтруктураПодключения, СтруктураURI, СтруктураЗапроса, АдресаПеременных);
	СтруктураОтвета = РезультатыАвторизации.СтруктураОтвета;
	Если СтруктураОтвета.КодСостояния = 401 Тогда
		Возврат СтруктураОтвета;
	КонецЕсли;
	
	КоличествоПопыток = 1;
	КоличествоПопытокОтключенияСжатия = 1;
	КоличествоПопытокОбновленияТокена = 1;
	Пока КоличествоПопыток > 0 Цикл
		
		НачалоСобытия = ТекущаяУниверсальнаяДатаВМиллисекундах();
				
		СтруктураОтвета = REST_API_ВыполнитьHTTPЗапрос(СтруктураURI,СтруктураЗапроса,ОтправляемыеДанные,АдресаПеременных);
		
		// Запись в ЖР
		СтрокаЗапроса = ?(СтруктураОтвета.Свойство("СтрокаЗапроса"), СтруктураОтвета.СтрокаЗапроса, "");
		ТекстЗаписиЖР = "HTTPМетод: " + СтруктураЗапроса.HTTPМетод + ", Метод:" + СтруктураЗапроса.Метод + 
			?(СтруктураЗапроса.Свойство("ТипЗапроса"), ", Тип запроса: " + СтруктураЗапроса.ТипЗапроса, "")
			+ Символы.ПС + "Строка запроса: " + СтрокаЗапроса + Символы.ПС + "Время выполнения: ";
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации("REST_API_ВыполнитьHTTPЗапрос", "Информация", ТекстЗаписиЖР, НачалоСобытия, АдресаПеременных);
		
		Если СтруктураОтвета.Свойство("ТекстОшибки") И ЗначениеЗаполнено(СтруктураОтвета.ТекстОшибки) Тогда
			ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации("REST_API_ВыполнитьHTTPЗапрос", "Ошибка", СтруктураОтвета.ТекстОшибки, , АдресаПеременных);
		КонецЕсли;
		// Если требуется отключить сжатие данных, пробуем отключить и делаем еще одну попытку
		Если СтруктураОтвета.Свойство("ОтключитьСжатиеДанных") 
			И СтруктураОтвета.ОтключитьСжатиеДанных
			И КоличествоПопытокОтключенияСжатия Тогда
			Попытка
				ГлЯдро_ЗаписатьВКэшНастройкуSMARTS("ОтключитьСжатиеДанных",	Истина, АдресаПеременных);
				ГлЯдро_СохранитьНастройкуВБазеSMARTS("ОтключитьСжатиеДанных", Истина, , АдресаПеременных);
			Исключение
				ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации("ОтключитьСжатиеДанных", "Ошибка", ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()),, АдресаПеременных);
			КонецПопытки;
			КоличествоПопытокОтключенияСжатия = КоличествоПопытокОтключенияСжатия - 1;
		ИначеЕсли СтруктураОтвета.КодСостояния = 401
            И КоличествоПопытокОбновленияТокена Тогда
			Access_token  = "";
			Refresh_token = "";
			Если ТипЗнч(СтруктураПодключения) = Тип("Структура")
				И СтруктураПодключения.Свойство("АвторизацияРефрешТокен") Тогда
				Refresh_token = СтруктураПодключения.АвторизацияРефрешТокен;
			КонецЕсли;
				
			ДанныеТокена = REST_API_ОбновитьТокенSMARTS(СтрокаПодключения, РезультатыАвторизации.REST_API_Session, Refresh_token, АдресаПеременных);
			Если ТипЗнч(ДанныеТокена) = Тип("Структура") Тогда
				Access_token  = ДанныеТокена.АвторизацияТокен;
				Refresh_token = ДанныеТокена.АвторизацияРефрешТокен;
			КонецЕсли;
			
			Если ЗначениеЗаполнено(Access_token) Тогда
            	СтруктураЗапроса.Заголовки.Вставить("Authorization", "Bearer " + Access_token);				
			КонецЕсли;
			КоличествоПопытокОбновленияТокена = КоличествоПопытокОбновленияТокена - 1;	
		Иначе
			КоличествоПопыток = ?(СтруктураОтвета.КодСостояния = Неопределено, КоличествоПопыток - 1, 0);	
		КонецЕсли;
	КонецЦикла;
	
	Если СтруктураОтвета.КодСостояния = 401 Тогда
		//В плане сделать переавторизацию
		//Если REST_API_session <> Неопределено Тогда
		//	refresh_token = REST_API_session.Получить("refresh_token");
		//	Логин = REST_API_session.Получить("Логин");
		//	Пароль = REST_API_session.Получить("Пароль");
		//КонецЕсли;
	КонецЕсли;
	
	Возврат СтруктураОтвета;
	
КонецФункции

Функция REST_API_ПолучитьСтруктуруРезультатовАвторизации()

	СтруктураОтвета = Новый Структура("КодСостояния, ТекстОшибки");
	
	РезультатыАвторизации = Новый Структура;
	РезультатыАвторизации.Вставить("REST_API_Session", Неопределено);
	РезультатыАвторизации.Вставить("СтруктураОтвета",  СтруктураОтвета);
	
	Возврат РезультатыАвторизации;	
	
КонецФункции

Функция REST_API_ЗаполнитьДанныеАвторизацииHTTPЗапроса(СтрокаПодключения, СтруктураПодключения, СтруктураURI, СтруктураЗапроса, АдресаПеременных)
	
	РезультатыАвторизации = REST_API_ПолучитьСтруктуруРезультатовАвторизации();
	
	АвторизацияВключена = ТипЗнч(СтруктураПодключения) = Тип("Структура")
		И СтруктураПодключения.Свойство("АвторизацияВключена")
		И СтруктураПодключения.АвторизацияВключена;
	ТребуетсяПолучитьТокен = Ложь;
	АвторизацияЛогин 	   = "";
	АвторизацияПароль 	   = "";
	
	REST_API_session = КомЯдро_ПолучитьЗначениеПеременной("API_session_" + СтрЗаменить(СтрЗаменить(СтруктураURI.Хост, ".", "_"), "-", "_") + "_" + Формат(СтруктураURI.Порт, "ЧГ=") + "_" + СтрЗаменить(СтруктураURI.ПутьНаСервере, "-", ""), АдресаПеременных);
	Если REST_API_session <> Неопределено Тогда
		Access_token = REST_API_session.Получить("Access_token");
		Если Access_token = Неопределено Тогда
			Access_token = REST_API_session.Получить("access_token");	
		КонецЕсли;
		СтруктураЗапроса.Заголовки.Вставить("Authorization", "Bearer " + Access_token);
		РезультатыАвторизации.Вставить("REST_API_session", REST_API_session);
	ИначеЕсли АвторизацияВключена
		И СтруктураПодключения.Свойство("АвторизацияТокен")
		И ЗначениеЗаполнено(СтруктураПодключения.АвторизацияТокен) Тогда
		СтруктураЗапроса.Заголовки.Вставить("Authorization", "Bearer " + СтруктураПодключения.АвторизацияТокен);
	ИначеЕсли АвторизацияВключена
		И ЗначениеЗаполнено(СтруктураURI.TempUid) Тогда
		ТребуетсяПолучитьТокен = Истина;
		АвторизацияЛогин  = "__tempuid__";
		АвторизацияПароль = СтруктураURI.TempUid;
	ИначеЕсли АвторизацияВключена Тогда
		ТребуетсяПолучитьТокен = Истина;
		АвторизацияЛогин  = ГлЯдро_ПолучитьДанныеИзХранилища1С("СохраненнаяАвторизацияЛогин");
		АвторизацияПароль = ГлЯдро_ПолучитьДанныеИзХранилища1С("СохраненнаяАвторизацияПароль");
		АвторизацияПароль = ГлЯдро_РасшифроватьСтроку(АвторизацияПароль, ГлЯдро_ПолучитьКлючШифрования(АвторизацияЛогин, СтрДлина(АвторизацияПароль)));
	КонецЕсли;
	
	Если ТребуетсяПолучитьТокен
		И ЗначениеЗаполнено(АвторизацияЛогин) Тогда
		ДанныеТокена = REST_API_ПолучитьТокенSMARTS(СтрокаПодключения, АвторизацияЛогин, АвторизацияПароль, "Основная", АдресаПеременных);
		Если ДанныеТокена = Ложь ИЛИ ДанныеТокена = Неопределено Тогда
			РезультатыАвторизации.СтруктураОтвета.Вставить("КодСостояния", 401);
			РезультатыАвторизации.СтруктураОтвета.Вставить("ТекстОшибки",  "Не удалось авторизоваться");
		ИначеЕсли ТипЗнч(ДанныеТокена) = Тип("Структура") Тогда
			СтруктураЗапроса.Заголовки.Вставить("Authorization", "Bearer " + ДанныеТокена.АвторизацияТокен);
			Если ТипЗнч(СтруктураПодключения) = Тип("Структура") Тогда
				СтруктураПодключения.Вставить("АвторизацияТокен", 		ДанныеТокена.АвторизацияТокен);
				СтруктураПодключения.Вставить("АвторизацияРефрешТокен",	ДанныеТокена.АвторизацияРефрешТокен);
			КонецЕсли;
		Иначе
			СтруктураЗапроса.Заголовки.Вставить("Authorization", "Bearer " + ДанныеТокена);
			Если ТипЗнч(СтруктураПодключения) = Тип("Структура") Тогда
				СтруктураПодключения.Вставить("АвторизацияТокен", 		ДанныеТокена);
				СтруктураПодключения.Вставить("АвторизацияРефрешТокен",	Неопределено);
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	Возврат РезультатыАвторизации;
	
КонецФункции

Функция REST_API_ПолучитьВерсиюAPI()
	Возврат "v1"
КонецФункции

// Разбирает строку URI на составные части и возвращает в виде структуры.
// На основе RFC 3986.
//
// Параметры:
//     СтрокаURI - Строка - ссылка на ресурс в формате:
//                          <схема>://<логин>:<пароль>@<хост>:<порт>/<путь>?<параметры>#<якорь>.
//
// Возвращаемое значение:
//     Структура - составные части URI согласно формату:
//         * Схема         - Строка.
//         * Логин         - Строка.
//         * Пароль        - Строка.
//         * ИмяСервера    - Строка - часть <хост>:<порт> входного параметра.
//         * Хост          - Строка.
//         * Порт          - Строка.
//         * ПутьНаСервере - Строка - часть <путь>?<параметры>#<якорь> входного параметра.
Функция REST_API_ПолучитьСтруктуруURIИзСтроки(Знач СтрокаURI) 
   
    СтрокаURI = СокрЛП(СтрокаURI);
   
    // Схема
    Схема = "";
    Позиция = ГлЯдро_СтрНайти(СтрокаURI, "://");
    Если Позиция > 0 Тогда
        Схема = НРег(Лев(СтрокаURI, Позиция - 1));
        СтрокаURI = Сред(СтрокаURI, Позиция + 3);
    КонецЕсли;

	// Строка соединения и путь на сервере.
	СтрокаСоединения = СтрокаURI;
    ПутьНаСервере = "";
    ПозицияСтрокиПоиска = ГлЯдро_СтрНайти(СтрокаСоединения, "/");
	Если ПозицияСтрокиПоиска > 0 Тогда
		ПутьНаСервере = Сред(СтрокаСоединения, ПозицияСтрокиПоиска + 1);
		Если Прав(ПутьНаСервере, 1) = "/" Тогда
			ПутьНаСервере = Лев(ПутьНаСервере, СтрДлина(ПутьНаСервере) - 1);
		КонецЕсли;
		СтрокаСоединения = Лев(СтрокаСоединения, ПозицияСтрокиПоиска - 1);
		
		ПозицияСтрокиПоиска = ГлЯдро_СтрНайти(ПутьНаСервере, "?");
		Если ПозицияСтрокиПоиска > 0 Тогда
			ПутьНаСервере = Лев(ПутьНаСервере, ПозицияСтрокиПоиска - 1);
		КонецЕсли;
	КонецЕсли;
       
    // Информация пользователя и имя сервера
    СтрокаАвторизации = "";
    ИмяСервера = СтрокаСоединения;
    Позиция = ГлЯдро_СтрНайти(СтрокаСоединения, "@");
    Если Позиция > 0 Тогда
        СтрокаАвторизации = Лев(СтрокаСоединения, Позиция - 1);
        ИмяСервера = Сред(СтрокаСоединения, Позиция + 1);
    КонецЕсли;
   
    // Логин и пароль
    Логин = СтрокаАвторизации;
    Пароль = "";
    Позиция = ГлЯдро_СтрНайти(СтрокаАвторизации, ":");
    Если Позиция > 0 Тогда
        Логин = Лев(СтрокаАвторизации, Позиция - 1);
        Пароль = Сред(СтрокаАвторизации, Позиция + 1);
    КонецЕсли;
   
    // Хост и порт
    Хост = ИмяСервера;
    Порт = "";
    Позиция = ГлЯдро_СтрНайти(ИмяСервера, ":");
    Если Позиция > 0 Тогда
        Хост = Лев(ИмяСервера, Позиция - 1);
        Порт = Сред(ИмяСервера, Позиция + 1);
        Если Не ГлЯдро_ТолькоЦифрыВСтроке(Порт) Тогда
            Порт = "";
        КонецЕсли;
	КонецЕсли;
	
	// Данные упрощенной авторизации
	TempUid = "";
	ПозицияСтрокиПоиска = ГлЯдро_СтрНайти(СтрокаURI, "tempuid=");
	Если ПозицияСтрокиПоиска > 0 Тогда
		TempUid	= Сред(СтрокаURI, ПозицияСтрокиПоиска + 8);
	КонецЕсли;
   
    Результат = Новый Структура;
    Результат.Вставить("Схема",			Схема);
    Результат.Вставить("Логин",			Логин);
    Результат.Вставить("Пароль",		Пароль);
    Результат.Вставить("ИмяСервера",	ИмяСервера);
    Результат.Вставить("Хост",			Хост);
    Результат.Вставить("Порт", 			?(ПустаяСтрока(Порт), Неопределено, Число(Порт)));
    Результат.Вставить("ПутьНаСервере", ПутьНаСервере);
    Результат.Вставить("Протокол", 		?(ПустаяСтрока(Схема), "http", Схема));
	Результат.Вставить("TempUid",		TempUid);
	
    Возврат Результат;

КонецФункции

Функция REST_API_ВыполнитьHTTPЗапрос(СтруктураURI,СтруктураЗапроса,ОтправляемыеДанные = Неопределено,АдресаПеременных) 
	
	Перем ОтветHTTP,ТекстОшибки;
	
	Таймаут = ГлЯдро_ПолучитьТаймаутПоТипуМетода(СтруктураЗапроса,АдресаПеременных);
	
	ВернутьСтруктуру = ?(СтруктураЗапроса.Свойство("ВернутьСтруктуру"),СтруктураЗапроса.ВернутьСтруктуру,Ложь);
	
	ВерсияAPI = ?(СтруктураЗапроса.Свойство("ВерсияAPI"), СтруктураЗапроса.ВерсияAPI, "/api/"+REST_API_ПолучитьВерсиюAPI());
	
	Соединение = Новый HTTPСоединение(
        СтруктураURI.Хост // сервер (хост)
        ,СтруктураURI.Порт // порт, по умолчанию
        ,//СтруктураURI.Логин, // пользователь для доступа к серверу (если он есть)
        ,//СтруктураURI.Пароль, // пароль для доступа к серверу (если он есть)
        , // здесь указывается прокси, если он есть
        ,Таймаут // таймаут в секундах, 0 или пусто - не устанавливать
        ,?(СтруктураURI.Протокол = "https",Новый ЗащищенноеСоединениеOpenSSL(),Неопределено)  // защищенное соединение, если используется https
    );
	
	СтрокаЗапроса = ?(ЗначениеЗаполнено(СтруктураURI.ПутьНаСервере),"/"+СтруктураURI.ПутьНаСервере,"")
					+ВерсияAPI
					+?(ЗначениеЗаполнено(СтруктураЗапроса.Метод),"/"+СтрЗаменить(СтруктураЗапроса.Метод,"#","%23"),"");	 // временное решение, замена # на %23
	
	Запрос = Новый HTTPЗапрос(СтрокаЗапроса,СтруктураЗапроса.Заголовки);
	
	Если СтруктураЗапроса.HTTPМетод = "POST"  
		ИЛИ СтруктураЗапроса.HTTPМетод = "PATCH" 
		ИЛИ СтруктураЗапроса.HTTPМетод = "PUT" Тогда
		Если ТипЗнч(ОтправляемыеДанные) = Тип("Строка") Тогда
			Запрос.УстановитьТелоИзСтроки(ОтправляемыеДанные);
		Иначе
			ЗаписьJSON = Новый ЗаписьJSON; 
			ПараметрыJSON = Новый ПараметрыЗаписиJSON(ПереносСтрокJSON.Авто,"",Истина,,Ложь,Ложь,Ложь,Истина,Ложь);
			ЗаписьJSON.УстановитьСтроку(ПараметрыJSON);
			ЗаписатьJSON(ЗаписьJSON, ОтправляемыеДанные); // ОтправляемыеДанные обязательны в этом случае
			СтрокаДляТела = ЗаписьJSON.Закрыть();
				
			ОтключитьСжатиеДанных = ГлЯдро_ПолучитьИзКэшаНастройкуSMARTS("ОтключитьСжатиеДанных",, АдресаПеременных);
			Если ОтключитьСжатиеДанных = Истина Тогда
				Запрос.УстановитьТелоИзСтроки(СтрокаДляТела, КодировкаТекста.UTF8, ИспользованиеByteOrderMark.НеИспользовать);
			Иначе
				СжатыеДанные = Неопределено;
				КоличествоПопытокСжатия = 2;
				Пока КоличествоПопытокСжатия Цикл
					Попытка
						СжатыеДанные = ГлЯдро_ЗашифроватьGZIP(СтрокаДляТела);
						КоличествоПопытокСжатия = 0;
					Исключение	
						ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
						ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации("ГлЯдро_ЗашифроватьGZIP", "Ошибка", ТекстОшибки,, АдресаПеременных);
						КоличествоПопытокСжатия = КоличествоПопытокСжатия - 1;						
					КонецПопытки;
				КонецЦикла;
				Если СжатыеДанные <> Неопределено Тогда
					Запрос.Заголовки.Вставить("Content-Encoding", "gzip");
					Запрос.УстановитьТелоИзДвоичныхДанных(СжатыеДанные);
				Иначе
					Запрос.УстановитьТелоИзСтроки(СтрокаДляТела, КодировкаТекста.UTF8, ИспользованиеByteOrderMark.НеИспользовать);	
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	СтруктураОтвета = Новый Структура;
	СтруктураОтвета.Вставить("КодСостояния", Неопределено);	
	Попытка
		ОтветHTTP = Соединение.ВызватьHTTPМетод(СтруктураЗапроса.HTTPМетод,Запрос);
		
		СтруктураОтвета.КодСостояния = ОтветHTTP.КодСостояния;
		
		Если ОтветHTTP.Заголовки.Получить("Content-Encoding") = "gzip" Тогда
			КоличествоПопытокРаспаковки = 2;
			Пока КоличествоПопытокРаспаковки Цикл
				Попытка	
					ОтветСервера = ГлЯдро_РасшифроватьGZIP(ОтветHTTP.ПолучитьТелоКакДвоичныеДанные());
					КоличествоПопытокРаспаковки = 0;
				Исключение				
					ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
					ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации("ГлЯдро_РасшифроватьGZIP", "Ошибка", ТекстОшибки,, АдресаПеременных);
					КоличествоПопытокРаспаковки = КоличествоПопытокРаспаковки - 1;
				КонецПопытки;
			КонецЦикла;
		Иначе
			ОтветСервера = ОтветHTTP.ПолучитьТелоКакСтроку("UTF-8");
		КонецЕсли;
		
		Если ОтветHTTP.КодСостояния = Неопределено ИЛИ ОтветHTTP.КодСостояния < 200 ИЛИ ОтветHTTP.КодСостояния >= 300 Тогда
			ТекстОшибки = " Ошибка " + ОтветHTTP.КодСостояния + Символы.ПС +
			ОтветСервера;
		КонецЕсли;
		
		ЧтениеJSON = Новый ЧтениеJSON;
		Если ЗначениеЗаполнено(ОтветСервера) Тогда
			Если ВернутьСтруктуру Тогда
				НачСреза = ГлЯдро_СтрНайти(ОтветСервера,"""@odata.context""");
				Если НачСреза > 0 Тогда
					КонецСреза = ГлЯдро_СтрНайти(ОтветСервера,""",",,НачСреза);
					ОтветСервера = Лев(ОтветСервера,НачСреза) + Прав(ОтветСервера,СтрДлина(ОтветСервера)-КонецСреза-2);
				КонецЕсли;
			КонецЕсли;
			ЧтениеJSON.УстановитьСтроку(ОтветСервера);
			Соответствие = ПрочитатьJSON(ЧтениеJSON,НЕ ВернутьСтруктуру);
			СтруктураОтвета.Вставить("ОтветСервера", Соответствие);
			СтруктураОтвета.Вставить("ОтветСервераНеРасшифрованный", ОтветСервера);
		КонецЕсли;
				
	Исключение
		Если НЕ ЗначениеЗаполнено(ТекстОшибки) Тогда
			ТекстОшибки = "Не удалось выполнить HTTP запрос по причине " + ИнформацияОбОшибке().Описание;
		КонецЕсли;
	КонецПопытки;
	
	Если ЗначениеЗаполнено(ТекстОшибки) Тогда
		ВыполняемыйЗапрос = СтрокаЗапроса;
		Если СтруктураЗапроса.Свойство("СтрокаЗапроса") Тогда
			ВыполняемыйЗапрос = СтруктураЗапроса.СтрокаЗапроса;		
		КонецЕсли;		
		ТекстОшибки = ГлЯдро_ПреобразоватьИзUnicode(ТекстОшибки);
		ТекстОшибки = ТекстОшибки + ", Строка запроса: " + СтруктураURI.Протокол + "://" + СтруктураURI.ИмяСервера + ВыполняемыйЗапрос + ", Таймаут: " + Таймаут + "с.";
		
		// Возможно, необходимо отключить сжатие
		Если СтруктураОтвета.КодСостояния = 400
			И (ГлЯдро_СтрНайти(ВРег(ТекстОшибки), ВРег("Не удается преобразовать байты"))
				ИЛИ ГлЯдро_СтрНайти(ВРег(ТекстОшибки), ВРег("Unable to translate bytes"))) Тогда
            СтруктураОтвета.Вставить("ОтключитьСжатиеДанных", Истина);
		ИначеЕсли СтруктураОтвета.КодСостояния = 500 И НайтиНедопустимыеСимволыXML(ТекстОшибки) Тогда
			#Если ВебКлиент Тогда
				ТекстОшибки = "Ошибка 500" + Символы.ПС + ", Строка запроса: " + СтруктураURI.Протокол + "://" + СтруктураURI.ИмяСервера + ВыполняемыйЗапрос + ", Таймаут: " + Таймаут + "с.";
			#Иначе
				Если НайтиНедопустимыеСимволыXML(ТекстОшибки) Тогда
					ТекстОшибки = ГлЯдро_ОчиститьНедопустимыеСимволыXML(ТекстОшибки);					
				КонецЕсли;
			#КонецЕсли
			СтруктураОтвета.Вставить("ОтключитьСжатиеДанных", Истина);
		КонецЕсли;
	КонецЕсли;
	
	СтруктураОтвета.Вставить("ТекстОшибки",ТекстОшибки);
	СтруктураОтвета.Вставить("СтрокаЗапроса", СтрокаЗапроса);
	
	Возврат СтруктураОтвета;
	
КонецФункции

#КонецОбласти

Функция REST_API_ПолучитьМобильныеУстройстваSMARTS(ТипБазы,АдресаПеременных)
	
	ИмяСобытия = "REST_API_ПолучитьМобильныеУстройстваSMARTS";
	
	Если ТипБазы = "Частная" Тогда
		КлючПеременной = "REST_API_СтруктураПодключенияЧастнойБазыMS";
	ИначеЕсли ТипБазы = "Временная" Тогда
		КлючПеременной = "REST_API_СтруктураПодключенияВременнойБазыMS";
	Иначе
		КлючПеременной = "REST_API_СтруктураПодключенияБазыMS";
	КонецЕсли;
	
	СтруктураПодключения = КомЯдро_ПолучитьЗначениеПеременной(КлючПеременной,АдресаПеременных);
	
	СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключения,Новый Структура("HTTPМетод,Метод,ТипЗапроса","GET","Devices","ПолучениеМетаданных"),,АдресаПеременных);	
	Если СтруктураОтвета.КодСостояния <> 200 Тогда
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Запрос: GET, Devices. Получен некорректный ответ от сервера, Код состояния: " + Строка(СтруктураОтвета.КодСостояния)+ ". Содержание ошибки: " + Строка(СтруктураОтвета.ТекстОшибки),,АдресаПеременных);	
		Devices = Неопределено;
	Иначе
		Devices = СтруктураОтвета.ОтветСервера.Получить("value");	
	КонецЕсли;	
		
	СписокУстройствMS = Новый СписокЗначений;
	
	Если Devices <> Неопределено Тогда
		Для Каждого ТекущееУстройство ИЗ Devices Цикл                  
			Pincode    = СокрЛП(ТекущееУстройство.Получить("pincode"));
			DeviceId   = СокрЛП(ТекущееУстройство.Получить("deviceId"));
			DeviceName = СокрЛП(ТекущееУстройство.Получить("deviceName"));
			СписокУстройствMS.Добавить(Pincode + ";" + DeviceId + ";" + ?(НЕ ЗначениеЗаполнено(DeviceName), DeviceId, DeviceName + ", (" + DeviceId + ")") + ";");			
		КонецЦикла;
	КонецЕсли;
	
	УстройстваMS = Новый ДеревоЗначений;
	УстройстваMS.Колонки.Добавить("Выгружать", 			  Новый ОписаниеТипов("Булево"), "Выгружать");
	УстройстваMS.Колонки.Добавить("ПинКод",   		  	  Новый ОписаниеТипов("Строка"), "Пин-код");
	УстройстваMS.Колонки.Добавить("ГруппаПользователь",   Новый ОписаниеТипов("Строка"), "Группа/пользователь");
	УстройстваMS.Колонки.Добавить("ИдГруппыПользователя", Новый ОписаниеТипов("Строка"), "Ид группы/пользователя");	
	
	Для Каждого Устройство из СписокУстройствMS Цикл
		
		ИдИИмяУстройства = ГлЯдро_РазложитьСтрокуВМассивПодстрок(Устройство.Значение, ";");
		
		ПинУстройства  	= ИдИИмяУстройства[0];
		ИдУстройства  	= ИдИИмяУстройства[1];
		ИмяУстройства 	= ИдИИмяУстройства[2];
		
		СтрокаДерева 						= УстройстваMS.Строки.Добавить();
		СтрокаДерева.ИдГруппыПользователя 	= ИдУстройства;
		СтрокаДерева.ГруппаПользователь 	= ИмяУстройства;		            
		СтрокаДерева.ПинКод 				= ПинУстройства;					
				
	КонецЦикла;
	
	Возврат ПоместитьВоВременноеХранилище(УстройстваMS, Новый УникальныйИдентификатор());
	
КонецФункции

Процедура REST_API_ОбновитьШаблоныВесовогоТовараMS(ТаблицаШаблонов, ТипБазы, АдресаПеременных)
	
	ИмяСобытия = "REST_API_ОбновитьШаблоныВесовогоТовараMS";
	
	Если ТипБазы = "Частная" Тогда
		КлючПеременной = "REST_API_СтруктураПодключенияЧастнойБазыMS";
	ИначеЕсли ТипБазы = "Временная" Тогда
		КлючПеременной = "REST_API_СтруктураПодключенияВременнойБазыMS";
	Иначе
		КлючПеременной = "REST_API_СтруктураПодключенияБазыMS";
	КонецЕсли;
	
	СтруктураПодключения = КомЯдро_ПолучитьЗначениеПеременной(КлючПеременной, АдресаПеременных);                              
	
	КоллекцияШаблонов = Новый Массив;
	// Добавление новых шаблонов
	Для Каждого Шаблон из ТаблицаШаблонов Цикл
		ЦелаяЧасть = Шаблон.ЦелаяЧасть - СтрДлина(Шаблон.Префикс);
		Если Шаблон.ПрефиксВключенВКод Тогда			
			КоллекцияШаблонов.Добавить("{Barcode:@" + Шаблон.Префикс + "[0-9]{" + Шаблон.ДлинаКодаВесовогоТовара + "}}{Quantity:" + ЦелаяЧасть + "." + Шаблон.ДробнаяЧасть + "}{OneC:1}");
		Иначе
			КоллекцияШаблонов.Добавить(Шаблон.Префикс + "{Barcode:" + Шаблон.ДлинаКодаВесовогоТовара + "}{Quantity:" + ЦелаяЧасть + "." + Шаблон.ДробнаяЧасть + "}{OneC:1}");
		КонецЕсли;
	КонецЦикла;	
	
	ОтправляемыеДанные = Новый Соответствие;
	ОтправляемыеДанные.Вставить("commonTemplates", КоллекцияШаблонов);
	
	СтруктураЗапроса = Новый Структура("HTTPМетод,Метод,ТипЗапроса", "PATCH", "ProductSchema('1')", "ПолучениеМетаданных");	
	СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключения, СтруктураЗапроса, ОтправляемыеДанные, АдресаПеременных);	
	
	Если СтруктураОтвета.КодСостояния <> 204 Тогда
		ГлЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Запрос: PATCH, ProductSchema. Получен некорректный ответ от сервера, Код состояния: " + Строка(СтруктураОтвета.КодСостояния)+ ". Содержание ошибки: " + Строка(СтруктураОтвета.ТекстОшибки),, АдресаПеременных);	
	КонецЕсли;	
	
КонецПроцедуры

#КонецОбласти
