
#Область НастройкиУчета

//Возвращает массив значений видов продукции в зависимости от включенных опций учета ТГ.
//Похоже по функциональности с МассивДоступныхВидовПродукции(), но массив элементов содержит список значений другого типа.
//
Функция УчитываемыеВидыМаркируемойПродукции() Экспорт
	
	ВидыПродукции = Новый Массив();
	
	Если ПроверитьЗначениеОбщейФОМаркировки() Тогда
		
		Если Константы.ВестиУчетМаркируемойОбувиИСМПТК.Получить() Тогда 
			ВидыПродукции.Добавить(Перечисления.ВидыПродукцииИСМПТК.Обувная);
		КонецЕсли;
		
		Если Константы.ВестиУчетМаркируемогоТабакаИСМПТК.Получить() Тогда 
			ВидыПродукции.Добавить(Перечисления.ВидыПродукцииИСМПТК.Табачная);
		КонецЕсли;
		
		Если Константы.ВестиУчетМаркируемойМолочкиИСМПТК.Получить() Тогда 
			ВидыПродукции.Добавить(Перечисления.ВидыПродукцииИСМПТК.МолочнаяПродукция);
		КонецЕсли;
		
		Если Константы.ВестиУчетМаркируемыхЛекарствИСМПТК.Получить() Тогда 
			ВидыПродукции.Добавить(Перечисления.ВидыПродукцииИСМПТК.ЛекарственныеПрепараты);
		КонецЕсли;
		
		Если Константы.ВестиУчетМаркируемогоТекстиляИСМПТК.Получить() Тогда 
			ВидыПродукции.Добавить(Перечисления.ВидыПродукцииИСМПТК.ЛегкаяПромышленность);
		КонецЕсли;
		
	КонецЕсли;
		
	Возврат ВидыПродукции;
	
КонецФункции

Функция ПроверитьЗначениеОбщейФОМаркировки() Экспорт
	
	Возврат ПолучитьФункциональнуюОпцию("ВестиУчетМаркируемойПродукцииИСМПТК");
	
КонецФункции

Функция ПроверитьЗначениеКонстанты(ИмяКонстанты) Экспорт
	
	Возврат Константы[ИмяКонстанты].Получить();
	
КонецФункции

Процедура ЗполнитьДопустимыеВидыПродукции(БазовыеПараметры) Экспорт
	
	БазовыеПараметры.ДопустимыеВидыПродукции = УчитываемыеВидыМаркируемойПродукции(); 
	
КонецПроцедуры

//Возвращает массив значений шаблонов КМ для СУЗ в зависимости от включенных опций учета ТГ.
//Похоже по функциональности с УчитываемыеВидыМаркируемойПродукции(), но массив элементов содержит список значений другого типа.
//
Функция МассивДоступныхВидовПродукции() Экспорт
	
	МассивВидовПродукции = Новый Массив();
	
	Если Константы.ВестиУчетМаркируемогоТабакаИСМПТК.Получить() Тогда
		МассивВидовПродукции.Добавить(ПредопределенноеЗначение("Перечисление.ШаблоныКодовМаркировкиСУЗИСМПТК.ЛекарственныеПрепараты"));
	КонецЕсли;
	
	Если Константы.ВестиУчетМаркируемойМолочкиИСМПТК.Получить() Тогда
		МассивВидовПродукции.Добавить(ПредопределенноеЗначение("Перечисление.ШаблоныКодовМаркировкиСУЗИСМПТК.МолочнаяПродукция"));
	КонецЕсли;
	
	Если Константы.ВестиУчетМаркируемогоТекстиляИСМПТК.Получить() Тогда
		МассивВидовПродукции.Добавить(ПредопределенноеЗначение("Перечисление.ШаблоныКодовМаркировкиСУЗИСМПТК.ЛегкаяПромышленность"));
	КонецЕсли;
	
	Если Константы.ВестиУчетМаркируемойОбувиИСМПТК.Получить() Тогда
		МассивВидовПродукции.Добавить(ПредопределенноеЗначение("Перечисление.ШаблоныКодовМаркировкиСУЗИСМПТК.Обувь"));
	КонецЕсли;
	
	Если Константы.ВестиУчетМаркируемыхЛекарствИСМПТК.Получить() Тогда
		МассивВидовПродукции.Добавить(ПредопределенноеЗначение("Перечисление.ШаблоныКодовМаркировкиСУЗИСМПТК.ЛекарственныеПрепараты"));
	КонецЕсли;
		
	Возврат МассивВидовПродукции;
	
КонецФункции

#КонецОбласти

#Область ПреобразованиеДанных

// Рассчитать хеш для строки
// 
// Параметры:
//  СтрокаДляРасчетаХеша - Строка - Строка для расчета хеша
// Возвращаемое значение:
//  Строка - Описание
Функция ХешированиеДанныхSHA256(СтрокаДляРасчетаХеша) Экспорт
	
	ХешированиеДанныхОбъект = Новый ХешированиеДанных(ХешФункция.SHA256);
	ХешированиеДанныхОбъект.Добавить(СтрокаДляРасчетаХеша);
	
	Возврат Base64Строка(ХешированиеДанныхОбъект.ХешСумма);
	
КонецФункции

Функция ОбъектXDTOИзСтрокиXML(Знач СтрокаXML, Знач Фабрика) Экспорт
	
	ЧтениеXML = Новый ЧтениеXML;
	ЧтениеXML.УстановитьСтроку(СтрокаXML);	
	ОбъектXDTO = Фабрика.ПрочитатьXML(ЧтениеXML);
	
	Возврат ОбъектXDTO;
	
КонецФункции

Функция СписокXDTOИзОбъектXDTO(Знач ОбъектXDTO) Экспорт
	
	Если ТипЗнч(ОбъектXDTO) = Тип("СписокXDTO") Тогда
		СписокXDTO = ОбъектXDTO;
	Иначе
		ЧтениеXML = Новый ЧтениеXML;
		ЧтениеXML.УстановитьСтроку("<parent><list></list><list></list></parent>");	
		СписокXDTO = ФабрикаXDTO.ПрочитатьXML(ЧтениеXML).list;
		СписокXDTO.Очистить();
		СписокXDTO.Добавить(ОбъектXDTO);	
	КонецЕсли;
	
	Возврат СписокXDTO;
	
КонецФункции

Функция УдалитьСлужебныеСимволыВСтроке(ИсходнаяСтрока) Экспорт
	
	ОбработаннаяСтрока = СтрЗаменить(ИсходнаяСтрока, Символы.ВК, "");
	ОбработаннаяСтрока = СтрЗаменить(ОбработаннаяСтрока, Символы.ПС, "");
	ОбработаннаяСтрока = СтрЗаменить(ОбработаннаяСтрока, "¶", "");
		
	Возврат ОбработаннаяСтрока;
	
КонецФункции

Функция ХэшСуммаСтроки(СтрокаДляРасчетаХеша) Экспорт
	
	ХешированиеДанныхОбъект = Новый ХешированиеДанных(ХешФункция.SHA256);
	ХешированиеДанныхОбъект.Добавить(СтрокаДляРасчетаХеша);
	
	Возврат Base64Строка(ХешированиеДанныхОбъект.ХешСумма);
	
КонецФункции

Функция ПреобразоватьJSON_В_МассивСтруктур(СтрокаJSON) Экспорт
	
	ЧтениеJSON = Новый ЧтениеJSON;
	ЧтениеJSON.УстановитьСтроку(СтрокаJSON);
	Структура = ПрочитатьJSON(ЧтениеJSON);	
	ЧтениеJSON.Закрыть();

	Возврат Структура;
	
КонецФункции 

Функция ПривестиСтрокуКДате(Строка, ФорматДаты="дмг") Экспорт
	
	СписокТех = Новый Массив;
	
	Подстрока = "";
	Позиция = 1;
	ДлинаСтроки = СтрДлина(Строка) + 1;
	Пока Позиция <= ДлинаСтроки цикл
		Символ = Сред(Строка, Позиция, 1);
		Если (Символ >= "0") И (Символ <= "9") тогда
			Подстрока = Подстрока + Символ;
		ИначеЕсли Подстрока <> "" тогда
			СписокТех.Добавить(Число(Подстрока));
			Подстрока = "";
		КонецЕсли;
		Позиция = Позиция + 1;
	КонецЦикла;
	Если СписокТех.Количество() < 3 тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если ФорматДаты="дмг" тогда
		День = СписокТех[0]; Месяц = СписокТех[1]; Год = СписокТех[2];
	ИначеЕсли ФорматДаты="мдг" тогда
		День = СписокТех[1]; Месяц = СписокТех[0]; Год = СписокТех[2];
	ИначеЕсли ФорматДаты="гмд" тогда
		День = СписокТех[2]; Месяц = СписокТех[1]; Год = СписокТех[0];
	Иначе
		День = 1; Месяц = 1; Год = 1;
	КонецЕсли;
	
	Час = 0; Минута = 0; Секунда = 0;
	
	Если СписокТех.Количество() >= 5 тогда
		Час = СписокТех[3];
		Минута = СписокТех[4];
		Секунда = ?(СписокТех.Количество() >= 6, СписокТех[5], 0);
	КонецЕсли;
	
	Попытка
		Результат = Дата(Год, Месяц, День, Час, Минута, Секунда);
	Исключение
		Возврат Неопределено;
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции

Функция УдалитьРазрывыВСтроке(Строка) Экспорт

	Возврат	СтрЗаменить(СокрЛП(Строка), Символ(160), "");

КонецФункции

//Проверяет наличие конструкции "https://" в адресе сервера, если ее нет - добавляет (необходимо для работы в методах АПИ)
//
Функция ПроверитьНаличиеПротоколаВАдресе(АдресСервера) Экспорт
	
	Если СтрНайти(АдресСервера, "http") = 0 Тогда
		АдресСервера = "https://" + СокрЛП(АдресСервера);
		Если Не Прав(АдресСервера, 1) = "/" Тогда
			АдресСервера = АдресСервера + "/";
		КонецЕсли;
	КонецЕсли;
	
	Возврат АдресСервера;
	
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Функция ПолучитьИмяИПредставлениеПоСсылке(Объект) Экспорт
	
	ДанныеДокумента = Новый Структура("Имя, Синоним", Объект.Ссылка.Метаданные().Имя, Объект.Метаданные().Синоним);
	
	Возврат ДанныеДокумента;
	
КонецФункции

Функция ПолучитьПредставлениеПоПолномуИмени(ПолноеИмяОбъекта) Экспорт

	МетаданныеОбъекта = Метаданные.НайтиПоПолномуИмени(ПолноеИмяОбъекта);
	Возврат ?(МетаданныеОбъекта = Неопределено, "", МетаданныеОбъекта.Представление());
	
КонецФункции

// Добавляет новый элемент в СписокXDTO и возвращает его.
//
// Параметры:
//  СписокXDTO - СписокXDTO - Список, в который необходимо добавить новый элемент.
//  Фабрика - ФабрикаXDTO - Фабрика, которая будет использоваться для создания нового элемента списка.
//  Значение - Произвольный - Значение которое будет установлено для добавленного элемента.
//                            Если не задано, то будет добавлен пустой элемент.
//
// Возвращаемое значение:
//  ЗначениеXDTO, ОбъектXDTO - Добавленный элемент.
//
// Пример:
//  seller = НовыйЭлементСпискаXDTO(sellers.seller, Фабрика);
//
Функция НовыйЭлементСпискаXDTO(Знач СписокXDTO, Знач Фабрика, Знач Значение = Неопределено) Экспорт
	
	ТипЭлемент = СписокXDTO.ВладеющееСвойство.Тип;
	Элемент    = Фабрика.Создать(ТипЭлемент);
	
	Если Значение <> Неопределено Тогда
		Элемент = Значение;
	КонецЕсли;
	
	Возврат СписокXDTO.Добавить(Элемент);
	
КонецФункции

// Создает новый ОбъектXDTO, устанавливает его как свойство Владельца, возвращает созданный ОбъектXDTO.
//
// Параметры:
//  Владелец - ОбъектXDTO - Объект, для которого будет установлено свойство.
//  ИмяСвойства - Строка - Имя свойства, в которое необходимо записать созданный ОбъектXDTO.
//  Фабрика - ФабрикаXDTO - Фабрика, которая будет использоваться для создания нового ОбъектXDTO.
//
// Возвращаемое значение:
//  ОбъектXDTO - Новый ОбъектXDTO, установленный как свойство Вледельца.
//
// Пример:
//  sellers = НовоеСвойствоОбъектаXDTO(invoice, "sellers", Фабрика);
//
Функция НовоеСвойствоОбъектаXDTO(Знач Владелец, Знач ИмяСвойства, Знач Фабрика) Экспорт
	
	ТипСвойство = Владелец.Тип().Свойства.Получить(ИмяСвойства).Тип;
	Свойство = Фабрика.Создать(ТипСвойство);
	
	Владелец.Установить(ИмяСвойства, Свойство); 
	
	Возврат Свойство;
	
КонецФункции

// Возвращает каноническую строку XML, созданную на основе XDTO объекта.
//
// Параметры:
//  ОбъектXDTO - ОбъектXDTO - Объект на основе которого будет создана строка.
//  ИмяЭлемента - Строка - Имя корневого элемента создаваемой XML строки.
//  Фабрика - ФабрикаXDTO - Фабрика, которая будет использоваться при создании XML строки.
//
// Возвращаемое значение:
//  Строка - Строка, содержащая сериализованный XDTO объект.
//
// Пример:
//  InvoiceXML = КаноническаяСтрокаXMLИзОбъектаXDTO(InvoiceXDTO, "Invoice", Фабрика);
//
Функция КаноническаяСтрокаXMLИзОбъектаXDTO(Знач ОбъектXDTO, Знач ИмяЭлемента, Знач Фабрика) Экспорт
	
	ДокументDOM = Новый ДокументDOM("", "ExclusiveXMLCanonicalization");
	
	ЗаписьУзловDOM = Новый ЗаписьУзловDOM;
	ЗаписьУзловDOM.Открыть(ДокументDOM);
	Фабрика.ЗаписатьXML(ЗаписьУзловDOM, ОбъектXDTO, ИмяЭлемента); 	
	ДокументDOM.ЭлементДокумента.ДобавитьДочерний(ЗаписьУзловDOM.УзелDOM);
	
	КаноническийDOM       = Новый КаноническийDOM;
	КаноническаяЗаписьXML = Новый КаноническаяЗаписьXML; 
	КаноническаяЗаписьXML.УстановитьСтроку(ТипКаноническогоXML.ИсключающийКаноническийXML, "");
	
	КаноническийDOM.Канонизировать(ДокументDOM, КаноническаяЗаписьXML, "");
	СтрокаXML = КаноническаяЗаписьXML.Закрыть();
	СтрокаXML = СтрЗаменить(СтрокаXML, "<ExclusiveXMLCanonicalization>", "");
	СтрокаXML = СтрЗаменить(СтрокаXML, "</ExclusiveXMLCanonicalization>", "");
	
	Возврат СтрокаXML;
	
КонецФункции

Функция ЕстьРеквизитОбъекта(Объект, ИмяРеквизита) Экспорт
	
	МетаданныеОбъекта = Объект.Метаданные();
	Если МетаданныеОбъекта.Реквизиты.Найти(ИмяРеквизита) = Неопределено Тогда
		Возврат Ложь;
	Иначе
		Возврат Истина;
	КонецЕсли; 

КонецФункции

// Структура, содержащая значения реквизитов, прочитанные из информационной базы по ссылке на объект.
//
// Если необходимо зачитать реквизит независимо от прав текущего пользователя,
// то следует использовать предварительный переход в привилегированный режим.
//
// Параметры:
//  Ссылка    - ЛюбаяСсылка - объект, значения реквизитов которого необходимо получить.
//            - Строка      - полное имя предопределенного элемента, значения реквизитов которого необходимо получить.
//  Реквизиты - Строка - имена реквизитов, перечисленные через запятую, в формате
//                       требований к свойствам структуры.
//                       Например, "Код, Наименование, Родитель".
//            - Структура, ФиксированнаяСтруктура - в качестве ключа передается
//                       псевдоним поля для возвращаемой структуры с результатом, а в качестве
//                       значения (опционально) фактическое имя поля в таблице.
//                       Если ключ задан, а значение не определено, то имя поля берется из ключа.
//            - Массив, ФиксированныйМассив - имена реквизитов в формате требований
//                       к свойствам структуры.
//  ВыбратьРазрешенные - Булево - если Истина, то запрос к объекту выполняется с учетом прав пользователя, и в случае,
//                                    - если есть ограничение на уровне записей, то все реквизиты вернутся 
//                                      со значением Неопределено;
//                                    - если нет прав для работы с таблицей, то возникнет исключение.
//                              - если Ложь, то возникнет исключение при отсутствии прав на таблицу 
//                                или любой из реквизитов.
//
// Возвращаемое значение:
//  Структура - содержит имена (ключи) и значения затребованных реквизитов.
//            - если в параметр Реквизиты передана пустая строка, то возвращается пустая структура.
//            - если в параметр Ссылка передана пустая ссылка, то возвращается структура, 
//              соответствующая именам реквизитов со значениями Неопределено.
//            - если в параметр Ссылка передана ссылка несуществующего объекта (битая ссылка), 
//              то все реквизиты вернутся со значением Неопределено.
//
Функция ЗначенияРеквизитовОбъекта(Ссылка, Знач Реквизиты, ВыбратьРазрешенные = Ложь) Экспорт
	
	// Если передано имя предопределенного. 
	Если ТипЗнч(Ссылка) = Тип("Строка") Тогда 
		
		ПолноеИмяПредопределенногоЭлемента = Ссылка;
		
		// Вычисление ссылки по имени предопределенного.
		// - дополнительно выполняет проверку метаданных предопределенного, выполняется предварительно.
		Попытка
			Ссылка = ОбщегоНазначенияИСМПТККлиентСерверПереопределяемый.ПредопределенныйЭлемент(ПолноеИмяПредопределенногоЭлемента);
		Исключение
			ТекстОшибки = НСтр("ru = 'Передан неверный первый параметр ""Ссылка"".'")
						  + Символы.ПС
						  + КраткоеПредставлениеОшибки(ИнформацияОбОшибке());
			ВызватьИсключение ТекстОшибки;
		КонецПопытки;
		
		// Разбор полного имени предопределенного.
		ЧастиПолногоИмени = СтрРазделить(ПолноеИмяПредопределенногоЭлемента, ".");
		ПолноеИмяОбъектаМетаданных = ЧастиПолногоИмени[0] + "." + ЧастиПолногоИмени[1];
		
		// Если предопределенный не создан в ИБ, то требуется выполнить проверку доступа к объекту.
		// В других сценариях проверка доступа выполняется в момент исполнения запроса.
		Если Ссылка = Неопределено Тогда 
			
			МетаданныеОбъекта = Метаданные.НайтиПоПолномуИмени(ПолноеИмяОбъектаМетаданных);
			
			Если Не ПравоДоступа("Чтение", МетаданныеОбъекта) Тогда 
				ВызватьИсключение ОбщегоНазначенияИСМПТККлиентСерверПереопределяемый.ПодставитьПараметрыВСтроку(
								  НСтр("ru = 'Недостаточно прав для работы с таблицей ""%1""'"), 
								  ПолноеИмяОбъектаМетаданных);
			КонецЕсли;
			
		КонецЕсли;
		
	Иначе // Если передана ссылка.
		
		Попытка
			ПолноеИмяОбъектаМетаданных = Ссылка.Метаданные().ПолноеИмя(); 
		Исключение
			ВызватьИсключение НСтр("ru = 'Неверный первый параметр Ссылка:'")
							  + Символы.ПС
							  + "- " + НСтр("ru = 'Значение должно быть ссылкой или именем предопределенного элемента'");	
		КонецПопытки;
		
	КонецЕсли;
	
	// Разбор реквизитов, если второй параметр Строка.
	Если ТипЗнч(Реквизиты) = Тип("Строка") Тогда
		Если ПустаяСтрока(Реквизиты) Тогда
			Возврат Новый Структура;
		КонецЕсли;
		
		// Удаление пробелов.
		Реквизиты = СтрЗаменить(Реквизиты, " ", "");
		// Преобразование параметра в массив полей.
		Реквизиты = СтрРазделить(Реквизиты, ",");
	КонецЕсли;
	
	// Приведение реквизитов к единому формату.
	СтруктураПолей = Новый Структура;
	Если ТипЗнч(Реквизиты)    = Тип("Структура")
		Или ТипЗнч(Реквизиты) = Тип("ФиксированнаяСтруктура") Тогда
		
		СтруктураПолей = Реквизиты;
		
	ИначеЕсли ТипЗнч(Реквизиты) = Тип("Массив")
		Или ТипЗнч(Реквизиты)   = Тип("ФиксированныйМассив") Тогда
		
		Для Каждого Реквизит Из Реквизиты Цикл
			
			Попытка
				ПсевдонимПоля = СтрЗаменить(Реквизит, ".", "");
				СтруктураПолей.Вставить(ПсевдонимПоля, Реквизит);
			Исключение 
				// Если псевдоним не является ключом.
				
				// Поиск ошибки доступности полей.
				Результат = НайтиОшибкуДоступностиРеквизитовОбъекта(ПолноеИмяОбъектаМетаданных, Реквизиты);
				Если Результат.Ошибка Тогда 
					ВызватьИсключение ОбщегоНазначенияИСМПТККлиентСерверПереопределяемый.ПодставитьПараметрыВСтроку(НСтр("ru = 'Неверный второй параметр ""Реквизиты"": %1'"), Результат.ОписаниеОшибки);
				КонецЕсли;
				
				// Не удалось распознать ошибку, проброс первичной ошибки.
				ВызватьИсключение;
			
			КонецПопытки;
		КонецЦикла;
	Иначе
		ВызватьИсключение ОбщегоНазначенияИСМПТККлиентСерверПереопределяемый.ПодставитьПараметрыВСтроку(НСтр("ru = 'Неверный тип второго параметра ""Реквизиты"": %1'"), Строка(ТипЗнч(Реквизиты)));
	КонецЕсли;
	
	// Подготовка результата (после выполнения запроса переопределится).
	Результат = Новый Структура;
	
	// Формирование текста запроса к выбираемым полям.
	ТекстЗапросаПолей = "";
	Для Каждого КлючИЗначение Из СтруктураПолей Цикл
		
		ИмяПоля 	  	  = ?(ЗначениеЗаполнено(КлючИЗначение.Значение), КлючИЗначение.Значение, КлючИЗначение.Ключ);
		ПсевдонимПоля	  = КлючИЗначение.Ключ;
		ТекстЗапросаПолей = ТекстЗапросаПолей + ?(ПустаяСтрока(ТекстЗапросаПолей), "", ",") + "
										|	" + ИмяПоля + " КАК " + ПсевдонимПоля;
				
		// Предварительное добавление поля по псевдониму в возвращаемый результат.
		Результат.Вставить(ПсевдонимПоля);
		
	КонецЦикла;
	
	// Если предопределенного нет в ИБ.
	// - приведение результата к отсутствию объекта в ИБ или передаче пустой ссылки.
	Если Ссылка = Неопределено Тогда 
		Возврат Результат;
	КонецЕсли;
	
	ТекстЗапроса = 
		"ВЫБРАТЬ " + ?(ВыбратьРазрешенные, "РАЗРЕШЕННЫЕ", "") + "
		|" + ТекстЗапросаПолей + "
		|ИЗ
		|	" + ПолноеИмяОбъектаМетаданных + " КАК Таблица
		|ГДЕ
		|	Таблица.Ссылка = &Ссылка
		|";
	
	// Выполнение запроса.
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Ссылка", Ссылка);
	Запрос.Текст = ТекстЗапроса;
	
	Попытка
		Выборка = Запрос.Выполнить().Выбрать();
	Исключение
		
		// Если реквизиты были переданы строкой, то они уже конвертированы в массив.
		// Если реквизиты - массив, оставляем без изменений.
		// Если реквизиты - структура - конвертируем в массив.
		// В остальных случаях уже было бы выброшено исключение.
		Если Тип("Структура") = ТипЗнч(Реквизиты) Тогда
			Реквизиты = Новый Массив;
			Для Каждого КлючИЗначение Из СтруктураПолей Цикл
				ИмяПоля = ?(ЗначениеЗаполнено(КлючИЗначение.Значение), КлючИЗначение.Значение, КлючИЗначение.Ключ);
				Реквизиты.Добавить(ИмяПоля);
			КонецЦикла;
		КонецЕсли;
		
		// Поиск ошибки доступности полей.
		Результат = НайтиОшибкуДоступностиРеквизитовОбъекта(ПолноеИмяОбъектаМетаданных, Реквизиты);
		Если Результат.Ошибка Тогда 
			ВызватьИсключение ОбщегоНазначенияИСМПТККлиентСерверПереопределяемый.ПодставитьПараметрыВСтроку(НСтр("ru = 'Неверный второй параметр ""Реквизиты"": %1'"), Результат.ОписаниеОшибки);
		КонецЕсли;
		
		// Не удалось распознать ошибку, проброс первичной ошибки.
		ВызватьИсключение;
		
	КонецПопытки;
	
	// Заполнение реквизитов.
	Если Выборка.Следующий() Тогда
		ЗаполнитьЗначенияСвойств(Результат, Выборка);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Значения реквизитов, прочитанные из информационной базы для нескольких объектов.
//
//  Если необходимо зачитать реквизит независимо от прав текущего пользователя,
//  то следует использовать предварительный переход в привилегированный режим.
//
// Параметры:
//  Ссылки - Массив - массив ссылок на объекты одного типа.
//                          Значения массива должны быть ссылками на объекты одного типа.
//                          если массив пуст, то результатом будет пустое соответствие.
//  Реквизиты - Строка - имена реквизитов перечисленные через запятую, в формате требований к свойствам
//                             структуры. Например, "Код, Наименование, Родитель".
//  ВыбратьРазрешенные - Булево - если Истина, то запрос к объектам выполняется с учетом прав пользователя, и в случае,
//                                    - если какой-либо объект будет исключен из выборки по правам, то этот объект
//                                      будет исключен и из результата;
//                              - если Ложь, то возникнет исключение при отсутствии прав на таблицу
//                                или любой из реквизитов.
//
// Возвращаемое значение:
//  Соответствие - список объектов и значений их реквизитов:
//   * Ключ - ЛюбаяСсылка - ссылка на объект;
//   * Значение - Структура - значения реквизитов:
//    ** Ключ - Строка - имя реквизита;
//    ** Значение - Произвольный - значение реквизита.
// 
Функция ЗначенияРеквизитовОбъектов(Ссылки, Знач Реквизиты, ВыбратьРазрешенные = Ложь) Экспорт
	
	Если ТипЗнч(Реквизиты) = Тип("Массив") Или ТипЗнч(Реквизиты) = Тип("ФиксированныйМассив") Тогда
		Реквизиты = СтрСоединить(Реквизиты, ",");
	КонецЕсли;
	
	Если ПустаяСтрока(Реквизиты) Тогда 
		ВызватьИсключение НСтр("ru = 'Неверный второй параметр Реквизиты:'")
						  + Символы.ПС
						  + "- " + НСтр("ru = 'Поле объекта должно быть указано'");
	КонецЕсли;
	
	Если СтрНайти(Реквизиты, ".") <> 0 Тогда 
		ВызватьИсключение НСтр("ru = 'Неверный второй параметр Реквизиты:'")
						  + Символы.ПС
						  + "- " + НСтр("ru = 'Обращение через точку не поддерживается'");
	КонецЕсли;
	
	ЗначенияРеквизитов = Новый Соответствие;
	Если Ссылки.Количество() = 0 Тогда
		Возврат ЗначенияРеквизитов;
	КонецЕсли;
	
	ПерваяСсылка = Ссылки[0];
	
	Попытка
		ПолноеИмяОбъектаМетаданных = ПерваяСсылка.Метаданные().ПолноеИмя();
	Исключение
		ВызватьИсключение НСтр("ru = 'Неверный первый параметр Ссылки:'")
						  + Символы.ПС
						  + "- " + НСтр("ru = 'Значения массива должны быть ссылками'");
	КонецПопытки;
	
	ТекстЗапроса =
		"ВЫБРАТЬ РАЗРЕШЕННЫЕ
		|	Ссылка КАК Ссылка,
		|	&Реквизиты
		|ИЗ
		|	&ПолноеИмяОбъектаМетаданных КАК Таблица
		|ГДЕ
		|	Таблица.Ссылка В (&Ссылки)";
	
	Если Не ВыбратьРазрешенные Тогда 
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "РАЗРЕШЕННЫЕ", "");
	КонецЕсли;
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&Реквизиты", Реквизиты);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ПолноеИмяОбъектаМетаданных", ПолноеИмяОбъектаМетаданных);
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Ссылки", Ссылки);
	Запрос.Текст = ТекстЗапроса;

	Попытка
		Выборка = Запрос.Выполнить().Выбрать();
	Исключение
		
		// Удаление пробелов.
		Реквизиты = СтрЗаменить(Реквизиты, " ", "");
		// Преобразование параметра в массив полей.
		Реквизиты = СтрРазделить(Реквизиты, ",");
		
		// Поиск ошибки доступности полей.
		Результат = НайтиОшибкуДоступностиРеквизитовОбъекта(ПолноеИмяОбъектаМетаданных, Реквизиты);
		Если Результат.Ошибка Тогда 
			ВызватьИсключение ОбщегоНазначенияИСМПТККлиентСерверПереопределяемый.ПодставитьПараметрыВСтроку(НСтр("ru = 'Неверный второй параметр ""Реквизиты"": %1'"), Результат.ОписаниеОшибки);
		КонецЕсли;
		
		// Не удалось распознать ошибку, проброс первичной ошибки.
		ВызватьИсключение;
		
	КонецПопытки;
	
	Пока Выборка.Следующий() Цикл
		Результат = Новый Структура(Реквизиты);
		ЗаполнитьЗначенияСвойств(Результат, Выборка);
		ЗначенияРеквизитов[Выборка.Ссылка] = Результат;
	КонецЦикла;
	
	Возврат ЗначенияРеквизитов;
	
КонецФункции

// Значение реквизита, прочитанного из информационной базы по ссылке на объект.
//
// Если необходимо зачитать реквизит независимо от прав текущего пользователя,
// то следует использовать предварительный переход в привилегированный режим.
//
// Параметры:
//  Ссылка    - ЛюбаяСсылка - объект, значения реквизитов которого необходимо получить.
//            - Строка      - полное имя предопределенного элемента, значения реквизитов которого необходимо получить.
//  ИмяРеквизита       - Строка - имя получаемого реквизита.
//  ВыбратьРазрешенные - Булево - если Истина, то запрос к объекту выполняется с учетом прав пользователя, и в случае,
//                                    - если есть ограничение на уровне записей, то возвращается Неопределено;
//                                    - если нет прав для работы с таблицей, то возникнет исключение.
//                              - если Ложь, то возникнет исключение при отсутствии прав на таблицу
//                                или любой из реквизитов.
//
// Возвращаемое значение:
//  Произвольный - зависит от типа значения прочитанного реквизита.
//               - если в параметр Ссылка передана пустая ссылка, то возвращается Неопределено.
//               - если в параметр Ссылка передана ссылка несуществующего объекта (битая ссылка), 
//                 то возвращается Неопределено.
//
Функция ЗначениеРеквизитаОбъекта(Ссылка, ИмяРеквизита, ВыбратьРазрешенные = Ложь) Экспорт
	
	Если ПустаяСтрока(ИмяРеквизита) Тогда 
		ВызватьИсключение НСтр("ru = 'Неверный второй параметр ИмяРеквизита:'")
						  + Символы.ПС
						  + "- " + НСтр("ru = 'Имя реквизита должно быть заполнено.'");
	КонецЕсли;
	
	Результат = ЗначенияРеквизитовОбъекта(Ссылка, ИмяРеквизита, ВыбратьРазрешенные);
	Возврат Результат[СтрЗаменить(ИмяРеквизита, ".", "")];
	
КонецФункции

// Значения реквизита, прочитанного из информационной базы для нескольких объектов.
//
//  Если необходимо зачитать реквизит независимо от прав текущего пользователя,
//  то следует использовать предварительный переход в привилегированный режим.
//
// Параметры:
//  МассивСсылок       - Массив - массив ссылок на объекты одного типа.
//                                Значения массива должны быть ссылками на объекты одного типа.
//  ИмяРеквизита       - Строка - например, "Код".
//  ВыбратьРазрешенные - Булево - если Истина, то запрос к объектам выполняется с учетом прав пользователя, и в случае,
//                                    - если какой-либо объект будет исключен из выборки по правам, то этот объект
//                                      будет исключен и из результата;
//                              - если Ложь, то возникнет исключение при отсутствии прав на таблицу
//                                или любой из реквизитов.
//
// Возвращаемое значение:
//  Соответствие - Ключ - ссылка на объект, Значение - значение прочитанного реквизита.
//      * Ключ     - ссылка на объект, 
//      * Значение - значение прочитанного реквизита.
// 
Функция ЗначениеРеквизитаОбъектов(МассивСсылок, ИмяРеквизита, ВыбратьРазрешенные = Ложь) Экспорт
	
	Если ПустаяСтрока(ИмяРеквизита) Тогда 
		ВызватьИсключение НСтр("ru = 'Неверный второй параметр ИмяРеквизита:'")
						  + Символы.ПС
						  + "- " + НСтр("ru = 'Имя реквизита должно быть заполнено.'");
	КонецЕсли;
	
	ЗначенияРеквизитов = ЗначенияРеквизитовОбъектов(МассивСсылок, ИмяРеквизита, ВыбратьРазрешенные);
	Для каждого Элемент Из ЗначенияРеквизитов Цикл
		ЗначенияРеквизитов[Элемент.Ключ] = Элемент.Значение[ИмяРеквизита];
	КонецЦикла;
		
	Возврат ЗначенияРеквизитов;
	
КонецФункции

// Выполняет поиск проверяемых выражений среди реквизитов объекта метаданных.
// 
// Параметры:
//  ПолноеИмяОбъектаМетаданных - Строка - полное имя проверяемого объекта.
//  ПроверяемыеВыражения       - Массив - имена полей или проверяемые выражения объекта метаданных.
// 
// Возвращаемое значение:
//  Структура - Результат проверки.
//  * Ошибка         - Булево - Найдена ошибка.
//  * ОписаниеОшибки - Строка - Описание найденных ошибок.
//
// Пример:
//  
// Реквизиты = Новый Массив;
// Реквизиты.Добавить("Номер");
// Реквизиты.Добавить("Валюта.НаименованиеПолное");
//
// Результат = ОбщегоНазначения.НайтиОшибкуДоступностиРеквизитовОбъекта("Документ._ДемоЗаказПокупателя", Реквизиты);
//
// Если Результат.Ошибка Тогда
//     ВызватьИсключение Результат.ОписаниеОшибки;
// КонецЕсли;
//
Функция НайтиОшибкуДоступностиРеквизитовОбъекта(ПолноеИмяОбъектаМетаданных, ПроверяемыеВыражения) Экспорт
	
	МетаданныеОбъекта = Метаданные.НайтиПоПолномуИмени(ПолноеИмяОбъектаМетаданных);
	
	Если МетаданныеОбъекта = Неопределено Тогда 
		Возврат Новый Структура("Ошибка, ОписаниеОшибки", Истина, 
			ОбщегоНазначенияИСМПТККлиентСерверПереопределяемый.ПодставитьПараметрыВСтроку(НСтр("ru = 'Ошибка получения метаданных ""%1""'"), ПолноеИмяОбъектаМетаданных));
	КонецЕсли;

	// Разрешение вызова из безопасного режима внешней обработки или расширения.
	// Информация о доступности полей источника схемы при проверке метаданных не является секретной.
	УстановитьОтключениеБезопасногоРежима(Истина);
	УстановитьПривилегированныйРежим(Истина);
	
	Схема 	 = Новый СхемаЗапроса;
	Пакет 	 = Схема.ПакетЗапросов.Добавить(Тип("ЗапросВыбораСхемыЗапроса"));
	Оператор = Пакет.Операторы.Получить(0);
	
	Источник = Оператор.Источники.Добавить(ПолноеИмяОбъектаМетаданных, "Таблица");
	ТекстОшибки = "";
	
	Для Каждого ТекущееВыражение Из ПроверяемыеВыражения Цикл
		
		Если Не ПолеИсточникаСхемыЗапросаДоступно(Источник, ТекущееВыражение) Тогда 
			ТекстТекущейОшибки = "- " + НСтр("ru = 'Поле объекта ""%1"" не найдено'");
			ТекстТекущейОшибки = ОбщегоНазначенияИСМПТККлиентСерверПереопределяемый.ПодставитьПараметрыВСтроку(ТекстТекущейОшибки, ТекущееВыражение);
			ТекстОшибки = ТекстОшибки + Символы.ПС + ТекстТекущейОшибки;
		КонецЕсли;
		
	КонецЦикла;
		
	Возврат Новый Структура("Ошибка, ОписаниеОшибки", Не ПустаяСтрока(ТекстОшибки), ТекстОшибки);
	
КонецФункции

// Используется в НайтиОшибкуДоступностиРеквизитовОбъекта.
// Выполняет проверку доступности поля проверяемого выражения в источнике оператора схемы запроса.
//
Функция ПолеИсточникаСхемыЗапросаДоступно(ИсточникОператора, ПроверяемоеВыражение) Экспорт 
	
	ЧастиИмениПоля = СтрРазделить(ПроверяемоеВыражение, ".");
	ДоступныеПоля  = ИсточникОператора.Источник.ДоступныеПоля;
	
	ТекущаяЧастьИмениПоля = 0;
	Пока ТекущаяЧастьИмениПоля < ЧастиИмениПоля.Количество() Цикл 
		
		ТекущееПоле = ДоступныеПоля.Найти(ЧастиИмениПоля.Получить(ТекущаяЧастьИмениПоля)); 
		
		Если ТекущееПоле = Неопределено Тогда 
			Возврат Ложь;
		КонецЕсли;
		
		// Инкрементация следующей части имени поля и соответствующего списка доступности полей.
		ТекущаяЧастьИмениПоля = ТекущаяЧастьИмениПоля + 1;
		ДоступныеПоля 		  = ТекущееПоле.Поля;
		
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

Процедура ПриДобавленииОбработчиковОбновления(Обработчики) Экспорт

	// Обновление розничного контура маркировки (ЧекиККМ)
	РозничноеВыбытиеИСМПТКПереопределяемый.ПриДобавленииОбработчиковОбновления(Обработчики);
	// Обновление объектов сервиса 1С:Маркировка для Казахстана
	ИнтеграцияИСМПТКПереопределяемый.ПриДобавленииОбработчиковОбновления(Обработчики);
			
КонецПроцедуры

// Очищает документ или элемент справочника.
// Устанавливает значения реквизитов в значения по умолчанию, очищает табличные части.
//
// Параметры:
//  Объект - ДокументОбъект.<Имя>, СправочникОбъект.<Имя> - Объект, который необходимо очистить.
//  ИсключаемыеРеквизиты - Строка - Имена реквизитов, через запятую, которые не будут очищены.
//   Если параметр не задан, то будут очищены все реквизиты.
//  ИсключаемыеТабличныеЧасти - Строка - Имена табличных частей, через запятую, которые не будут очищены.
//   Если параметр не задан, то будут очищены все табличные части.
//                               
Процедура ОчиститьОбъект(Объект, ИсключаемыеРеквизиты = Неопределено, ИсключаемыеТабличныеЧасти = Неопределено) Экспорт
	
	// Создать МассивИсключаемыхРеквизитов.
	Если ИсключаемыеРеквизиты = Неопределено Тогда
		МассивИсключаемыхРеквизитов = Новый Массив;
	Иначе
		МассивИсключаемыхРеквизитов = ОбщегоНазначенияИСМПТККлиентСервер.МассивИмен(ИсключаемыеРеквизиты);	
	КонецЕсли;
	
	// Создать МассивИсключаемыхТабличныхЧастей.
	Если ИсключаемыеТабличныеЧасти = Неопределено Тогда
		МассивИсключаемыхТабличныхЧастей = Новый Массив;
	Иначе
		МассивИсключаемыхТабличныхЧастей = ОбщегоНазначенияИСМПТККлиентСервер.МассивИмен(ИсключаемыеТабличныеЧасти);	
	КонецЕсли;
	
	МетаданныеОбъекта = Объект.Метаданные();
	ПолноеИмяОбъекта = МетаданныеОбъекта.ПолноеИмя();	
	ИмяГруппыОбъекта = Лев(ПолноеИмяОбъекта, Найти(ПолноеИмяОбъекта, ".") - 1);
	
	Если ИмяГруппыОбъекта = "Справочник" Тогда
		ПустойОбъект =  Справочники[МетаданныеОбъекта.Имя].ПустаяСсылка();
	ИначеЕсли ИмяГруппыОбъекта = "Документ" Тогда
		ПустойОбъект =  Документы[МетаданныеОбъекта.Имя].ПустаяСсылка();
	КонецЕсли;
	
	Для Каждого Реквизит Из МетаданныеОбъекта.Реквизиты Цикл
		Если МассивИсключаемыхРеквизитов.Найти(Реквизит.Имя) = Неопределено Тогда
			Объект[Реквизит.Имя] = ПустойОбъект[Реквизит.Имя];
		КонецЕсли;
	КонецЦикла;
	
	Для Каждого ТабличнаяЧасть Из МетаданныеОбъекта.ТабличныеЧасти Цикл
		Если МассивИсключаемыхТабличныхЧастей.Найти(ТабличнаяЧасть.Имя) = Неопределено Тогда
			Объект[ТабличнаяЧасть.Имя].Очистить();	
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Формирует пакет запросов и возвращает результат каждого запроса
//
// Параметры:
//  Запрос				 - Запрос	 - запрос, параметры которого предварительно установлены.
//  ТекстыЗапроса		 - СписокЗначений	 - в списке перечислены тексты запросов и их имена.
//  ВыгрузитьРезультат	 - Булево			 - Истина, если результат запроса нужно выгрузить в таблицы значений.
// 
// Возвращаемое значение:
//  Структура - структура в которую помещены полученные таблицы
//
Функция ВыполнитьПакетЗапросов(Запрос, ТекстыЗапроса, ВыгрузитьРезультат = Ложь) Экспорт

	Таблицы = Новый Структура;
	
	МассивТекстаЗапроса = Новый Массив;
	
	// Формирование текст запроса.
	Для Каждого ТекстЗапроса из ТекстыЗапроса Цикл
		Если ЗначениеЗаполнено(ТекстЗапроса.Представление) Тогда
			МассивТекстаЗапроса.Добавить("// " + ТекстЗапроса.Представление);
		КонецЕсли;
		МассивТекстаЗапроса.Добавить(ТекстЗапроса.Значение);
		
		МассивТекстаЗапроса.Добавить(
		";
		|
		|////////////////////////////////////////////////////////////////////////////////
		|");
	КонецЦикла;
	
	Запрос.Текст = СтрСоединить(МассивТекстаЗапроса, Символы.ПС);
	
	// Выполнение запроса.
	Результат = Запрос.ВыполнитьПакет();

	КоличествоЗапросовВПакете = 0;
	
	// Помещение результатов запроса в таблицы
	Для Каждого ТекстЗапроса из ТекстыЗапроса Цикл
		
		Если СтрЧислоВхождений(ТекстЗапроса.Значение, ";") > 0 Тогда
			Подзапросы = ОбщегоНазначенияИСМПТККлиентСерверПереопределяемый.РазложитьСтрокуВМассивПодстрок(ТекстЗапроса.Значение, ";");
			КоличествоПодзапросов = Подзапросы.Количество();
			ИндексЗапросаРезультате = Неопределено;
			Для Индекс = -(КоличествоПодзапросов - 1) По 0 Цикл
				Если Найти(Подзапросы[-Индекс], "#РезультатЗапроса#") > 0 Тогда
					ИндексЗапросаРезультате = -Индекс;
					Прервать;
				КонецЕсли;
			КонецЦикла;
			Если ИндексЗапросаРезультате = Неопределено Тогда
				ИндексЗапросаРезультате = КоличествоПодзапросов - 1;
			КонецЕсли;
		Иначе
			КоличествоПодзапросов = 1;
			ИндексЗапросаРезультате = 0;
		КонецЕсли;
		
		Если ЗначениеЗаполнено(ТекстЗапроса.Представление) Тогда
			РезультатТаблица = Результат[КоличествоЗапросовВПакете + ИндексЗапросаРезультате];
			РезультатТаблица = ?(ВыгрузитьРезультат, РезультатТаблица.Выгрузить(), РезультатТаблица);
			Таблицы.Вставить(ТекстЗапроса.Представление, РезультатТаблица);
		КонецЕсли;
		
		КоличествоЗапросовВПакете = КоличествоЗапросовВПакете + КоличествоПодзапросов;
		
	КонецЦикла;
	
	Возврат Таблицы;
	
КонецФункции

// Определяет режим эксплуатации информационной базы файловый (Истина) или серверный (Ложь).
// При проверке используется СтрокаСоединенияИнформационнойБазы, которую можно указать явно.
//
// Параметры:
//  СтрокаСоединенияИнформационнойБазы - Строка - параметр используется, если
//                 нужно проверить строку соединения не текущей информационной базы.
//
// Возвращаемое значение:
//  Булево - Истина, если файловая.
//
Функция ИнформационнаяБазаФайловая(Знач СтрокаСоединенияИнформационнойБазы = "") Экспорт
	
	Если ПустаяСтрока(СтрокаСоединенияИнформационнойБазы) Тогда
		СтрокаСоединенияИнформационнойБазы =  СтрокаСоединенияИнформационнойБазы();
	КонецЕсли;
	Возврат СтрНайти(ВРег(СтрокаСоединенияИнформационнойБазы), "FILE=") = 1;
	
КонецФункции 

// Создает массив и копирует в него значения, содержащиеся в колонке объекта, для
// которого доступен обход посредством оператора Для каждого … Из.
//
// Параметры:
//  КоллекцияСтрок           - ТаблицаЗначений
//                           - ДеревоЗначений
//                           - СписокЗначений
//                           - ТабличнаяЧасть
//                           - Соответствие
//                           - Структура - коллекция, колонку которой нужно выгрузить в массив.
//                                         А так же другие объекты, для которых доступен обход
//                                         посредством оператора Для каждого … Из … Цикл.
//  ИмяКолонки               - Строка - имя поля коллекции, значения которого нужно выгрузить.
//  ТолькоУникальныеЗначения - Булево - если Истина, то в массив будут включены
//                                      только различающиеся значения.
//
// Возвращаемое значение:
//  Массив - значения колонки.
//
Функция ВыгрузитьКолонку(КоллекцияСтрок, ИмяКолонки, ТолькоУникальныеЗначения = Ложь) Экспорт

	МассивЗначений = Новый Массив;
	
	УникальныеЗначения = Новый Соответствие;
	
	Для каждого СтрокаКоллекции Из КоллекцияСтрок Цикл
		Значение = СтрокаКоллекции[ИмяКолонки];
		Если ТолькоУникальныеЗначения И УникальныеЗначения[Значение] <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
		МассивЗначений.Добавить(Значение);
		УникальныеЗначения.Вставить(Значение, Истина);
	КонецЦикла; 
	
	Возврат МассивЗначений;
	
КонецФункции

// Находит среди элементов полей СКД поле по полному имени
//
// Параметры:
//	Элементы - КоллекцияПолейГруппировкиКомпоновкиДанных - поля СКД
//	ПолноеИмя - Строка - полное имя поля СКД.
//
// Возвращаемое значение:
//	ПолеКомпоновкиДанных - поле СКД.
//
Функция НайтиПолеСКДПоПолномуИмени(Элементы, ПолноеИмя) Экспорт

	масЧастейИмен = ИзПолногоИмениПоляПолучитьЧасти(ПолноеИмя);
	колЧастей = масЧастейИмен.Количество();
	
	текИмя = масЧастейИмен[0];
	Поле = НайтиПолеСКДПоИмени(Элементы, текИмя);
	Если Поле = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Для Сч = 2 По колЧастей Цикл
		текИмя = текИмя +"." + масЧастейИмен[Сч-1];
		Поле = НайтиПолеСКДПоИмени(Поле.Элементы, текИмя);
		Если Поле = Неопределено Тогда
			Возврат Неопределено;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Поле;

КонецФункции

// Получает полное имя поля по частям
//
// Параметры:
//	ПолноеИмя - полное имя поля СКД.
//
// Возвращаемое значение:
//	масЧастей - массив, содержащий части полного имени.
//
Функция ИзПолногоИмениПоляПолучитьЧасти(ПолноеИмя)

	масЧастей = Новый Массив;
	СтрИмя = ПолноеИмя;
	
	Пока Не ПустаяСтрока(СтрИмя) Цикл
		Если Лев(СтрИмя, 1) = "[" Тогда
			
			Поз = СтрНайти(СтрИмя, "]");
			Если Поз = 0 Тогда
				масЧастей.Добавить(Сред(СтрИмя, 2));
				СтрИмя = "";
			Иначе
				масЧастей.Добавить(Сред(СтрИмя, 1, Поз));
				СтрИмя = Сред(СтрИмя, Поз + 2);
			КонецЕсли;
			
		Иначе
			
			Поз = СтрНайти(СтрИмя, ".");
			Если Поз = 0 Тогда
				масЧастей.Добавить(СтрИмя);
				СтрИмя = "";
			Иначе
				масЧастей.Добавить(Лев(СтрИмя, Поз - 1));
				СтрИмя = Сред(СтрИмя, Поз + 1);
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Возврат масЧастей;

КонецФункции

// Находит среди элементов полей СКД поле по имени.
//
// Параметры:
//	Элементы - поля СКД
//	Имя - Строка - имя поля СКД
//
// Возвращаемое значение:
//	ПолеКомпоновкиДанных - поле СКД.
//
Функция НайтиПолеСКДПоИмени(Элементы, Имя)
	
	Для Каждого Элемент Из Элементы Цикл
		Если ВРЕГ(Строка(Элемент.Поле)) = ВРЕГ(Имя) Тогда
			Возврат Элемент;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Неопределено;
	
КонецФункции

Функция ПолучитьПредставлениеТипаДокумента(ТипДокумента) Экспорт

	Если ТипДокумента = ПредопределенноеЗначение("Перечисление.ВидыДокументаИСМПТК.Исправленный") Тогда
		Возврат Метаданные.Перечисления.ВидыДокументаИСМПТК.ЗначенияПеречисления.Исправленный.Представление();
	Иначе
		Возврат Метаданные.Перечисления.ВидыДокументаИСМПТК.ЗначенияПеречисления.Исходный.Представление();
	КонецЕсли;
	
КонецФункции

#КонецОбласти

#Область РаботаСЧасовымиПоясами

Функция ДатаИзСтрокиUNIX(Значение, Делитель = 1000, ПриводитьКМестномуВремени = Истина) Экспорт
	
	Значение = '19700101' + Цел(Значение / Делитель);
	
	Если ПриводитьКМестномуВремени Тогда
		Возврат МестноеВремя(Значение);
	Иначе
		Возврат Значение;
	КонецЕсли;
	
КонецФункции

#КонецОбласти
