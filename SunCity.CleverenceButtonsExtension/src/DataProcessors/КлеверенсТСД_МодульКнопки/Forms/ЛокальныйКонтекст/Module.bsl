///////////////////////////////////////////////////////////////////////////////
// Служебные процедуры и функции локального контекста:
// - для инициализации подключения к базе Mobile Smarts;
// - для инициализации чтения и записи данных в базе Mobile Smarts;
// - для инициализации чтения и записи данных в базе 1С;
// - для вызова служебных процедур и функций глобального контекста;
// - прочее.
///////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////
//Все модули Управляемых и Обычных форм обработки одинаковы и совместимы.
//Для копирования модуля Управляемой формы в модуль Обычной формы, нужно
//быстрой заменой закомментировать директивы "&НаКлиенте" и "//&НаСервере".
//Для копирования модуля Обычной формы в модуль Управляемой формы, нужно 
//быстрой заменой раскомментировать директивы "&НаКлиенте" и "//&НаСервере".

&НаСервере
Перем ИнтеграционнаяОбработка Экспорт; 

&НаКлиенте
Перем ФормаИнтеграционнойОбработки Экспорт; 

&НаКлиенте
Перем РасположениеКомпоненты Экспорт,
	ДанныеТекущегоУзла Экспорт,
	КатегорииНастроекMS Экспорт,
	НастройкиИнициализированы Экспорт,
	ПараметрыПодключенияMS Экспорт,
	СтруктураМетаданных Экспорт,
	COMЧастнойБазыMS Экспорт,
	COMВременнойБазыMS Экспорт,
	COMБазыMS Экспорт,
	ТекущиеНастройкиMS Экспорт,
	ПутьКОбработке Экспорт,
	КОМсоздан Экспорт,
	ПраваПользователя Экспорт,
	СоотвСимволов,
	КэшЗначенийПолученныхПоID Экспорт,
	ПередаваемыеВОбработчикОжиданияПараметры Экспорт,
	КэшТаймаутов;

	
#Область ОбработчикиСобытийФОрмы

&НаСервере
Процедура ПриСозданииНаСервере(Отказ, СтандартнаяОбработка)
	
	#Если НЕ ТолстыйКлиентОбычноеПриложение Тогда
		
		РеквизитОбъект 			= РеквизитФормыВЗначение("Объект");
		ПолноеИмяОбъекта 		= РеквизитОбъект.Метаданные().ПолноеИмя();
		ИспользуемоеИмяФайла 	= ?(ЛокЯдро_ЭтоВнешняяОбработка(), РеквизитОбъект.ИспользуемоеИмяФайла, "");
		ИмяОбъекта 				= РеквизитОбъект.Метаданные().Имя;
		
	#КонецЕсли
	
КонецПроцедуры

#КонецОбласти

#Область ЛокальныйКонтекст

#Область ЛокальныйКонтекст_Настройки

#Область ЛокальныйКонтекст_Настройки_Инициализация

// Собирает необходимые настройки в структуры и помещает в глобальные переменные для быстрого доступа. 
// Вызывается при запуске обработки в интерактивном режиме или при изменении подключения к базе MS
// 
// Параметры:
// 	пПараметрыПодключенияMS - Структура, Неопределено - структура с параметрами для подключения, в случае если подключаемся к новой базе, не из сохранённых настроек
//	ОписаниеОповещенияРодительскойФормы - ОписаниеОповещения - описание оповещения в методом, который будет выполнен после инициализации (нужен для фон заданий)
&НаКлиенте
Процедура ЛокЯдро_Инициализация(пПараметрыПодключенияMS = Неопределено, ОписаниеОповещенияРодительскойФормы = Неопределено) Экспорт
	
	НачалоСобытия = ТекущаяУниверсальнаяДатаВМиллисекундах();
	
	РасположениеКомпоненты = ЛокЯдро_ПолучитьДанныеИзХранилища1С("Cleverence_РасположениеКомпоненты");
	Если пПараметрыПодключенияMS = Неопределено Тогда
		ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации("ЛокЯдро_АктуализацияСтруктурыПараметровПодключенияSMARTS", "Информация", "Начало", НачалоСобытия);
		ПараметрыПодключенияMS = ЛокЯдро_ПолучитьДанныеИзХранилища1С("Cleverence_ПараметрыПодключенияMS");
		ПараметрыПодключенияMS = ЛокЯдро_АктуализацияСтруктурыПараметровПодключенияSMARTS(ПараметрыПодключенияMS);
		ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации("ЛокЯдро_АктуализацияСтруктурыПараметровПодключенияSMARTS", "Информация", "Конец", НачалоСобытия);
	Иначе
		ПараметрыПодключенияMS = пПараметрыПодключенияMS;
	КонецЕсли;
	
	Если ПараметрыПодключенияMS <> Неопределено Тогда
		КомЯдро_СохранитьЗначениеПеременной("ПараметрыПодключенияMS",ПараметрыПодключенияMS);	
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(РасположениеКомпоненты) Тогда
		РасположениеКомпоненты = "НаСервере";
	КонецЕсли;
	
	Если РасположениеКомпоненты = "НаСервере" Тогда		
		ЛокЯдро_ИнициализацияКомпонентаНаСервере(ОписаниеОповещенияРодительскойФормы);	
	Иначе
		ТипИнтерфейса = ЛокЯдро_ПолучитьДанныеИзХранилища1С("Cleverence_ТипИнтерфейса");
		
		КатегорииНастроекMS = ЛокЯдро_ПолучитьКатегорииНастроекMS();
		
		КомЯдро_СохранитьЗначениеПеременной("КатегорииНастроекMS", КатегорииНастроекMS);
		
		ЛокЯдро_ПроверитьАктуальностьКэшируемыхНастроекПриИнициализации();
		
		// Структура для получения настроек, достаточных для определения узла
		СтруктураНачальныхНастроек = Новый Структура;
		СтруктураНачальныхНастроек.Вставить("Узлы", Ложь);
		
		ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации("ЛокЯдро_ПолучитьНастройкиНаСервереSMARTS", "Информация", "Начало", НачалоСобытия);
		СтруктураНачальныхНастроек = ЛокЯдро_ПолучитьНастройкиНаСервереSMARTS(СтруктураНачальныхНастроек);
		ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации("ЛокЯдро_ПолучитьНастройкиНаСервереSMARTS", "Информация", "Конец", НачалоСобытия);
		
		ДанныеТекущегоУзла = Новый Структура;
		ДанныеТекущегоУзла.Вставить("ID_Узла", 			"");
		ДанныеТекущегоУзла.Вставить("Наименование", 	"");
		ДанныеТекущегоУзла.Вставить("ЧастнаяБазаMS", 	"");
				
		// Текущий узел		
		ID_ТекущегоУзла = ЛокЯдро_ПолучитьДанныеИзХранилища1С("Cleverence_ID_ТекущегоУзла_"+ПараметрыПодключенияMS.Ид);
		Если Не ЗначениеЗаполнено(ID_ТекущегоУзла) Тогда
			ID_ТекущегоУзла = "";	
		КонецЕсли;		

		ДанныеУзла = Неопределено;
		Если ID_ТекущегоУзла <> "" И ТипЗнч(СтруктураНачальныхНастроек.Узлы) = Тип("Массив") Тогда
			
			ДанныеУзла = НайтиСтруктуруВМассивеПоЭлементу(СтруктураНачальныхНастроек.Узлы, "ID_Узла", ID_ТекущегоУзла);
			Если ДанныеУзла <> Неопределено Тогда
				ID_ТекущегоУзла = ДанныеУзла.ID_Узла;
				ДанныеТекущегоУзла.Вставить("ID_Узла", 		ID_ТекущегоУзла);
				ДанныеТекущегоУзла.Вставить("Наименование", ДанныеУзла.Наименование);
				Если ДанныеУзла.ИспользоватьЧастнуюБазу Тогда
					ДанныеТекущегоУзла.Вставить("ЧастнаяБазаMS", ДанныеУзла.ЧастнаяБазаMS);					
				КонецЕсли;
			КонецЕсли;
			
		КонецЕсли;
		
		СтруктураНастроек = ЛокЯдро_ПолучитьПустуюСтруктуруНастроекSMARTS(КатегорииНастроекMS.СериализуемыеНастройки);
		
		ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации("ЛокЯдро_ПолучитьНастройкиНаСервереSMARTS", "Информация", "Начало, ID_Узла = " + СокрЛП(ID_ТекущегоУзла), НачалоСобытия);
		СтруктураНастроек = ЛокЯдро_ПолучитьНастройкиНаСервереSMARTS(СтруктураНастроек, ID_ТекущегоУзла);
		ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации("ЛокЯдро_ПолучитьНастройкиНаСервереSMARTS", "Информация", "Конец, ID_Узла = " + СокрЛП(ID_ТекущегоУзла), НачалоСобытия);
		
		ДанныеДляИнициализации = ЛокЯдро_ПолучитьДанныеДляИнициализации(Ложь);
		
		// Настройки
		ДанныеДляИнициализации.Вставить("ТекущиеНастройкиMS", СтруктураНастроек);
		
		// Метаданные документов
		пСтруктураМетаданных = ЛокЯдро_ОбновитьМетаданныеДокументовMS();

		ДанныеДляИнициализации.СтруктураМетаданных.Вставить("ДокументыMS",?(пСтруктураМетаданных=Неопределено, Новый Структура(),пСтруктураМетаданных.ДокументыMS));
		ДанныеДляИнициализации.СтруктураМетаданных.Вставить("ПользователиMS",?(пСтруктураМетаданных=Неопределено, "",пСтруктураМетаданных.ПользователиMS));
		ДанныеДляИнициализации.СтруктураМетаданных.Вставить("УстройстваMS",?(пСтруктураМетаданных=Неопределено, "",пСтруктураМетаданных.УстройстваMS));
		ДанныеДляИнициализации.СтруктураМетаданных.Вставить("Tables",?(пСтруктураМетаданных=Неопределено, Новый СписокЗначений(),пСтруктураМетаданных.Tables));
		ДанныеДляИнициализации.СтруктураМетаданных.Вставить("UniПолейНоменклатуры",?(пСтруктураМетаданных=Неопределено, Новый Соответствие(),пСтруктураМетаданных.UniПолейНоменклатуры));		
		ДанныеДляИнициализации.СтруктураМетаданных.Вставить("ВыгружаемыеПоляНоменклатурыMS",?(пСтруктураМетаданных=Неопределено, Новый Структура, пСтруктураМетаданных.ВыгружаемыеПоляНоменклатурыMS));
		
		ДанныеДляИнициализации.Вставить("ДанныеТекущегоУзла", ДанныеТекущегоУзла);

		КомЯдро_СохранитьЗначениеПеременной("ТекущиеНастройкиMS",ДанныеДляИнициализации.ТекущиеНастройкиMS);
		КомЯдро_СохранитьЗначениеПеременной("СтруктураМетаданных",ДанныеДляИнициализации.СтруктураМетаданных);
		КомЯдро_СохранитьЗначениеПеременной("ДанныеТекущегоУзла",ДанныеДляИнициализации.ДанныеТекущегоУзла);
		КомЯдро_СохранитьЗначениеПеременной("НастройкиИнициализированы",Истина);
	
		ТекущиеНастройкиMS  = ДанныеДляИнициализации.ТекущиеНастройкиMS;
		СтруктураМетаданных = ДанныеДляИнициализации.СтруктураМетаданных;
		ДанныеТекущегоУзла  = ДанныеДляИнициализации.ДанныеТекущегоУзла;
		ПраваПользователя = ДанныеДляИнициализации.ПраваПользователя;
		
		НастройкиИнициализированы = Истина;
		
		ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации("ЛокЯдро_ПроверитьИспользованиеНовойСтруктурыНастроекБизнесПроцессов", "Информация", "Начало", НачалоСобытия);
		// Проверяем текущие настройки по-умолчанию (нового формата они, или нет) и сохраняем результат в переменную 
		КомЯдро_СохранитьЗначениеПеременной(
			"НовыеНастройкиБизнесПроцессов", 
			ЛокЯдро_ПроверитьИспользованиеНовойСтруктурыНастроекБизнесПроцессов());
		ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации("ЛокЯдро_ПроверитьИспользованиеНовойСтруктурыНастроекБизнесПроцессов", "Информация", "Конец", НачалоСобытия);
		
		ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации("РеструктуризацияНастроек", "Информация", "Начало", НачалоСобытия);

		//Реструктуризация настроек - Начало
		ВерсияНастроек_ПоУмолчанию 				= Ложь;
		НастройкиБизнесПроцессов_ПоУмолчанию 	= Ложь;
		Если ТипЗнч(СтруктураНастроек.НастройкиБизнесПроцессов_ПоУмолчанию) = Тип("Структура") Тогда
			Если СтруктураНастроек.НастройкиБизнесПроцессов_ПоУмолчанию.Свойство("ВерсияНастроек") Тогда
				ВерсияНастроек_ПоУмолчанию = СтруктураНастроек.НастройкиБизнесПроцессов_ПоУмолчанию.ВерсияНастроек;
			КонецЕсли;
			Если СтруктураНастроек.НастройкиБизнесПроцессов_ПоУмолчанию.Свойство("НастройкиБизнесПроцессов") Тогда
				НастройкиБизнесПроцессов_ПоУмолчанию = СтруктураНастроек.НастройкиБизнесПроцессов_ПоУмолчанию.НастройкиБизнесПроцессов;
			КонецЕсли;
		КонецЕсли;
		
		ЛокЯдро_ВыполнитьОбновлениеГлобальныхПараметров(СтруктураНастроек.ВерсияГлобальныеПараметры);

		пСтруктураНастроек = Новый Структура;
		пСтруктураНастроек.Вставить("ВерсияОбработкиНастроек", 		СтруктураНастроек.ВерсияОбработкиНастроек);
		пСтруктураНастроек.Вставить("ВерсияОбработкиКлеверенсТСД", 	СтруктураНастроек.ВерсияОбработкиКлеверенсТСД);
		пСтруктураНастроек.Вставить("ВерсияНастроек_ПоУмолчанию", 	ВерсияНастроек_ПоУмолчанию);
		пСтруктураНастроек.Вставить("НастройкиБизнесПроцессов",		НастройкиБизнесПроцессов_ПоУмолчанию);
		пСтруктураНастроек.Вставить("ВыполненоОбновлениеГлобальныхПараметров");

		СтруктураВызова = Новый Структура;
		СтруктураВызова.Вставить("ТипМетода", "Функция"); 
		СтруктураВызова.Вставить("ИмяМетода", "ВыполнитьОбновлениеСтруктурыНастроек");
		СтруктураВызова.Вставить("ПараметрыМетода", Новый Структура("пСтруктураНастроек", пСтруктураНастроек));
		
		СтруктураИзменений = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,,АдресаПеременных,2);
		
		Если ЛокЯдро_ПроверитьСохраненнуюСтрокуПодключения1С() = Ложь Тогда
			Если СтруктураИзменений.ИзменениеВНастройках = Неопределено Тогда
				СтруктураИзменений.ИзменениеВНастройках = Новый Структура;
			КонецЕсли;
			#Область СовместимыйКодFresh
			//Если ПараметрыПодключенияMS.Свойство("База1ССтрокаСоединенияКлиент") Тогда
			//	СтруктураИзменений.ИзменениеВНастройках.Вставить("ServiceHTTPAddress",ПараметрыПодключенияMS.База1ССтрокаСоединенияКлиент);
			//КонецЕсли;
			#КонецОбласти //СовместимыйКодFresh
			СтруктураИзменений.ИзменениеВНастройках.Вставить("База1СПодключенаДата",ТекущаяДата());
		КонецЕсли;
		
		Если ТипЗнч(СтруктураИзменений.ИзменениеВНастройках) = Тип("Структура")
			И СтруктураИзменений.ИзменениеВНастройках.Количество() > 0 Тогда
			ЛокЯдро_СохранитьНастройкиВБазеSMARTS(СтруктураИзменений.ИзменениеВНастройках,ID_ТекущегоУзла);
		КонецЕсли;
		ЛокЯдро_ЗаписатьВКэшНастройкиSMARTS(СтруктураИзменений.ИзмененияВКэше);
		//Реструктуризация настроек - Конец
		
		ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации("РеструктуризацияНастроек", "Информация", "Конец", НачалоСобытия);
		
		ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации("ЛокЯдро_ОбъединитьПроизвольныеКоды", "Информация", "Начало", НачалоСобытия);
		ЛокЯдро_ОбъединитьПроизвольныеКоды(); //Временная заплатка на случай если произвольные коды лежат в 4-х ключах
		ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации("ЛокЯдро_ОбъединитьПроизвольныеКоды", "Информация", "Конец", НачалоСобытия);
		
		ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации("ЛокЯдро_СобратьОбщуюСтруктуруБизнесПроцессов", "Информация", "Начало", НачалоСобытия);
		ЛокЯдро_ПроверитьОбновлениеТиповыхБизнесПроцессов(СтруктураНастроек);
		ЛокЯдро_СобратьОбщуюСтруктуруБизнесПроцессов(ID_ТекущегоУзла);
		ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации("ЛокЯдро_СобратьОбщуюСтруктуруБизнесПроцессов", "Информация", "Конец", НачалоСобытия);
		
		ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации("ЛокЯдро_СобратьОбщуюСтруктуруПроизвольныхКодов", "Информация", "Начало", НачалоСобытия);
		ЛокЯдро_СобратьОбщуюСтруктуруПроизвольныхКодов();
		ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации("ЛокЯдро_СобратьОбщуюСтруктуруПроизвольныхКодов", "Информация", "Конец", НачалоСобытия);
		
		ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации("ЛокЯдро_СобратьОбщуюСтруктуруГлобальныхПараметров", "Информация", "Начало", НачалоСобытия);
		ЛокЯдро_СобратьОбщуюСтруктуруГлобальныхПараметров();
		ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации("ЛокЯдро_СобратьОбщуюСтруктуруГлобальныхПараметров", "Информация", "Конец", НачалоСобытия);

		ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации("ЛокЯдро_ПроверитьНастройкиТаймаутов", "Информация", "Начало", НачалоСобытия);
		ЛокЯдро_ПроверитьНастройкиТаймаутов();
		ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации("ЛокЯдро_ПроверитьНастройкиТаймаутов", "Информация", "Конец", НачалоСобытия);
		
		// Перенесено в условие расположение компоненты = НаКлиенте, т.к. при серверной инициализации выполняется аналогичный метод
		ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации("ЛокЯдро_УстановитьДанныеТекущегоУзла", "Информация", "Начало", НачалоСобытия);
		ЛокЯдро_УстановитьДанныеТекущегоУзла(ДанныеТекущегоУзла.ID_Узла);	
		ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации("ЛокЯдро_УстановитьДанныеТекущегоУзла", "Информация", "Конец", НачалоСобытия);
		
		Оповестить("УстановленыНастройкиПодключения",,ЭтаФорма);	
		СтруктураСменыСтатуса = Новый Структура("Статус, Параметр, Операция", 
			"БезОшибок", 
			"", 
			"ПодключениеКБазеSMARTS");
		Оповестить("СменаСтатуса", СтруктураСменыСтатуса);

	КонецЕсли;
			
КонецПроцедуры              

// Вызывает метод из модуля обработки для получения структур настроек при выполнении инициализации
// 
// Параметры:
// 	ЗаполнятьДанные - Булево - флаг, указывающий, нужно ли получить и заполнить значения глобальных переменных на стороне сервера в модуле обработки.
//							   Если Истина, то значения будут получены и заполнены на стороне модуля обработки
//	ВыполнятьВФоне - Булево - признак необходимо получения данных инициализации в фоне
//	ОписаниеОповещенияРодительскойФормы - ОписаниеОповещения - описания оповещения метода родительской формы, который необходимо выполнить после инициализации
// 		  
// Возвращаемое значение:
// 	Структура - ДанныеДляИнициализации  
&НаКлиенте
Функция ЛокЯдро_ПолучитьДанныеДляИнициализации(ЗаполнятьДанные = Истина, ВыполнятьВФоне = Ложь, ОписаниеОповещенияРодительскойФормы = Неопределено)
	
	ПараметрыМетода = Новый Структура("ЗаполнятьДанные", ЗаполнятьДанные);
	
	Если Не ВыполнятьВФоне Тогда
		СтруктураВызова = Новый Структура;
		СтруктураВызова.Вставить("ТипМетода", "Функция");
		СтруктураВызова.Вставить("ИмяМетода", "ПолучитьДанныеДляИнициализации");
		СтруктураВызова.Вставить("ПараметрыМетода", ПараметрыМетода);
		
		Возврат Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,,АдресаПеременных);	
	Иначе
				
		ПараметрыМетода.Вставить("АдресаПеременных", АдресаПеременных);

		ПараметрыФЗ = Новый Структура;
		ПараметрыФЗ.Вставить("ИмяМетода", 		"ГлЯдро_ПолучитьДанныеДляИнициализацииВФоне");
		ПараметрыФЗ.Вставить("ПараметрыМетода", ПараметрыМетода);		
		ПараметрыФЗ.Вставить("НаименованиеФЗ",	"Получение данных для инициализации на сервере");
		ПараметрыФЗ.Вставить("ТекстСообщения", 	"Получение данных для инициализации");
		
		ДопПараметры = Новый Структура;
		ДопПараметры.Вставить("ОписаниеОповещенияРодительскойФормы", ОписаниеОповещенияРодительскойФормы);
		
		ОписаниеОповещенияЗавершенияФЗ 	= Новый ОписаниеОповещения("ЛокЯдро_ПолучитьДанныеДляИнициализацииВФонеЗавершение", ЭтаФорма, ДопПараметры);
		ОписаниеОповещенияОшибкиФЗ 		= Новый ОписаниеОповещения("ЛокЯдро_ОбработатьОшибкиПолученияДанныхДляИнициализацииВФоне", ЭтаФорма);

		ЛокЯдро_НачатьВыполнениеФоновогоЗадания(ПараметрыФЗ, ОписаниеОповещенияЗавершенияФЗ, ОписаниеОповещенияОшибкиФЗ);
	КонецЕсли;
	
КонецФункции

&НаКлиенте
Функция ЛокЯдро_ПолучитьКатегорииНастроекMS() Экспорт

	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода", "Функция");
	СтруктураВызова.Вставить("ИмяМетода", "ПолучитьКатегорииНастроекMS");
		
	Возврат Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова);
	
КонецФункции

&НаКлиенте
Функция ЛокЯдро_ПолучитьПустуюСтруктуруНастроекSMARTS(СериализуемыеНастройки) Экспорт
	
    СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода", 		"Функция");
	СтруктураВызова.Вставить("ИмяМетода", 		"ПолучитьПустуюСтруктуруНастроекSMARTS");
	СтруктураВызова.Вставить("ПараметрыМетода", Новый Структура("СериализуемыеНастройки", СериализуемыеНастройки));
	
	Возврат Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова);
	
КонецФункции

// Получает структуру с данными узла из массива со списком узлов и сохраняет ее в кэш
// 
// Параметры:
// 	ID_Узла - Строка - Идентификатор узла
&НаКлиенте
Процедура ЛокЯдро_УстановитьДанныеТекущегоУзла(ID_Узла = "") Экспорт
	
	ДанныеУзла = Неопределено;
	ВсеУзлы = ЛокЯдро_ПолучитьИзКэшаНастройкуSMARTS("Узлы");
	Если ТипЗнч(ВсеУзлы) = Тип("Массив") Тогда
		ДанныеУзла = НайтиСтруктуруВМассивеПоЭлементу(ВсеУзлы,"ID_Узла",ID_Узла);
	КонецЕсли;
		
	Если ТипЗнч(ДанныеУзла) = Тип("Структура") Тогда
		ДанныеТекущегоУзла.Вставить("ID_Узла",       ДанныеУзла.ID_Узла);
		ДанныеТекущегоУзла.Вставить("Наименование",  ДанныеУзла.Наименование);
		ДанныеТекущегоУзла.Вставить("ЧастнаяБазаMS", ДанныеУзла.ЧастнаяБазаMS);
		ЕстьЧастнаяБаза = ДанныеУзла.ИспользоватьЧастнуюБазу;
		Если ТипЗнч(ДанныеУзла.ЧастнаяБазаMS) = Тип("Структура")
			И ЕстьЧастнаяБаза = Истина Тогда
			// И РасположениеКомпоненты = "НаКлиенте" Тогда
			ОП = Новый ОписаниеОповещения("ЛокЯдро_ИнициализацияПодключениеЧастнойБазыЗавершение",ЭтаФорма,Новый Структура("ЧастнаяБазаMS",ДанныеУзла.ЧастнаяБазаMS));					
			ЛокЯдро_ПроверитьСоединениеССерверомSMARTS(ДанныеУзла.ЧастнаяБазаMS,Ложь,"Частная",?(ДанныеУзла.Свойство("РасположениеКомпонентыЧБ"),ДанныеУзла.РасположениеКомпонентыЧБ,Неопределено),Истина,Истина,ОП)
		КонецЕсли;
	Иначе
		ДанныеТекущегоУзла.Вставить("ID_Узла",       "");
		ДанныеТекущегоУзла.Вставить("Наименование",  "");
		ДанныеТекущегоУзла.Вставить("ЧастнаяБазаMS", "");
		ЕстьЧастнаяБаза = Ложь;
	КонецЕсли;
		
	ЛокЯдро_СохранитьДанныеВХранилище1С("Cleverence_ID_ТекущегоУзла_"+ПараметрыПодключенияMS.Ид, ДанныеТекущегоУзла.ID_Узла);
	
	// закачиваем в кэш узловые настройки
	СтруктураНастроек = Новый Структура;
	Для Каждого ИмяНастройки Из КатегорииНастроекMS.УзловыеНастройки Цикл
		СтруктураНастроек.Вставить(ИмяНастройки, Ложь);
	КонецЦикла;
	СтруктураНастроек = ЛокЯдро_ПолучитьНастройкиНаСервереSMARTS(СтруктураНастроек, ID_Узла);
	
	КомЯдро_СохранитьЗначениеПеременной("ДанныеТекущегоУзла",ДанныеТекущегоУзла);
	ЛокЯдро_ЗаписатьВКэшНастройкиSMARTS(СтруктураНастроек);
	
	// Дублируем ID_ТекущегоУзла в кэш глобального контекста, т.к. он будет использоваться при получении некоторых настроек
	//СтруктураВызова = Новый Структура;
	//СтруктураВызова.Вставить("ТипМетода", "Процедура");
	//СтруктураВызова.Вставить("ИмяМетода", "ЗаписатьВКэшНастройкуSMARTS");
	//СтруктураВызова.Вставить("ПараметрыМетода", Новый Структура("КлючНастройки, ЗначениеНастройки", "ID_ТекущегоУзла", ДанныеТекущегоУзла.ID_Узла));
	//Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,, АдресаПеременных);
	
КонецПроцедуры

// Подключает интеграционную обработку по указанному в настройках пути к файлу. 
// Если расположение компоненты "НаКлиенте", то полученный файл обработки методом "НачатьПомещениеФайла" передается на сервер 
// 
// Параметры:
// 	РасположениеКомпоненты - Строка - указывается сторона, где установлена компонента для работы с базой Mobile SMARTS
// 	ПараметрыОбработки - Структура - cодержит:
//		* ИмяИнтеграционнойОбработки - Строка
//		* ПутьИнтеграционнойОбработки - Строка
// 
// Возвращаемое значение:
// 	Булево, Строка - описание ошибки или Истина в случае успешного подключения
&НаКлиенте
Функция ЛокЯдро_ПодключитьИнтеграционнуюОбработку(РасположениеКомпоненты = "НаСервере", ПараметрыОбработки = Неопределено) Экспорт
	
	Если ЭтоАдресВременногоХранилища(_ИнтеграционнаяОбработкаАдрес) Тогда
		УдалитьИзВременногоХранилища(_ИнтеграционнаяОбработкаАдрес);
		_ИнтеграционнаяОбработкаАдрес = Неопределено;
	КонецЕсли;
	
	Если ПараметрыПодключенияMS = Неопределено Тогда
		ПараметрыПодключенияMS   = ЛокЯдро_ПолучитьДанныеИзХранилища1С("Cleverence_ПараметрыПодключенияMS");	
	КонецЕсли;
	
	РабочийКаталог = ПараметрыПодключенияMS.РабочийКаталог;
	Если ПараметрыОбработки = Неопределено Тогда
		ИмяИнтеграционнойОбработки 	= ПараметрыПодключенияMS.ИмяИнтеграционнойОбработки;
		ПутьИнтеграционнойОбработки = ПараметрыПодключенияMS.ПутьИнтеграционнойОбработки;
		ТипОбработки				= ?(НЕ ПараметрыПодключенияMS.Свойство("ТипОбработки") ИЛИ НЕ ЗначениеЗаполнено(ПараметрыПодключенияMS.ТипОбработки),
			"ФайлНаДиске",
			ПараметрыПодключенияMS.ТипОбработки);
	Иначе
		ПараметрыОбработки.Вставить("РабочийКаталог", РабочийКаталог);
		ИмяИнтеграционнойОбработки 	= ПараметрыОбработки.ИмяИнтеграционнойОбработки;
		ПутьИнтеграционнойОбработки = ПараметрыОбработки.ПутьИнтеграционнойОбработки;
		ТипОбработки				= ПараметрыОбработки.ТипОбработки;
	КонецЕсли;
	
	ПутьОсновнойОбработки = "";
	#Если НЕ ТолстыйКлиентОбычноеПриложение Тогда
		ПутьОсновнойОбработки = ИспользуемоеИмяФайла;	
	#КонецЕсли
	
	мАдресХранилища 							= Неопределено;
	ПолныйПутьКИнтеграционнойОбработке 			= "";
	ЗагрузитьИнтеграционнуюОбработкуВСправочник = Ложь;
	
	Если ТипОбработки = "ФайлНаДиске" Тогда
		
		#Область НесовместимыйКодFresh
		Если ЗначениеЗаполнено(РабочийКаталог)
			ИЛИ ЗначениеЗаполнено(ПутьОсновнойОбработки) Тогда 
			// Сначала пробуем подцепить обработку по адресу Путь+Имя, если там её нет, берем РабочийКаталог+Путь+Имя
			ПолныйПутьКИнтеграционнойОбработке = Строка(ПутьИнтеграционнойОбработки)
				+ Строка(ИмяИнтеграционнойОбработки);

			ФайлИнтеграционнойОбработки = Новый Файл(ПолныйПутьКИнтеграционнойОбработке);
			Если НЕ ФайлИнтеграционнойОбработки.Существует()
				ИЛИ ФайлИнтеграционнойОбработки.Расширение <> ".epf" Тогда
				Если ЗначениеЗаполнено(РабочийКаталог) Тогда
					ПолныйПутьКИнтеграционнойОбработке = Строка(РабочийКаталог)
						+ Строка(ПутьИнтеграционнойОбработки)
						+ Строка(ИмяИнтеграционнойОбработки);
					ФайлИнтеграционнойОбработки = Новый Файл(ПолныйПутьКИнтеграционнойОбработке);
				КонецЕсли;
			КонецЕсли;

			// Если файл интеграционной обработки не найден, пробуем подключить
			// её по относительному пути из каталога основной обработки
			Если ЗначениеЗаполнено(ПутьОсновнойОбработки) Тогда
				Если НЕ ЗначениеЗаполнено(РабочийКаталог)
					ИЛИ НЕ ФайлИнтеграционнойОбработки.Существует()
					ИЛИ ФайлИнтеграционнойОбработки.Расширение <> ".epf" Тогда
					ПутьИнтеграционнойОбработки = ЛокЯдро_ПолучитьПутьИнтеграционнойОбработки(ПутьОсновнойОбработки);
					Если НЕ ПустаяСтрока(ПутьИнтеграционнойОбработки) Тогда
						ЗагрузитьИнтеграционнуюОбработкуВСправочник = Истина;
						ПолныйПутьКИнтеграционнойОбработке = ПутьИнтеграционнойОбработки
							+ Строка(ИмяИнтеграционнойОбработки);
						ФайлИнтеграционнойОбработки = Новый Файл(ПолныйПутьКИнтеграционнойОбработке);
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
			
			Если НЕ ФайлИнтеграционнойОбработки.Существует()
					ИЛИ ФайлИнтеграционнойОбработки.Расширение <> ".epf" Тогда
				Возврат "Файл интеграционной обработки по пути """
					+ Строка(ПутьИнтеграционнойОбработки)
					+ Строка(ИмяИнтеграционнойОбработки) + """ не найден.";
			КонецЕсли;
			
			пАдрес = ПоместитьВоВременноеХранилище(Новый ДвоичныеДанные(ПолныйПутьКИнтеграционнойОбработке), Новый УникальныйИдентификатор());
			
			ПараметрыМетода = Новый Структура;
			ПараметрыМетода.Вставить("мАдресХранилища",			мАдресХранилища);
			ПараметрыМетода.Вставить("ПутьКФайлу",				ПолныйПутьКИнтеграционнойОбработке);
			ПараметрыМетода.Вставить("ПараметрыПодключенияMS",	ПараметрыПодключенияMS);
			ПараметрыМетода.Вставить("ТипОбработки", 			ТипОбработки);
			ПараметрыМетода.Вставить("мАдресХранилища",			пАдрес);
			ПараметрыМетода.Вставить("ЗагрузитьИнтеграционнуюОбработкуВСправочник", ЗагрузитьИнтеграционнуюОбработкуВСправочник);
			ЛокЯдро_ПодключитьИнтеграционнуюОбработкуСервер(Истина, Ложь,, ПараметрыМетода);
		Иначе
			ПараметрыМетода = Новый Структура;
			ПараметрыМетода.Вставить("мАдресХранилища",			мАдресХранилища);
			ПараметрыМетода.Вставить("ПутьКФайлу",				ПолныйПутьКИнтеграционнойОбработке);
			ПараметрыМетода.Вставить("ПараметрыПодключенияMS", 	?(ПараметрыОбработки = Неопределено, ПараметрыПодключенияMS, ПараметрыОбработки));
			ПараметрыМетода.Вставить("ТипОбработки", 			ТипОбработки);
			ЛокЯдро_ПодключитьИнтеграционнуюОбработкуСервер(Истина, Ложь,, ПараметрыМетода);
		КонецЕсли;
		#КонецОбласти //НесовместимыйКодFresh
	ИначеЕсли ТипОбработки = "СправочникСсылка" ИЛИ ТипОбработки = "Встроенная" Тогда
		Если ЗначениеЗаполнено(ПутьИнтеграционнойОбработки) Тогда
			ПараметрыМетода = Новый Структура("мАдресХранилища", мАдресХранилища);
			ПараметрыМетода.Вставить("ПутьКФайлу", ПолныйПутьКИнтеграционнойОбработке);
			Если ПараметрыОбработки = Неопределено Тогда
				ПараметрыМетода.Вставить("ПараметрыПодключенияMS", ПараметрыПодключенияMS);
			Иначе
				ПараметрыМетода.Вставить("ПараметрыПодключенияMS", ПараметрыОбработки);
			КонецЕсли;
			ПараметрыМетода.Вставить("ТипОбработки", ТипОбработки);
			ЛокЯдро_ПодключитьИнтеграционнуюОбработкуСервер(Истина, Ложь, , ПараметрыМетода);
		КонецЕсли;	
			
	КонецЕсли;
	
	Возврат ИнтеграционнаяОбработкаПодключена;
	
КонецФункции

// Вызывает из модуля обработки метод подключения интеграционной обработки. 
// Т.к. на стороне клиента нет возможности хранить переменную с типом ВнешняяОбработкаОбъект, 
// то помещаем обработку в структуру и кладем во временное хранилище 
// 
// Параметры:
//	Результат - Булево - Ложь - в параметре <Интерактивно> установлен интерактивный режим (Истина) и пользователь отказался от выполнения операции в диалоге выбора файла
//	мАдресХранилища - Строка - расположение нового файла
//	ВыбранноеИмяФайла - Строка - через этот параметр возвращается путь к файлу, указанный в диалоге выбора файла. 
//								 Для неинтерактивного режима выбранное имя файла соответствует начальному имени файла. 
//								 В режиме запуска "Веб-клиент" значение параметра зависит от типа браузера.
//								 Для Mozilla Firefox 3 в параметре возвращается только имя файла без пути.
//								 Для Microsoft Internet Explorer возвращаемое значение зависит от настройки текущей зоны.
//								 Подробности: http://msdn.microsoft.com/en-us/library/ms535128(VS.85).aspx
//	ПараметрыМетода - Неопределено, Структура - содержит:
//		* мАдресХранилища - Неопределено, Строка - расположение нового файла
//		* ПутьКФайлу - Строка - путь к исходному файлу
//		* ПараметрыПодключенияMS - Структура - структура настроек подключения к базе Mobile SMARTS
&НаКлиенте
Процедура ЛокЯдро_ПодключитьИнтеграционнуюОбработкуСервер(Результат,мАдресХранилища,ВыбранноеИмяФайла,ПараметрыМетода=Неопределено) Экспорт
	
	ИмяСобытия = "ЛокЯдро_ПодключитьИнтеграционнуюОбработкуСервер";
	
	ЗагрузитьИнтеграционнуюОбработкуВСправочник = Ложь;
	Если ПараметрыМетода.Свойство("ЗагрузитьИнтеграционнуюОбработкуВСправочник") Тогда
		ЗагрузитьИнтеграционнуюОбработкуВСправочник = ПараметрыМетода.ЗагрузитьИнтеграционнуюОбработкуВСправочник;
		ПараметрыМетода.Удалить("ЗагрузитьИнтеграционнуюОбработкуВСправочник");
	КонецЕсли;	
	
	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода", "Функция");
	СтруктураВызова.Вставить("ИмяМетода", "ПодключитьИнтеграционнуюОбработку");
	СтруктураВызова.Вставить("ПараметрыМетода",ПараметрыМетода);
	
	Если ПараметрыМетода.мАдресХранилища = Неопределено Тогда
		ПараметрыМетода.мАдресХранилища = мАдресХранилища;
	КонецЕсли;
	СтруктураВызоваАдрес = ПоместитьВоВременноеХранилище(СтруктураВызова, Новый УникальныйИдентификатор());
	пРезультат = Транзит_ВызватьГлобальныйМетодНаСервере(СтруктураВызоваАдрес,АдресаПеременных);
	АдресСтруктуры = ПолучитьИзВременногоХранилища(пРезультат);
	Если ЭтоАдресВременногоХранилища(АдресСтруктуры) Тогда
		_ИнтеграционнаяОбработкаАдрес=АдресСтруктуры;
		ПолучитьЗначенияПеременныхИО(АдресСтруктуры);
	Иначе
		СтруктураОбработки = Новый Структура();
		СтруктураОбработки.Вставить("Обработка",Неопределено);
		СтруктураОбработки.Вставить("Подключена",Ложь);
		СтруктураОбработки.Вставить("ПутьКФайлу","");	
		ИнтеграционнаяОбработкаПодключена = Ложь;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ИмяИнтеграционнойОбработки) И ИнтеграционнаяОбработкаПодключена = Истина Тогда
		Попытка
			ФормаИнтеграционнойОбработки = ПолучитьФормуИнтеграционнойОбработки(ТипОбработки, ИмяИнтеграционнойОбработки);
		Исключение
			ИнфоОбОшибке = ИнформацияОбОшибке();
			Если ЭтоАдресВременногоХранилища(_ИнтеграционнаяОбработкаАдрес) Тогда
				УдалитьИзВременногоХранилища(_ИнтеграционнаяОбработкаАдрес);
				_ИнтеграционнаяОбработкаАдрес = Неопределено;
			КонецЕсли;
			ИнтеграционнаяОбработкаПодключена = Ложь;
		КонецПопытки;
	КонецЕсли;
	
	#Область НесовместимыйКодFresh
	Если ЗагрузитьИнтеграционнуюОбработкуВСправочник Тогда
		Если ЗначениеЗаполнено(ИмяИнтеграционнойОбработки) И ИнтеграционнаяОбработкаПодключена = Истина Тогда
		    // Если интеграционную обработку удалось подключить только по относительному пути из каталога основной обработки,
			// загружаем ее в справочник дополнительных отчетов и обработок и далее используем оттуда
			РасположениеКомпоненты = КомЯдро_ПолучитьЗначениеПеременной("РасположениеКомпоненты");
			Попытка
				ПутьОсновнойОбработки = "";
				#Если НЕ ТолстыйКлиентОбычноеПриложение Тогда
					ПутьОсновнойОбработки = ИспользуемоеИмяФайла;	
				#КонецЕсли
				
				СтруктураПараметровПодключения = Новый Структура;	
				СтруктураПараметровПодключения.Вставить("НеОбновлятьВерсиюПриложения",			Истина);
				СтруктураПараметровПодключения.Вставить("ОбновлятьОсновнуюОбработку", 			Ложь);
				СтруктураПараметровПодключения.Вставить("ПроверятьВерсииПриложенийОбработок", 	Ложь);
				СтруктураПараметровПодключения.Вставить("РабочийКаталог",						ЛокЯдро_ПолучитьРабочийКаталогОсновнойОбработки(ПутьОсновнойОбработки));
				
				ЛокЯдро_ПодключитьФайлыВСправочникДопОтчетовОбработок(Истина, СтруктураПараметровПодключения);
				
				//СообщениеПользователю = Новый СообщениеПользователю;
				//СообщениеПользователю.Текст = "Интеграционная обработка была добавлена в справочник дополнительных отчетов и обработок.";
				//СообщениеПользователю.Сообщить();
			Исключение
				ТекстОшибки = "Не удалось добавить файл интеграционной обработки в справочник дополнительных отчетов и обработок. Причина:";
				ТекстОшибки = Символы.ПС + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
				ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", ТекстОшибки);
				
				//СообщениеПользователю = Новый СообщениеПользователю;
				//СообщениеПользователю.Текст = ТекстОшибки;
				//СообщениеПользователю.Сообщить();
			КонецПопытки;		
		КонецЕсли;
		
		// Сразу подключаем расширения из каталога основной обработки
		РезультатыПодключенийРасширений = ЛокЯдро_ПодключитьРасширенияАвтоматически(Истина);
		Если РезультатыПодключенийРасширений <> Неопределено
			И РезультатыПодключенийРасширений.Количество() Тогда
			Оповестить("ПодключеныРасширенияКонфигурации");
		КонецЕсли;
	КонецЕсли;	
	#КонецОбласти //НесовместимыйКодFresh
	
КонецПроцедуры 

&НаКлиенте
Функция ЛокЯдро_ПроверитьСуществованиеИнтеграционнаяОбработкаДвоичныеДанные()
	
	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода", "Функция");
	СтруктураВызова.Вставить("ИмяМетода", "ПроверитьСуществованиеИнтеграционнаяОбработкаДвоичныеДанные");	
	
	Возврат Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,,АдресаПеременных);
	
КонецФункции

&НаКлиенте
Функция ЛокЯдро_ПолучитьРабочийКаталогОсновнойОбработки(ПутьОсновнойОбработки)

	КаталогОсновнойОбработки = "";
	
	РазделительПути = ПолучитьРазделительПути();
	
	ПозицияРазделителя = ЛокЯдро_СтрНайти(ПутьОсновнойОбработки, РазделительПути, "СКонца");
	Если ПозицияРазделителя Тогда
		КаталогОсновнойОбработки = Лев(ПутьОсновнойОбработки, ПозицияРазделителя - 1);
	КонецЕсли;	
	
	Возврат КаталогОсновнойОбработки;
	
КонецФункции

&НаКлиенте
Функция ЛокЯдро_ПолучитьПутьИнтеграционнойОбработки(ПутьОсновнойОбработки)

	РазделительПути = ПолучитьРазделительПути();
	
	ПутьИнтеграционнойОбработки = ЛокЯдро_ПолучитьРабочийКаталогОсновнойОбработки(ПутьОсновнойОбработки)
		 + РазделительПути
		 + "Обработки интеграции"
		 + РазделительПути;
	
	Возврат ПутьИнтеграционнойОбработки;
	
КонецФункции

&НаСервере
Процедура ПолучитьЗначенияПеременныхИО(АдресСтруктуры) 

	СтруктураОбработки = ПолучитьИзВременногоХранилища(АдресСтруктуры);
	ИнтеграционнаяОбработкаПодключена = СтруктураОбработки.Свойство("Подключена") И СтруктураОбработки.Подключена;
	ИмяИнтеграционнойОбработки = СтруктураОбработки.ИмяОбработки;
	
КонецПроцедуры
	
// Выполняет обновление структуры настроек бизнес-процессов
//
// Возвращаемое значение:
//	Булево - флаг успешности выполнения операции
&НаКлиенте
Функция ЛокЯдро_ПроверитьОбновлениеТиповыхБизнесПроцессов(пСтруктураНастроек) Экспорт
	
	СтруктураНастроек = Новый Структура("ВерсияНастроек,ВерсияНастроек_ПоУмолчанию", Неопределено, Неопределено);
	СтруктураНастроек_Пользовательские 	= Новый Структура;
	СтруктураНастроек_ПоУмолчанию 		= Новый Структура;
	
	ВерсияНастроек_ПоУмолчанию 				= Ложь;
	НастройкиБизнесПроцессов_ПоУмолчанию 	= Ложь;
	Если ТипЗнч(пСтруктураНастроек.НастройкиБизнесПроцессов_ПоУмолчанию) = Тип("Структура") Тогда
		Если пСтруктураНастроек.НастройкиБизнесПроцессов_ПоУмолчанию.Свойство("ВерсияНастроек") Тогда
			ВерсияНастроек_ПоУмолчанию = пСтруктураНастроек.НастройкиБизнесПроцессов_ПоУмолчанию.ВерсияНастроек;
		КонецЕсли;
		Если пСтруктураНастроек.НастройкиБизнесПроцессов_ПоУмолчанию.Свойство("НастройкиБизнесПроцессов") Тогда
			НастройкиБизнесПроцессов_ПоУмолчанию = пСтруктураНастроек.НастройкиБизнесПроцессов_ПоУмолчанию.НастройкиБизнесПроцессов;
		КонецЕсли;
	КонецЕсли;
	
	ВерсияНастроек_Пользовательские 			= Ложь;
	НастройкиБизнесПроцессов_Пользовательские 	= Ложь;
	Если ТипЗнч(пСтруктураНастроек.НастройкиБизнесПроцессов_Пользовательские) = Тип("Структура") Тогда
		Если пСтруктураНастроек.НастройкиБизнесПроцессов_Пользовательские.Свойство("ВерсияНастроек") Тогда
			ВерсияНастроек_Пользовательские = пСтруктураНастроек.НастройкиБизнесПроцессов_Пользовательские.ВерсияНастроек;
		КонецЕсли;
		Если пСтруктураНастроек.НастройкиБизнесПроцессов_Пользовательские.Свойство("НастройкиБизнесПроцессов") Тогда
			НастройкиБизнесПроцессов_Пользовательские = пСтруктураНастроек.НастройкиБизнесПроцессов_Пользовательские.НастройкиБизнесПроцессов;
		КонецЕсли;
	КонецЕсли;
	
	// Получаем версии пользовательских настроек из настроек БП (если настройки сохранены в новом формате), либо по старому ключу, все это реализовано в соответствующих методах
	СтруктураНастроек_ПоУмолчанию.Вставить("НастройкиБизнесПроцессов", 		НастройкиБизнесПроцессов_ПоУмолчанию);
	СтруктураНастроек_Пользовательские.Вставить("НастройкиБизнесПроцессов", НастройкиБизнесПроцессов_Пользовательские);

	СтруктураНастроек.ВерсияНастроек			 = ВерсияНастроек_Пользовательские;
	СтруктураНастроек.ВерсияНастроек_ПоУмолчанию = ВерсияНастроек_ПоУмолчанию;		
		
	НужноОбновить = Ложь;
	Если Не ЗначениеЗаполнено(СтруктураНастроек.ВерсияНастроек) ИЛИ СтруктураНастроек.ВерсияНастроек = Ложь Тогда
		НужноОбновить = Истина;
	ИначеЕсли ТипЗнч(СтруктураНастроек.ВерсияНастроек) = Тип("Строка") И ТипЗнч(СтруктураНастроек.ВерсияНастроек_ПоУмолчанию) = Тип("Строка") Тогда		
		ВерсияНастроекСтр = СтруктураНастроек.ВерсияНастроек;
		ВерсияНастроек_ПоУмолчаниюСтр = СтруктураНастроек.ВерсияНастроек_ПоУмолчанию;
		Пока Истина Цикл
			Если СтрДлина(ВерсияНастроек_ПоУмолчаниюСтр) = 0 Тогда
				Прервать;
			КонецЕсли;
			Если СтрДлина(ВерсияНастроекСтр) = 0 Тогда
				НужноОбновить = Истина;
				Прервать;
			КонецЕсли;
			
			Инд = Найти(ВерсияНастроек_ПоУмолчаниюСтр,".");
			Если Инд = 0 Тогда				
				ВерсияПоУмолчанию = ВерсияНастроек_ПоУмолчаниюСтр;
				ВерсияНастроек_ПоУмолчаниюСтр = "";
			Иначе
				ВерсияПоУмолчанию = Лев(ВерсияНастроек_ПоУмолчаниюСтр,Инд-1);
				ВерсияНастроек_ПоУмолчаниюСтр = Прав(ВерсияНастроек_ПоУмолчаниюСтр,СтрДлина(ВерсияНастроек_ПоУмолчаниюСтр)-Инд);
			КонецЕсли;
			
			Попытка
				ВерсияПоУмолчанию = Число(ВерсияПоУмолчанию);	
			Исключение
				Прервать;
			КонецПопытки;
			
			Инд = Найти(ВерсияНастроекСтр,".");
			Если Инд = 0 Тогда				
				ТекВерсия = ВерсияНастроекСтр;
				ВерсияНастроекСтр = "";
			Иначе
				ТекВерсия = Лев(ВерсияНастроекСтр,Инд-1);
				ВерсияНастроекСтр = Прав(ВерсияНастроекСтр,СтрДлина(ВерсияНастроекСтр)-Инд);
			КонецЕсли;
			
			Попытка
				ТекВерсия = Число(ТекВерсия);	
			Исключение
				НужноОбновить = Истина;
				Прервать;
			КонецПопытки;
			
			Если ВерсияПоУмолчанию > ТекВерсия Тогда
				НужноОбновить = Истина;
				Прервать;	
			КонецЕсли;
			
		КонецЦикла;
	КонецЕсли;
	
	Если НЕ НужноОбновить Тогда
		Возврат Ложь;	
	КонецЕсли;
	
	НастройкиБизнесПроцессовПоУмолчанию = СтруктураНастроек_ПоУмолчанию.НастройкиБизнесПроцессов;
	Если НастройкиБизнесПроцессовПоУмолчанию <> Неопределено и НастройкиБизнесПроцессовПоУмолчанию <> Ложь Тогда
		Если ТипЗнч(НастройкиБизнесПроцессовПоУмолчанию) = Тип("Строка") Тогда
			НастройкиБизнесПроцессовПоУмолчанию = ЛокЯдро_ЗначениеИзСтрокиXML(НастройкиБизнесПроцессовПоУмолчанию,Истина);
		КонецЕсли;
		
		СтруктураНастроекБизнесПроцессов_ПоУмолчанию = ЛокЯдро_СкомпоноватьСтруктуруНастроекДляСохранения(
				НастройкиБизнесПроцессовПоУмолчанию, 
				ЛокЯдро_ПолучитьВерсиюСтруктурыНастроекОбработки()); 		                                                                		
		ЛокЯдро_ЗаписатьВКэшНастройкуSMARTS("НастройкиБизнесПроцессов_ПоУмолчанию", СтруктураНастроекБизнесПроцессов_ПоУмолчанию);
	
	КонецЕсли; 
		
	Если СтруктураНастроек_Пользовательские.НастройкиБизнесПроцессов = Ложь Тогда	
		НастройкиБизнесПроцессовСтарые = ЛокЯдро_ПолучитьНастройкуНаСервереSMARTS("НастройкиБизнесПроцессов");	
		Если НастройкиБизнесПроцессовСтарые <> Неопределено и НастройкиБизнесПроцессовСтарые <> Ложь Тогда
			НастройкиБизнесПроцессов_Пользовательские = НастройкиБизнесПроцессовСтарые;
			СтруктураНастроекБизнесПроцессов_Пользовательские = ЛокЯдро_СкомпоноватьСтруктуруНастроекДляСохранения(
				НастройкиБизнесПроцессов_Пользовательские, 
				ЛокЯдро_ПолучитьВерсиюСтруктурыНастроекОбработки()); 		
			ЛокЯдро_СохранитьНастройкуВБазеSMARTS("НастройкиБизнесПроцессов_Пользовательские", 	СтруктураНастроекБизнесПроцессов_Пользовательские);
			ЛокЯдро_ЗаписатьВКэшНастройкуSMARTS("НастройкиБизнесПроцессов_Пользовательские", 	СтруктураНастроекБизнесПроцессов_Пользовательские);
			ЛокЯдро_УдалитьНастройкиВБазеSMARTS(Новый Структура("НастройкиБизнесПроцессов",Ложь), Неопределено);
		КонецЕсли;
	КонецЕсли;
	
	НужноСохранить=Ложь;
	
	НастройкиБизнесПроцессов_Пользовательские = СтруктураНастроек_Пользовательские.НастройкиБизнесПроцессов;
	Если НастройкиБизнесПроцессов_Пользовательские <> Неопределено И НастройкиБизнесПроцессов_Пользовательские <> Ложь Тогда		
		Если ТипЗнч(НастройкиБизнесПроцессов_Пользовательские) = Тип("Строка") Тогда
			НастройкиБизнесПроцессов_Пользовательские = ЛокЯдро_ЗначениеИзСтрокиXML(НастройкиБизнесПроцессов_Пользовательские,Истина);
		КонецЕсли;
		Икс = НастройкиБизнесПроцессов_Пользовательские.Количество();
		Пока Икс > 0 Цикл
			Икс = Икс - 1;
			НастройкаБП = НастройкиБизнесПроцессов_Пользовательские[Икс];
			Если НастройкаБП.Свойство("ID_БизнесПроцесса") Тогда
				ID = НастройкаБП.ID_БизнесПроцесса;
			ИначеЕсли НастройкаБП.Свойство("IDБизнесПроцесса") Тогда
				ID = НастройкаБП.IDБизнесПроцесса;
			Иначе
				ID = Неопределено;
			КонецЕсли;
			Если ID <> Неопределено Тогда
				Индекс = НайтиСтруктуруВМассивеПоЭлементу(НастройкиБизнесПроцессовПоУмолчанию,"ID_БизнесПроцесса",ID,Истина);
				Если Индекс <> Неопределено Тогда
					НастройкиБизнесПроцессов_Пользовательские.Удалить(Икс);
					НужноСохранить=Истина;
				КонецЕсли;
			КонецЕсли;	
		КонецЦикла;
		НастройкиБизнесПроцессов_Пользовательские = ЛокЯдро_ОбновитьСтруктуруНастроекБизнесПроцессов(НастройкиБизнесПроцессов_Пользовательские, НужноСохранить);
	КонецЕсли;	
	
	Если НужноСохранить Тогда
		СтруктураНастроекБизнесПроцессов_Пользовательские = ЛокЯдро_СкомпоноватьСтруктуруНастроекДляСохранения(
			НастройкиБизнесПроцессов_Пользовательские, 
			ЛокЯдро_ПолучитьВерсиюСтруктурыНастроекОбработки()); 		
		ЛокЯдро_СохранитьНастройкуВБазеSMARTS("НастройкиБизнесПроцессов_Пользовательские", 	СтруктураНастроекБизнесПроцессов_Пользовательские);
		ЛокЯдро_ЗаписатьВКэшНастройкуSMARTS("НастройкиБизнесПроцессов_Пользовательские", 	СтруктураНастроекБизнесПроцессов_Пользовательские);	
	КонецЕсли;
	
	ПроизвольныеКоды_ПоУмолчанию = ЛокЯдро_ПолучитьНастройкуПоУмолчаниюНаСервереSMARTS("ПроизвольныеКоды_ПоУмолчанию");
	Если ПроизвольныеКоды_ПоУмолчанию <> Неопределено и ПроизвольныеКоды_ПоУмолчанию <> Ложь Тогда
		Если ТипЗнч(ПроизвольныеКоды_ПоУмолчанию) = Тип("Строка") Тогда
			ПроизвольныеКоды_ПоУмолчанию = ЛокЯдро_ЗначениеИзСтрокиXML(ПроизвольныеКоды_ПоУмолчанию,Истина);
		КонецЕсли;
		
		ЛокЯдро_ЗаписатьВКэшНастройкуSMARTS("ПроизвольныеКоды_ПоУмолчанию", ПроизвольныеКоды_ПоУмолчанию);
	КонецЕсли;
	
	ПроизвольныеКоды_Пользовательские = ЛокЯдро_ПолучитьИзКэшаНастройкуSMARTS("ПроизвольныеКоды_Пользовательские");
	НужноСохранить=Ложь;
	Если ПроизвольныеКоды_Пользовательские <> Неопределено и ПроизвольныеКоды_Пользовательские <> Ложь Тогда
		Если ТипЗнч(ПроизвольныеКоды_Пользовательские) = Тип("Строка") Тогда
			ПроизвольныеКоды_Пользовательские = ЛокЯдро_ЗначениеИзСтрокиXML(ПроизвольныеКоды_Пользовательские,Истина);
		КонецЕсли;
		Икс = ПроизвольныеКоды_Пользовательские.Количество();
		Пока Икс > 0 Цикл
			Икс = Икс - 1;
			СтрокаПК = ПроизвольныеКоды_Пользовательские[Икс];
			Если СтрокаПК.Свойство("ID_ПроизвольногоКода") Тогда
				Индекс = НайтиСтруктуруВМассивеПоЭлементу(ПроизвольныеКоды_ПоУмолчанию,"ID_ПроизвольногоКода",СтрокаПК.ID_ПроизвольногоКода,Истина);
				Если Индекс <> Неопределено Тогда
					ПроизвольныеКоды_Пользовательские.Удалить(Икс);
					НужноСохранить=Истина;
				КонецЕсли;
			КонецЕсли;	
		КонецЦикла;		
		
		НоваяНастройка = Новый Массив;
		НоваяНастройка.Добавить(Новый Структура("КолонкиТаблицыЗначений,ЭтоТаблицаЗначений","Наименование,Описание,ТекстПроизвольногоКода,ID_ПроизвольногоКода,Направление,ТипОбъекта",Истина));
		
		Для Каждого ПроизвольныйКод из ПроизвольныеКоды_Пользовательские Цикл
			Если ПроизвольныйКод.Свойство("ЭтоТаблицаЗначений") Тогда
				Продолжить;
			КонецЕсли;
			Если ПроизвольныйКод.Свойство("ID_Кода") Тогда
				НовыйПроизвольныйКод = Новый Структура();
				НовыйПроизвольныйКод.Вставить("Наименование",			ПроизвольныйКод.Наименование);
				НовыйПроизвольныйКод.Вставить("Описание",				"");
				НовыйПроизвольныйКод.Вставить("ТекстПроизвольногоКода",	ПроизвольныйКод.ТекстКода);
				НовыйПроизвольныйКод.Вставить("ID_ПроизвольногоКода",	ПроизвольныйКод.ID_Кода);
				НовыйПроизвольныйКод.Вставить("Направление",			ПроизвольныйКод.Направление);
				НовыйПроизвольныйКод.Вставить("ТипОбъекта",				ПроизвольныйКод.ТипОбъекта);		
				НоваяНастройка.Добавить(НовыйПроизвольныйКод);
				НужноСохранить = Истина;
			ИначеЕсли ПроизвольныйКод.Свойство("ID_ПроизвольногоКода") Тогда
				НоваяНастройка.Добавить(ПроизвольныйКод);
			КонецЕсли;
		КонецЦикла;
		
	КонецЕсли;
	Если НужноСохранить Тогда
		ЛокЯдро_СохранитьНастройкуВБазеSMARTS("ПроизвольныеКоды_Пользовательские", НоваяНастройка);
		ЛокЯдро_ЗаписатьВКэшНастройкуSMARTS("ПроизвольныеКоды_Пользовательские", НоваяНастройка);	
	КонецЕсли;	
	
	Возврат Истина;
	
КонецФункции

&НаКлиенте 
Процедура ЛокЯдро_ОбъединитьПроизвольныеКоды()
	
	ПроизвольныеКоды_ПоУмолчанию = ЛокЯдро_ПолучитьИзКэшаНастройкуSMARTS("ПроизвольныеКоды_ПоУмолчанию");
	ПроизвольныеКоды_Пользовательские = ЛокЯдро_ПолучитьИзКэшаНастройкуSMARTS("ПроизвольныеКоды_Пользовательские"); 
	
	Если (НЕ ПроизвольныеКоды_ПоУмолчанию = Ложь И ЗначениеЗаполнено(ПроизвольныеКоды_ПоУмолчанию))
		ИЛИ (НЕ ПроизвольныеКоды_Пользовательские = Ложь И ЗначениеЗаполнено(ПроизвольныеКоды_Пользовательские)) Тогда
		Возврат;
	КонецЕсли;
	
	СтруктураНастроек = Новый Структура("ПроизвольныеКоды_Выгрузка_ШапкаДокумента,ПроизвольныеКоды_Выгрузка_ТабличнаяЧастьДокумента,ПроизвольныеКоды_Загрузка_ШапкаДокумента,ПроизвольныеКоды_Загрузка_ТабличнаяЧастьДокумента",Неопределено,Неопределено);
	СтруктураНастроек = ЛокЯдро_ПолучитьНастройкиНаСервереSMARTS(СтруктураНастроек);		
		
	ПроизвольныеКоды_Пользовательские = Новый Массив;
	ПроизвольныеКоды_Пользовательские.Добавить(Новый Структура("ЭтоТаблицаЗначений,КолонкиТаблицыЗначений",Истина,"Наименование,Описание,ТекстПроизвольногоКода,ID_ПроизвольногоКода,Направление,ТипОбъекта"));
	
	Если ЗначениеЗаполнено(СтруктураНастроек.ПроизвольныеКоды_Выгрузка_ШапкаДокумента)
		И НЕ СтруктураНастроек.ПроизвольныеКоды_Выгрузка_ШапкаДокумента = Ложь Тогда
		Если ТипЗнч(СтруктураНастроек.ПроизвольныеКоды_Выгрузка_ШапкаДокумента) = Тип("Строка") Тогда
			СтруктураНастроек.ПроизвольныеКоды_Выгрузка_ШапкаДокумента = ЛокЯдро_ЗначениеИзСтрокиXML(СтруктураНастроек.ПроизвольныеКоды_Выгрузка_ШапкаДокумента, Истина);		
		КонецЕсли;
		Для каждого ПК Из СтруктураНастроек.ПроизвольныеКоды_Выгрузка_ШапкаДокумента Цикл
			Если НЕ ПК.Свойство("ЭтоТаблицаЗначений") Тогда
				ПК.Вставить("Направление","Выгрузка");
				ПК.Вставить("ТипОбъекта","Шапка");
				ПроизвольныеКоды_Пользовательские.Добавить(ПК);
			КонецЕсли;
		КонецЦикла;
		
	КонецЕсли;
	
	Если ЗначениеЗаполнено(СтруктураНастроек.ПроизвольныеКоды_Выгрузка_ТабличнаяЧастьДокумента)
		И НЕ СтруктураНастроек.ПроизвольныеКоды_Выгрузка_ТабличнаяЧастьДокумента = Ложь Тогда
		Если ТипЗнч(СтруктураНастроек.ПроизвольныеКоды_Выгрузка_ТабличнаяЧастьДокумента) = Тип("Строка") Тогда
			СтруктураНастроек.ПроизвольныеКоды_Выгрузка_ТабличнаяЧастьДокумента = ЛокЯдро_ЗначениеИзСтрокиXML(СтруктураНастроек.ПроизвольныеКоды_Выгрузка_ТабличнаяЧастьДокумента, Истина);		
		КонецЕсли;
		Для каждого ПК Из СтруктураНастроек.ПроизвольныеКоды_Выгрузка_ТабличнаяЧастьДокумента Цикл
			Если НЕ ПК.Свойство("ЭтоТаблицаЗначений") Тогда
				ПК.Вставить("Направление","Выгрузка");
				ПК.Вставить("ТипОбъекта","ТабличнаяЧасть");
				ПроизвольныеКоды_Пользовательские.Добавить(ПК);
			КонецЕсли;
		КонецЦикла;
		
	КонецЕсли;
	
	Если ЗначениеЗаполнено(СтруктураНастроек.ПроизвольныеКоды_Загрузка_ШапкаДокумента)
		И НЕ СтруктураНастроек.ПроизвольныеКоды_Загрузка_ШапкаДокумента = Ложь Тогда
		Если ТипЗнч(СтруктураНастроек.ПроизвольныеКоды_Загрузка_ШапкаДокумента) = Тип("Строка") Тогда
			СтруктураНастроек.ПроизвольныеКоды_Загрузка_ШапкаДокумента = ЛокЯдро_ЗначениеИзСтрокиXML(СтруктураНастроек.ПроизвольныеКоды_Загрузка_ШапкаДокумента, Истина);		
		КонецЕсли;
		Для каждого ПК Из СтруктураНастроек.ПроизвольныеКоды_Загрузка_ШапкаДокумента Цикл
			Если НЕ ПК.Свойство("ЭтоТаблицаЗначений") Тогда
				ПК.Вставить("Направление","Загрузка");
				ПК.Вставить("ТипОбъекта","Шапка");
				ПроизвольныеКоды_Пользовательские.Добавить(ПК);
			КонецЕсли;
		КонецЦикла;
		
	КонецЕсли;
	
	Если ЗначениеЗаполнено(СтруктураНастроек.ПроизвольныеКоды_Загрузка_ТабличнаяЧастьДокумента)
		И НЕ СтруктураНастроек.ПроизвольныеКоды_Загрузка_ТабличнаяЧастьДокумента = Ложь Тогда
		Если ТипЗнч(СтруктураНастроек.ПроизвольныеКоды_Загрузка_ТабличнаяЧастьДокумента) = Тип("Строка") Тогда
			СтруктураНастроек.ПроизвольныеКоды_Загрузка_ТабличнаяЧастьДокумента = ЛокЯдро_ЗначениеИзСтрокиXML(СтруктураНастроек.ПроизвольныеКоды_Загрузка_ТабличнаяЧастьДокумента, Истина);		
		КонецЕсли;
		Для каждого ПК Из СтруктураНастроек.ПроизвольныеКоды_Загрузка_ТабличнаяЧастьДокумента Цикл
			Если НЕ ПК.Свойство("ЭтоТаблицаЗначений") Тогда
				ПК.Вставить("Направление","Загрузка");
				ПК.Вставить("ТипОбъекта","ТабличнаяЧасть");
				ПроизвольныеКоды_Пользовательские.Добавить(ПК);
			КонецЕсли;
		КонецЦикла;
		
	КонецЕсли;
	
	Если ПроизвольныеКоды_Пользовательские.Количество() > 0 Тогда
		ЛокЯдро_СохранитьНастройкуВБазеSMARTS("ПроизвольныеКоды_Пользовательские", ПроизвольныеКоды_Пользовательские);
		ЛокЯдро_ЗаписатьВКэшНастройкуSMARTS("ПроизвольныеКоды_Пользовательские", ПроизвольныеКоды_Пользовательские);
	КонецЕсли;
	
КонецПроцедуры

// Собирает общую структуру настроек бизнес-процессов и помещает ее в кэш
&НаКлиенте
Процедура ЛокЯдро_СобратьОбщуюСтруктуруБизнесПроцессов(ID_Узла = "", ИспользоватьХранилищеНастроек = Истина) Экспорт	
	
	НастройкиБизнесПроцессов = ЛокЯдро_ПолучитьОбщуюСтруктуруБизнесПроцессов(ID_Узла, ИспользоватьХранилищеНастроек);
	
	ЛокЯдро_ЗаписатьВКэшНастройкуSMARTS("НастройкиБизнесПроцессов", НастройкиБизнесПроцессов);
	
КонецПроцедуры

// Получаем общую структуру настроек бизнес-процессов по узлу
&НаКлиенте
Функция ЛокЯдро_ПолучитьОбщуюСтруктуруБизнесПроцессов(ID_Узла = "", ИспользоватьХранилищеНастроек = Истина) Экспорт
	
	Если ТипЗнч(ДанныеТекущегоУзла) = Тип("Структура") Тогда
		ID_ТекущегоУзла = ДанныеТекущегоУзла.ID_Узла;
	КонецЕсли;

	Если ИспользоватьХранилищеНастроек Тогда
		НастройкиБизнесПроцессов = ЛокЯдро_ПолучитьЗначениеКэшируемойНастройки("НастройкиБизнесПроцессов", ID_Узла);
		Если ЗначениеЗаполнено(НастройкиБизнесПроцессов) И НЕ НастройкиБизнесПроцессов = Ложь Тогда
			Возврат НастройкиБизнесПроцессов;
		КонецЕсли;
	КонецЕсли;
	
	НастройкиБизнесПроцессов = Новый Массив();
	Если ID_ТекущегоУзла = ID_Узла Тогда
		// В функцию передан Ид текущего узла, значения настроек БП содержатся в кэше
		СтруктураНастроекБизнесПроцессов_ПользовательскиеНастройки	= ЛокЯдро_ПолучитьИзКэшаСтруктуруИзмененныхТиповыхНастроекБизнесПроцессов();
	Иначе
		// Настроек БП нет в кэше, получаем их для переданного Ид узла из базы MS                                                        		
		СтруктураНастроекБизнесПроцессов_ПользовательскиеНастройки	= ЛокЯдро_ПолучитьСтруктуруИзмененныхТиповыхНастроекБизнесПроцессовНаСервереSMARTS(ID_Узла);
	КонецЕсли;
	
	// НастройкиБизнесПроцессов_ПоУмолчанию и СтруктураНастроекБизнесПроцессов_Пользовательские не отличаются для разных узлов
	СтруктураНастроекБизнесПроцессов_ПоУмолчанию 		= ЛокЯдро_ПолучитьИзКэшаСтруктуруНастроекПоУмолчаниюБизнесПроцессов();
	СтруктураНастроекБизнесПроцессов_Пользовательские 	= ЛокЯдро_ПолучитьИзКэшаСтруктуруПользовательскихНастроекБизнесПроцессов();
	
	НастройкиБизнесПроцессов_ПоУмолчанию				= СтруктураНастроекБизнесПроцессов_ПоУмолчанию.НастройкиБизнесПроцессов;
	НастройкиБизнесПроцессов_Пользовательские 			= СтруктураНастроекБизнесПроцессов_Пользовательские.НастройкиБизнесПроцессов;
	НастройкиБизнесПроцессов_ПользовательскиеНастройки 	= СтруктураНастроекБизнесПроцессов_ПользовательскиеНастройки.НастройкиБизнесПроцессов;
	
	ИдТиповыхБП = Новый Массив();
	
	Если ЗначениеЗаполнено(НастройкиБизнесПроцессов_ПоУмолчанию) И НЕ НастройкиБизнесПроцессов_ПоУмолчанию = Ложь Тогда
		Если ТипЗнч(НастройкиБизнесПроцессов_ПоУмолчанию) = Тип("Строка") Тогда
			НастройкиБизнесПроцессов_ПоУмолчанию = ЛокЯдро_ЗначениеИзСтрокиXML(НастройкиБизнесПроцессов_ПоУмолчанию, Истина);		
		КонецЕсли;
		Для Каждого СтрокаБП Из НастройкиБизнесПроцессов_ПоУмолчанию Цикл			
			Если НЕ СтрокаБП.Свойство("ЭтоТаблицаЗначений") Тогда
				СтрокаБП.Вставить("ЭтоТиповойБизнесПроцесс",Истина);
				НастройкиБизнесПроцессов.Добавить(ЛокЯдро_СкопироватьСтруктуру(СтрокаБП));
				ИдТиповыхБП.Добавить(СтрокаБП.ID_БизнесПроцесса);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(НастройкиБизнесПроцессов_Пользовательские) И НЕ НастройкиБизнесПроцессов_Пользовательские = Ложь Тогда
		Если ТипЗнч(НастройкиБизнесПроцессов_Пользовательские) = Тип("Строка") Тогда
			НастройкиБизнесПроцессов_Пользовательские = ЛокЯдро_ЗначениеИзСтрокиXML(НастройкиБизнесПроцессов_Пользовательские, Истина);		
		КонецЕсли;
		Для Каждого СтрокаБП Из НастройкиБизнесПроцессов_Пользовательские Цикл
			Если НЕ СтрокаБП.Свойство("ЭтоТаблицаЗначений") Тогда			
				СтрокаБП.Вставить("ЭтоТиповойБизнесПроцесс",Ложь);
				Если ИдТиповыхБП.Найти(СтрокаБП.ID_БизнесПроцесса) = Неопределено Тогда
					НастройкиБизнесПроцессов.Добавить(ЛокЯдро_СкопироватьСтруктуру(СтрокаБП));
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	ЭтоГлавныйУзел = НЕ ЗначениеЗаполнено(ID_Узла);
	
	КатегорииНастроекMS = КомЯдро_ПолучитьЗначениеПеременной("КатегорииНастроекMS");
	Если КатегорииНастроекMS = Неопределено Тогда
		КатегорииНастроекMS = ЛокЯдро_ПолучитьКатегорииНастроекMS();
	КонецЕсли;
	
	ПользовательскиеНастройкиГлавногоУзла = КатегорииНастроекMS.ПользовательскиеНастройкиГлавногоУзла;
	
	Если ЗначениеЗаполнено(НастройкиБизнесПроцессов_ПользовательскиеНастройки) И НЕ (НастройкиБизнесПроцессов_ПользовательскиеНастройки) = Ложь Тогда
		Если ТипЗнч(НастройкиБизнесПроцессов_ПользовательскиеНастройки) = Тип("Строка") Тогда
			НастройкиБизнесПроцессов_ПользовательскиеНастройки = ЛокЯдро_ЗначениеИзСтрокиXML(НастройкиБизнесПроцессов_ПользовательскиеНастройки, Истина);		
		КонецЕсли;
		Для Каждого СтрокаБП Из НастройкиБизнесПроцессов_ПользовательскиеНастройки Цикл
			Если СтрокаБП.Свойство("ЭтоТаблицаЗначений") Тогда
				Продолжить;
			КонецЕсли;
			Если ЭтоГлавныйУзел И ИдТиповыхБП.Найти(СтрокаБП.ID_БизнесПроцесса) = Неопределено Тогда
			    Продолжить;
			КонецЕсли;
			Индекс = НайтиСтруктуруВМассивеПоЭлементу(НастройкиБизнесПроцессов, "ID_БизнесПроцесса", СтрокаБП.ID_БизнесПроцесса, Истина);
			Если Индекс <> Неопределено Тогда
				НастройкиБизнесПроцессов[Индекс].Вставить("ПользовательскаяНастройка", Истина);
				Для Каждого КлючИЗначение Из СтрокаБП Цикл
					Если НЕ ЭтоГлавныйУзел И ПользовательскиеНастройкиГлавногоУзла.Найти(КлючИЗначение.Ключ) <> Неопределено Тогда
						Продолжить;
					КонецЕсли;
					
					НастройкиБизнесПроцессов[Индекс].Вставить(КлючИЗначение.Ключ, КлючИЗначение.Значение);
				КонецЦикла;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	НастройкиБизнесПроцессов_ПользовательскиеНастройки_ГлавныйУзел = Неопределено;
	Если НЕ ЭтоГлавныйУзел Тогда
		СтруктураНастроекБизнесПроцессов_ПользовательскиеНастройки_ГлавныйУзел = ЛокЯдро_ПолучитьСтруктуруИзмененныхТиповыхНастроекБизнесПроцессовНаСервереSMARTS("");
		НастройкиБизнесПроцессов_ПользовательскиеНастройки_ГлавныйУзел = СтруктураНастроекБизнесПроцессов_ПользовательскиеНастройки_ГлавныйУзел.НастройкиБизнесПроцессов; 
	КонецЕсли;
		
	Если ЗначениеЗаполнено(НастройкиБизнесПроцессов_ПользовательскиеНастройки_ГлавныйУзел) И НЕ НастройкиБизнесПроцессов_ПользовательскиеНастройки_ГлавныйУзел = Ложь Тогда
		Если ТипЗнч(НастройкиБизнесПроцессов_ПользовательскиеНастройки_ГлавныйУзел) = Тип("Строка") Тогда
			НастройкиБизнесПроцессов_ПользовательскиеНастройки_ГлавныйУзел = ЛокЯдро_ЗначениеИзСтрокиXML(НастройкиБизнесПроцессов_ПользовательскиеНастройки_ГлавныйУзел, Истина);
		КонецЕсли;
		Для Каждого СтрокаБП Из НастройкиБизнесПроцессов_ПользовательскиеНастройки_ГлавныйУзел Цикл
			Если СтрокаБП.Свойство("ЭтоТаблицаЗначений") Тогда
				Продолжить;
			КонецЕсли;
			Индекс = НайтиСтруктуруВМассивеПоЭлементу(НастройкиБизнесПроцессов, "ID_БизнесПроцесса", СтрокаБП.ID_БизнесПроцесса, Истина);
			Если Индекс <> Неопределено Тогда
				НастройкиБизнесПроцессов[Индекс].Вставить("ПользовательскаяНастройка", Истина);
				Для Каждого КлючИЗначение Из СтрокаБП Цикл
					Если ПользовательскиеНастройкиГлавногоУзла.Найти(КлючИЗначение.Ключ) = Неопределено Тогда
						Продолжить;
					КонецЕсли;
					
					НастройкиБизнесПроцессов[Индекс].Вставить(КлючИЗначение.Ключ, КлючИЗначение.Значение);
				КонецЦикла;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	// Обновляем значения кэшируемых настроек
	ЛокЯдро_СохранитьЗначениеКэшируемойНастройки("НастройкиБизнесПроцессов", НастройкиБизнесПроцессов, ID_Узла);
	
	// Настройки кэшируются при получении из базы SMARTS и обновляются в кэше при сохранении в базу SMARTS
	//ЛокЯдро_СохранитьЗначениеКэшируемойНастройки("НастройкиБизнесПроцессов_ПоУмолчанию", 					НастройкиБизнесПроцессов_ПоУмолчанию,				ID_Узла);
	//ЛокЯдро_СохранитьЗначениеКэшируемойНастройки("НастройкиБизнесПроцессов_Пользовательские", 			НастройкиБизнесПроцессов_Пользовательские, 			ID_Узла);
	//ЛокЯдро_СохранитьЗначениеКэшируемойНастройки("НастройкиБизнесПроцессов_ПользовательскиеНастройки",	НастройкиБизнесПроцессов_ПользовательскиеНастройки, ID_Узла);
	
	Возврат НастройкиБизнесПроцессов;
	
КонецФункции

// Собирает общую структуру произвольных кодов и помещает ее в кэш
&НаКлиенте
Процедура ЛокЯдро_СобратьОбщуюСтруктуруПроизвольныхКодов(ИспользоватьХранилищеНастроек = Истина) Экспорт
	
	Если ИспользоватьХранилищеНастроек Тогда
		ПроизвольныеКоды = ЛокЯдро_ПолучитьЗначениеКэшируемойНастройки("ПроизвольныеКоды", "");
		Если ЗначениеЗаполнено(ПроизвольныеКоды) И НЕ ПроизвольныеКоды = Ложь Тогда
			ЛокЯдро_ЗаписатьВКэшНастройкуSMARTS("ПроизвольныеКоды", ПроизвольныеКоды);
			Возврат;
		КонецЕсли;
	КонецЕсли;
	
	ПроизвольныеКоды = Новый Массив();
	ПроизвольныеКоды_ПоУмолчанию = ЛокЯдро_ПолучитьИзКэшаНастройкуSMARTS("ПроизвольныеКоды_ПоУмолчанию");
	ПроизвольныеКоды_Пользовательские = ЛокЯдро_ПолучитьИзКэшаНастройкуSMARTS("ПроизвольныеКоды_Пользовательские");	
	
	Если ЗначениеЗаполнено(ПроизвольныеКоды_ПоУмолчанию) И НЕ ПроизвольныеКоды_ПоУмолчанию = Ложь Тогда
		Для Каждого СтрокаПК Из ПроизвольныеКоды_ПоУмолчанию Цикл    
			Если НЕ СтрокаПК.Свойство("ЭтоТаблицаЗначений") Тогда
				СтрокаПК.Вставить("ЭтоТиповой",Истина);
				ПроизвольныеКоды.Добавить(ЛокЯдро_СкопироватьСтруктуру(СтрокаПК));
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ПроизвольныеКоды_Пользовательские) И НЕ ПроизвольныеКоды_Пользовательские = Ложь Тогда
		Для Каждого СтрокаПК Из ПроизвольныеКоды_Пользовательские Цикл
			Если НЕ СтрокаПК.Свойство("ЭтоТаблицаЗначений") Тогда
				СтрокаПК.Вставить("ЭтоТиповой",Ложь);
				ПроизвольныеКоды.Добавить(ЛокЯдро_СкопироватьСтруктуру(СтрокаПК));
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	ЛокЯдро_ЗаписатьВКэшНастройкуSMARTS("ПроизвольныеКоды", ПроизвольныеКоды);
	
	// Обновляем значения кэшируемых настроек
	ЛокЯдро_СохранитьЗначениеКэшируемойНастройки("ПроизвольныеКоды", 					ПроизвольныеКоды, 					"");
	ЛокЯдро_СохранитьЗначениеКэшируемойНастройки("ПроизвольныеКоды_ПоУмолчанию", 		ПроизвольныеКоды_ПоУмолчанию, 		"");
	ЛокЯдро_СохранитьЗначениеКэшируемойНастройки("ПроизвольныеКоды_Пользовательские", 	ПроизвольныеКоды_Пользовательские, 	"");
	
КонецПроцедуры

&НаКлиенте
Процедура ЛокЯдро_СобратьОбщуюСтруктуруГлобальныхПараметров(ИспользоватьХранилищеНастроек = Истина) Экспорт
	
	Если ИспользоватьХранилищеНастроек Тогда
		ГлобальныеПараметры = ЛокЯдро_ПолучитьЗначениеКэшируемойНастройки("ГлобальныеПараметры", "");
		Если ЗначениеЗаполнено(ГлобальныеПараметры) И НЕ ГлобальныеПараметры = Ложь Тогда
			ЛокЯдро_ЗаписатьВКэшНастройкуSMARTS("ГлобальныеПараметры", ГлобальныеПараметры);
			Возврат;
		КонецЕсли;
	КонецЕсли;
	
	ГлобальныеПараметры = Новый Массив();
	ГлобальныеПараметры_ПоУмолчанию 	 = ЛокЯдро_ПолучитьИзКэшаНастройкуSMARTS("ГлобальныеПараметры_ПоУмолчанию");
	ГлобальныеПараметры_Пользовательские = ЛокЯдро_ПолучитьИзКэшаНастройкуSMARTS("ГлобальныеПараметры_Пользовательские");	
	
	Если НЕ ЗначениеЗаполнено(ГлобальныеПараметры_ПоУмолчанию) ИЛИ ГлобальныеПараметры_ПоУмолчанию = Ложь Тогда
		ГлобальныеПараметры_ПоУмолчанию = ЛокЯдро_ПолучитьНастройкуНаСервереSMARTS("ГлобальныеПараметры");
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ГлобальныеПараметры_ПоУмолчанию) И НЕ ГлобальныеПараметры_ПоУмолчанию = Ложь Тогда
		Для каждого СтрокаГП ИЗ ГлобальныеПараметры_ПоУмолчанию Цикл
			Если НЕ СтрокаГП.Свойство("ЭтоТаблицаЗначений") Тогда
				СтрокаГП.Вставить("Типовой", Истина);
				ГлобальныеПараметры.Добавить(ЛокЯдро_СкопироватьСтруктуру(СтрокаГП));
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ГлобальныеПараметры_Пользовательские) И НЕ ГлобальныеПараметры_Пользовательские = Ложь Тогда
		Для каждого СтрокаГП ИЗ ГлобальныеПараметры_Пользовательские Цикл
			Если НЕ СтрокаГП.Свойство("ЭтоТаблицаЗначений") Тогда
				НайденныйПараметр = ЛокЯдро_НайтиСтруктуруВМассивеПоЭлементу(ГлобальныеПараметры_ПоУмолчанию, "ID_Параметра", СтрокаГП.ID_Параметра);
				Если НайденныйПараметр <> Неопределено Тогда
					Продолжить;
				КонецЕсли;
				
				СтрокаГП.Вставить("Типовой", Ложь);
				ГлобальныеПараметры.Добавить(ЛокЯдро_СкопироватьСтруктуру(СтрокаГП));
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	ЛокЯдро_ЗаписатьВКэшНастройкуSMARTS("ГлобальныеПараметры", ГлобальныеПараметры);
	
	// Обновляем значения кэшируемых настроек
	ЛокЯдро_СохранитьЗначениеКэшируемойНастройки("ГлобальныеПараметры", ГлобальныеПараметры, "");
	
	// Настройки кэшируются при получении из базы SMARTS и обновляются в кэше при сохранении в базу SMARTS
	//ЛокЯдро_СохранитьЗначениеКэшируемойНастройки("ГлобальныеПараметры_ПоУмолчанию", 		ГлобальныеПараметры_ПоУмолчанию, 		"");
	//ЛокЯдро_СохранитьЗначениеКэшируемойНастройки("ГлобальныеПараметры_Пользовательские", 	ГлобальныеПараметры_Пользовательские, 	"");
	
КонецПроцедуры

// Вызывает из модуля обработки функцию получения информации совместимости интеграционной обработки
//
// Возвращаемое значение:
//	- Структура - содержит:	
//		* ВерсияИнтеграции - Строка
//		* ВерсияAPI - Строка
//		* ПоддерживаемаяКонфигурацияМассивИмен - Массив из Строка
//		* ПоддерживаемаяКонфигурацияСиноним - Строка
//		* флСоответствуетКонфигурации - Булево
//		* ПоддерживаемыеВерсииКонфигурации - Строка
//		* флСоответствуетВерсии - Булево
//		* ПутьКФайлу - Строка
//	- Неопределено - если информацию совместимости получить не удалось
&НаКлиенте
Функция ЛокЯдро_ПолучитьИнформациюСовместимости() Экспорт
	
	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода", "Функция");
	СтруктураВызова.Вставить("ИмяМетода", "ПолучитьИнформациюСовместимости");
	ИнформацияСовместимости = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,,АдресаПеременных);
	Возврат ИнформацияСовместимости
	
КонецФункции

// Вызывает функцию подключения к базе Mobile Smarts.
// Если требуется авторизация, открывает форму авторизации ФормаСлужебная_АвторизацииSMARTS (ОФ_ФормаСлужебная_АвторизацииSMARTS)
//
// Параметры:
//	СтруктураПодключения - Структура - структура подключения к базе Mobile Smarts
//  Переподключиться - Булево - определяет необходимость явного переподключения к базе Mobile Smarts
//  ТипБазы - Строка - "Частная", "Временная", "Основная"
//	Компонента - Строка - указывается сторона, где установлена компонента для работы с базой Mobile SMARTS
//  Интерактивно - Булево - флаг работы в интерактивном режиме
//	ОписаниеОповещения - ОписаниеОповещения - описание оповещения, обработку которого необходимо выполнить при закрытии формы авторизации
//  СохранятьАвторизацию - Булево - флаг необходимости сохранения данных авторизации
//
// Возвращаемое значение:
//	- Структура - если необходима авторизация в интерактивном режиме - содержит:
//  	* Статус - Строка	
//      * СтрокаПодключения - Строка
//      * ИмяБазы - Строка
//      * Логин - Строка
//      * ТипБазы - Строка
//      * ДопПараметры - Структура - содержит:
//			** СтрокаПодключения - Строка
//          ** ТипБазы - Строка
//          ** СтруктураПодключения - Структура - структура подключения к базе Mobile Smarts
//          ** СохранятьАвторизацию - Булево
//          ** ИмяБазы - Строка
//			** Логин - Строка
//	- Булево - результат проверки соединения с подключенной базой Mobile Smarts
&НаКлиенте
Процедура ЛокЯдро_ПодключитьсяКБазеSMARTS(СтруктураПодключения, Переподключиться = Ложь, ТипБазы = "Основная", Компонента = Неопределено, Интерактивно = Ложь, ОписаниеОповещения = Неопределено, СохранятьАвторизацию = Ложь, НеПроверятьАвторизацию = Ложь) Экспорт
	
	Если ТипЗнч(СтруктураПодключения) <> Тип("Структура") Тогда
		Если ОписаниеОповещения <> Неопределено Тогда
			ВыполнитьОбработкуОповещения(ОписаниеОповещения,Ложь);	
		КонецЕсли;
		Возврат;
	КонецЕсли;
	
	Если Компонента = Неопределено Тогда
		РасположениеКомпоненты = ЛокЯдро_ПолучитьДанныеИзХранилища1С("Cleverence_РасположениеКомпоненты");
	Иначе
		РасположениеКомпоненты = Компонента;	
	КонецЕсли;
	
	ТипБазы = СтруктураПодключения.ТипБазы;
	Если СтруктураПодключения.Свойство("ТипИнтерфейса")
		И ЗначениеЗаполнено(СтруктураПодключения.ТипИнтерфейса) Тогда
		ТипИнтерфейса = СтруктураПодключения.ТипИнтерфейса;
	Иначе
		ТипИнтерфейса = ЛокЯдро_ПолучитьТипИнтерфейса(ТипБазы); // ТипИнтерфейса = КомЯдро_ПолучитьЗначениеПеременной("ТипИнтерфейса");
	КонецЕсли;
	
	ЭтоREST_API = ТипИнтерфейса = "REST_API";	
		
	Если ЭтоREST_API Тогда
		Если ТипБазы = "Частная" Тогда
			КлючПеременной = "REST_API_СтруктураПодключенияЧастнойБазыMS";
		ИначеЕсли ТипБазы = "Временная" Тогда
			КлючПеременной = "REST_API_СтруктураПодключенияВременнойБазыMS";
		Иначе
			КлючПеременной = "REST_API_СтруктураПодключенияБазыMS";
		КонецЕсли;
		
		КомЯдро_СохранитьЗначениеПеременной(КлючПеременной,СтруктураПодключения);
	Иначе
		Если ТипБазы = "Частная" Тогда
			КлючПеременной = "СтруктураПодключенияЧастнойБазыMS";
		ИначеЕсли ТипБазы = "Временная" Тогда
			КлючПеременной = "СтруктураПодключенияВременнойБазыMS";
		Иначе
			КлючПеременной = "СтруктураПодключенияБазыMS";
		КонецЕсли;
		
		КомЯдро_СохранитьЗначениеПеременной(КлючПеременной,СтруктураПодключения);
	КонецЕсли;
	
	Если Компонента = "НаСервере" Тогда
		ПараметрыМетода = Новый Структура;
		ПараметрыМетода.Вставить("СтруктураПодключения", 	СтруктураПодключения);
		ПараметрыМетода.Вставить("Переподключиться", 		Переподключиться);
		ПараметрыМетода.Вставить("ТипБазы", 				СтруктураПодключения.ТипБазы);
		ПараметрыМетода.Вставить("Интерактивно", 			Интерактивно);		
		ПараметрыМетода.Вставить("НеПроверятьАвторизацию",	НеПроверятьАвторизацию);
		
		СтруктураВызова = Новый Структура;
		СтруктураВызова.Вставить("ТипМетода", 		"Функция");
		СтруктураВызова.Вставить("ИмяМетода", 		"ПодключитьсяКБазеSMARTS");
		СтруктураВызова.Вставить("ПараметрыМетода", ПараметрыМетода);
		РезультатПодключения = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,,АдресаПеременных);
	Иначе
		Если ЭтоREST_API Тогда
			РезультатПодключения = REST_API_ПодключитьсяКБазеSMARTS(СтруктураПодключения, Интерактивно, НеПроверятьАвторизацию);
		Иначе
			РезультатПодключения = КомЯдро_ПодключитьсяКБазеSMARTS(СтруктураПодключения, Переподключиться, ТипБазы, Компонента, СохранятьАвторизацию, Интерактивно);
		КонецЕсли;
	КонецЕсли;

	Если РезультатПодключения = Истина Тогда
		Если ОписаниеОповещения <> Неопределено Тогда
			ВыполнитьОбработкуОповещения(ОписаниеОповещения,Истина);	
		КонецЕсли;
	ИначеЕсли ТипЗнч(РезультатПодключения) = Тип("Строка") Тогда
		Оповестить("ОшибкаАвторизацииПоTempUid", РезультатПодключения);
		
		Если ОписаниеОповещения <> Неопределено Тогда
			ВыполнитьОбработкуОповещения(ОписаниеОповещения, Ложь);	
		КонецЕсли;
		Возврат;
	ИначеЕсли ТипЗнч(РезультатПодключения) = Тип("Структура") Тогда
		
		ДопПараметры = РезультатПодключения.ДопПараметры;
		
		#Если ТолстыйКлиентОбычноеПриложение Тогда      
			ФормаСлужебная_АвторизацииSMARTS = ЭтаФорма.ВладелецФормы.ПолучитьФорму("ОФ_ФормаСлужебная_АвторизацииSMARTS",ЭтаФорма);
		#Иначе
			ФормаСлужебная_АвторизацииSMARTS = ПолучитьФорму(ПолноеИмяОбъекта + ".Форма.ФормаСлужебная_АвторизацииSMARTS", , ЭтаФорма, ЭтаФорма);
			ФормаСлужебная_АвторизацииSMARTS.РежимОткрытияОкна = РежимОткрытияОкнаФормы.БлокироватьВесьИнтерфейс;
		#КонецЕсли

		ФормаСлужебная_АвторизацииSMARTS.ЗакрыватьПриЗакрытииВладельца 	= Истина;
		ФормаСлужебная_АвторизацииSMARTS._ЛокКонтекст 					= ЭтаФорма;
		ФормаСлужебная_АвторизацииSMARTS.Компонента 					= Компонента;
		ФормаСлужебная_АвторизацииSMARTS.СтрокаПодключения 				= ДопПараметры.СтрокаПодключения;
		ФормаСлужебная_АвторизацииSMARTS.ИмяБазы 						= РезультатПодключения.ИмяБазы;
		ФормаСлужебная_АвторизацииSMARTS.Логин 							= РезультатПодключения.Логин;
		ФормаСлужебная_АвторизацииSMARTS.ОписаниеОповещенияОЗакрытии 	= ОписаниеОповещения;
		ФормаСлужебная_АвторизацииSMARTS.ВидимостьКнопкиЗапомнить 		= Истина;
		ФормаСлужебная_АвторизацииSMARTS.ТипБазы 						= ТипБазы;
		ФормаСлужебная_АвторизацииSMARTS.ТипИнтерфейса 					= ТипИнтерфейса;
		ФормаСлужебная_АвторизацииSMARTS.ДопПараметры 					= ДопПараметры;
		ФормаСлужебная_АвторизацииSMARTS.ТекстОшибки					= РезультатПодключения.ТекстОшибки;
		
		#Если ТолстыйКлиентОбычноеПриложение Тогда
			ФормаСлужебная_АвторизацииSMARTS.ОткрытьМодально();
		#Иначе
			ФормаСлужебная_АвторизацииSMARTS.Открыть();
		#КонецЕсли
		
		Возврат;
	Иначе
		Если ОписаниеОповещения <> Неопределено Тогда
			ВыполнитьОбработкуОповещения(ОписаниеОповещения,Ложь);	
		КонецЕсли;	
	КонецЕсли;
	
КонецПроцедуры

// Вызывает функцию проверки соединения с базой Mobile Smarts.
// Если требуется авторизация, открывает форму авторизации ФормаСлужебная_АвторизацииSMARTS (ОФ_ФормаСлужебная_АвторизацииSMARTS)
//
// Параметры:
//	СтруктураПодключения - Структура - структура подключения к базе Mobile Smarts
//  Переподключиться - Булево - определяет необходимость явного переподключения к базе Mobile Smarts
//  ТипБазы - Строка - "Частная", "Временная", "Основная"
//	Компонента - Строка - указывается сторона, где установлена компонента для работы с базой Mobile SMARTS
//	СохранятьАвторизацию - Булево - флаг необходимости сохранять данные авторизации
//  Интерактивно - Булево - флаг работы в интерактивном режиме
//  ОписаниеОповещения - ОписаниеОповещения - описание оповещения, обработку которого необходимо выполнить при закрытии формы авторизации
//
// Возвращаемое значение:
//	- Структура - если требуется авторизация в интерактивном режиме - содержит:
//  	* Статус - Строка	
//      * СтрокаПодключения - Строка
//      * ИмяБазы - Строка
//      * Логин - Строка
//      * ТипБазы - Строка
//      * ДопПараметры - Структура - содержит:
//			** СтрокаПодключения - Строка
//          ** ТипБазы - Строка
//          ** СтруктураПодключения - Структура - структура подключения к базе Mobile Smarts
//          ** СохранятьАвторизацию - Булево
//          ** ИмяБазы - Строка
//			** Логин - Строка
//	- Булево - результат проверки соединения с сервером Mobile Smarts
&НаКлиенте
Функция ЛокЯдро_ПроверитьСоединениеССерверомSMARTS(СтруктураПодключения = Неопределено,Переподключиться = Ложь,ТипБазы = "Основная", Компонента = Неопределено,СохранятьАвторизацию=Ложь,Интерактивно=Истина,ОписаниеОповещения = Неопределено) Экспорт
	
	НачалоСобытия = ТекущаяУниверсальнаяДатаВМиллисекундах();
	
	ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации("ЛокЯдро_ПроверитьСоединениеСБазойSMARTS", "Информация", "Начало", НачалоСобытия);
	РезультатПроверки = ЛокЯдро_ПроверитьСоединениеСБазойSMARTS(СтруктураПодключения, Переподключиться, ТипБазы, Компонента, СохранятьАвторизацию, Интерактивно);
	ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации("ЛокЯдро_ПроверитьСоединениеСБазойSMARTS", "Информация", "Конец", НачалоСобытия);
	
	Если РезультатПроверки = Истина Тогда
		СтруктураСменыСтатуса = Новый Структура("Статус, Параметр, Операция", 
			"БезОшибок", 
			"", 
			"ПодключениеКБазеSMARTS");
		Оповестить("СменаСтатуса", СтруктураСменыСтатуса);
		Если ОписаниеОповещения <> Неопределено Тогда
			ВыполнитьОбработкуОповещения(ОписаниеОповещения,Истина);	
		КонецЕсли;
		Возврат Истина;
	ИначеЕсли ТипЗнч(РезультатПроверки) = Тип("Строка") Тогда
		Оповестить("ОшибкаАвторизацииПоTempUid", РезультатПроверки);
		
		Если ОписаниеОповещения <> Неопределено Тогда
			ВыполнитьОбработкуОповещения(ОписаниеОповещения, Ложь);
		КонецЕсли;
		Возврат Ложь;
	ИначеЕсли ТипЗнч(РезультатПроверки) = Тип("Структура") Тогда
		
		ДопПараметры = РезультатПроверки.ДопПараметры;
		
		Если ТипЗнч(СтруктураПодключения) = Тип("Структура")
			И СтруктураПодключения.Свойство("ТипИнтерфейса")
			И ЗначениеЗаполнено(СтруктураПодключения.ТипИнтерфейса) Тогда
			ТипИнтерфейса = СтруктураПодключения.ТипИнтерфейса;
		Иначе
			ТипИнтерфейса = ЛокЯдро_ПолучитьТипИнтерфейса(ТипБазы); // ТипИнтерфейса = КомЯдро_ПолучитьЗначениеПеременной("ТипИнтерфейса");
		КонецЕсли;
		
		#Если ТолстыйКлиентОбычноеПриложение Тогда      
			ФормаСлужебная_АвторизацииSMARTS = ЭтаФорма.ВладелецФормы.Объект.ПолучитьФорму("ОФ_ФормаСлужебная_АвторизацииSMARTS",ЭтаФорма);
		#Иначе
			ФормаСлужебная_АвторизацииSMARTS = ПолучитьФорму(ПолноеИмяОбъекта + ".Форма.ФормаСлужебная_АвторизацииSMARTS", , ЭтаФорма, ЭтаФорма);
			ФормаСлужебная_АвторизацииSMARTS.РежимОткрытияОкна = РежимОткрытияОкнаФормы.БлокироватьВесьИнтерфейс;
		#КонецЕсли
		
		ФормаСлужебная_АвторизацииSMARTS.ЗакрыватьПриЗакрытииВладельца 	= Истина;
		ФормаСлужебная_АвторизацииSMARTS._ЛокКонтекст 					= ЭтаФорма;
		ФормаСлужебная_АвторизацииSMARTS.Компонента 					= Компонента;
		ФормаСлужебная_АвторизацииSMARTS.СтрокаПодключения 				= ДопПараметры.СтрокаПодключения;
		ФормаСлужебная_АвторизацииSMARTS.ИмяБазы 						= РезультатПроверки.ИмяБазы;
		ФормаСлужебная_АвторизацииSMARTS.Логин 							= ?(ДопПараметры.Свойство("Логин"), ДопПараметры.Логин, "");
		ФормаСлужебная_АвторизацииSMARTS.ОписаниеОповещенияОЗакрытии 	= ОписаниеОповещения;
		ФормаСлужебная_АвторизацииSMARTS.ВидимостьКнопкиЗапомнить 		= Истина;
		ФормаСлужебная_АвторизацииSMARTS.ТипБазы 						= ТипБазы;
		ФормаСлужебная_АвторизацииSMARTS.ТипИнтерфейса 					= ТипИнтерфейса;
		ФормаСлужебная_АвторизацииSMARTS.ДопПараметры 					= ДопПараметры;
		ФормаСлужебная_АвторизацииSMARTS.ТекстОшибки					= РезультатПроверки.ТекстОшибки;
		
		#Если ТолстыйКлиентОбычноеПриложение Тогда
			ФормаСлужебная_АвторизацииSMARTS.ОткрытьМодально();
		#Иначе
			ФормаСлужебная_АвторизацииSMARTS.Открыть();
		#КонецЕсли
		
		Возврат Ложь;
	Иначе
		СтруктураСменыСтатуса = Новый Структура("Статус, Параметр, Операция, ТипБазы", 
			"РаботаССерверомБазаНедоступна", 
			СтруктураПодключения, 
			"ПодключениеКБазеSMARTS",
			ТипБазы);
		Оповестить("СменаСтатуса", СтруктураСменыСтатуса);

		Если ОписаниеОповещения <> Неопределено Тогда
			ВыполнитьОбработкуОповещения(ОписаниеОповещения,Ложь);	
		КонецЕсли;
		Возврат Ложь;
	КонецЕсли;	
	
КонецФункции

// Выполняет автоматическое подключение расширений, обработок, отчетов из файлов
//
// Параметры:
//  ПервыйЗапуск - Булево  - признак первого запуска обработки
//	ОбновлятьОсновнуюОбработкуПриПервомЗапуске - Булево - Истина - если обновляется основная обработка
//											   			- Ложь - если обновляются расширения и интеграционная обработка
//											   - Неопределено
//	СтруктураПараметров - Структура - структура со значениями из параметров запуска
//						- Неопределено
&НаКлиенте
Процедура ЛокЯдро_ОбновитьКомпонентыИзПодключеннойБазы(ПервыйЗапуск = Ложь, ОбновлятьОсновнуюОбработкуПриПервомЗапуске = Неопределено, СтруктураПараметров = Неопределено) Экспорт
	
	#Область НесовместимыйКодFresh
	ЭтоВебКлиент 	= Ложь;
	ЭтоТестКлиент 	= Ложь;
	#Если ВебКлиент Тогда
		ЭтоВебКлиент = Истина;
	#КонецЕсли
	Если ТипЗнч(СтруктураПараметров) = Тип("Структура") Тогда
		Если СтруктураПараметров.Свойство("ЭтоТестКлиент") Тогда
			ЭтоТестКлиент = СтруктураПараметров.ЭтоТестКлиент;
		КонецЕсли;
	КонецЕсли;
	
	Если ЭтоВебКлиент Или
		ЭтоТестКлиент Тогда
		Возврат;
	КонецЕсли;
	
	Если ПараметрыПодключенияMS = Неопределено Тогда
		ПараметрыПодключенияMS   = ЛокЯдро_ПолучитьДанныеИзХранилища1С("Cleverence_ПараметрыПодключенияMS");	
	КонецЕсли;
	
	Если ПараметрыПодключенияMS.Свойство("ВерсияПриложения") Тогда
		ВерсияПриложенияАктуальная = ПараметрыПодключенияMS.ВерсияПриложения;
	Иначе
		// Не удалось определить актуальную версию
		Возврат;
	КонецЕсли;
	
	СтруктураПараметровПодключения = Новый Структура;	
	СтруктураПараметровПодключения.Вставить("ВерсияПриложенияАктуальная", 			ВерсияПриложенияАктуальная);
	СтруктураПараметровПодключения.Вставить("ОбновлятьОсновнуюОбработку", 			ОбновлятьОсновнуюОбработкуПриПервомЗапуске);
	СтруктураПараметровПодключения.Вставить("ПроверятьВерсииПриложенийОбработок", 	Ложь);
	
	Если ПервыйЗапуск Тогда
		// При первом запуске не проверяем версию приложения (сборки)
		Если НЕ ОбновлятьОсновнуюОбработкуПриПервомЗапуске = Истина Тогда
			РезультатыПодключенийРасширений = ЛокЯдро_ПодключитьРасширенияАвтоматически(ПервыйЗапуск);
		КонецЕсли;
		ЛокЯдро_ПодключитьФайлыВСправочникДопОтчетовОбработок(ПервыйЗапуск, СтруктураПараметровПодключения);
		
		// Запись в настройки актуальной версии приложения, чтобы при открытии обработки не произошло повторное обновление расширений/обработок
		//ЛокЯдро_СохранитьНастройкуВБазеSMARTS("ВерсияПриложения", ВерсияПриложенияАктуальная);
		//ЛокЯдро_ЗаписатьВКэшНастройкуSMARTS("ВерсияПриложения", ВерсияПриложенияАктуальная);
	Иначе
		// Если запуск не первый, то сравниваем версию приложения (сборки) из базы MS с версией приложения из настроек
		// если версия приложения из настроек меньше, то запускаем обновление расширений/обработок
		
		Если ТипЗнч(ПараметрыПодключенияMS) = Тип("Структура")
			И ПараметрыПодключенияMS.Свойство("ВерсияПриложения") Тогда
			ВерсияПриложенияИзНастроек = ЛокЯдро_ПолучитьИзКэшаНастройкуSMARTS("ВерсияПриложения");
						
			Если ЗначениеЗаполнено(ВерсияПриложенияАктуальная)
				И ВерсияПриложенияАктуальная <> ВерсияПриложенияИзНастроек Тогда
				// Запускаем обновление
				РезультатыПодключенийРасширений = ЛокЯдро_ПодключитьРасширенияАвтоматически(ПервыйЗапуск);
				// Сначала подключаем ИО, т.к. если обновить ИО и ОО вместе может возникнуть необрабатываемая ошибка "Неизвестный идентификатор формы"
				СтруктураПараметровПодключения.Вставить("ОбновлятьОсновнуюОбработку", Ложь);
				ЛокЯдро_ПодключитьФайлыВСправочникДопОтчетовОбработок(ПервыйЗапуск, СтруктураПараметровПодключения);
				// Затем подключаем ОО
				СтруктураПараметровПодключения.Вставить("ОбновлятьОсновнуюОбработку", Истина);
				ЛокЯдро_ПодключитьФайлыВСправочникДопОтчетовОбработок(ПервыйЗапуск, СтруктураПараметровПодключения);
				
				// Запись в настройки актуальной версии приложения
				//ЛокЯдро_СохранитьНастройкуВБазеSMARTS("ВерсияПриложения", ВерсияПриложенияАктуальная);
				//ЛокЯдро_ЗаписатьВКэшНастройкуSMARTS("ВерсияПриложения", ВерсияПриложенияАктуальная);
			ИначеЕсли ВерсияПриложенияАктуальная = ВерсияПриложенияИзНастроек Тогда
				// Проверка версий приложений, для которых были получены ОО и ИО
				СтруктураПараметровПодключения.Вставить("ПроверятьВерсииПриложенийОбработок", 	Истина);
				СтруктураПараметровПодключения.Вставить("НеОбновлятьВерсиюПриложения", 			Истина); // Версия приложения из настроек уже актуальна
				// Сначала подключаем ИО, т.к. если обновить ИО и ОО вместе может возникнуть необрабатываемая ошибка "Неизвестный идентификатор формы"
				СтруктураПараметровПодключения.Вставить("ОбновлятьОсновнуюОбработку", Ложь);
				ЛокЯдро_ПодключитьФайлыВСправочникДопОтчетовОбработок(ПервыйЗапуск, СтруктураПараметровПодключения);
				// Затем подключаем ОО
				СтруктураПараметровПодключения.Вставить("ОбновлятьОсновнуюОбработку", Истина);
				ЛокЯдро_ПодключитьФайлыВСправочникДопОтчетовОбработок(ПервыйЗапуск, СтруктураПараметровПодключения);
			КонецЕсли;

		КонецЕсли;
		
	КонецЕсли;
	#КонецОбласти //НесовместимыйКодFresh
	
КонецПроцедуры

// Выполняет автоматическое подключение расширений
//
// Параметры:
//  ПервыйЗапуск 	- Булево  - признак первого запуска обработки
//
// Возвращаемое значение:
//   Массив   - см. описание ГлЯдро_ПодключитьРасширения
//	 Неопределено - если не требуется загрузка расширений
//
&НаКлиенте
Функция ЛокЯдро_ПодключитьРасширенияАвтоматически(ПервыйЗапуск = Ложь) Экспорт
	
	#Область НесовместимыйКодFresh
	ИмяСобытия = "ЛокЯдро_ПодключитьРасширенияАвтоматически";
	
	РезультатыПодключений = Новый Массив;
	
	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода", "Функция");
	СтруктураВызова.Вставить("ИмяМетода", "ПолучитьИмяКонфигурации");
	
	ИмяКонфигурации = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова);
	
	ЭтоБазоваяВерсия = ЛокЯдро_СтрНайти(ВРег(ИмяКонфигурации), "БАЗОВАЯ") <> 0;
	
	Если ЭтоБазоваяВерсия Тогда
		// В базовые версии не подключаем расширения
		ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Предупреждение", "В базовую версию запрещено подключение расширений");
		Возврат РезультатыПодключений;
	КонецЕсли;
					
	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода", "Функция");
	СтруктураВызова.Вставить("ИмяМетода", "ПолучитьСтруктуруИменРасширений");
	
	СтруктураИменРасширений = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова);
	
	МассивИменПодключаемыхФайлов = Новый Массив;
	
	СтруктураВерсийПоУмолчанию = Новый Структура;
	
	Для каждого ЭлементСтруктуры Из СтруктураИменРасширений Цикл
		// 13.11.2020. Закомментировал механизм сравнения версий по умолчанию и версий из настроек.
		//ИмяНастройкиПоУмолчанию = "ВерсияРасширения_" + ЭлементСтруктуры.Значение + "_ПоУмолчанию";
		//ЗначениеНастройкиПоУмолчанию = ЛокЯдро_ПолучитьИзКэшаНастройкуSMARTS(ИмяНастройкиПоУмолчанию);
		//ЗначениеНастройкиПоУмолчанию = ?(ТипЗнч(ЗначениеНастройкиПоУмолчанию) <> Тип("Строка"), "0.0.0.0", ЗначениеНастройкиПоУмолчанию);
		//			
		//ИмяНастройки = "ВерсияРасширения_" + ЭлементСтруктуры.Значение;
		//ЗначениеНастройки = ЛокЯдро_ПолучитьИзКэшаНастройкуSMARTS(ИмяНастройки);
		////Новые расширения подключаются только при первом запуске.
		////Если в базе не подключено расширение, то нет необходимости его добавлять,
		////для этого установим высокую версию подключенного расширения, чтобы сымитировать, что актуализация не требуется
		//Если ТипЗнч(ЗначениеНастройки) <> Тип("Строка") Или ЗначениеНастройки = "0.0.0.0" Тогда
		//	ЗначениеНастройки = "999.999.999.999";
		//КонецЕсли;
		//
		//РезультатСравнения = ЛокЯдро_СравнитьВерсии(ЗначениеНастройкиПоУмолчанию, ЗначениеНастройки);
		//
		//Если РезультатСравнения > 0 Тогда
		//	//Если в папке MS файл расширения имеет версию больше, чем подключенное в базу 1с расширения, то необходима актуализация
		//	МассивИменПодключаемыхФайлов.Добавить(ЭлементСтруктуры.Значение);
		//КонецЕсли;
		
		Если ПервыйЗапуск Тогда
			// При первом запуске не выполняем дополнительных проверок при подключении расширений
			МассивИменПодключаемыхФайлов.Добавить(ЭлементСтруктуры.Значение);
		Иначе
			// Теперь проверяем только наличие настройки версии из настроек. Это значит, что расширение уже было подключено ранее
			// Если настройка есть, то добавляем в массив подключаемых файлов
			ИмяНастройки = "ВерсияРасширения_" + ЭлементСтруктуры.Значение;
			ЗначениеНастройки = ЛокЯдро_ПолучитьИзКэшаНастройкуSMARTS(ИмяНастройки);
			Если ЗначениеНастройки <> Ложь
				И ЗначениеНастройки <> "0.0.0.0" Тогда
				МассивИменПодключаемыхФайлов.Добавить(ЭлементСтруктуры.Значение);
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Если МассивИменПодключаемыхФайлов.Количество() = 0 Тогда
		//Нечего подключать
		Возврат Неопределено;
	КонецЕсли;
	
	РабочийКаталог = ?(ПараметрыПодключенияMS.Свойство("РабочийКаталог"), ПараметрыПодключенияMS.РабочийКаталог, "");
	
	КаталогОсновнойОбработки = "";
	#Если НЕ ТолстыйКлиентОбычноеПриложение Тогда
		КаталогОсновнойОбработки = ЛокЯдро_ПолучитьРабочийКаталогОсновнойОбработки(ИспользуемоеИмяФайла);
	#КонецЕсли
	
	КаталогиПоискаРасширений = Новый Массив;
	Если ЗначениеЗаполнено(РабочийКаталог) Тогда
		КаталогиПоискаРасширений.Добавить(РабочийКаталог);
	КонецЕсли;
	Если ЗначениеЗаполнено(КаталогОсновнойОбработки) Тогда
		КаталогиПоискаРасширений.Добавить(КаталогОсновнойОбработки);
	КонецЕсли;
	
	Если КаталогиПоискаРасширений.Количество() Тогда
		
		МассивФайловРасширений = Новый Массив;
		ИменаФайловРасширений  = Новый Массив;
		
		//Поиск расширений в папке базы MS и каталоге основной обработки
		Для каждого КаталогПоиска ИЗ КаталогиПоискаРасширений Цикл
		
			МассивФайлов = НайтиФайлы(КаталогПоиска, "*.cfe", Истина);
			
			Для Каждого Файл Из МассивФайлов Цикл
				
				ИмяБезРасширения = Файл.ИмяБезРасширения;
				
				Если МассивИменПодключаемыхФайлов.Найти(ИмяБезРасширения) = Неопределено Тогда
					Продолжить;
				КонецЕсли;
				
				Если ИменаФайловРасширений.Найти(ИмяБезРасширения) <> Неопределено Тогда
					Продолжить;
				КонецЕсли;
				
				ДвоичныеДанные = Новый ДвоичныеДанные(Файл.ПолноеИмя);
				
				СтруктураФайлаРасширения = Новый Структура;
				
				СтруктураФайлаРасширения.Вставить("Имя", 		Файл.Имя);
				СтруктураФайлаРасширения.Вставить("Хранение", 	ПоместитьВоВременноеХранилище(ДвоичныеДанные, Новый УникальныйИдентификатор));
				
				МассивФайловРасширений.Добавить(СтруктураФайлаРасширения);
				ИменаФайловРасширений.Добавить(ИмяБезРасширения);
				
			КонецЦикла;
			
		КонецЦикла;
		
	КонецЕсли;
		
	РезультатыПодключений = ЛокЯдро_ПодключитьРасширенияАвтоматическиЗавершение(МассивФайловРасширений);
	
	Возврат РезультатыПодключений;
	#КонецОбласти //НесовместимыйКодFresh
	
КонецФункции

// Выполняет завершение автоматического подключения расширений
//
// Параметры:
//  МассивФайловРасширений  - Массив - массив, содержащий элементы ОписаниеПереданногоФайла либо структуры, 
//										в которых обязательно должны быть ключи: Хранение - адрес файла в хранилище, Имя - имя файла
//
// Возвращаемое значение:
//   Массив   - см. описание ГлЯдро_ПодключитьРасширения 
//
&НаКлиенте
Функция ЛокЯдро_ПодключитьРасширенияАвтоматическиЗавершение(МассивФайловРасширений) Экспорт
	
	ИмяСобытия = "ЛокЯдро_ПодключитьРасширенияАвтоматическиЗавершение";
	
	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода", "Функция");
	СтруктураВызова.Вставить("ИмяМетода", "ПодключитьРасширенияАвтоматическиЗавершение");
	СтруктураВызова.Вставить("ПараметрыМетода", Новый Структура("МассивФайловРасширений, АдресаПеременных", МассивФайловРасширений, АдресаПеременных));
	
	РезультатыПодключений = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова);
	
	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода", "Функция");
	СтруктураВызова.Вставить("ИмяМетода", "ПолучитьСтруктуруИменРасширений");
	
	СтруктураИменРасширений = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова);
	
	Для каждого РезультатПодключения Из РезультатыПодключений Цикл
		
		ИмяРасширения = РезультатПодключения.ИмяРасширения;
		
		Если РезультатПодключения.Подключено Тогда
			
			Версия = РезультатПодключения.Версия;

			//Сохранение версии в настройки
			ЛокЯдро_СохранитьНастройкуВБазеSMARTS("ВерсияРасширения_" + ИмяРасширения, Версия);
			
			ТекстИнформации = "Подключено расширение " + РезультатПодключения.ИмяРасширения;
			ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", ТекстИнформации);
			
		КонецЕсли;
				
		Если ИмяРасширения = СтруктураИменРасширений.РасширениеСКнопкамиОбмена И РезультатПодключения.Подключено Тогда
			
			//Здесь можно выполнить какие-либо действия после успешного подключения расширения
			РезультатВыполния = ЛокЯдро_ВыполнитьДействияПослеПодключенияРасширения(ИмяРасширения, СтруктураИменРасширений, АдресаПеременных);
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат РезультатыПодключений;
	
КонецФункции

// Выполняет дополнительные действия, после подключения расширения
//
// Параметры:
//  ИмяРасширения  			- Строка  - имя расширения
// 	СтруктураИменРасширений - Структура - структура
//
&НаКлиенте
Функция ЛокЯдро_ВыполнитьДействияПослеПодключенияРасширения(ИмяРасширения, СтруктураИменРасширений, АдресаПеременных) Экспорт

	//Здесь можно выполнить код после подключения расширения
	
КонецФункции

// Подключение файлов в справочник дополнительных отчетов и обработок
//
// Параметры:
//  ПервыйЗапуск 				   - Булево  - признак первого запуска обработки
//  СтруктураПараметровПодключения - Структура
&НаКлиенте
Процедура ЛокЯдро_ПодключитьФайлыВСправочникДопОтчетовОбработок(ПервыйЗапуск = Ложь, СтруктураПараметровПодключения = Неопределено) Экспорт
	
	#Область НесовместимыйКодFresh
	#Если ВебКлиент Тогда
		Возврат;
	#КонецЕсли
	
	ИмяСобытия = "ЛокЯдро_ПодключитьФайлыВСправочникДопОтчетовОбработок";
	
	ИмяОсновнойОбработки 		= "КлеверенсТСД_ОсновнаяОбработка.epf";
	ИмяИнтеграционнойОбработки 	= ПараметрыПодключенияMS.ИмяИнтеграционнойОбработки;
	ИмяИнтеграционнойОбработки 	= ?(Найти(ИмяИнтеграционнойОбработки, ".epf") = 0, ИмяИнтеграционнойОбработки + ".epf", ИмяИнтеграционнойОбработки);	
	//Параметры для определения версий обработок
	ИмяПараметраНастройкиОО 	= "ОсновнаяОбработка";
	ИмяПараметраНастройкиИО 	= "ИнтеграционнаяОбработка";
	
	ВерсияПриложенияАктуальная 			= Ложь;
	ОбновлятьОсновнуюОбработку 			= Неопределено;
	ПроверятьВерсииПриложенийОбработок 	= Ложь;
	НеОбновлятьВерсиюПриложения 		= Ложь;
	РабочийКаталог						= "";
	Если ТипЗнч(СтруктураПараметровПодключения) = Тип("Структура") Тогда
		Если СтруктураПараметровПодключения.Свойство("ВерсияПриложенияАктуальная") Тогда
			ВерсияПриложенияАктуальная = СтруктураПараметровПодключения.ВерсияПриложенияАктуальная;
		КонецЕсли;
		Если СтруктураПараметровПодключения.Свойство("ОбновлятьОсновнуюОбработку") Тогда
			ОбновлятьОсновнуюОбработку = СтруктураПараметровПодключения.ОбновлятьОсновнуюОбработку;
		КонецЕсли;
		Если СтруктураПараметровПодключения.Свойство("ПроверятьВерсииПриложенийОбработок") Тогда
			ПроверятьВерсииПриложенийОбработок = СтруктураПараметровПодключения.ПроверятьВерсииПриложенийОбработок;
		КонецЕсли;
		Если СтруктураПараметровПодключения.Свойство("НеОбновлятьВерсиюПриложения") Тогда
			НеОбновлятьВерсиюПриложения = СтруктураПараметровПодключения.НеОбновлятьВерсиюПриложения;
		КонецЕсли;
		Если СтруктураПараметровПодключения.Свойство("РабочийКаталог") Тогда
			РабочийКаталог = СтруктураПараметровПодключения.РабочийКаталог;
		КонецЕсли;
	КонецЕсли;
	
	// Необходимо отключать автообновление ОО при запуске автотестов
	Если Найти(ПараметрЗапуска, "КлеверенсАвтотесты") Тогда
		ОбновлятьОсновнуюОбработку = Ложь;
	КонецЕсли;
	
	МассивИменПодключаемыхФайлов = Новый Массив;

	Если ПервыйЗапуск Тогда
		
		ОтключатьКонфликтующие 						= Истина;
		ДобавитьВБыстрыйДоступТекПользователя 		= Истина;
		ПеренестиБыстрыйДоступИзПредыдущейВерсии 	= Ложь;
		ДобавитьВоВсеРазделы 						= Истина;
		ПеренестиРазделыИзПредыдущейВерсии 			= Ложь;
		
		//Подключаем основную и интеграционную обработки
		Если НЕ ОбновлятьОсновнуюОбработку = Ложь Тогда
			МассивИменПодключаемыхФайлов.Добавить(ИмяОсновнойОбработки);
		КонецЕсли;
		Если НЕ ОбновлятьОсновнуюОбработку = Истина Тогда
			МассивИменПодключаемыхФайлов.Добавить(ИмяИнтеграционнойОбработки);
		КонецЕсли;
		
	Иначе
		
		ОтключатьКонфликтующие 						= Истина;
		ДобавитьВБыстрыйДоступТекПользователя 		= Ложь;
		ПеренестиБыстрыйДоступИзПредыдущейВерсии 	= Истина;
		ДобавитьВоВсеРазделы 						= Ложь;
		ПеренестиРазделыИзПредыдущейВерсии 			= Истина;
		
		МассивПараметровФайлов = Новый Массив;
		Если ОбновлятьОсновнуюОбработку = Истина Тогда
			МассивПараметровФайлов.Добавить(Новый Структура("ИмяФайла, ИмяПараметраНастройки", ИмяОсновнойОбработки, ИмяПараметраНастройкиОО));
		ИначеЕсли ОбновлятьОсновнуюОбработку = Ложь Тогда
			МассивПараметровФайлов.Добавить(Новый Структура("ИмяФайла, ИмяПараметраНастройки", ИмяИнтеграционнойОбработки, ИмяПараметраНастройкиИО));
		Иначе
			МассивПараметровФайлов.Добавить(Новый Структура("ИмяФайла, ИмяПараметраНастройки", ИмяОсновнойОбработки, ИмяПараметраНастройкиОО));
			МассивПараметровФайлов.Добавить(Новый Структура("ИмяФайла, ИмяПараметраНастройки", ИмяИнтеграционнойОбработки, ИмяПараметраНастройкиИО));
		КонецЕсли;
		
		//Определение актуальности версий
		Для Каждого СтруктураПараметровФайла Из МассивПараметровФайлов Цикл
			
			ИмяФайла 				= СтруктураПараметровФайла.ИмяФайла;
			ИмяПараметраНастройки 	= СтруктураПараметровФайла.ИмяПараметраНастройки;
			
			// 13.11.2020. Закомментировал механизм сравнения версий по умолчанию и версий из настроек.
			////Получение версии обработки, находящейся в папке базы MS
			//ИмяНастройкиПоУмолчанию = "ВерсияОбработки_" + ИмяПараметраНастройки + "_ПоУмолчанию";
			//ЗначениеНастройкиПоУмолчанию = ЛокЯдро_ПолучитьИзКэшаНастройкуSMARTS(ИмяНастройкиПоУмолчанию);
			//ЗначениеНастройкиПоУмолчанию = ?(ТипЗнч(ЗначениеНастройкиПоУмолчанию) <> Тип("Строка"), "0.0.0.0", ЗначениеНастройкиПоУмолчанию);
			//
			////Получение версии обработки, подключенной в базе 1с
			//ИмяНастройки = "ВерсияОбработки_" + ИмяПараметраНастройки;
			//ЗначениеНастройки = ЛокЯдро_ПолучитьИзКэшаНастройкуSMARTS(ИмяНастройки);
			////Новые файлы подключаются только при первом запуске.
			////Если в базу не подключена обработка/отчет, то нет необходимости ее добавлять,
			////для этого установим высокую версию подключенной обработки/отчета, чтобы сымитировать, что актуализация не требуется
			//Если ТипЗнч(ЗначениеНастройки) <> Тип("Строка") Или ЗначениеНастройки = "0.0.0.0" Тогда
			//	ЗначениеНастройки = "999.999.999.999";
			//КонецЕсли;
			//
			//РезультатСравнения = ЛокЯдро_СравнитьВерсии(ЗначениеНастройкиПоУмолчанию, ЗначениеНастройки);
			//
			//Если РезультатСравнения > 0 Тогда
			//	//Если в папке MS файл обработки имеет версию больше, чем подключенная в базу 1с обработка, то необходима актуализация
			//	МассивИменПодключаемыхФайлов.Добавить(ИмяФайла);				
			//КонецЕсли;
			
			//// Теперь проверяем только наличие настройки версии из настроек. Это значит, что обработка уже была подключена ранее
			//// Если настройка есть, то добавляем в массив подключаемых файлов
			//ИмяНастройки = "ВерсияОбработки_" + ИмяПараметраНастройки;
			//ЗначениеНастройки = ЛокЯдро_ПолучитьИзКэшаНастройкуSMARTS(ИмяНастройки);
			//Если ЗначениеНастройки <> Ложь
			//	И ЗначениеНастройки <> "0.0.0.0" Тогда
				Если ПроверятьВерсииПриложенийОбработок Тогда
					ИмяНастройки = "ВерсияПриложения_" + ИмяПараметраНастройки;
					ЗначениеНастройки = ЛокЯдро_ПолучитьИзКэшаНастройкуSMARTS(ИмяНастройки);
					Если ЗначениеНастройки <> ВерсияПриложенияАктуальная Тогда
						МассивИменПодключаемыхФайлов.Добавить(ИмяФайла);
					КонецЕсли;
				Иначе
					МассивИменПодключаемыхФайлов.Добавить(ИмяФайла);
				КонецЕсли;
			//КонецЕсли;

		КонецЦикла;
				
	КонецЕсли;

	Если НЕ ЗначениеЗаполнено(РабочийКаталог) Тогда
		РабочийКаталог = ?(ПараметрыПодключенияMS.Свойство("РабочийКаталог"), ПараметрыПодключенияMS.РабочийКаталог, "");
	КонецЕсли;
	
	ДопПараметры = Новый Структура;
	ДопПараметры.Вставить("РабочийКаталог", 							РабочийКаталог);
	ДопПараметры.Вставить("ИмяСобытия", 								ИмяСобытия);
	ДопПараметры.Вставить("МассивИменПодключаемыхФайлов", 				МассивИменПодключаемыхФайлов);
	ДопПараметры.Вставить("ОтключатьКонфликтующие", 					ОтключатьКонфликтующие);
	ДопПараметры.Вставить("ДобавитьВБыстрыйДоступТекПользователя", 		ДобавитьВБыстрыйДоступТекПользователя);
	ДопПараметры.Вставить("ПеренестиБыстрыйДоступИзПредыдущейВерсии", 	ПеренестиБыстрыйДоступИзПредыдущейВерсии);
	ДопПараметры.Вставить("ДобавитьВоВсеРазделы", 						ДобавитьВоВсеРазделы);
	ДопПараметры.Вставить("ПеренестиРазделыИзПредыдущейВерсии", 		ПеренестиРазделыИзПредыдущейВерсии);	
	ДопПараметры.Вставить("ИмяИнтеграционнойОбработки", 				ИмяИнтеграционнойОбработки);
	ДопПараметры.Вставить("ВерсияПриложенияАктуальная",					ВерсияПриложенияАктуальная);        
	ДопПараметры.Вставить("ИмяОсновнойОбработки",						ИмяОсновнойОбработки);        
	ДопПараметры.Вставить("ИмяПараметраНастройкиОО",					ИмяПараметраНастройкиОО);        
	ДопПараметры.Вставить("ИмяПараметраНастройкиИО",					ИмяПараметраНастройкиИО);        
	ДопПараметры.Вставить("НеОбновлятьВерсиюПриложения",				НеОбновлятьВерсиюПриложения);
	
	Если Не ПустаяСтрока(РабочийКаталог) Тогда
		УказанныйКаталог = Новый Файл(РабочийКаталог);		
		УказанныйКаталогСуществует = УказанныйКаталог.Существует();
		ЛокЯдро_ПодключитьФайлыВСправочникДопОтчетовОбработокЗавершение(УказанныйКаталогСуществует, ДопПараметры);
	Иначе
		ЛокЯдро_ПодключитьФайлыВСправочникДопОтчетовОбработокЗавершение(Ложь, ДопПараметры);
	КонецЕсли;
	#КонецОбласти //НесовместимыйКодFresh
	
КонецПроцедуры

&НаКлиенте
Процедура ЛокЯдро_ПодключитьФайлыВСправочникДопОтчетовОбработокЗавершение(Существует, ДополнительныеПараметры) Экспорт

	#Область НесовместимыйКодFresh
	ЕстьКаталог = Ложь;
	
	Если Существует Тогда	
		РабочийКаталог = ДополнительныеПараметры.РабочийКаталог;		
		ЕстьКаталог = Истина;
	Иначе
		Если ЗначениеЗаполнено(ДополнительныеПараметры.РабочийКаталог) Тогда
			ТекстСообщения = "Не удалось найти каталог с файлами: " + ДополнительныеПараметры.РабочийКаталог;
			ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ДополнительныеПараметры.ИмяСобытия, "Информация", ТекстСообщения);
		КонецЕсли;		
	КонецЕсли;                                      	

	МассивПараметровПодключаемыхФайлов = Новый Массив;
	
	Если ЕстьКаталог Тогда
	
		Для каждого ИмяФайла Из ДополнительныеПараметры.МассивИменПодключаемыхФайлов Цикл
		
			МассивФайлов = НайтиФайлы(РабочийКаталог, ИмяФайла, Истина);
			
			Если МассивФайлов.Количество() <> 0 Тогда
				
				ФайлОбработки = МассивФайлов[0];
				ПутьОбработки = ФайлОбработки.ПолноеИмя;
				ДвоичныеДанные = Новый ДвоичныеДанные(ПутьОбработки);
				АдресОбработки = ПоместитьВоВременноеХранилище(ДвоичныеДанные, Новый УникальныйИдентификатор);
				
				СтруктураПараметров = Новый Структура;
				СтруктураПараметров.Вставить("АдресФайла", 									АдресОбработки);
				СтруктураПараметров.Вставить("ИмяФайла", 									ИмяФайла);
				СтруктураПараметров.Вставить("ОтключатьКонфликтующие", 						ДополнительныеПараметры.ОтключатьКонфликтующие);
				СтруктураПараметров.Вставить("ДобавитьВБыстрыйДоступТекПользователя", 		ДополнительныеПараметры.ДобавитьВБыстрыйДоступТекПользователя);
				СтруктураПараметров.Вставить("ПеренестиБыстрыйДоступИзПредыдущейВерсии", 	ДополнительныеПараметры.ПеренестиБыстрыйДоступИзПредыдущейВерсии);
				СтруктураПараметров.Вставить("ДобавитьВоВсеРазделы", 						ДополнительныеПараметры.ДобавитьВоВсеРазделы);
				СтруктураПараметров.Вставить("ПеренестиРазделыИзПредыдущейВерсии", 			ДополнительныеПараметры.ПеренестиРазделыИзПредыдущейВерсии);
				СтруктураПараметров.Вставить("ИмяОсновнойОбработки", 						ДополнительныеПараметры.ИмяОсновнойОбработки);
				СтруктураПараметров.Вставить("ИмяИнтеграционнойОбработки", 					ИмяИнтеграционнойОбработки);
				СтруктураПараметров.Вставить("ВерсияПриложенияАктуальная",					ДополнительныеПараметры.ВерсияПриложенияАктуальная);
				СтруктураПараметров.Вставить("НеОбновлятьВерсиюПриложения",					ДополнительныеПараметры.НеОбновлятьВерсиюПриложения);
				
				МассивПараметровПодключаемыхФайлов.Добавить(СтруктураПараметров);
				
				Если ИмяФайла = ИмяИнтеграционнойОбработки Тогда
					// Устанавливка для главной формы режима перед подключением ИО, т.к. само подключение ИО происходит на сервере, а Оповестить работает с клиента
					СтруктураСменыСтатуса = Новый Структура("Статус, Параметр, Операция", 
						"НачалоПодключенияИнтеграционнойОбработкиСообщениеБезопасности", 
						"", 
						"ПодключениеИО");
					Оповестить("СменаСтатуса", СтруктураСменыСтатуса);
				КонецЕсли;
				
			Иначе
				
				ТекстСообщения = "Не удалось найти файл: " + ИмяФайла;
				ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ДополнительныеПараметры.ИмяСобытия, "Информация", ТекстСообщения);
				
			КонецЕсли;
		
		КонецЦикла;
		
	КонецЕсли;

	ПерезаписатьНастройки1С = Ложь;
		
	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода", 		"Функция");
	СтруктураВызова.Вставить("ИмяМетода", 		"ПодключитьФайлыВСправочникДополнительныхОтчетовИОбработок");
	СтруктураВызова.Вставить("ПараметрыМетода", Новый Структура("МассивПараметровФайлов", МассивПараметровПодключаемыхФайлов));	
	
	СтруктураВызоваАдрес = ПоместитьВоВременноеХранилище(СтруктураВызова, Новый УникальныйИдентификатор());
	пРезультат = Транзит_ВызватьГлобальныйМетодНаСервере(СтруктураВызоваАдрес, АдресаПеременных);
	РезультатыПодключений = ПолучитьИзВременногоХранилища(пРезультат);
		
	Для Каждого РезультатПодключения Из РезультатыПодключений Цикл
		
		Если РезультатПодключения.Подключено Тогда
			Если РезультатПодключения.ИмяФайла = ДополнительныеПараметры.ИмяОсновнойОбработки Тогда
				
				Путь = РезультатПодключения.Путь;
				
				Если РасположениеКомпоненты = "НаКлиенте" Тогда
					// Сохраняем настройки только, если режим работы - НаКлиенте, т.к. при обновлении ОО может возникнуть ошибки "Неизвестный идентификатор формы"
					// из-за вызова серверного метода. Если режим работы НаСервере, то при сохранении настроек вызывается сервеный метод, чего нельзя делать.
					// Если режим работы = НаСервере, то аналогичный код выполняется в серверном методе "ГлЯдро_ПодключитьФайлВСправочникДополнительныхОтчетовИОбработок"
					СтруктураНастроекДляСохранения = Новый Структура();
					СтруктураНастроекДляСохранения.Вставить("ПутьОсновнойОбработки", Путь);
					СтруктураНастроекДляСохранения.Вставить("ТипОсновнойОбработки",  РезультатПодключения.ТипОбработки);
					СтруктураНастроекДляСохранения.Вставить("ВерсияОбработки_" + ДополнительныеПараметры.ИмяПараметраНастройкиОО,  РезультатПодключения.Версия);
					СтруктураНастроекДляСохранения.Вставить("ВерсияПриложения_" + ДополнительныеПараметры.ИмяПараметраНастройкиОО, ДополнительныеПараметры.ВерсияПриложенияАктуальная);
					СтруктураНастроекДляСохранения.Вставить("НеКэшировать", Истина); // Приведет к вызову серверного метода
					СтруктураНастроекДляСохранения.Вставить("НеЛогировать", Истина); // Приведет к вызову серверного метода
					
					ЛокЯдро_СохранитьНастройкиВБазеSMARTS(СтруктураНастроекДляСохранения);
					
					Сообщить("Основная обработка была актуализирована в справочнике """ + РезультатПодключения.СинонимСправочника + """, перезапустите основную обработку.");					
				КонецЕсли;
				
			ИначеЕсли РезультатПодключения.ИмяФайла = ИмяИнтеграционнойОбработки Тогда
				
				ТекстОшибки = "";
								
				#Если ТолстыйКлиентОбычноеПриложение Тогда
					// Для ОФ корректность формы уже была проверена в методе "ГлЯдро_ПодключитьИнтеграционнуюОбработку"
					ОшибкиФормыИО = Ложь;
				#Иначе
					// Мы не можем выполнять серверные методы с клиента при подключении ОО/ИО, т.к. можно получить ошибку "Неизвестный идентификатор формы"
					// Поэтому выполняем только проверку корректности формы ИО.
					Попытка
						ФормаИнтеграционнойОбработки = ПолучитьФормуИнтеграционнойОбработки(РезультатПодключения.ТипОбработки, РезультатПодключения.ИмяФайла);
						ОшибкиФормыИО = Ложь;
					Исключение
						ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
						ОшибкиФормыИО = Истина;
					КонецПопытки;
				#КонецЕсли
				
				Если Не ОшибкиФормыИО Тогда
										
					Путь = РезультатПодключения.Путь;
					
					ЛокЯдро_СохранитьНастройкуВБазеSMARTS("ИмяИнтеграционнойОбработкиКонфигурации1С", 	РезультатПодключения.ИмяФайла);
					ЛокЯдро_СохранитьНастройкуВБазеSMARTS("ПутьИнтеграционнойОбработкиКонфигурации1С", 	Путь);
					ЛокЯдро_СохранитьНастройкуВБазеSMARTS("ТипОбработки", РезультатПодключения.ТипОбработки);
					ЛокЯдро_СохранитьНастройкуВБазеSMARTS("ВерсияОбработки_" + ДополнительныеПараметры.ИмяПараметраНастройкиИО,  РезультатПодключения.Версия);
					ЛокЯдро_СохранитьНастройкуВБазеSMARTS("ВерсияПриложения_" + ДополнительныеПараметры.ИмяПараметраНастройкиИО, ДополнительныеПараметры.ВерсияПриложенияАктуальная);
					
					ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ДополнительныеПараметры.ИмяСобытия, "Информация", "Подключена интеграционная обработка " + РезультатПодключения.ИмяФайла);
					
				Иначе
					ПараметрыПодключенияMS.ИмяИнтеграционнойОбработки = РезультатПодключения.ИмяФайла;
					ПараметрыПодключенияMS.ПутьИнтеграционнойОбработки = "";
					ПараметрыПодключенияMS.Вставить("ТипОбработки", "ФайлНаДиске");

					Если ЭтоАдресВременногоХранилища(_ИнтеграционнаяОбработкаАдрес) Тогда
						УдалитьИзВременногоХранилища(_ИнтеграционнаяОбработкаАдрес);
						_ИнтеграционнаяОбработкаАдрес = Неопределено;
					КонецЕсли;
					ИнтеграционнаяОбработкаПодключена = Ложь;
					
					ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ДополнительныеПараметры.ИмяСобытия, "Ошибка", "Ошибка подключения интеграционной обработки " + РезультатПодключения.ИмяФайла + ": " + ТекстОшибки);
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЕсли;
		
		Если РезультатПодключения.ИмяФайла = ИмяИнтеграционнойОбработки Тогда
					
			СтруктураСменыСтатуса = Новый Структура("Статус, Параметр, Операция", 
				"ТребуетсяОбновитьИнформациюОбИнтеграционнойОбработке", 
				"", 
				"ПодключениеИО");
			Оповестить("СменаСтатуса", СтруктураСменыСтатуса);
			
		КонецЕсли;
		
	КонецЦикла;
	
	Если Не ДополнительныеПараметры.НеОбновлятьВерсиюПриложения Тогда
		Если РасположениеКомпоненты = "НаКлиенте" Тогда
			// Сохраняем настройки только, если режим работы - НаКлиенте, т.к. при обновлении ОО может возникнуть ошибки "Неизвестный идентификатор формы"
			// из-за вызова серверного метода. Если режим работы НаСервере, то при сохранении настроек вызывается сервеный метод, чего нельзя делать.
			// Если режим работы = НаСервере, то аналогичный код выполняется в серверном методе "ГлЯдро_ПодключитьФайлВСправочникДополнительныхОтчетовИОбработок"
			СтруктураНастроекДляСохранения = Новый Структура();
			СтруктураНастроекДляСохранения.Вставить("ВерсияПриложения", ДополнительныеПараметры.ВерсияПриложенияАктуальная);
			СтруктураНастроекДляСохранения.Вставить("НеКэшировать", Истина); // Приведет к вызову серверного метода
			СтруктураНастроекДляСохранения.Вставить("НеЛогировать", Истина); // Приведет к вызову серверного метода
					
			ЛокЯдро_СохранитьНастройкиВБазеSMARTS(СтруктураНастроекДляСохранения);
		КонецЕсли;
	КонецЕсли;
	#КонецОбласти //НесовместимыйКодFresh
	
КонецПроцедуры

// Вызывает функцию проверки соединения с сервером Mobile Smarts, при успешном выполнении проверки - с подключенной базой Mobile Smarts.
//
// Параметры:
//	СтруктураПодключения - Структура - структура подключения к базе Mobile Smarts
//  Переподключиться - Булево - определяет необходимость явного переподключения к базе Mobile Smarts
//  ТипБазы - Строка - "Частная", "Временная", "Основная"
//	Компонента - Строка - указывается сторона, где установлена компонента для работы с базой Mobile SMARTS
//	СохранятьАвторизацию - Булево - флаг необходимости сохранять данные авторизации
//  Интерактивно - Булево - флаг работы в интерактивном режиме
//  ОписаниеОповещения - ОписаниеОповещения - описание оповещения, обработку которого необходимо выполнить при закрытии формы авторизации
//	ТипИнтерфейса - Строка - тип используемого интерфейса. Например, REST_API или COM
//	НеПроверятьАвторизацию - Булево - признак необходимости проверки авторизации
//
// Возвращаемое значение:
//	- Структура - если требуется авторизация в интерактивном режиме - содержит:
//  	* Статус - Строка	
//      * СтрокаПодключения - Строка
//      * ИмяБазы - Строка
//      * Логин - Строка
//      * ТипБазы - Строка
//      * ДопПараметры - Структура - содержит:
//			** СтрокаПодключения - Строка
//          ** ТипБазы - Строка
//          ** СтруктураПодключения - Структура - структура подключения к базе Mobile Smarts
//          ** СохранятьАвторизацию - Булево
//          ** ИмяБазы - Строка
//			** Логин - Строка
//	- Булево - результат проверки соединения с сервером Mobile Smarts
&НаКлиенте
Функция ЛокЯдро_ПроверитьСоединениеСБазойSMARTS(СтруктураПодключения = Неопределено, Переподключиться = Ложь,
	ТипБазы = "Основная", Компонента = Неопределено, СохранятьАвторизацию = Ложь, Интерактивно = Истина, 
	ТипИнтерфейса = Неопределено, НеПроверятьАвторизацию = Ложь) Экспорт
		
	Если ТипЗнч(СтруктураПодключения) = Тип("Структура")
		И СтруктураПодключения.Свойство("ТипИнтерфейса")
		И ЗначениеЗаполнено(СтруктураПодключения.ТипИнтерфейса) Тогда
		ТипИнтерфейса = СтруктураПодключения.ТипИнтерфейса;
	ИначеЕсли Не ЗначениеЗаполнено(ТипИнтерфейса) Тогда
		ТипИнтерфейса = ЛокЯдро_ПолучитьТипИнтерфейса(ТипБазы); // ТипИнтерфейса = КомЯдро_ПолучитьЗначениеПеременной("ТипИнтерфейса");
	КонецЕсли;
	
	Если Компонента = Неопределено Тогда
		РасположениеКомпоненты = КомЯдро_ПолучитьЗначениеПеременной("РасположениеКомпоненты");
		Компонента = РасположениеКомпоненты;	
	КонецЕсли;
	
	Если ТипБазы = "Частная" Тогда
		КлючПеременной = "СтруктураПодключенияЧастнойБазыMS";
	ИначеЕсли ТипБазы = "Временная" Тогда
		КлючПеременной = "СтруктураПодключенияВременнойБазыMS";
	Иначе
		КлючПеременной = "СтруктураПодключенияБазыMS";
	КонецЕсли;
	
	Если ТипИнтерфейса = "REST_API" Тогда
		КлючПеременной = "REST_API_" + КлючПеременной;
	КонецЕсли;	
		
	Если СтруктураПодключения = Неопределено ИЛИ СтруктураПодключения = "" Тогда
		СтруктураПодключения = КомЯдро_ПолучитьЗначениеПеременной(КлючПеременной);
		Если НЕ СтруктураПодключения.Свойство("ТипБазы") Тогда
			СтруктураПодключения.Вставить("ТипБазы",ТипБазы);
		КонецЕсли;
	Иначе
		Если НЕ СтруктураПодключения.Свойство("ТипБазы") Тогда
			СтруктураПодключения.Вставить("ТипБазы",ТипБазы);
		КонецЕсли;
		КомЯдро_СохранитьЗначениеПеременной(КлючПеременной,СтруктураПодключения);
	КонецЕсли;
	
	Если Компонента = "НаСервере" Тогда
		СтруктураВызова = Новый Структура;
		СтруктураВызова.Вставить("ТипМетода", "Функция");
		СтруктураВызова.Вставить("ИмяМетода", "ПроверитьСоединениеССерверомSMARTS");
		СтруктураВызова.Вставить("ПараметрыМетода", Новый Структура("СтруктураПодключения,Переподключиться,ТипБазы,СохранятьАвторизацию,Интерактивно,НеПроверятьАвторизацию", 
			СтруктураПодключения,Переподключиться,ТипБазы,СохранятьАвторизацию,Интерактивно,НеПроверятьАвторизацию));
		РезультатПроверки = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,,АдресаПеременных);
	Иначе
		Если ТипИнтерфейса = "REST_API" Тогда
			РезультатПроверки = REST_API_ПодключитьсяКБазеSMARTS(СтруктураПодключения, Интерактивно, НеПроверятьАвторизацию);
		Иначе
			РезультатПроверки = КомЯдро_ПроверитьСоединениеССерверомSMARTS(СтруктураПодключения, Компонента,Переподключиться,ТипБазы,СохранятьАвторизацию,Интерактивно);
		КонецЕсли;
	КонецЕсли;
		
	Возврат РезультатПроверки;

КонецФункции

// Проверяет доступность онлайн режима
//
// Параметры:
//  СтруктураПодключения 	- Структура, Неопределено  - структура подключения
//	РасположениеКомпоненты 	- Строка - строка расположени компоненты
//
// Возвращаемое значение:
//   Булево   - доступность онлайн режима
//
&НаКлиенте
Функция ЛокЯдро_ПроверитьДоступностьОнлайнРежима(СтруктураПодключения = Неопределено, РасположениеКомпоненты = Неопределено) Экспорт
	
	#Если ТолстыйКлиентОбычноеПриложение Тогда
		// Для ОФ не выполняем проверку доступности, т.к. проверка доступности базы некорректно работает на сервере
		// Например, при прямом подключении базы MS отображается, что с сервера доступно подключение, хотя это не так из-за особенности работы толстого клиента
		Возврат Истина;		
	#КонецЕсли
	
	ТипБазы 				= "Временная"; //Проверяем доступность через временную базу, чтобы настройки подключения не сохранились для основной базы
	Переподключиться 		= Истина;
	СохранятьАвторизацию 	= Ложь;
	Интерактивно 			= Ложь;
	
	ДоступностьОнлайнРежима				= Ложь;
	НеобходимостьПроверкиДоступности 	= Ложь; // Проверять доступность онлайн режима необходимо не во всех случаях, например, если подключение компонента находится на сервере, то не выполняем проверку
	
	Если ТипЗнч(СтруктураПодключения) = Тип("Структура")
		И СтруктураПодключения.Свойство("ТипИнтерфейса")
		И ЗначениеЗаполнено(СтруктураПодключения.ТипИнтерфейса) Тогда
		ТипИнтерфейса = СтруктураПодключения.ТипИнтерфейса;
	Иначе
		ТипИнтерфейса = КомЯдро_ПолучитьЗначениеПеременной("ТипИнтерфейса");
	КонецЕсли;
	
	Если РасположениеКомпоненты = Неопределено Тогда
		РасположениеКомпоненты = КомЯдро_ПолучитьЗначениеПеременной("РасположениеКомпоненты");
	КонецЕсли;
		
	ЭтоREST_API = ТипИнтерфейса = "REST_API";	
		
	// Если компонента на сервере, то нет необходимости проверять подключение с сервера, т.к. оно уже выполнено ранее
	Если РасположениеКомпоненты <> "НаСервере" Тогда
		
		Если ЭтоREST_API Тогда
			// Для рест на данный момент нет возможности проверить включен ли онлайн режим, поэтому проверяем доступность базы с сервера в любом случае
			ВключеныСобытияСервера = Истина;
		Иначе
			
			// Вариант при ком соединении
			Если COMБазыMS <> Неопределено 
				И Строка(COMБазыMS.TerminalConnector) = "COMОбъект" Тогда
				
				// Проверка, что включен онлайн режим. Проверям именно на компоненте основной базы, т.к. компонента временной базы может быть не подключена
				Попытка
					СобытияСервера 			= COMБазыMS.TerminalConnector.StorageConnector.GetServerEvents();
					ВключеныСобытияСервера 	= ЗначениеЗаполнено(СобытияСервера.ProductNotFound) Или ЗначениеЗаполнено(СобытияСервера.ProductsNotFound);
				Исключение
					ВключеныСобытияСервера = Ложь;
				КонецПопытки;
				
			КонецЕсли;
			
		КонецЕсли;
		
		Если ВключеныСобытияСервера Тогда
			
			НеобходимостьПроверкиДоступности = Истина;
			
			СтруктураСменыСтатуса = Новый Структура("Статус, Параметр, Операция", 
				"НачалоПроверкиДоступностиОнлайнРежимаСообщениеБезопасности", 
				"", 
				"ДоступностьОнлайнРежима");
			Оповестить("СменаСтатуса", СтруктураСменыСтатуса);
			
			НеПроверятьАвторизацию = Истина; // Не проверяем авторизацию
			РезультатПроверки = ЛокЯдро_ПроверитьСоединениеСБазойSMARTS(СтруктураПодключения, Переподключиться, ТипБазы, 
				"НаСервере", СохранятьАвторизацию, Интерактивно,, НеПроверятьАвторизацию);
						
			Если РезультатПроверки = Ложь Тогда
				СтруктураСменыСтатуса = Новый Структура("Статус, Параметр, Операция", 
					"РаботаВОнлайнеНедоступна", 
					СтруктураПодключения, 
					"ДоступностьОнлайнРежима");
				Оповестить("СменаСтатуса", СтруктураСменыСтатуса);
			Иначе
				ДоступностьОнлайнРежима = Истина;
				СтруктураСменыСтатуса = Новый Структура("Статус, Параметр, Операция", 
					"БезОшибок", 
					"", 
					"ДоступностьОнлайнРежима");
				Оповестить("СменаСтатуса", СтруктураСменыСтатуса);
			КонецЕсли;
			
		КонецЕсли;

	КонецЕсли;

	// Если нет необходимости проверять доступность базы с сервера, то считаем, что база доступна с сервера
	ДоступностьОнлайнРежима = Не НеобходимостьПроверкиДоступности Или ДоступностьОнлайнРежима;
	
	Возврат ДоступностьОнлайнРежима;
	
КонецФункции

// Изменяет текущие настройки MS и сохраняет их в базе MS
//
// Параметры:
//	ТекущиеНастройкиMS - Структура - изменяемые настройки MS
//
&НаКлиенте
Процедура ЛокЯдро_ИзменитьТекущиеНастройкиMS(ТекущиеНастройкиMS) Экспорт
		
	OneCProcessingFileName_ПоУмолчанию = "КлеверенсТСД_ОсновнаяОбработка.epf";
	
	Если ТипЗнч(ТекущиеНастройкиMS) = Тип("Структура") Тогда
		Если ТекущиеНастройкиMS.Свойство("OneCProcessingFileName")
			И ТекущиеНастройкиMS.OneCProcessingFileName <> Ложь
			И ТекущиеНастройкиMS.OneCProcessingFileName <> OneCProcessingFileName_ПоУмолчанию Тогда
			
			ЛокЯдро_СохранитьНастройкуВБазеSMARTS("OneCProcessingFileName", OneCProcessingFileName_ПоУмолчанию);
			ТекущиеНастройкиMS.OneCProcessingFileName = OneCProcessingFileName_ПоУмолчанию;
		КонецЕсли;
	КонецЕсли;

КонецПроцедуры

&НаКлиенте
Процедура ЛокЯдро_ПроверитьНастройкиТаймаутов() Экспорт
	
	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода", "Функция");
	СтруктураВызова.Вставить("ИмяМетода", "ОбновитьНастройкиТаймаутов");
	ОбновленныеНастройкиТаймаутов = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,,АдресаПеременных);
	
	ЛокЯдро_ЗаписатьВКэшНастройкуSMARTS("НастройкиТаймаутов",ОбновленныеНастройкиТаймаутов);
	
КонецПроцедуры

&НаКлиенте
Функция ЛокЯдро_ПолучитьТаймаутПоТипуМетода(СтруктураЗапроса)
	
	ЗначениеТаймаутаПоУмолчанию = 3;
	
	НастройкиТаймаутов = ЛокЯдро_ПолучитьИзКэшаНастройкуSMARTS("НастройкиТаймаутов");
	Если НастройкиТаймаутов = Неопределено Тогда // Если возвращается Неопределено, значит переменные кэша еще не созданы, возьмем напрямую настройки по умолчанию
		
		Если КэшТаймаутов = Неопределено Тогда 			
			СтруктураВызова = Новый Структура;
			СтруктураВызова.Вставить("ТипМетода", "Функция");
			СтруктураВызова.Вставить("ИмяМетода", "ТаймаутыПоУмолчанию");
			НастройкиТаймаутов = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,,АдресаПеременных);
			
			КэшТаймаутов = НастройкиТаймаутов;
			
		Иначе
			НастройкиТаймаутов = КэшТаймаутов;
		КонецЕсли;
		
	ИначеЕсли НастройкиТаймаутов = Ложь Тогда  // если в кэше нет настроек, то вызовем обновление таймаутов, внутри обновления есть запись в кэш,
		ЛокЯдро_ПроверитьНастройкиТаймаутов(); // поэтому после обновления просто переполучим из него.		
		НастройкиТаймаутов = ЛокЯдро_ПолучитьИзКэшаНастройкуSMARTS("НастройкиТаймаутов");
		
	КонецЕсли;
	
	ТипЗапроса = "ПоУмолчанию";
	Если СтруктураЗапроса.Свойство("ТипЗапроса") // Если в структуре запроса не задан тип запроса, то берем таймаут по умолчанию
		И ЗначениеЗаполнено(СтруктураЗапроса.ТипЗапроса) Тогда
		ТипЗапроса = СтруктураЗапроса.ТипЗапроса;
	КонецЕсли;
	
	СтрокаНастройки = ЛокЯдро_НайтиВМассивеСтруктурПоОтбору(НастройкиТаймаутов,Новый Структура("ТипЗапроса", ТипЗапроса));
	
	Если СтрокаНастройки = Неопределено 
		И ТипЗапроса <> "ПоУмолчанию" Тогда // Названия методов могут меняться со временем, если забыли переименовать и настройка не нашлась, то будем брать значение по умолчанию
		СтрокаНастройки = ЛокЯдро_НайтиВМассивеСтруктурПоОтбору(НастройкиТаймаутов,Новый Структура("ТипЗапроса", "ПоУмолчанию"));
	КонецЕсли;
	
	Если СтрокаНастройки = Неопределено Тогда // Если по какой-то причине строки настройки всё равно нет, то назначим значение таймаута 3
		ЗначениеТаймаута = ЗначениеТаймаутаПоУмолчанию;
	Иначе
		ЗначениеТаймаута = СтрокаНастройки[0].Значение;
	КонецЕсли;
	
	Возврат ЗначениеТаймаута;
КонецФункции

// Выполняет сброс пользовательских настроек к состоянию по умолчанию
//
&НаКлиенте
Процедура ЛокЯдро_СброситьНастройкиПодключеннойБазыНаСтандартные() Экспорт
	
	РасположениеКомпоненты = ЛокЯдро_ПолучитьДанныеИзХранилища1С("Cleverence_РасположениеКомпоненты");
	
	Если НЕ ЗначениеЗаполнено(РасположениеКомпоненты) Тогда
		РасположениеКомпоненты = "НаСервере";
	КонецЕсли;
	
	Если РасположениеКомпоненты <> "НаСервере" Тогда		
		
		// Получаем пустую структуру настроек
		КатегорииНастроекMS = ЛокЯдро_ПолучитьКатегорииНастроекMS();
        СтруктураНастроек 	= ЛокЯдро_ПолучитьПустуюСтруктуруНастроекSMARTS(КатегорииНастроекMS.СериализуемыеНастройки);
		
		// Заполняем пустую структуру текущими значениями
		СтруктураНастроек = ЛокЯдро_ПолучитьНастройкиНаСервереSMARTS(СтруктураНастроек);
		
		// Определяем текущий узел		
		ID_ТекущегоУзла = ЛокЯдро_ПолучитьДанныеИзХранилища1С("Cleverence_ID_ТекущегоУзла_"+ПараметрыПодключенияMS.Ид);
		Если Не ЗначениеЗаполнено(ID_ТекущегоУзла) Тогда
			ID_ТекущегоУзла = "";	
		КонецЕсли;		
		
		// Если он определен, получаем по нему структуру настроек
		ДанныеУзла = Неопределено;
		Если ID_ТекущегоУзла <> "" И ТипЗнч(СтруктураНастроек.Узлы) = Тип("Массив") Тогда
			ДанныеУзла = НайтиСтруктуруВМассивеПоЭлементу(СтруктураНастроек.Узлы,"ID_Узла",ID_ТекущегоУзла);
			Если ДанныеУзла <> Неопределено Тогда			
				СтруктураНастроек = ЛокЯдро_ПолучитьНастройкиНаСервереSMARTS(СтруктураНастроек, ID_ТекущегоУзла);				
			КонецЕсли;
		КонецЕсли;
		
		// Убираем из структуры параметры, отвечающие за соединение с базой 1С и расширениями (иначе они слетают)
		СтруктураНастроек.Удалить("ПодключеннаяБазаСтрокаСоединения");
		СтруктураНастроек.Удалить("ПодключеннаяБазаИмяКонфигурации1С");
		СтруктураНастроек.Удалить("ПодключеннаяБазаСинонимКонфигурации1С");
		СтруктураНастроек.Удалить("ПодключеннаяБазаВерсияПлатформы1С");
		СтруктураНастроек.Удалить("ПодключеннаяБазаВерсияКонфигурации1С");
		СтруктураНастроек.Удалить("База1СПодключенаДата");
		СтруктураНастроек.Удалить("OneCProcessingFileName");
		СтруктураНастроек.Удалить("ВерсияРасширения_CleverenceWebExtension");
		СтруктураНастроек.Удалить("ВерсияРасширения_CleverenceButtonsExtension");
				
		// Получаем структуру настроек по умолчанию и записываем ее для дальнейшего использования
		СтруктураНастроек = ЛокЯдро_ПолучитьНастройкиПоУмолчаниюНаСервереSMARTS(СтруктураНастроек, ?(ДанныеУзла = Неопределено, "", ID_ТекущегоУзла)); 
		ЛокЯдро_ЗаписатьВКэшНастройкиSMARTS(СтруктураНастроек);
								
	КонецЕсли;		
	
КонецПроцедуры

&НаКлиенте
Процедура ЛокЯдро_ИнициализацияКомпонентаНаСервере(ОписаниеОповещенияРодительскойФормы)
	
	// Инициализируем отдельную переменную ВыполняетсяВФоне, 
	// т.к. в процессе выполнения ФЗ при ошибке мы можем поменять значение переменной ДоступноВыполнениеВФоне
	ВыполняетсяВФоне = ДоступноВыполнениеВФоне;
	
	ДанныеДляИнициализации = ЛокЯдро_ПолучитьДанныеДляИнициализации(Истина, ВыполняетсяВФоне, ОписаниеОповещенияРодительскойФормы);

	// Если не доступно выполнение в фоне, вызываем метод напрямую
	Если Не ВыполняетсяВФоне Тогда
		ЛокЯдро_ПолучитьДанныеДляИнициализацииЗавершение(ДанныеДляИнициализации);
	КонецЕсли;	

КонецПроцедуры

&НаКлиенте
Процедура ЛокЯдро_ПолучитьДанныеДляИнициализацииВФонеЗавершение(Результат, ДополнительныеПараметры) Экспорт

	Если ЭтоАдресВременногоХранилища(Результат) Тогда
		СтруктураРезультата = ПолучитьИзВременногоХранилища(Результат);
		ДанныеДляИнициализации = СтруктураРезультата.ДанныеДляИнициализации;
		// Актуализируем кэш, т.к. он мог измениться в сеансе фонового задания
		// TODO. Проверить, надо ли 3-й параметр ЛокЯдро_ДополнитьСтруктуру перевести в Истина 
		ЛокЯдро_ДополнитьСтруктуру(АдресаПеременных, СтруктураРезультата.АдресаПеременных, Ложь); 
	Иначе
		ДанныеДляИнициализации = Результат;
	КонецЕсли;
	
    ЛокЯдро_ПолучитьДанныеДляИнициализацииЗавершение(ДанныеДляИнициализации, ДополнительныеПараметры);
	
КонецПроцедуры

&НаКлиенте
Процедура ЛокЯдро_ПолучитьДанныеДляИнициализацииЗавершение(ДанныеДляИнициализации, ДополнительныеПараметры = Неопределено)
	
    КатегорииНастроекMS = ДанныеДляИнициализации.КатегорииНастроекMS;
	
	ТекущиеНастройкиMS  = ДанныеДляИнициализации.ТекущиеНастройкиMS;
	СтруктураМетаданных = ДанныеДляИнициализации.СтруктураМетаданных;
	ДанныеТекущегоУзла  = ДанныеДляИнициализации.ДанныеТекущегоУзла;
	ПраваПользователя 	= ДанныеДляИнициализации.ПраваПользователя;
	
	ЕстьЧастнаяБаза = КомЯдро_ПолучитьЗначениеПеременной("ЕстьЧастнаяБаза");
	Если ЕстьЧастнаяБаза = Неопределено Тогда
		ЕстьЧастнаяБаза = Ложь;
	КонецЕсли;	
	
	НастройкиИнициализированы = Истина;
	
	Оповестить("УстановленыНастройкиПодключения",,ЭтаФорма);	
	СтруктураСменыСтатуса = Новый Структура("Статус, Параметр, Операция", 
		"БезОшибок", 
		"", 
		"ПодключениеКБазеSMARTS");
	Оповестить("СменаСтатуса", СтруктураСменыСтатуса);
	
	Если ТипЗнч(ДополнительныеПараметры) = Тип("Структура") Тогда
		ОписаниеОповещенияРодительскойФормы = ДополнительныеПараметры.ОписаниеОповещенияРодительскойФормы;
		Если ОписаниеОповещенияРодительскойФормы <> Неопределено Тогда
			ВыполнитьОбработкуОповещения(ОписаниеОповещенияРодительскойФормы);
		КонецЕсли;
	КонецЕсли;

КонецПроцедуры

// Изменение структуры глобальных параметров:
// 	1. ГлобальныеПараметры разделены на ГлобальныеПараметры_ПоУмолчанию и ГлобальныеПараметры_Пользовательские
// 	2. Для хранения параметров главного узла используется настройка ГлобальныеПараметры_Значения вместо ГлобальныеПараметры
// 	3. Настройка ЗначенияПараметровУзлов_[УзелN] переименована в ГлобальныеПараметры_Значения_[УзелN]
&НаКлиенте
Процедура ЛокЯдро_ВыполнитьОбновлениеГлобальныхПараметров(ВерсияГлобальныхПараметров) Экспорт

	ОбновлятьГлобальныеПараметры = Истина;

	Если ЗначениеЗаполнено(ВерсияГлобальныхПараметров)
		И НЕ ВерсияГлобальныхПараметров = Ложь
		И ВерсияГлобальныхПараметров >= 1003014000 Тогда
		ОбновлятьГлобальныеПараметры = Ложь;				
	КонецЕсли;
	
	Если НЕ ОбновлятьГлобальныеПараметры Тогда
		Возврат;
	КонецЕсли;	
	
	ID_ТекущегоУзла = "";
	
	Если ТипЗнч(ДанныеТекущегоУзла) = Тип("Структура") Тогда
		ID_ТекущегоУзла = ДанныеТекущегоУзла.ID_Узла;		
	КонецЕсли;
	
	ИзмененияВКэше 		= Новый Структура();
	ИзмененияВСтруктуре = Новый Структура();
	
	ГлобальныеПараметры = ЛокЯдро_ПолучитьИзКэшаНастройкуSMARTS("ГлобальныеПараметры");
	
	Если ЗначениеЗаполнено(ГлобальныеПараметры) И НЕ ГлобальныеПараметры = Ложь Тогда
		ГлобальныеПараметры_Значения 		 = ЛокЯдро_ПолучитьНастройкуНаСервереSMARTS("ГлобальныеПараметры_Значения");
	    ГлобальныеПараметры_ПоУмолчанию 	 = ЛокЯдро_ПолучитьИзКэшаНастройкуSMARTS("ГлобальныеПараметры_ПоУмолчанию");
		ГлобальныеПараметры_Пользовательские = ЛокЯдро_ПолучитьИзКэшаНастройкуSMARTS("ГлобальныеПараметры_Пользовательские");
		
		ЕстьГлобальныеПараметры_Значения 		 = ЗначениеЗаполнено(ГлобальныеПараметры_Значения) И НЕ ГлобальныеПараметры_Значения = Ложь;
		ЕстьГлобальныеПараметры_ПоУмолчанию 	 = ЗначениеЗаполнено(ГлобальныеПараметры_ПоУмолчанию) И НЕ ГлобальныеПараметры_ПоУмолчанию = Ложь;
		ЕстьГлобальныеПараметры_Пользовательские = ЗначениеЗаполнено(ГлобальныеПараметры_Пользовательские) И НЕ ГлобальныеПараметры_Пользовательские = Ложь;
		
		Если НЕ ЕстьГлобальныеПараметры_Значения Тогда
			ГлобальныеПараметры_Значения = Новый Массив;
			ГлобальныеПараметры_Значения.Добавить(Новый Структура("ЭтоТаблицаЗначений, КолонкиТаблицыЗначений", Истина, "Использование, Наименование, Значение, ID_Параметра, Комментарий"));
		КонецЕсли;
		
		Если НЕ ЕстьГлобальныеПараметры_Пользовательские Тогда
			ГлобальныеПараметры_Пользовательские = Новый Массив;
			ГлобальныеПараметры_Пользовательские.Добавить(Новый Структура("ЭтоТаблицаЗначений, КолонкиТаблицыЗначений", Истина, "Использование, Наименование, Значение, ID_Параметра, Комментарий"));
		КонецЕсли;
			
		Для каждого СтрокаПараметра ИЗ ГлобальныеПараметры Цикл	
			Если СтрокаПараметра.Свойство("ЭтоТаблицаЗначений") Тогда
				Продолжить;
			КонецЕсли;
						
			// Дополняем ключ ГлобальныеПараметры_Значения значениями ключа ГлобальныеПараметры
			НайденныйПараметр = ЛокЯдро_НайтиСтруктуруВМассивеПоЭлементу(ГлобальныеПараметры_Значения, "ID_Параметра", СтрокаПараметра.ID_Параметра);
			Если НайденныйПараметр = Неопределено Тогда
				ГлобальныеПараметры_Значения.Добавить(ЛокЯдро_СкопироватьСтруктуру(СтрокаПараметра));	
			КонецЕсли;
						
			// Дополняем ключ ГлобальныеПараметры_Пользовательские по наличию настроек в ключе ГлобальныеПараметры_ПоУмолчанию
			Если ЕстьГлобальныеПараметры_ПоУмолчанию Тогда
				НайденныйПараметр = ЛокЯдро_НайтиСтруктуруВМассивеПоЭлементу(ГлобальныеПараметры_ПоУмолчанию, "ID_Параметра", СтрокаПараметра.ID_Параметра);
				Если НайденныйПараметр <> Неопределено Тогда
					Продолжить;						
				КонецЕсли;
						
				НайденныйПараметр = ЛокЯдро_НайтиСтруктуруВМассивеПоЭлементу(ГлобальныеПараметры_Пользовательские, "ID_Параметра", СтрокаПараметра.ID_Параметра);
				Если НайденныйПараметр = Неопределено Тогда
					ГлобальныеПараметры_Пользовательские.Добавить(ЛокЯдро_СкопироватьСтруктуру(СтрокаПараметра));
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
		
		ЛокЯдро_УдалитьНастройкиВБазеSMARTS(Новый Структура("ГлобальныеПараметры"));
		ЛокЯдро_СохранитьЗначениеКэшируемойНастройки("ГлобальныеПараметры", Неопределено, "");
		
		// Если нет ключа ГлобальныеПараметры_ПоУмолчанию, дополняем ключ ГлобальныеПараметры_Пользовательские по наличию настроек в ключе ГлобальныеПараметры 
		Если НЕ ЕстьГлобальныеПараметры_ПоУмолчанию Тогда
            ГлобальныеПараметры_ПоУмолчанию = ЛокЯдро_ПолучитьНастройкуНаСервереSMARTS("ГлобальныеПараметры");
			Если ЗначениеЗаполнено(ГлобальныеПараметры_ПоУмолчанию) И НЕ ГлобальныеПараметры_ПоУмолчанию = Ложь Тогда
                Для каждого СтрокаПараметра ИЗ ГлобальныеПараметры Цикл	
					Если СтрокаПараметра.Свойство("ЭтоТаблицаЗначений") Тогда
						Продолжить;
					КонецЕсли;
				
					НайденныйПараметр = ЛокЯдро_НайтиСтруктуруВМассивеПоЭлементу(ГлобальныеПараметры_ПоУмолчанию, "ID_Параметра", СтрокаПараметра.ID_Параметра);
					Если НайденныйПараметр <> Неопределено Тогда
						Продолжить;						
					КонецЕсли;
							
					НайденныйПараметр = ЛокЯдро_НайтиСтруктуруВМассивеПоЭлементу(ГлобальныеПараметры_Пользовательские, "ID_Параметра", СтрокаПараметра.ID_Параметра);
					Если НайденныйПараметр = Неопределено Тогда
						ГлобальныеПараметры_Пользовательские.Добавить(ЛокЯдро_СкопироватьСтруктуру(СтрокаПараметра));
					КонецЕсли;
				КонецЦикла;
				
				ИзмененияВКэше.Вставить("ГлобальныеПараметры_ПоУмолчанию", ГлобальныеПараметры_ПоУмолчанию);
			КонецЕсли;
			ЛокЯдро_СохранитьЗначениеКэшируемойНастройки("ГлобальныеПараметры", Неопределено, "");
		КонецЕсли;
		
		ИзмененияВСтруктуре.Вставить("ГлобальныеПараметры_Значения", 		 ГлобальныеПараметры_Значения);
		ИзмененияВСтруктуре.Вставить("ГлобальныеПараметры_Пользовательские", ГлобальныеПараметры_Пользовательские);
		
		ИзмененияВКэше.Вставить("ГлобальныеПараметры_Пользовательские", 	 ГлобальныеПараметры_Пользовательские);
		ИзмененияВКэше.Вставить("ГлобальныеПараметры", 						 Неопределено);
		
		Если ID_ТекущегоУзла = "" Тогда
			ИзмененияВКэше.Вставить("ГлобальныеПараметры_Значения", 	 	 ГлобальныеПараметры_Пользовательские);	
		КонецЕсли;
	КонецЕсли;
	
	ВсеУзлы = ЛокЯдро_ПолучитьИзКэшаНастройкуSMARTS("Узлы");
	Если ТипЗнч(ВсеУзлы) = Тип("Массив") Тогда
		Для каждого СтрокаУзла ИЗ ВсеУзлы Цикл
			Если СтрокаУзла.Свойство("ЭтоТаблицаЗначений") Тогда
				Продолжить;
			КонецЕсли;
			
			ID_Узла = СтрокаУзла.ID_Узла;
			
			// ЗначенияПараметровУзлов_[Узел] заменяем на ГлобальныеПараметры_Значения_[Узел]
			ЗначенияПараметровУзлов = ЛокЯдро_ПолучитьНастройкуНаСервереSMARTS("ЗначенияПараметровУзлов", ID_Узла);
			Если ЗначениеЗаполнено(ЗначенияПараметровУзлов) И НЕ ЗначенияПараметровУзлов = Ложь Тогда
				ГлобальныеПараметры_Значения = ЛокЯдро_ПолучитьНастройкуНаСервереSMARTS("ГлобальныеПараметры_Значения", ID_Узла);
			    
				ЕстьГлобальныеПараметры_Значения = ЗначениеЗаполнено(ГлобальныеПараметры_Значения) И НЕ ГлобальныеПараметры_Значения = Ложь;
				Если НЕ ЕстьГлобальныеПараметры_Значения Тогда
					ГлобальныеПараметры_Значения = Новый Массив;
					ГлобальныеПараметры_Значения.Добавить(Новый Структура("ЭтоТаблицаЗначений, КолонкиТаблицыЗначений", Истина, "Использование, Наименование, Значение, ID_Параметра, Комментарий"));
				КонецЕсли;
				
				Для каждого СтрокаПараметра ИЗ ЗначенияПараметровУзлов Цикл	
					Если СтрокаПараметра.Свойство("ЭтоТаблицаЗначений") Тогда
						Продолжить;
					КонецЕсли;
								
					// Дополняем ключ ГлобальныеПараметры_Значения_[Узел] значениями ключа ЗначенияПараметровУзлов_[Узел]
					НайденныйПараметр = ЛокЯдро_НайтиСтруктуруВМассивеПоЭлементу(ГлобальныеПараметры_Значения, "ID_Параметра", СтрокаПараметра.ID_Параметра);
					Если НайденныйПараметр = Неопределено Тогда
						ГлобальныеПараметры_Значения.Добавить(ЛокЯдро_СкопироватьСтруктуру(СтрокаПараметра));	
					КонецЕсли;
				КонецЦикла;
				
				ЛокЯдро_УдалитьНастройкиВБазеSMARTS(Новый Структура("ЗначенияПараметровУзлов"), ID_Узла);
				
				ЛокЯдро_СохранитьНастройкуВБазеSMARTS("ГлобальныеПараметры_Значения", ГлобальныеПараметры_Значения, ID_Узла);
				
				Если ID_ТекущегоУзла = ID_Узла Тогда
					ИзмененияВКэше.Вставить("ГлобальныеПараметры_Значения", ГлобальныеПараметры_Пользовательские);
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	ИзмененияВСтруктуре.Вставить("ВерсияГлобальныеПараметры", 1003014000);
	
	ЛокЯдро_СохранитьНастройкиВБазеSMARTS(ИзмененияВСтруктуре, ID_ТекущегоУзла);
	ЛокЯдро_ЗаписатьВКэшНастройкиSMARTS(ИзмененияВКэше);
	
КонецПроцедуры

#КонецОбласти

#Область ЛокальныйКонтекст_Настройки_ЧтениеНастроек

// Получает из компоненты SMARTS список всех подключенных баз
// 
// Параметры:
// 	РежимПоиска - Строка - указывается сторона, где установлена компонента для работы с базой Mobile SMARTS
// 	Полное - Строка - флаг возврата для каждой базы из списка полного (Истина) либо краткого (Ложь) описания
// 	
// Возвращаемое значение:
// 	Неопределено, Массив из Структура - Если нет подключения к компоненте, то вернется Неопределено. 
//										Если подключение есть, то вернется массив со списком баз и описанием структуры массива.
&НаКлиенте
Функция ЛокЯдро_ПолучитьСписокБазНаСервереSMARTS(РежимПоиска = "",Полное = Истина) Экспорт
	
	Если РежимПоиска = "" Тогда
		РежимПоиска = РасположениеКомпоненты;
	КонецЕсли;
	
	Если РежимПоиска = "НаСервере" Тогда
		СтруктураВызова = Новый Структура;
		СтруктураВызова.Вставить("ТипМетода", "Функция");
		СтруктураВызова.Вставить("ИмяМетода", "ПолучитьСписокБазНаСервереSMARTS");
		СтруктураВызова.Вставить("ПараметрыМетода", Новый Структура("Полное",Полное));
		СписокБаз = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,,АдресаПеременных);	
	Иначе
		СписокБаз = КомЯдро_ПолучитьСписокБазНаСервереSMARTS(Полное);	
	КонецЕсли;
	
	Возврат СписокБаз;
	
КонецФункции

// Получает значение настройки Mobile Smarts из кэша
// 
// Параметры:
// 	КлючНастройки - Строка - имя настройки Mobile Smarts, которую необходимо получить
// 	ВернутьМассивСтруктур - Булево - определяет, будет возвращено значение табличной настройки в виде массива структур (Истина) или таблицы значений (Ложь)
// 	ВернутьАдресХранилища - Булево - если Истина, то результат будет помещен во временное хранилище
// 
// Возвращаемое значение:
// 	Неопределено, Массив из Структура, Булево, Строка - значение настройки в выбранном формате
&НаКлиенте 
Функция ЛокЯдро_ПолучитьИзКэшаНастройкуSMARTS(КлючНастройки,ВернутьМассивСтруктур = Ложь,ВернутьАдресХранилища=Ложь) Экспорт
	
	ЗначениеНастройки = Ложь;
	
	Если ТипЗнч(ЭтаФорма.ТекущиеНастройкиMS) <> Тип("Структура") Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	НайденноеЗначение = Неопределено;
	Если ТекущиеНастройкиMS.Свойство(КлючНастройки, НайденноеЗначение) Тогда
		ЗначениеНастройки = НайденноеЗначение;
	КонецЕсли;
	
	Если ВернутьМассивСтруктур
		И НЕ (ТипЗнч(ЗначениеНастройки) = Тип("Массив") И ЗначениеНастройки.Количество() > 0 
		И ТипЗнч(ЗначениеНастройки[0]) = Тип("Структура") 
		И (НЕ ЗначениеНастройки[0].Свойство("ЭтоТаблицаЗначений") ИЛИ ЗначениеНастройки[0].ЭтоТаблицаЗначений)) Тогда
	   
		ЗначениеНастройки = ЛокЯдро_ТаблицуЗначенийВМассивСтруктур(ЗначениеНастройки);
	
	КонецЕсли; 
	
	Если ВернутьАдресХранилища Тогда
	
		ЗначениеНастройки = ПоместитьВоВременноеХранилище(ЗначениеНастройки,Новый УникальныйИдентификатор());
	
	КонецЕсли; 
	
	Возврат ЗначениеНастройки;
	
КонецФункции

// Получает из кэша значение табличной настройки Mobile Smarts или значение ее отдельной колонки с возможностью выполнения отбора
//
// Параметры:
//	КлючТаблицы	- Строка - имя табличной настройки Mobile Smarts, из которой необходимо получить данные
//  Отбор - Структура - в качестве ключей содержит имена колонок табличной настройки Mobile Smarts, в качестве
//						значений - значения соответствующих колонок, по которым необходимо выполнить отбор
//  ИмяКолонки - Строка - имя колонки табличной настройки Mobile Smarts, значение которой необходимо вернуть
//
// Возвращаемое значение:
//	- ТаблицаЗначений - если значение полученной настройки хранится в кэше в виде таблицы значений
//	- Массив из Структура - если значение полученной настройки хранится в кэше в виде массива структур
//	- Произвольный - если запрошено значение одной колонки
//  - Неопределено - если значение настройки получить не удалось
&НаКлиенте 
Функция ЛокЯдро_ПолучитьИзКэшаЗначениеТабличнойНастройкиSMARTS(КлючТаблицы, Отбор, ИмяКолонки = "") Экспорт

	Результат = Неопределено;
	
	ТаблицаНастроек = ЛокЯдро_ПолучитьИзКэшаНастройкуSMARTS(КлючТаблицы,Истина);
	РезультатОтбора = Новый Массив;
	СтруктураТЗ = Неопределено;
	Если ТипЗнч(ТаблицаНастроек) = Тип("Массив") Тогда
		Для Каждого ЭлементМассива Из ТаблицаНастроек Цикл
			Если ЭлементМассива.Свойство("КолонкиТаблицыЗначений") Тогда
				СтруктураТЗ = ЭлементМассива;
				Продолжить;
			КонецЕсли;
			Подходит = Истина;
			Для Каждого ЭлементОтбора из Отбор Цикл
				Если ТипЗнч(ЭлементОтбора.Значение) = Тип("Массив") Тогда
					ПодходящийОтбор = ЭлементМассива.Свойство(ЭлементОтбора.Ключ) И ЭлементОтбора.Значение.Найти(ЭлементМассива[ЭлементОтбора.Ключ]) <> Неопределено;
				Иначе
					ПодходящийОтбор = ЭлементМассива.Свойство(ЭлементОтбора.Ключ) И ЭлементМассива[ЭлементОтбора.Ключ] = ЭлементОтбора.Значение;
				КонецЕсли;
				
				Если НЕ ПодходящийОтбор Тогда
					Подходит = Ложь;
					Продолжить;
				КонецЕсли;
			КонецЦикла;
			Если Подходит Тогда
				РезультатОтбора.Добавить(ЭлементМассива);
			КонецЕсли;
		КонецЦикла;
		Если РезультатОтбора.Количество() > 0 Тогда
			Если ЗначениеЗаполнено(ИмяКолонки) Тогда
				Результат = ?(РезультатОтбора.Количество() = 1, РезультатОтбора[0][ИмяКолонки], "");
			Иначе
				Если СтруктураТЗ <> Неопределено Тогда
					РезультатОтбора.Вставить(0,СтруктураТЗ);
				КонецЕсли;
				Результат = РезультатОтбора;
			КонецЕсли;
		КонецЕсли
	КонецЕсли;	
	
	Возврат Результат;
	
КонецФункции

// Вызывает функцию получения настроек на сервере Mobile Smarts и конвертации сериализуемых настроек
//
// Параметры:
//	СтруктураНастроек - Структура - ключами являются имена настроек Mobile Smarts, значения которых необходимо получить
//  ID_Узла - Строка - идентификатор узла в текущей сессии Mobile Smarts
//
// Возвращаемое значение:
//	Структура - ключами являются имена настроек Mobile Smarts, переданные в параметре СтруктураНастроек, 
//				значениями - соответствующие значения полученных настроек
&НаКлиенте
Функция ЛокЯдро_ПолучитьНастройкиНаСервереSMARTS(СтруктураНастроек, ID_Узла = "") Экспорт
	
	Если РасположениеКомпоненты = "НаСервере" Тогда
		СтруктураВызова = Новый Структура;
		СтруктураВызова.Вставить("ТипМетода", "Функция");
		СтруктураВызова.Вставить("ИмяМетода", "ПолучитьНастройкиНаСервереSMARTS");
		СтруктураВызова.Вставить("ПараметрыМетода", Новый Структура);
		СтруктураВызова.ПараметрыМетода.Вставить("СтруктураНастроек", СтруктураНастроек);
		СтруктураВызова.ПараметрыМетода.Вставить("УзловыеНастройки", КатегорииНастроекMS.УзловыеНастройки);
		СтруктураВызова.ПараметрыМетода.Вставить("ID_Узла", ID_Узла);
		СтруктураНастроек = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,,АдресаПеременных);
	Иначе
		СтруктураНастроек = ЛокЯдро_ЗаполнитьНастройкиSMARTS(СтруктураНастроек, КатегорииНастроекMS.УзловыеНастройки, ID_Узла);
	КонецЕсли;

	Возврат СтруктураНастроек;
	
КонецФункции

// Вызывает функцию получения настройки из базы Mobile Smarts по ключу
//
// Параметры:
//	КлючНастройки - Строка - имя настройки Mobile Smarts, которую необходимо получить
//	ID_Узла - Строка - идентификатор узла в текущей сессии Mobile Smarts
//
// Возвращаемое значение:
//	Произвольный - значение настройки Mobile Smarts, переданной в параметре КлючНастройки
&НаКлиенте
Функция ЛокЯдро_ПолучитьНастройкуНаСервереSMARTS(КлючНастройки, ID_Узла = "") Экспорт
	
	СтруктураНастроек = Новый Структура(КлючНастройки, Ложь);
	СтруктураНастроек = ЛокЯдро_ПолучитьНастройкиНаСервереSMARTS(СтруктураНастроек, ID_Узла);
	
	Возврат СтруктураНастроек[КлючНастройки];
	
КонецФункции

// Получает значение табличной настройки из базы Mobile Smarts или значение ее отдельной колонки с возможностью выполнения отбора
//
// Параметры:
//	КлючТаблицы	- Строка - имя табличной настройки Mobile Smarts, из которой необходимо получить данные
//  Отбор - Структура - в качестве ключей содержит имена колонок табличной настройки Mobile Smarts, в качестве
//						значений - значения соответствующих колонок, по которым необходимо выполнить отбор
// 	ID_Узла - Строка - идентификатор узла получаемой настройки
//  ИмяКолонки - Строка - имя колонки табличной настройки Mobile Smarts, значение которой необходимо вернуть
//
// Возвращаемое значение:
//	- ТаблицаЗначений - если значение полученной настройки хранится в виде таблицы значений
//	- Массив из Структура - если значение полученной настройки хранится в виде массива структур
//	- Произвольный - если запрошено значение одной колонки
//  - Неопределено - если значение настройки получить не удалось
&НаКлиенте
Функция ЛокЯдро_ПолучитьЗначениеТабличнойНастройкиНаСервереSMARTS(КлючТаблицы, Отбор, ID_Узла = "", ИмяКолонки = "") Экспорт
	
	Результат = Неопределено;
	
	ТаблицаНастроек = ЛокЯдро_ПолучитьНастройкуНаСервереSMARTS(КлючТаблицы, ID_Узла);
	
	Если НЕ ТаблицаНастроек = Ложь И ТипЗнч(ТаблицаНастроек) = Тип("Массив") Тогда
		РезультатОтбора = ЛокЯдро_НайтиВМассивеСтруктурПоОтбору(ТаблицаНастроек,Отбор);
		Если РезультатОтбора <> Неопределено И РезультатОтбора.Количество() > 0 Тогда
			Если ЗначениеЗаполнено(ИмяКолонки) Тогда
				Результат = ?(РезультатОтбора.Количество() = 1, РезультатОтбора[0][ИмяКолонки], "");
			Иначе
				Результат = РезультатОтбора;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;	
	
	Возврат Результат;
	
КонецФункции

// Вызывает метод из модуля обработки для получения настройки из хранилища общих настроек
//
// Параметры:
//	КлючДляПолучения - Строка - имя настройки, которую необходимо получить	
//	ПолучитьПользовательскуюИОбщуюНастройку - определяет, нужно ли получить пользовательскую и общую настройку (Истина) или одну из них (Ложь)
//
// Возвращаемое значение:
//	- Структура - содержит:
//		* ПользовательскаяНастройка - Произвольный - значение пользовательской настройки
//      * ОбщаяНастройка - Произвольный - значение общей настройки
//	- Произвольный - значение пользовательской или - при отсутствии пользовательской - общей настройки
&НаКлиенте
Функция ЛокЯдро_ПолучитьДанныеИзХранилища1С(КлючДляПолучения, ПолучитьПользовательскуюИОбщуюНастройку = Ложь) Экспорт
	
	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода", "Функция");
	СтруктураВызова.Вставить("ИмяМетода", "ПолучитьДанныеИзХранилища1С");
	СтруктураВызова.Вставить("ПараметрыМетода", Новый Структура);
	СтруктураВызова.ПараметрыМетода.Вставить("КлючДляПолучения", КлючДляПолучения);
	СтруктураВызова.ПараметрыМетода.Вставить("ПолучитьПользовательскуюИОбщуюНастройку", ПолучитьПользовательскуюИОбщуюНастройку);
	
	Данные1С = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова);
	
	Возврат Данные1С; 	

КонецФункции

// Вызывает метод из модуля обработки для получения значений глобальных параметров для текущего узла в сессии Mobile Smarts
//
// Параметры:
//	ID_Узла - Строка - идентификатор узла в текущей сессии Mobile Smarts
//
// Возвращаемое значение:
//	Массив из Структура - содержит:	
//		* ID_Параметра - Строка
//		* Наименование - Строка
//		* Значение - Произвольный
//      * Комментарий - Строка
//      * Использование - Булево
//      * Тип - Строка
//      * ЗначениеПоУмолчанию - Произвольный
&НаКлиенте
Функция ЛокЯдро_ПолучитьЗначенияГлобальныхПараметров(ID_Узла = "") Экспорт
	
	ОбщиеПараметры = ЛокЯдро_ПолучитьИзКэшаНастройкуSMARTS("ГлобальныеПараметры");
	
	Если ID_Узла = ""
		И ТипЗнч(ДанныеТекущегоУзла) = Тип("Структура")
		И ДанныеТекущегоУзла.ID_Узла <> "" Тогда
		ID_Узла = ДанныеТекущегоУзла.ID_Узла;		
	КонецЕсли;
	
	ЧастныеПараметры = ЛокЯдро_ПолучитьНастройкуНаСервереSMARTS("ГлобальныеПараметры_Значения", ID_Узла);
	
	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода", "Функция");
	СтруктураВызова.Вставить("ИмяМетода", "ПолучитьЗначенияГлобальныхПараметров");
	ПараметрыМетода = Новый Структура;
	ПараметрыМетода.Вставить("ОбщиеПараметры", ОбщиеПараметры);
	ПараметрыМетода.Вставить("ЧастныеПараметры", ЧастныеПараметры);
	ПараметрыМетода.Вставить("ID_Узла", ID_Узла);
	СтруктураВызова.Вставить("ПараметрыМетода", ПараметрыМетода);
	
	ТаблицаПараметров = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,,АдресаПеременных);	
	
	Возврат ТаблицаПараметров;
		
КонецФункции

&НаКлиенте
Функция ЛокЯдро_НайтиПоЗначениюВМассивеСтруктур(Массив,КлючПоиска,Значене) Экспорт
	Для Каждого ЭлементМассива Из Массив Цикл
		Если ЭлементМассива.Свойство(КлючПоиска) И ЭлементМассива[КлючПоиска] = Значене Тогда
			Возврат ЭлементМассива;	
		КонецЕсли;
	КонецЦикла;
	Возврат Неопределено;
КонецФункции

// Удаляет значения текущих настроек в базе Mobile Smarts для возможности получения значений по умолчанию
//
// Параметры:
//	СтруктураНастроек - Структура - ключами являются имена настроек Mobile Smarts, значения которых необходимо получить	
//  ID_Узла - Строка - идентификатор узла в текущей сессии Mobile Smarts
//
// Возвращаемое значение:
//	Структура - структура настроек с заполненными значениями по умолчанию
&НаКлиенте
Функция ЛокЯдро_ПолучитьНастройкиПоУмолчаниюНаСервереSMARTS(СтруктураНастроек, ID_Узла = "") Экспорт
	
	Если КатегорииНастроекMS = Неопределено Тогда
		КатегорииНастроекMS = ЛокЯдро_ПолучитьКатегорииНастроекMS();
	КонецЕсли;
	
	Если РасположениеКомпоненты = "НаСервере" Тогда
		СтруктураВызова = Новый Структура;
		СтруктураВызова.Вставить("ТипМетода", 		"Функция");
		СтруктураВызова.Вставить("ИмяМетода", 		"ПолучитьНастройкиПоУмолчаниюНаСервереSMARTS");
		СтруктураВызова.Вставить("ПараметрыМетода", Новый Структура);
		СтруктураВызова.ПараметрыМетода.Вставить("СтруктураНастроек", СтруктураНастроек);
		СтруктураВызова.ПараметрыМетода.Вставить("УзловыеНастройки",  КатегорииНастроекMS.УзловыеНастройки);
		СтруктураВызова.ПараметрыМетода.Вставить("ID_Узла", 		  ID_Узла);
		СтруктураНастроек = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,, АдресаПеременных);
	Иначе
		ЛокЯдро_УдалитьНастройкиВБазеSMARTS(СтруктураНастроек, ID_Узла);
		СтруктураНастроек = ЛокЯдро_ПолучитьНастройкиНаСервереSMARTS(СтруктураНастроек);
		
		//Выполним обновление - Начало
		ВерсияОбработки = ЛокЯдро_ПолучитьИзКэшаНастройкуSMARTS("ВерсияОбработки");
		ВерсияОбработкиКлеверенсТСД = ЛокЯдро_ПолучитьИзКэшаНастройкуSMARTS("ВерсияОбработкиКлеверенсТСД");
		
		// Метод может быть вызван до инициализации для получения простых настроек, реструктуризация которых не требуется
		ПроверятьВерсиюОбработки = ВерсияОбработки <> Неопределено
			И ВерсияОбработкиКлеверенсТСД <> Неопределено;
		
		Если ПроверятьВерсиюОбработки И ВерсияОбработки > ВерсияОбработкиКлеверенсТСД Тогда
			СтруктураВызова = Новый Структура;
			СтруктураВызова.Вставить("ТипМетода", "Функция");
			СтруктураВызова.Вставить("ИмяМетода", "ВыполнитьОбновлениеНастроек");
			СтруктураВызова.Вставить("ПараметрыМетода", Новый Структура("ВерсияНастроек, СтруктураНастроек", ВерсияОбработкиКлеверенсТСД, СтруктураНастроек));
			
			СтруктураНастроек = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,,АдресаПеременных);
		КонецЕсли;
		//Выполним обновление - Конец
	КонецЕсли;
	
	Возврат СтруктураНастроек;
	
КонецФункции	

// Удаляет текущее значение настройки Mobile Smarts для возможности получения значения по умолчанию
//
// Параметры:
//	КлючНастройки - Строка - имя настройки Mobile Smarts, которую необходимо получить
//  ID_Узла - Строка - идентификатор узла в текущей сессии Mobile Smarts
//
// Возвращаемое значение:
//	Произвольный - значение настройки Mobile Smarts, переданной в параметре КлючНастройки
&НаКлиенте
Функция ЛокЯдро_ПолучитьНастройкуПоУмолчаниюНаСервереSMARTS(КлючНастройки, ID_Узла = "") Экспорт
	
	СтруктураНастроек = Новый Структура(КлючНастройки);
	СтруктураНастроек = ЛокЯдро_ПолучитьНастройкиПоУмолчаниюНаСервереSMARTS(СтруктураНастроек, ID_Узла);	
	
	Возврат СтруктураНастроек[КлючНастройки];
	
КонецФункции	

&НаКлиенте
Функция ЛокЯдро_ЗаполнитьНастройкиSMARTS(СтруктураНастроек, УзловыеНастройки, ID_Узла = "",ТипБазы = "Основная")
	
	НачалоСобытия = ТекущаяУниверсальнаяДатаВМиллисекундах();
	ИмяСобытия = "ЛокЯдро_ЗаполнитьНастройкиSMARTS";
	
	ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Начало, Получение настроек на сервере SMARTS");
	
	Если УзловыеНастройки = Неопределено Тогда
		КатегорииНастроекMS = КомЯдро_ПолучитьЗначениеПеременной("КатегорииНастроекMS");
		УзловыеНастройки = КатегорииНастроекMS.УзловыеНастройки;
	КонецЕслИ;
	
	// Получаем значения кэшируемых настроек, которые не нужно запрашивать и конвертировать
	АктуальныеНастройки = ЛокЯдро_ПроверитьАктуальностьКэшируемыхНастроек(СтруктураНастроек, ID_Узла);
	Для каждого АктуальнаяНастройка ИЗ АктуальныеНастройки Цикл	
		СтруктураНастроек.Удалить(АктуальнаяНастройка.Ключ);
	КонецЦикла;
	
	ТипИнтерфейса = КомЯдро_ПолучитьЗначениеПеременной("ТипИнтерфейса");
	Если ТипИнтерфейса = "REST_API" Тогда
		СтруктураНастроек = REST_API_ЗаполнитьНастройкиSMARTS(СтруктураНастроек, УзловыеНастройки, ID_Узла,ТипБазы);
	Иначе
		СтруктураНастроек = КомЯдро_ЗаполнитьНастройкиSMARTS(СтруктураНастроек, УзловыеНастройки, ID_Узла,ТипБазы);
	КонецЕсли;
	СтруктураНастроек = ЛокЯдро_КонвертироватьСериализуемыеНастройки(СтруктураНастроек, "ИзСтроки");
	
	// Кэшируем полученные из базы настройки
	ЛокЯдро_СохранитьЗначенияКэшируемыхНастроек(СтруктураНастроек, ID_Узла);
	
	// Дополняем возвращаемую структуру актуальными кэшируемыми настройками
	Для каждого АктуальнаяНастройка ИЗ АктуальныеНастройки Цикл	
		СтруктураНастроек.Вставить(АктуальнаяНастройка.Ключ, АктуальнаяНастройка.Значение);
	КонецЦикла;
	
	ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Конец, Получение настроек на сервере SMARTS", НачалоСобытия);
	
	Возврат СтруктураНастроек;
КонецФункции

&НаКлиенте
Процедура ЛокЯдро_ОбновитьМетаданныеТаблицMS(ТипБазы = "Основная") Экспорт

	#Если ВебКлиент Тогда
		СтруктураВызова = Новый Структура;
		СтруктураВызова.Вставить("ТипМетода", "Функция");
		СтруктураВызова.Вставить("ИмяМетода", "ОбновитьМетаданныеТаблицMS");
		СтруктураВызова.Вставить("ПараметрыМетода", Новый Структура("ТипБазы", ТипБазы));
		Таблицы = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,, АдресаПеременных);
	#Иначе
		ТипИнтерфейса = КомЯдро_ПолучитьЗначениеПеременной("ТипИнтерфейса");
		Если ТипИнтерфейса = "REST_API" Тогда
			Таблицы = REST_API_ОбновитьМетаданныеТаблицMS(ТипБазы);
		Иначе
			Таблицы = КомЯдро_ОбновитьМетаданныеТаблицMS(ТипБазы);
		КонецЕсли;
	#КонецЕсли
	
	Если Таблицы <> Неопределено
		И ТипЗнч(СтруктураМетаданных) = Тип("Структура")
		И СтруктураМетаданных.Свойство("Tables") Тогда
		СтруктураМетаданных.Вставить("Tables", Таблицы);	
	КонецЕсли;
	
КонецПроцедуры

&НаКлиенте
Процедура ЛокЯдро_ОбновитьМетаданныеДокументов1СВФоне() Экспорт
	
	ПараметрыМетода = Новый Структура; // Новый Структура("АдресаПеременных", АдресаПеременных);
	
	ПараметрыФЗ = Новый Структура;
	ПараметрыФЗ.Вставить("ИмяМетода", 				"ГлЯдро_ОбновитьМетаданныеДокументов1СВФоне");
	ПараметрыФЗ.Вставить("ПараметрыМетода", 		ПараметрыМетода);		
	ПараметрыФЗ.Вставить("НаименованиеФЗ",			"Обновление метаданных 1С");
	ПараметрыФЗ.Вставить("ТекстСообщения", 			"Обновление метаданных 1С");
	ПараметрыФЗ.Вставить("ВыводитьОкноОжидания", 	Ложь);
		
	ОписаниеОповещенияЗавершенияФЗ 	= Новый ОписаниеОповещения("ЛокЯдро_ОбновитьМетаданныеДокументов1СВФонеЗавершение", ЭтаФорма);
	ОписаниеОповещенияОшибкиФЗ 		= Новый ОписаниеОповещения("ЛокЯдро_ОбновитьМетаданныеДокументов1СВФонеОшибка", 	ЭтаФорма);

	ЛокЯдро_НачатьВыполнениеФоновогоЗадания(ПараметрыФЗ, ОписаниеОповещенияЗавершенияФЗ, ОписаниеОповещенияОшибкиФЗ);
	
КонецПроцедуры

&НаКлиенте
Процедура ЛокЯдро_ОбновитьМетаданныеДокументов1СВФонеЗавершение(Результат, ДополнительныеПараметры) Экспорт
	
	ИмяСобытия = "ЛокЯдро_ОбновитьМетаданныеДокументов1СВФоне";
	
	Если ЭтоАдресВременногоХранилища(Результат)
		И ТипЗнч(СтруктураМетаданных) = Тип("Структура") Тогда
		СтруктураРезультата = ПолучитьИзВременногоХранилища(Результат);
		
		Документы1С = СтруктураРезультата.Документы1С;
		Если ТипЗнч(Документы1С) = Тип("Структура") Тогда
			СтруктураМетаданных.Вставить("Документы1С", Документы1С);
			КомЯдро_СохранитьЗначениеПеременной("СтруктураМетаданных", СтруктураМетаданных);
			
			// При изменении кэша в процессе фонового задания дополнительно актуализировать кэш! // ЛокЯдро_ДополнитьСтруктуру(АдресаПеременных, СтруктураРезультата.АдресаПеременных, Ложь);
		КонецЕсли;
		
		ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Метаданные 1С успешно обновлены в фоне");
	КонецЕсли;
	
КонецПроцедуры

&НаКлиенте
Процедура ЛокЯдро_ОбновитьМетаданныеДокументов1СВФонеОшибка(Результат, ДополнительныеПараметры) Экспорт
	
	ИмяСобытия = "ЛокЯдро_ОбновитьМетаданныеДокументов1СВФоне";
	
	ТекстОшибки = Результат;
	
	ТекстСообщения = "Ошибка обновления метаданных 1С в фоне по причине:" + Символы.ПС + ТекстОшибки;
	
	ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", ТекстСообщения);
	
КонецПроцедуры

&НаКлиенте
Функция ЛокЯдро_ОбновитьМетаданныеДокументов1С(ИспользоватьХранилищеНастроек = Истина, ОбновлятьКэш = Ложь) Экспорт
	
	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода", 		"Функция");
	СтруктураВызова.Вставить("ИмяМетода", 		"ОбновитьМетаданныеДокументов1С");
	СтруктураВызова.Вставить("ПараметрыМетода", Новый Структура("ИспользоватьХранилищеНастроек", ИспользоватьХранилищеНастроек));
	
	Документы1С = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,, АдресаПеременных);
	
	Если ОбновлятьКэш Тогда
		СтруктураМетаданных.Вставить("Документы1С", Документы1С);
	КонецЕсли;
	
	Возврат Документы1С;
	
КонецФункции

&НаКлиенте
Функция ЛокЯдро_ОбновитьМетаданныеДокументовMS(ИспользоватьХранилищеНастроек = Истина, ОбновлятьКэш = Ложь) Экспорт
	
	Если РасположениеКомпоненты = "НаСервере" Тогда
		СтруктураВызова = Новый Структура;
		СтруктураВызова.Вставить("ТипМетода", 		"Функция");
		СтруктураВызова.Вставить("ИмяМетода", 		"ОбновитьМетаданныеДокументовMS");
		СтруктураВызова.Вставить("ПараметрыМетода", Новый Структура("ИспользоватьХранилищеНастроек", ИспользоватьХранилищеНастроек));
		
		пСтруктураМетаданных = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,, АдресаПеременных);	
	Иначе
		ЕстьЧастнаяБаза = КомЯдро_ПолучитьЗначениеПеременной("ЕстьЧастнаяБаза");
		Если ЕстьЧастнаяБаза = Истина Тогда
			ТипБазы = "Частная";
	    Иначе
			ТипБазы = "Основная";
		КонецЕсли;
		
		ИдентификаторБазыMS = "";
		ВерсияМетаданныхMS  = "";
		
		ТипИнтерфейса = КомЯдро_ПолучитьЗначениеПеременной("ТипИнтерфейса");
		Если ТипИнтерфейса = "REST_API"	Тогда
			Если ПараметрыПодключенияMS = Неопределено Тогда
				ПараметрыПодключенияMS = ЛокЯдро_ПолучитьДанныеИзХранилища1С("Cleverence_ПараметрыПодключенияMS");
			КонецЕсли;
			Если ТипЗнч(ПараметрыПодключенияMS) = Тип("Структура") Тогда
				ИдентификаторБазыMS = ?(ПараметрыПодключенияMS.Свойство("Ид"), ПараметрыПодключенияMS.Ид, "");
				ВерсияМетаданныхMS =  ?(ПараметрыПодключенияMS.Свойство("ВерсияКонфигурацииSMARTS"), ПараметрыПодключенияMS.ВерсияКонфигурацииSMARTS, "");
			КонецЕсли;
		Иначе
			Если ТипБазы = "Частная" Тогда
				СтруктураПодключенияMS = COMЧастнойБазыMS;
			Иначе
				СтруктураПодключенияMS = COMБазыMS;
			КонецЕсли;
		    ИдентификаторБазыMS = СтруктураПодключенияMS.StorageConnector.CurrentAppSettings.ServerAppInstanceId;
			ВерсияМетаданныхMS  = СтруктураПодключенияMS.StorageConnector.GetEnvironment().Version;
			ВерсияМетаданныхMS 	= Формат(ВерсияМетаданныхMS, "ЧГ=0");
		КонецЕсли;	
		
		Если НЕ ЗначениеЗаполнено(ВерсияМетаданныхMS) Тогда
			ИспользоватьХранилищеНастроек = Ложь;	
		КонецЕсли;
		
		ИдентификаторБазыMS = СтрЗаменить(ИдентификаторБазыMS, "-", "_");
		
		ИмяПеременнойВерсия 	= "Cleverence_ВерсияМетаданныхMS_" 	  + ИдентификаторБазыMS;
		ИмяПеременнойНастройки 	= "Cleverence_СтруктураМетаданныхMS_" + ИдентификаторБазыMS;
		
		Если ИспользоватьХранилищеНастроек Тогда
			СохраненнаяВерсияМетаданныхMS = ЛокЯдро_ПолучитьДанныеИзХранилища1С(ИмяПеременнойВерсия);
			Если НЕ ЗначениеЗаполнено(СохраненнаяВерсияМетаданныхMS)
				ИЛИ СокрЛП(СохраненнаяВерсияМетаданныхMS) <> СокрЛП(ВерсияМетаданныхMS) Тогда
				ИспользоватьХранилищеНастроек = Ложь;
			КонецЕсли;
		КонецЕсли;
		
		Если ИспользоватьХранилищеНастроек Тогда
			Если ТипИнтерфейса = "REST_API" Тогда
				пСтруктураМетаданных = REST_API_ПолучитьМетаданныеMSИзХранилища1С(ТипБазы, ИмяПеременнойНастройки);
			Иначе
				пСтруктураМетаданных = КомЯдро_ПолучитьМетаданныеMSИзХранилища1С(ТипБазы, ИмяПеременнойНастройки);
			КонецЕсли;
			
			Если пСтруктураМетаданных <> Неопределено Тогда
				Возврат пСтруктураМетаданных;
			КонецЕсли;
		КонецЕсли;
		
		Если ТипИнтерфейса = "REST_API" Тогда
			пСтруктураМетаданных = REST_API_ПолучитьМетаданныеДокументовMS(ТипБазы, ИмяПеременнойНастройки);
		Иначе
			пСтруктураМетаданных = КомЯдро_ПолучитьМетаданныеДокументовMS(ТипБазы, ИмяПеременнойНастройки);
		КонецЕсли;
		
		ЛокЯдро_СохранитьДанныеВХранилище1С(ИмяПеременнойВерсия, ВерсияМетаданныхMS);
    КонецЕсли;
	
	Если ОбновлятьКэш
		И пСтруктураМетаданных <> Неопределено Тогда
		СтруктураМетаданных.Вставить("ДокументыMS",					  пСтруктураМетаданных.ДокументыMS);
		СтруктураМетаданных.Вставить("ПользователиMS",				  пСтруктураМетаданных.ПользователиMS);
		СтруктураМетаданных.Вставить("УстройстваMS",				  пСтруктураМетаданных.УстройстваMS);
		СтруктураМетаданных.Вставить("Tables",						  пСтруктураМетаданных.Tables);
		СтруктураМетаданных.Вставить("UniПолейНоменклатуры", 		  пСтруктураМетаданных.UniПолейНоменклатуры);
		СтруктураМетаданных.Вставить("ВыгружаемыеПоляНоменклатурыMS", пСтруктураМетаданных.ВыгружаемыеПоляНоменклатурыMS);
	КонецЕсли;
	
	Возврат пСтруктураМетаданных;
	
КонецФункции

&НаКлиенте
Функция ЛокЯдро_ПолучитьЗначениеКэшируемойНастройки(КлючНастройки, ID_Узла) Экспорт
	
	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода", 		"Функция");
	СтруктураВызова.Вставить("ИмяМетода", 		"ПолучитьЗначениеКэшируемойНастройки");
	СтруктураВызова.Вставить("ПараметрыМетода", Новый Структура("КлючНастройки, ID_Узла", КлючНастройки, ID_Узла));
		
	ЗначениеНастройки = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,, АдресаПеременных);

	Возврат ЗначениеНастройки;
	
КонецФункции

&НаКлиенте
Функция ЛокЯдро_ПолучитьЗначенияКэшируемойНастройкиПоУзлам(КлючНастройки, НастройкиПоУзлам, СписокКолонок = Неопределено) Экспорт
	
	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода", 		"Функция");
	СтруктураВызова.Вставить("ИмяМетода", 		"ПолучитьЗначенияКэшируемойНастройкиПоУзлам");
	СтруктураВызова.Вставить("ПараметрыМетода", Новый Структура("КлючНастройки, НастройкиПоУзлам, СписокКолонок", КлючНастройки, НастройкиПоУзлам, СписокКолонок));
		
	НастройкиПоУзлам = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,, АдресаПеременных);

	Возврат НастройкиПоУзлам;
	
КонецФункции

&НаКлиенте
Процедура ЛокЯдро_СохранитьЗначениеКэшируемойНастройки(КлючНастройки, ЗначениеНастройки, ID_Узла) Экспорт
	
	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода", 		"Процедура");
	СтруктураВызова.Вставить("ИмяМетода", 		"СохранитьЗначениеКэшируемойНастройки");
	СтруктураВызова.Вставить("ПараметрыМетода", Новый Структура("КлючНастройки, ЗначениеНастройки, ID_Узла", КлючНастройки, ЗначениеНастройки, ID_Узла));
		
	Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,, АдресаПеременных);
	
КонецПроцедуры

&НаКлиенте
Процедура ЛокЯдро_СохранитьЗначенияКэшируемыхНастроек(СтруктураНастроек, ID_Узла) Экспорт
	
	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода", 		"Процедура");
	СтруктураВызова.Вставить("ИмяМетода", 		"СохранитьЗначенияКэшируемыхНастроек");
	СтруктураВызова.Вставить("ПараметрыМетода", Новый Структура("СтруктураНастроек, ID_Узла", СтруктураНастроек, ID_Узла));
		
	Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,, АдресаПеременных);
	
КонецПроцедуры

&НаКлиенте
Процедура ЛокЯдро_ПроверитьАктуальностьКэшируемыхНастроекПриИнициализации()

	ДатаАктуальностиВБазеSMARTS = ЛокЯдро_ПолучитьНастройкуНаСервереSMARTS("ДатаАктуальностиКэшируемыхНастроек");
	Если НЕ ЗначениеЗаполнено(ДатаАктуальностиВБазеSMARTS) ИЛИ ДатаАктуальностиВБазеSMARTS = Ложь Тогда
		Возврат;		
	КонецЕсли;
	
	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода", 		"Функция");
	СтруктураВызова.Вставить("ИмяМетода", 		"ПроверитьАктуальностьКэшируемыхНастроекПриИнициализации");
	СтруктураВызова.Вставить("ПараметрыМетода", Новый Структура("ДатаАктуальностиВБазеSMARTS", ДатаАктуальностиВБазеSMARTS));
		
	Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,, АдресаПеременных);
	
КонецПроцедуры

&НаКлиенте
Функция ЛокЯдро_ПроверитьАктуальностьКэшируемыхНастроек(СтруктураНастроек, ID_Узла)

	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода", 		"Функция");
	СтруктураВызова.Вставить("ИмяМетода", 		"ПроверитьАктуальностьКэшируемыхНастроек");
	СтруктураВызова.Вставить("ПараметрыМетода", Новый Структура("СтруктураНастроек, ID_Узла", СтруктураНастроек, ID_Узла));
		
	АктуальныеНастройки = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,, АдресаПеременных);
	
	Возврат АктуальныеНастройки;
	
КонецФункции

&НаКлиенте
Процедура ЛокЯдро_ОчиститьКэшируемыеНастройки(ИдентификаторБазыMS = "", СтруктураНастроек = Неопределено) Экспорт

	ПараметрыМетода = Новый Структура;
	ПараметрыМетода.Вставить("ИдентификаторБазыMS", ИдентификаторБазыMS);
	ПараметрыМетода.Вставить("СтруктураНастроек",	СтруктураНастроек);
	
	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода", 		"Процедура");
	СтруктураВызова.Вставить("ИмяМетода", 		"ОчиститьКэшируемыеНастройки");
	СтруктураВызова.Вставить("ПараметрыМетода", ПараметрыМетода);
		
	Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,, АдресаПеременных);

КонецПроцедуры

&НаКлиенте
Процедура ЛокЯдро_ОчиститьКэшируемыеНастройкиДляВсехУзлов(КлючНастройки) Экспорт

	// Если изменились настройки пользовательских бизнес-процессов, нужно будет пересобрать общую структуру для всех узлов
	ЛокЯдро_СохранитьЗначениеКэшируемойНастройки(КлючНастройки, Неопределено, "");
	ВсеУзлы = ЛокЯдро_ПолучитьИзКэшаНастройкуSMARTS("Узлы");
	Если ТипЗнч(ВсеУзлы) = Тип("Массив") Тогда
		Для Каждого СтрокаУзла Из ВсеУзлы Цикл
			Если СтрокаУзла.Свойство("ЭтоТаблицаЗначений") Тогда
				Продолжить;
			Конецесли;
			ЛокЯдро_СохранитьЗначениеКэшируемойНастройки(КлючНастройки, Неопределено, СтрокаУзла.ID_Узла);
		КонецЦикла;
	КонецЕсли;

КонецПроцедуры

&НаКлиенте
Функция ЛокЯдро_ПроверитьСохраненнуюСтрокуПодключения1С()
	
	#Область НесовместимыйКодFresh
	База1СПодключенаДата = ЛокЯдро_ПолучитьНастройкуНаСервереSMARTS("База1СПодключенаДата");
	
	Результат = ЗначениеЗаполнено(База1СПодключенаДата) И База1СПодключенаДата <> Ложь;
	#КонецОбласти //НесовместимыйКодFresh
	
	#Область СовместимыйКодFresh
	//База1СПодключенаДата 		 = ЛокЯдро_ПолучитьНастройкуНаСервереSMARTS("База1СПодключенаДата");
	//База1ССтрокаСоединенияКлиент = ЛокЯдро_ПолучитьНастройкуНаСервереSMARTS("ServiceHTTPAddress");
	//
	//Результат = ЗначениеЗаполнено(База1СПодключенаДата) И База1СПодключенаДата <> Ложь 
	//			И ЗначениеЗаполнено(База1ССтрокаСоединенияКлиент) И База1ССтрокаСоединенияКлиент <> Ложь;
	#КонецОбласти //СовместимыйКодFresh
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти

#Область ЛокальныйКонтекст_Настройки_УстановкаНастроек

// Обновляет значения текущих настроек Mobile Smarts в кэше переданными значениями настроек
//
// Параметры:
//	СтруктураНастроек - Структура - ключами являются имена настроек Mobile Smarts, значения которых необходимо сохранить
&НаКлиенте 
Процедура ЛокЯдро_ЗаписатьВКэшНастройкиSMARTS(СтруктураНастроек) Экспорт
	
	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода", "Процедура");
	СтруктураВызова.Вставить("ИмяМетода", "ЗаписатьВКэшНастройкиSMARTS");
	СтруктураВызова.Вставить("ПараметрыМетода", Новый Структура("СтруктураНастроек", СтруктураНастроек));
	Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,,АдресаПеременных);
	
	Для Каждого Настройка Из СтруктураНастроек Цикл
		ТекущиеНастройкиMS.Вставить(Настройка.Ключ, Настройка.Значение);
	КонецЦикла;
	
КонецПроцедуры

// Обновляет значение текущей настройки Mobile Smarts в кэше переданным значением
//
// Параметры:
//	КлючНастройки - Строка - имя настройки Mobile Smarts, значение которой необходимо сохранить
//  ЗначениеНастройки - Произвольный - значение настройки
&НаКлиенте 
Процедура ЛокЯдро_ЗаписатьВКэшНастройкуSMARTS(КлючНастройки, ЗначениеНастройки) Экспорт
		
	СтруктураНастроек = Новый Структура(КлючНастройки, ЗначениеНастройки);
	ЛокЯдро_ЗаписатьВКэшНастройкиSMARTS(СтруктураНастроек);
	
КонецПроцедуры

// Вызывает процедуру сохранения настроек в базе Mobile Smarts
//
// Параметры:
//	СтруктураНастроек - Структура - ключами являются имена настроек Mobile Smarts, значения которых необходимо сохранить
//  ID_Узла - Строка - идентификатор узла в текущей сессии Mobile Smarts
&НаКлиенте
Процедура ЛокЯдро_СохранитьНастройкиВБазеSMARTS(Знач СтруктураНастроек, ID_Узла = "") Экспорт
	
	НеКэшировать = Ложь;
	НеЛогировать = Ложь;
	Если СтруктураНастроек.Свойство("НеКэшировать", НеКэшировать) Тогда
		СтруктураНастроек.Удалить("НеКэшировать");
	КонецЕсли;
	Если СтруктураНастроек.Свойство("НеЛогировать", НеЛогировать) Тогда
		СтруктураНастроек.Удалить("НеЛогировать");				
	КонецЕсли;
	
	Если РасположениеКомпоненты = "НаСервере" Тогда
		СтруктураВызова = Новый Структура;
		СтруктураВызова.Вставить("ТипМетода", "Процедура");
		СтруктураВызова.Вставить("ИмяМетода", "СохранитьНастройкиВБазеSMARTS");
		СтруктураВызова.Вставить("ПараметрыМетода", Новый Структура("СтруктураНастроек,ID_Узла", СтруктураНастроек, ID_Узла));
		Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,,АдресаПеременных);
	Иначе
		// При сохранении настроек в базу также обновляем их в настройках пользователя
		Если НеКэшировать <> Истина Тогда
			ЛокЯдро_СохранитьЗначенияКэшируемыхНастроек(СтруктураНастроек, ID_Узла);
		КонецЕсли;
		
		Если КатегорииНастроекMS = Неопределено Тогда
			КатегорииНастроекMS = ЛокЯдро_ПолучитьКатегорииНастроекMS();		
		КонецЕсли;
		
		СтруктураНастроекДляЗаписи = ЛокЯдро_КонвертироватьСериализуемыеНастройки(СтруктураНастроек, "ВСтроку");
		Если НеЛогировать = Истина Тогда
			СтруктураНастроекДляЗаписи.Вставить("НеЛогировать", Истина);
		КонецЕсли;
		
		ТипИнтерфейса = КомЯдро_ПолучитьЗначениеПеременной("ТипИнтерфейса");
		Если ТипИнтерфейса = "REST_API" Тогда
			REST_API_ЗаписатьНастройкиSMARTS(СтруктураНастроекДляЗаписи, КатегорииНастроекMS.УзловыеНастройки, ID_Узла);
		Иначе	
			КомЯдро_ЗаписатьНастройкиSMARTS(СтруктураНастроекДляЗаписи, КатегорииНастроекMS.УзловыеНастройки, ID_Узла);
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

// Вызывает процедуру сохранения настройки в базе Mobile Smarts по ключу
//
// Параметры:
//	КлючНастройки - Строка - имя настройки Mobile Smarts, значение которой необходимо сохранить
//	ЗначениеНастройки - Произвольный - значение настройки
//  ID_Узла - Строка - идентификатор узла в текущей сессии Mobile Smarts
&НаКлиенте 
Процедура ЛокЯдро_СохранитьНастройкуВБазеSMARTS(КлючНастройки, ЗначениеНастройки, ID_Узла = "") Экспорт
	
	СтруктураНастроек = Новый Структура(КлючНастройки, ЗначениеНастройки);
	ЛокЯдро_СохранитьНастройкиВБазеSMARTS(СтруктураНастроек, ID_Узла);
	
КонецПроцедуры

// В базе Mobile SMARTS находит настройку табличного типа (массив структур) по ключу, 
// находит все строки, соответствующие отбору, и заполняет их значениями из переданной структуры настроек 
// 
// Параметры:
//	КлючНастройки - Строка - название настройки в базе SMARTS
//	Отбор - Структура - в качестве ключей содержит имена колонок табличной настройки Mobile Smarts, в качестве
//						значений - значения соответствующих колонок, по которым необходимо выполнить отбор
// 	СтруктураНастройки - Структура - сохраняемое значение табличной настройки
// 	ID_Узла - Строка - идентификатор узла сохраняемых настроек
//	ПолнаяЗамена - Булево - флаг необходимости полной замены значений настроек в отобранных строках
&НаКлиенте
Процедура ЛокЯдро_СохранитьСтрокуВТабличнойНастройкеMS(КлючНастройки, Отбор, СтруктураНастройки, ID_Узла = "", ПолнаяЗамена = Ложь) Экспорт
	
	ЭтоТекущийУзел = (ID_Узла = ДанныеТекущегоУзла.ID_Узла) ИЛИ (КатегорииНастроекMS.УзловыеНастройки.Найти(КлючНастройки) = Неопределено);
	Если ЭтоТекущийУзел Тогда
		ТаблицаНастроек = ЛокЯдро_ПолучитьИзКэшаНастройкуSMARTS(КлючНастройки);
	Иначе
		ТаблицаНастроек = ЛокЯдро_ПолучитьНастройкуНаСервереSMARTS(КлючНастройки, ID_Узла);
	КонецЕсли;
	
	// Новые настройки бизнес-процессов заключены в структуру, поэтому сначала получим саму таблицу из нее
	ТаблицаВСтруктуре = Ложь;
	Если ТипЗнч(ТаблицаНастроек) = Тип("Структура") И ТаблицаНастроек.Свойство("НастройкиБизнесПроцессов") Тогда
		ТаблицаВСтруктуре = Истина;		
		пТаблицаНастроек = Новый Структура(Новый ФиксированнаяСтруктура(ТаблицаНастроек));
		ТаблицаНастроек = пТаблицаНастроек.НастройкиБизнесПроцессов;	
	КонецЕсли;
	
	Если ТипЗнч(ТаблицаНастроек) <> Тип("Массив") Тогда
		ТаблицаНастроек = Новый Массив;
		ТаблицаНастроек.Добавить(СтруктураНастройки);
	Иначе
		СтрокиДляЗаполнения = ЛокЯдро_НайтиВМассивеСтруктурПоОтбору(ТаблицаНастроек,Отбор);
		Если СтрокиДляЗаполнения = Неопределено Тогда
			ТаблицаНастроек.Добавить(СтруктураНастройки);
		Иначе
			Если ПолнаяЗамена = Истина Тогда
				Для Каждого СтрокаНастройки Из СтрокиДляЗаполнения Цикл
					Для каждого КлючЗначение Из СтруктураНастройки Цикл
						СтрокаНастройки.Вставить(КлючЗначение.Ключ,КлючЗначение.Значение);
					КонецЦикла;
				КонецЦикла;
			Иначе
				Для Каждого СтрокаНастройки Из СтрокиДляЗаполнения Цикл
					ЗаполнитьЗначенияСвойств(СтрокаНастройки,СтруктураНастройки);
				КонецЦикла;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	//Создадим описание структуры массива		
	Если ТаблицаНастроек[0].Свойство("ЭтоТаблицаЗначений") = Ложь Тогда	
		ПеречислениеКолонок = "";
		Для Каждого Свойство Из СтруктураНастройки Цикл
			ПеречислениеКолонок = ПеречислениеКолонок+?(ПеречислениеКолонок = "","",",")+Свойство.Ключ;
		КонецЦикла;
		СтрокаОписания = Новый Структура("ЭтоТаблицаЗначений,КолонкиТаблицыЗначений",Истина,ПеречислениеКолонок);
		ТаблицаНастроек.Вставить(0,СтрокаОписания);
	КонецЕсли; 		
	
	Если ТаблицаВСтруктуре Тогда
		пТаблицаНастроек.Вставить("НастройкиБизнесПроцессов", ТаблицаНастроек);
		ТаблицаНастроек = пТаблицаНастроек;
	КонецЕсли;
	
	ЛокЯдро_СохранитьНастройкуВБазеSMARTS(КлючНастройки, ТаблицаНастроек, ID_Узла);
	Если ЭтоТекущийУзел Тогда
		ЛокЯдро_ЗаписатьВКэшНастройкуSMARTS(КлючНастройки, ТаблицаНастроек);
	КонецЕсли;
	
КонецПроцедуры

&НаКлиенте
Функция ЛокЯдро_ПолучитьТекущуюДатуНаСервере()
	
	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода", "Функция");
	СтруктураВызова.Вставить("ИмяМетода", "ПолучитьТекущуюДату");

	Возврат Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова);	

КонецФункции

// Вызывает метод из модуля обработки для сохранения данных в хранилище общих настроек
//
// Параметры:
//	 КлючДляСохранения - Строка - ключ настройки для сохранения
//   ДанныеДляСохранения - Произвольный - значение настройки для сохранения
&НаКлиенте
Процедура ЛокЯдро_СохранитьДанныеВХранилище1С(КлючДляСохранения, ДанныеДляСохранения) Экспорт
	
	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода", "Процедура");
	СтруктураВызова.Вставить("ИмяМетода", "СохранитьДанныеВХранилище1С");
	СтруктураВызова.Вставить("ПараметрыМетода", Новый Структура("КлючДляСохранения,ДанныеДляСохранения", КлючДляСохранения, ДанныеДляСохранения));
	
	Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова);	

КонецПроцедуры

// Вызывает процедуру обновления шаблонов весового товара в базе Mobile Smarts
//
// Параметры:
//	ТаблицаШаблонов - Массив из Структура - содержит:
//		* Префикс - Строка	
//      * ЦелаяЧасть - Строка
//      * ДробнаяЧасть - Строка
//      * ДлинаКодаВесовогоТовара - Строка
//      * ПрефиксВключенВКод - Булево
&НаКлиенте
Процедура ЛокЯдро_СохранитьШаблоныВесовогоТовараВБазеSMARTS() Экспорт
	
	ТаблицаШаблонов = Новый Массив;	
	ИспользоватьШаблоны = ЛокЯдро_ПолучитьИзКэшаНастройкуSMARTS("ИспользоватьШаблоныВесовогоТовара");
	Если ИспользоватьШаблоны Тогда
		СтрокаПрефиксов = ЛокЯдро_ПолучитьИзКэшаНастройкуSMARTS("ПрефиксКодаВесовогоТовара");
		СтрокаПрефиксов = ?(СокрЛП(СтрокаПрефиксов) = "", "21", СтрокаПрефиксов);
		ДлинаКодаВесовогоТовара = ЛокЯдро_ПолучитьИзКэшаНастройкуSMARTS("ДлинаКодаВесовогоТовара");
		ОбщаяДлина = 12;
		ДробнаяЧасть = ЛокЯдро_ПолучитьИзКэшаНастройкуSMARTS("ЧислоЗнаковПослеЗапятойВесТовара");
		ДробнаяЧасть = ?(ДробнаяЧасть = Ложь ИЛИ ДробнаяЧасть = 0, 3, ДробнаяЧасть);
		ЦелаяЧасть = ОбщаяДлина - (ДробнаяЧасть + ДлинаКодаВесовогоТовара);
		ПрефиксВключенВКод = ЛокЯдро_ПолучитьИзКэшаНастройкуSMARTS("ПрефиксВключенВКодВесовогоТовара");
		ПрефиксВключенВКод = ?(ПрефиксВключенВКод = Истина, Истина, Ложь); // если вернется неопределено или "", то ложь.  
		
		МассивПрефиксов = Новый Массив;
		Пока Истина Цикл
			ПозицияРазделителя = Найти(СтрокаПрефиксов, ",");
			Если ПозицияРазделителя = 0 Тогда
				Если (СокрЛП(СтрокаПрефиксов) <> "") Тогда
					МассивПрефиксов.Добавить(СтрокаПрефиксов);
				КонецЕсли;
				Прервать;
			КонецЕсли;
			МассивПрефиксов.Добавить(СокрЛП(Лев(СтрокаПрефиксов,ПозицияРазделителя - 1)));
			СтрокаПрефиксов = Сред(СтрокаПрефиксов, ПозицияРазделителя + 1);
		КонецЦикла;
		
		Для Каждого Префикс Из МассивПрефиксов Цикл
			НовыйШаблон = Новый Структура;
			НовыйШаблон.Вставить("Префикс",Префикс);
			НовыйШаблон.Вставить("ЦелаяЧасть",Строка(ЦелаяЧасть));
			НовыйШаблон.Вставить("ДробнаяЧасть",Строка(ДробнаяЧасть));
			НовыйШаблон.Вставить("ДлинаКодаВесовогоТовара",Строка(ДлинаКодаВесовогоТовара));
			НовыйШаблон.Вставить("ПрефиксВключенВКод",ПрефиксВключенВКод);
			ТаблицаШаблонов.Добавить(НовыйШаблон);
		КонецЦикла;
	КонецЕсли;
	
	ЕстьЧастнаяБаза = КомЯдро_ПолучитьЗначениеПеременной("ЕстьЧастнаяБаза");
	Если ЕстьЧастнаяБаза = Истина Тогда
		ТипБазы = "Частная";
	Иначе
		ТипБазы = "Основная";
	КонецЕсли;
	
	#Если ВебКлиент Тогда  
		СтруктураВызова = Новый Структура;
		СтруктураВызова.Вставить("ТипМетода", "Процедура");
		СтруктураВызова.Вставить("ИмяМетода", "СохранитьШаблоныВесовогоТовараВБазеSMARTS");
		СтруктураВызова.Вставить("ПараметрыМетода", Новый Структура("ТаблицаШаблонов,ТипБазы", ТаблицаШаблонов, ТипБазы));
		Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,,АдресаПеременных);	
	#Иначе
		Если РасположениеКомпоненты = "НаСервере" Тогда
			СтруктураВызова = Новый Структура;
			СтруктураВызова.Вставить("ТипМетода", "Процедура");
			СтруктураВызова.Вставить("ИмяМетода", "СохранитьШаблоныВесовогоТовараВБазеSMARTS");
			СтруктураВызова.Вставить("ПараметрыМетода", Новый Структура("ТаблицаШаблонов,ТипБазы", ТаблицаШаблонов, ТипБазы));
			Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,,АдресаПеременных);	
		Иначе               
			ТипИнтерфейса = ЛокЯдро_ПолучитьТипИнтерфейса(ТипБазы);	
	
			Если ТипИнтерфейса = "REST_API" Тогда				
				REST_API_ОбновитьШаблоныВесовогоТовараMS(ТаблицаШаблонов, ТипБазы);
			Иначе
				КомЯдро_ОбновитьШаблоныВесовогоТовараMS(ТаблицаШаблонов);
			КонецЕсли;
		КонецЕсли;  
	#КонецЕсли	
	
КонецПроцедуры

// Устанавливает в базе Mobile Smarts флаг, определяющий, будет ли доступен поиск по наименованию для выгруженной номенклатуры
&НаКлиенте
Процедура ЛокЯдро_УстановитьПоискПоНаименованиюИАртикулу() Экспорт
	
	УстановитьПоискПоНаименованиюИАртикулу = ЛокЯдро_ПолучитьИзКэшаНастройкуSMARTS("УстановитьПоискПоНаименованиюИАртикулу");
	
	ТипИнтерфейса = КомЯдро_ПолучитьЗначениеПеременной("ТипИнтерфейса");
	Если ТипИнтерфейса ="REST_API" Тогда
		Возврат;
	КонецЕсли;
	
	Если РасположениеКомпоненты = "НаСервере" Тогда
		СтруктураВызова = Новый Структура;
		СтруктураВызова.Вставить("ТипМетода", "Процедура");
		СтруктураВызова.Вставить("ИмяМетода", "УстановитьПоискПоНаименованиюИАртикулу");		
		СтруктураВызова.Вставить("ПараметрыМетода", Новый Структура("УстановитьПоискПоНаименованиюИАртикулу", УстановитьПоискПоНаименованиюИАртикулу));
		Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,,АдресаПеременных);	
	Иначе
		КомЯдро_УстановитьПоискПоНаименованиюИАртикулу(УстановитьПоискПоНаименованиюИАртикулу);
	КонецЕсли;
	
КонецПроцедуры

// Удаляет из базы Mobile SMARTS настройку по ключу
// 
// Параметры:
// 	КлючНастройки - Строка - название настройки
// 	ID_Узла - Строка - идентификатор узла удаляемой настройки
&НаКлиенте
Процедура ЛокЯдро_УдалитьНастройкуВБазеSMARTS(КлючНастройки, ID_Узла = "") Экспорт
	
	СтруктураНастроек = Новый Структура(КлючНастройки);
	ЛокЯдро_УдалитьНастройкиВБазеSMARTS(СтруктураНастроек, ID_Узла);
	
КонецПроцедуры	

// Вызывает процедуру удаления настроек в базе Mobile Smarts
//
// Параметры:
//	СтруктураНастроек - Структура - ключами являются имена настроек Mobile Smarts, которые необходимо удалить
//  ID_Узла - Строка - идентификатор узла в текущей сессии Mobile Smarts
&НаКлиенте
Процедура ЛокЯдро_УдалитьНастройкиВБазеSMARTS(Знач СтруктураНастроек, ID_Узла = "") Экспорт
	
	Если КатегорииНастроекMS = Неопределено Тогда
		КатегорииНастроекMS = ЛокЯдро_ПолучитьКатегорииНастроекMS();
	КонецЕсли;
	
	Если РасположениеКомпоненты = "НаСервере" Тогда
		СтруктураВызова = Новый Структура;
		СтруктураВызова.Вставить("ТипМетода", "Процедура");
		СтруктураВызова.Вставить("ИмяМетода", "УдалитьНастройкиВБазеSMARTS");				
		СтруктураВызова.Вставить("ПараметрыМетода", Новый Структура);
		СтруктураВызова.ПараметрыМетода.Вставить("СтруктураНастроек", СтруктураНастроек);
		СтруктураВызова.ПараметрыМетода.Вставить("УзловыеНастройки", КатегорииНастроекMS.УзловыеНастройки);
		СтруктураВызова.ПараметрыМетода.Вставить("ID_Узла", ID_Узла);				
		Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,,АдресаПеременных);
	Иначе		
		// При удалении настроек из базы также удаляем их из настроек пользователя
		ЛокЯдро_ОчиститьКэшируемыеНастройки(, СтруктураНастроек);
		
		ТипИнтерфейса = КомЯдро_ПолучитьЗначениеПеременной("ТипИнтерфейса");
		Если ТипИнтерфейса = "REST_API" Тогда
			REST_API_УдалитьНастройкиSMARTS(СтруктураНастроек, КатегорииНастроекMS.УзловыеНастройки, ID_Узла);
		Иначе
			КомЯдро_УдалитьНастройкиSMARTS(СтруктураНастроек, КатегорииНастроекMS.УзловыеНастройки, ID_Узла);
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

&НаКлиенте
Процедура ЛокЯдро_ОчиститьХранилищеОбщихНастроек1С() Экспорт
	
	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода", "Процедура");
	СтруктураВызова.Вставить("ИмяМетода", "ОчиститьХранилищеОбщихНастроек1С");	
	СтруктураВызова.Вставить("ПараметрыМетода", Новый Структура);
	
	Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова);	

КонецПроцедуры
#КонецОбласти

#Область ЛокальныйКонтекст_Настройки_ВспомогательныеМеханизмы

// Осуществляет поиск в массиве структур по отбору
// 
// Параметры:
//	пМассив - Массив из Структура - массив структур, в котором осуществляется поиск
//	пОтбор - Структура - содержит параметры отбора
// 
// Возвращаемое значение:
// 	Неопределено, Массив из Структура - если значение не найдено, то возвращается Неопределено, иначе возвращается массив найденных значений
&НаКлиенте
Функция ЛокЯдро_НайтиВМассивеСтруктурПоОтбору(пМассив, пОтбор) Экспорт
	
	Если ТипЗнч(пМассив) <> Тип("Массив") 
		ИЛИ ТипЗнч(пОтбор) <> Тип("Структура") 
		ИЛИ пМассив.Количество() = 0
		ИЛИ ТипЗнч(пМассив[0]) <> Тип("Структура") Тогда
		Возврат Неопределено;
	КонецЕсли;
	МассивРезультат = Новый Массив;	
	Для Каждого пСтруктура Из пМассив Цикл
		Если пСтруктура.Свойство("ЭтоТаблицаЗначений") Тогда
			Продолжить;
		КонецЕсли;
		Подходит = Истина;
		Для Каждого ЭлОтбора Из пОтбор Цикл
			Значение = Неопределено;
			Если НЕ пСтруктура.Свойство(ЭлОтбора.Ключ,Значение)
				ИЛИ Значение <> ЭлОтбора.Значение Тогда
				Подходит = Ложь;
				Прервать;
			КонецЕсли;
		КонецЦикла;
		Если Подходит Тогда
			МассивРезультат.Добавить(пСтруктура);
		КонецЕсли;
	КонецЦикла;
	Если МассивРезультат.Количество() > 0 Тогда
		Возврат МассивРезультат;
	Иначе
		Возврат Неопределено;
	КонецЕсли;	
	
КонецФункции

// Преобразует значения из структуры настроек в строку или из строки в значения.
// Преобразуются только сериализуемые настройки. Сериализуемые берутся из параметра или из глобальных переменных
// 
// Параметры:
//	СтруктураНастроек - Структура - структура преобразовываемых настроек
//	Направление - Строка - направление преобразования "ИзСтроки" или "ВСтроку"
//	СериализуемыеНастройки - Массив из Строка, Неопределено - массив с именами настроек для преобразования 
//
// Возвращаемое значение:
//	Структура - структура преобразованных настроек
&НаКлиенте
Функция ЛокЯдро_КонвертироватьСериализуемыеНастройки(СтруктураНастроек, Направление, СериализуемыеНастройки = Неопределено) Экспорт
	
	НачалоСобытия = ТекущаяУниверсальнаяДатаВМиллисекундах();
	
	Если СериализуемыеНастройки = Неопределено Тогда
		СериализуемыеНастройки = КатегорииНастроекMS.СериализуемыеНастройки;
	КонецЕсли;
	
	Для Каждого Настройка Из СтруктураНастроек Цикл
		Если НЕ Настройка.Значение = Ложь И СериализуемыеНастройки.Найти(Настройка.Ключ) <> Неопределено Тогда
			
			ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации("ЛокЯдро_КонвертироватьСериализуемыеНастройки", "Информация", "Начало, " + Направление + ", " + СокрЛП(Настройка.Ключ), НачалоСобытия);
			ЗначениеНастройки = Настройка.Значение;
			Если Направление = "ИзСтроки" Тогда
				ЗначениеНастройки = ЛокЯдро_ЗначениеИзСтрокиXML(ЗначениеНастройки,Истина);
			ИначеЕсли Направление = "ВСтроку" Тогда	
				ЗначениеНастройки = ЛокЯдро_ЗначениеВСтрокуXML(ЗначениеНастройки);
			КонецЕсли;
			СтруктураНастроек.Вставить(Настройка.Ключ, ЗначениеНастройки);
			ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации("ЛокЯдро_КонвертироватьСериализуемыеНастройки", "Информация", "Конец, " + Направление + ", " + СокрЛП(Настройка.Ключ), НачалоСобытия);
			
		КонецЕсли;
	КонецЦикла;
	
	Возврат СтруктураНастроек;
	
КонецФункции

// Получает список доступных реквизитов для формирования представлений документов, выгружаемых в базу Mobile SMARTS
// 
// Параметры:
//	ИмяДокумента1С - Строка - название документа 1С
//
// Возвращаемое значение:
//	СписокЗначений - список реквизитов документа
&НаКлиенте
Функция ЛокЯдро_ПолучитьСписокРеквизитовВПредставленииДокумента(ИмяДокумента1С = Неопределено) Экспорт
	
	// Список реквизитов по умолчанию для всех конфигураций 	
	СписокРекв = Новый СписокЗначений;
	Если ИмяДокумента1С = Неопределено Тогда // Временное решение. Если не указано имя документа, то значит запрос пришел от формы обмена 
		СписокРекв.Добавить("Ссылка", "Название");
		СписокРекв.Добавить("Количество", "Количество строк");
		СписокРекв.Добавить("БизнесПроцесс","Бизнес процесс");
	Иначе
		СписокРекв.Добавить("Ссылка", "Ссылка");
		СписокРекв.Добавить("Количество", "Количество");	
	КонецЕсли;
	
	СписокРекв.Добавить("Дата", "Дата");
	СписокРекв.Добавить("Номер", "Номер");
	 	
	// дополнительные реквизиты, настроенные для подключенной конфигурации
	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода", "Функция");
	СтруктураВызова.Вставить("ИмяМетода", "ПолучитьДопРеквизитыПредставленияДокумента");
	ПараметрыМетода = Новый Структура;
	ПараметрыМетода.Вставить("ИмяДокумента1С", ИмяДокумента1С);
	СтруктураВызова.Вставить("ПараметрыМетода", ПараметрыМетода);
	
	СписокДопРеквизитов = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,,АдресаПеременных);
	Если СписокДопРеквизитов <> Неопределено Тогда
		Для Каждого ДопРеквизит из СписокДопРеквизитов Цикл
			СписокРекв.Добавить(ДопРеквизит.Значение, ДопРеквизит.Представление);
		КонецЦикла;
	КонецЕсли;
	
	Возврат СписокРекв;
	
КонецФункции

// Получает список доступных реквизитов для формирования таблицы документов Mobile SMARTS
// 
// Возвращаемое значение:
//	Массив - массив реквизитов документа
&НаКлиенте
Функция ЛокЯдро_ПолучитьМассивКолонокТаблицыДокументовSMARTS() Экспорт
	
	// Список реквизитов по умолчанию для всех конфигураций 	
	СписокРеквизитов = Новый СписокЗначений;
	
	СписокРеквизитов.Добавить("ДатаСоздания", 				"Дата создания");
	СписокРеквизитов.Добавить("Имя", 						"Наименование");
	СписокРеквизитов.Добавить("СтрокиПланКоличество", 		"Строки план");
	СписокРеквизитов.Добавить("СтрокиФактКоличество", 		"Строки факт");
	СписокРеквизитов.Добавить("Состояние", 					"Состояние");
	СписокРеквизитов.Добавить("ИмяПользователя", 			"Имя пользователя");
	СписокРеквизитов.Добавить("ИмяТипаДокумента", 			"Имя типа документа");
	СписокРеквизитов.Добавить("ДатаЗавершения", 			"Дата завершения");
	СписокРеквизитов.Добавить("ИмяБП", 						"Имя бизнес-процесса");
	СписокРеквизитов.Добавить("КонтрольКоличества", 		"Контроль количества");
	СписокРеквизитов.Добавить("ЕстьНедобор", 				"Есть недобор");
	СписокРеквизитов.Добавить("ЕстьПереполнение", 			"Есть переполнение");
	СписокРеквизитов.Добавить("ЕстьПереполнениеИлиНедобор", "Есть переполнение или недобор");
	СписокРеквизитов.Добавить("СозданНаТСД", 				"Создан на ТСД");
	СписокРеквизитов.Добавить("Ид", 						"Ид");
	СписокРеквизитов.Добавить("НастройкаБизнесПроцесса", 	"Настройка бизнес-процесса");
	СписокРеквизитов.Добавить("ИдИсходныхДокументов", 		"Ид исходных документов");
	
	#Если Не ВебКлиент Тогда
		
		// Дополняем существующую таблицу реквизитами шапки всех доступных типов документов
		СтруктураДоступныхДокументов = СтруктураМетаданных.ДокументыMS;
		Для Каждого ТипДокумента Из СтруктураДоступныхДокументов Цикл
			МассивРеквизитов = ТипДокумента.Значение.Реквизиты;
			Для Каждого СтрокаРеквизит Из МассивРеквизитов Цикл
				Если Не СписокРеквизитов.НайтиПоЗначению(СтрокаРеквизит.Значение) = Неопределено Тогда
					Продолжить;
				КонецЕсли;                                                                   			
				СписокРеквизитов.Добавить(СтрокаРеквизит.Значение, СтрокаРеквизит.Ключ);			
			КонецЦикла;		
			
		КонецЦикла;
	#КонецЕсли
	
	Возврат СписокРеквизитов;
	
КонецФункции

// Находит первое вхождение искомой строки как подстроки в исходной строке.
// Сравнение выполняется с учетом регистра.
//
// Параметры:
//	Строка - Строка - исходная строка
//  ПодстрокаПоиска - Строка - искомая подстрока
//  НаправлениеПоиска - Неопределено, Строка - направление поиска подстроки в строке ("СНачала", "СКонца")
//  НачальнаяПозиция - Неопределено, Число - позиция в строке, с которой начинается поиск
//	НомерВхождения - Число - номер вхождения искомой подстроки в исходной строке
//
// Возвращаемое значение:
//	Число - номер вхождения искомой подстроки в исходной строке
&НаКлиенте
Функция ЛокЯдро_СтрНайти(Строка, ПодстрокаПоиска, НаправлениеПоиска = Неопределено, НачальнаяПозиция = Неопределено, НомерВхождения = 1) Экспорт
	Результат = 0;
	
	// НаправлениеПоиска: СКонца,СНачала. По умолчанию: СНачала
	Если Строка = "" и ПодстрокаПоиска = "" Тогда
		// чтобы отрабатывало как в платформе
		Если НаправлениеПоиска = "СКонца" Тогда
			Если НомерВхождения = 1 Тогда
				Возврат 1;
			Иначе
				Возврат 0;
			КонецЕсли;
		Иначе
			Возврат мин(НомерВхождения, ?(НачальнаяПозиция=Неопределено, 1, НачальнаяПозиция));
		КонецЕсли;
	КонецЕсли;
	
	Если НачальнаяПозиция = Неопределено Тогда
		Если НаправлениеПоиска = "СКонца" Тогда
			лНачальнаяПозиция = СтрДлина(Строка);
		Иначе
			лНачальнаяПозиция = 1;
		КонецЕсли;
	Иначе
		лНачальнаяПозиция = НачальнаяПозиция;
	КонецЕсли;
	
	Если НаправлениеПоиска = "СКонца" Тогда
		лСтрока = "";
		Для сч = 1 По СтрДлина(Строка) Цикл
			лСтрока = Сред(Строка, сч, 1) + лСтрока;
		КонецЦикла;
		лПодстрокаПоиска = "";
		Для сч = 1 По СтрДлина(ПодстрокаПоиска) Цикл
			лПодстрокаПоиска = Сред(ПодстрокаПоиска, сч, 1) + лПодстрокаПоиска;
		КонецЦикла;
		лНачальнаяПозиция = макс(1, СтрДлина(Строка)-лНачальнаяПозиция-СтрДлина(ПодстрокаПоиска)+2);
	Иначе
		лСтрока = Строка;
		лПодстрокаПоиска = ПодстрокаПоиска;
		лНачальнаяПозиция = лНачальнаяПозиция;
	КонецЕсли;
	
	лНомерВхождения = 0;
	Результат = Найти(Сред(лСтрока, лНачальнаяПозиция), лПодстрокаПоиска);
	Пока Результат Цикл
		лНачальнаяПозиция = Результат + лНачальнаяПозиция + СтрДлина(ПодстрокаПоиска)-1;
		лНомерВхождения = лНомерВхождения + 1;
		Если лНомерВхождения = НомерВхождения Тогда
			Прервать;
		КонецЕсли;
		Результат = Найти(Сред(лСтрока, лНачальнаяПозиция), лПодстрокаПоиска);
	КонецЦикла;
	
	Если лНомерВхождения = НомерВхождения Тогда
		Результат = лНачальнаяПозиция - СтрДлина(ПодстрокаПоиска);
	Иначе
		Результат = 0;
	КонецЕсли;
	
	Если НаправлениеПоиска = "СКонца" И Результат<>0 Тогда
		Результат = СтрДлина(Строка) - Результат - СтрДлина(ПодстрокаПоиска) + 2;
	КонецЕсли;
	
	Возврат Результат;        
			
КонецФункции

&НаСервере
Функция ЛокЯдро_СтрНайтиНаСервере(Строка, ПодстрокаПоиска, НаправлениеПоиска = Неопределено, НачальнаяПозиция = Неопределено, НомерВхождения = 1) Экспорт
	Результат = 0;
	
	// НаправлениеПоиска: СКонца,СНачала. По умолчанию: СНачала
	Если Строка = "" и ПодстрокаПоиска = "" Тогда
		// чтобы отрабатывало как в платформе
		Если НаправлениеПоиска = "СКонца" Тогда
			Если НомерВхождения = 1 Тогда
				Возврат 1;
			Иначе
				Возврат 0;
			КонецЕсли;
		Иначе
			Возврат мин(НомерВхождения, ?(НачальнаяПозиция=Неопределено, 1, НачальнаяПозиция));
		КонецЕсли;
	КонецЕсли;
	
	Если НачальнаяПозиция = Неопределено Тогда
		Если НаправлениеПоиска = "СКонца" Тогда
			лНачальнаяПозиция = СтрДлина(Строка);
		Иначе
			лНачальнаяПозиция = 1;
		КонецЕсли;
	Иначе
		лНачальнаяПозиция = НачальнаяПозиция;
	КонецЕсли;
	
	Если НаправлениеПоиска = "СКонца" Тогда
		лСтрока = "";
		Для сч = 1 По СтрДлина(Строка) Цикл
			лСтрока = Сред(Строка, сч, 1) + лСтрока;
		КонецЦикла;
		лПодстрокаПоиска = "";
		Для сч = 1 По СтрДлина(ПодстрокаПоиска) Цикл
			лПодстрокаПоиска = Сред(ПодстрокаПоиска, сч, 1) + лПодстрокаПоиска;
		КонецЦикла;
		лНачальнаяПозиция = макс(1, СтрДлина(Строка)-лНачальнаяПозиция-СтрДлина(ПодстрокаПоиска)+2);
	Иначе
		лСтрока = Строка;
		лПодстрокаПоиска = ПодстрокаПоиска;
		лНачальнаяПозиция = лНачальнаяПозиция;
	КонецЕсли;
	
	лНомерВхождения = 0;
	Результат = Найти(Сред(лСтрока, лНачальнаяПозиция), лПодстрокаПоиска);
	Пока Результат Цикл
		лНачальнаяПозиция = Результат + лНачальнаяПозиция + СтрДлина(ПодстрокаПоиска)-1;
		лНомерВхождения = лНомерВхождения + 1;
		Если лНомерВхождения = НомерВхождения Тогда
			Прервать;
		КонецЕсли;
		Результат = Найти(Сред(лСтрока, лНачальнаяПозиция), лПодстрокаПоиска);
	КонецЦикла;
	
	Если лНомерВхождения = НомерВхождения Тогда
		Результат = лНачальнаяПозиция - СтрДлина(ПодстрокаПоиска);
	Иначе
		Результат = 0;
	КонецЕсли;
	
	Если НаправлениеПоиска = "СКонца" И Результат<>0 Тогда
		Результат = СтрДлина(Строка) - Результат - СтрДлина(ПодстрокаПоиска) + 2;
	КонецЕсли;
	
	Возврат Результат;        
			
КонецФункции

// Соединяет массив переданных строк в одну строку с указанным разделителем.
//
// Параметры:
//	Строки - Массив - массив, содержащий объединяемые строки.
//  Разделитель - Строка - строка, которая будет вставлена между объединяемыми строками.
//
// Возвращаемое значение:
//	Строка - строка, содержащая соединенные исходные строки с разделителем между ними.
//
&НаКлиенте
Функция ЛокЯдро_СтрСоединить(Строки, знач Разделитель = Неопределено) Экспорт
	
	Результат = "";
	
	Если Разделитель = Неопределено Тогда
		Разделитель = "";
	КонецЕсли;
	
	Если Строки.Количество() <> 0 Тогда
		Результат = Строки[0];
	КонецЕсли;
	
	Для Счетчик = 1 По Строки.ВГраница() Цикл
		Результат = Результат + Разделитель + Строки[Счетчик];
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

&НаКлиенте
Функция ЛокЯдро_ПолучитьМаксимальныйКодСимволаСтроки(СтрокаАнализа) Экспорт
	
	ДлинаСтрокиАнализа = СтрДлина(СтрокаАнализа);
	
	МаксимальныйКодСимвола = 0;
	
	Для Счетчик = 1 По ДлинаСтрокиАнализа Цикл
				
		КодТекущегоСимвола = КодСимвола(СтрокаАнализа, Счетчик);
		Если КодТекущегоСимвола > МаксимальныйКодСимвола Тогда
			МаксимальныйКодСимвола = КодТекущегоСимвола;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат МаксимальныйКодСимвола;
	
КонецФункции

&НаКлиенте
Функция ЛокЯдро_ПолучитьКлючШифрования(лПароль, ДлинаКодируемойСтроки) Экспорт
	
	лПароль_Длина 	= СтрДлина(лПароль);
	КлючШифрования	= "";
	
	ЧислоДляИнциализацииГенератораСлучаныхЧисел = ЛокЯдро_ПолучитьМаксимальныйКодСимволаСтроки(лПароль_Длина);
	
	ЧислоДляИнциализацииГенератораСлучаныхЧисел = ЧислоДляИнциализацииГенератораСлучаныхЧисел + ДлинаКодируемойСтроки;
	
	ГенераторСлучаныхЧисел = Новый ГенераторСлучайныхЧисел(ЧислоДляИнциализацииГенератораСлучаныхЧисел);
	
	СчетчикПоПаролю = Неопределено;
	
	Для Счетчик = 1 По ДлинаКодируемойСтроки Цикл
		
		Если (СчетчикПоПаролю = Неопределено) ИЛИ (СчетчикПоПаролю > лПароль_Длина) Тогда
			
			СчетчикПоПаролю = 1;
				
		КонецЕсли;
		
		СлучайноеСмещение = ГенераторСлучаныхЧисел.СлучайноеЧисло(1, ЧислоДляИнциализацииГенератораСлучаныхЧисел);
				
		СимволПароля = Сред(лПароль, СчетчикПоПаролю, 1);
		
		КлючШифрования = КлючШифрования + Символ(КодСимвола(СимволПароля) + СлучайноеСмещение);
		
		СчетчикПоПаролю = СчетчикПоПаролю + 1;
		
	КонецЦикла;
	
	Возврат КлючШифрования;
	
КонецФункции

&НаКлиенте
Функция ЛокЯдро_ЗашифроватьСтроку(КодируемаяСтрока, КлючШифрования) Экспорт
	
	ДлинаКодируемойСтроки = СтрДлина(КодируемаяСтрока);
	
	ЧислоДляИнциализацииГенератораСлучаныхЧисел = ЛокЯдро_ПолучитьМаксимальныйКодСимволаСтроки(КлючШифрования);
	
	ЧислоДляИнциализацииГенератораСлучаныхЧисел = ЧислоДляИнциализацииГенератораСлучаныхЧисел + ДлинаКодируемойСтроки;
	
	ГенераторСлучаныхЧисел = Новый ГенераторСлучайныхЧисел(ЧислоДляИнциализацииГенератораСлучаныхЧисел);
	
	ЗакодированнаяСтрока = "";
	
	Для Счетчик = 1 ПО ДлинаКодируемойСтроки Цикл
		
		КодСимволаИсходнойСтроки 	= КодСимвола(КодируемаяСтрока, Счетчик);
		КодСимволаКлючаШифрования 	= КодСимвола(КлючШифрования, Счетчик);		
		СлучайнаяСоставляющая 		= ГенераторСлучаныхЧисел.СлучайноеЧисло(1, ЧислоДляИнциализацииГенератораСлучаныхЧисел);
		
		КодЗакодированныгоСимвола = КодСимволаИсходнойСтроки + КодСимволаКлючаШифрования + СлучайнаяСоставляющая;
		
		ЗакодированнаяСтрока = ЗакодированнаяСтрока + Символ(КодЗакодированныгоСимвола);
		
	КонецЦикла;
	
	Возврат ЗакодированнаяСтрока;
	
КонецФункции

&НаКлиенте
Функция ЛокЯдро_РасшифроватьСтроку(КодируемаяСтрока, КлючШифрования) Экспорт
	
	ДлинаКодируемойСтроки = СтрДлина(КодируемаяСтрока);
	
	ЧислоДляИнциализацииГенератораСлучаныхЧисел = ЛокЯдро_ПолучитьМаксимальныйКодСимволаСтроки(КлючШифрования);
	
	ЧислоДляИнциализацииГенератораСлучаныхЧисел = ЧислоДляИнциализацииГенератораСлучаныхЧисел + ДлинаКодируемойСтроки;
	
	ГенераторСлучаныхЧисел = Новый ГенераторСлучайныхЧисел(ЧислоДляИнциализацииГенератораСлучаныхЧисел);
	
	ЗакодированнаяСтрока = "";
	
	Для Счетчик = 1 ПО ДлинаКодируемойСтроки Цикл
		
		КодСимволаКлючаШифрования 	= КодСимвола(КлючШифрования, Счетчик);			
		КодЗакодированныгоСимвола 	= КодСимвола(КодируемаяСтрока, Счетчик);
		СлучайнаяСоставляющая 		= ГенераторСлучаныхЧисел.СлучайноеЧисло(1, ЧислоДляИнциализацииГенератораСлучаныхЧисел);
		
		КодСимволаИсходнойСтроки = КодЗакодированныгоСимвола - КодСимволаКлючаШифрования - СлучайнаяСоставляющая;
		
		ЗакодированнаяСтрока = ЗакодированнаяСтрока + Символ(КодСимволаИсходнойСтроки);
		
	КонецЦикла;
	
	Возврат ЗакодированнаяСтрока;
	
КонецФункции

// Проверка соответствия структуры сохраненных параметров подключения базы SMARTS актуальным
// и в случае необходимости дополнение свойств (для исключения ошибок после обновления)
&НаКлиенте
Функция ЛокЯдро_АктуализацияСтруктурыПараметровПодключенияSMARTS(Знач СохраненныеПараметрыПодключения) Экспорт
	
	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода", 		"Функция");
	СтруктураВызова.Вставить("ИмяМетода", 		"АктуализацияСтруктурыПараметровПодключенияSMARTS");
	СтруктураВызова.Вставить("ПараметрыМетода", Новый Структура);
	СтруктураВызова.ПараметрыМетода.Вставить("СохраненныеПараметрыПодключения", СохраненныеПараметрыПодключения);
	
	Результат = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова);
	
	Возврат Результат; 	

КонецФункции

// Проверка соответствия структуры сохраненных параметров подключения базы SMARTS актуальным
// и в случае необходимости дополнение свойств (для исключения ошибок после обновления)
&НаКлиенте
Функция ЛокЯдро_СкомпоноватьСтруктуруНастроекДляСохранения(НастройкиБизнесПроцессов, ВерсияНастроек) Экспорт
		
	НовыйФорматНастроек = КомЯдро_ПолучитьЗначениеПеременной("НовыеНастройкиБизнесПроцессов");
	Если НовыйФорматНастроек Тогда	
		СтруктураНастроек = Новый Структура("ВерсияНастроек, НастройкиБизнесПроцессов", ВерсияНастроек, НастройкиБизнесПроцессов);
	Иначе
		// Для баз со старыми настройками оставляем сохранение настроек как есть, чтобы не сломать работу в случае случайного открытия новой обработки
		СтруктураНастроек = НастройкиБизнесПроцессов;
	КонецЕсли;

	Возврат СтруктураНастроек;	

КонецФункции

// Получение структуры настроек бизнес-процессов с учетом возможного наличия старых ключей и свойств настроек
//
&НаКлиенте
Функция ЛокЯдро_ПолучитьИзКэшаСтруктуруПользовательскихНастроекБизнесПроцессов() Экспорт
	
	Возврат ЛокЯдро_ПолучитьИзКэшаСтруктуруНастроекБизнесПроцессов("ВерсияНастроек", "НастройкиБизнесПроцессов_Пользовательские");	
	
КонецФункции

&НаКлиенте
Функция ЛокЯдро_ПолучитьИзКэшаСтруктуруИзмененныхТиповыхНастроекБизнесПроцессов() Экспорт
	
	Возврат ЛокЯдро_ПолучитьИзКэшаСтруктуруНастроекБизнесПроцессов("ВерсияНастроек", "НастройкиБизнесПроцессов_ПользовательскиеНастройки");	
	
КонецФункции

&НаКлиенте
Функция ЛокЯдро_ПолучитьИзКэшаСтруктуруНастроекПоУмолчаниюБизнесПроцессов() Экспорт
	
	Возврат ЛокЯдро_ПолучитьИзКэшаСтруктуруНастроекБизнесПроцессов("ВерсияНастроек_ПоУмолчанию", "НастройкиБизнесПроцессов_ПоУмолчанию");	
	
КонецФункции

&НаКлиенте
Функция ЛокЯдро_ПолучитьИзКэшаСтруктуруНастроекБизнесПроцессов(ВерсияНастроекИмя = "", НастройкиБизнесПроцессовИмя = "")
	
	СтруктураВозврат = Новый Структура("ВерсияНастроек,НастройкиБизнесПроцессов", Неопределено, Неопределено);	
	
	СтруктураНастроекБизнесПроцессов = ЛокЯдро_ПолучитьИзКэшаНастройкуSMARTS(НастройкиБизнесПроцессовИмя);
	
	Если ТипЗнч(СтруктураНастроекБизнесПроцессов) = Тип("Структура") Тогда
		ЗаполнитьЗначенияСвойств(СтруктураВозврат, СтруктураНастроекБизнесПроцессов);				
	Иначе				
		СтруктураВозврат.ВерсияНастроек 			= ЛокЯдро_ПолучитьИзКэшаНастройкуSMARTS(ВерсияНастроекИмя);
		СтруктураВозврат.НастройкиБизнесПроцессов 	= СтруктураНастроекБизнесПроцессов;
	КонецЕсли;
	
	
	Возврат СтруктураВозврат;
	
КонецФункции

&НаКлиенте
Функция ЛокЯдро_ПолучитьСтруктуруПользовательскихНастроекБизнесПроцессовНаСервереSMARTS(ID_Узла = "") Экспорт
	
	Возврат ЛокЯдро_ПолучитьСтруктуруНастроекБизнесПроцессовНаСервереSMARTS("ВерсияНастроек", "НастройкиБизнесПроцессов_Пользовательские", ID_Узла);	
	
КонецФункции

&НаКлиенте
Функция ЛокЯдро_ПолучитьСтруктуруИзмененныхТиповыхНастроекБизнесПроцессовНаСервереSMARTS(ID_Узла = "") Экспорт
	
	Возврат ЛокЯдро_ПолучитьСтруктуруНастроекБизнесПроцессовНаСервереSMARTS("ВерсияНастроек", "НастройкиБизнесПроцессов_ПользовательскиеНастройки", ID_Узла);	
	
КонецФункции

&НаКлиенте
Функция ЛокЯдро_ПолучитьСтруктуруНастроекБизнесПроцессовПоУмолчаниюНаСервереSMARTS(ID_Узла = "") Экспорт
	
	Возврат ЛокЯдро_ПолучитьСтруктуруНастроекБизнесПроцессовНаСервереSMARTS("ВерсияНастроек_ПоУмолчанию", "НастройкиБизнесПроцессов_ПоУмолчанию", ID_Узла);	
	
КонецФункции

&НаКлиенте
Функция ЛокЯдро_ПолучитьСтруктуруНастроекБизнесПроцессовНаСервереSMARTS(ВерсияНастроекИмя = "", НастройкиБизнесПроцессовИмя = "", ID_Узла)
	
	СтруктураВозврат = Новый Структура("ВерсияНастроек,НастройкиБизнесПроцессов", Неопределено, Неопределено);	
	
	пСтруктураНастроек = Новый Структура;
	пСтруктураНастроек.Вставить(НастройкиБизнесПроцессовИмя, Ложь);
	пСтруктураНастроек.Вставить(ВерсияНастроекИмя, Ложь); 
	
	СтруктураНастроек = ЛокЯдро_ПолучитьНастройкиНаСервереSMARTS(пСтруктураНастроек, ID_Узла);		
	СтруктураНастроекБизнесПроцессов = СтруктураНастроек[НастройкиБизнесПроцессовИмя];
	
	Если ТипЗнч(СтруктураНастроекБизнесПроцессов) = Тип("Структура") Тогда
		ЗаполнитьЗначенияСвойств(СтруктураВозврат, СтруктураНастроекБизнесПроцессов);		
	Иначе				
		СтруктураВозврат.ВерсияНастроек 			= СтруктураНастроек[ВерсияНастроекИмя];
		СтруктураВозврат.НастройкиБизнесПроцессов 	= СтруктураНастроекБизнесПроцессов;
	КонецЕсли;                 	
	
	Возврат СтруктураВозврат;
	
КонецФункции

&НаКлиенте
Функция ЛокЯдро_ПолучитьВерсиюСтруктурыНастроекОбработки() Экспорт
	
	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода", 		"Функция");
	СтруктураВызова.Вставить("ИмяМетода", 		"ПолучитьВерсиюСтруктурыНастроекОбработки");
	СтруктураВызова.Вставить("ПараметрыМетода", Новый Структура);
	
	Результат = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова);
	
	Возврат Результат;
		
КонецФункции

// Возвращает признак использования новых настроек в базе
//
&НаКлиенте
Функция ЛокЯдро_ПроверитьИспользованиеНовойСтруктурыНастроекБизнесПроцессов() Экспорт
	
	НастройкиБизнесПроцессов_ПоУмолчанию = ЛокЯдро_ПолучитьИзКэшаНастройкуSMARTS("НастройкиБизнесПроцессов_ПоУмолчанию", Истина);
	
	НетТиповыхНастроек = (НастройкиБизнесПроцессов_ПоУмолчанию = Неопределено Или НастройкиБизнесПроцессов_ПоУмолчанию = Ложь);
	
	ИспользоватьСтруктуру = НетТиповыхНастроек Или ТипЗнч(НастройкиБизнесПроцессов_ПоУмолчанию) = Тип("Структура");
	
	Возврат ИспользоватьСтруктуру;
	
КонецФункции

&НаКлиенте
Функция ЛокЯдро_СтрРазделить(Строка, Разделитель, ВключатьПустые = Истина) Экспорт
	
	Результат = Новый Массив;
	
	// Для обеспечения обратной совместимости.
	Если ПустаяСтрока(Строка) Тогда 
		Если Разделитель = " " Тогда
			Результат.Добавить("");
		КонецЕсли;
		Возврат Результат;
	КонецЕсли;	
	
	Позиция = ЛокЯдро_СтрНайти(Строка, Разделитель);
	Пока Позиция > 0 Цикл
		Подстрока = Лев(Строка, Позиция - 1);
		Если ВключатьПустые Или Не ПустаяСтрока(Подстрока) Тогда
			Если ВключатьПустые Тогда
				Результат.Добавить(Подстрока);				
			Иначе
				Результат.Добавить(СокрЛП(Подстрока));
			КонецЕсли;
		КонецЕсли;
		Строка = Сред(Строка, Позиция + СтрДлина(Разделитель));
		Позиция = ЛокЯдро_СтрНайти(Строка, Разделитель);
	КонецЦикла;
	
	Если ВключатьПустые Или Не ПустаяСтрока(Строка) Тогда
		Если ВключатьПустые Тогда
			Результат.Добавить(Строка);			
		Иначе
			Результат.Добавить(СокрЛП(Строка));
		КонецЕсли;
	КонецЕсли;
	
	Возврат Результат;       
			
КонецФункции

&НаСервере
Функция ЛокЯдро_СтрРазделитьНаСервере(Строка, Разделитель, ВключатьПустые = Истина) Экспорт
	
	Результат = Новый Массив;
	
	// Для обеспечения обратной совместимости.
	Если ПустаяСтрока(Строка) Тогда 
		Если Разделитель = " " Тогда
			Результат.Добавить("");
		КонецЕсли;
		Возврат Результат;
	КонецЕсли;	
	
	Позиция = ЛокЯдро_СтрНайтиНаСервере(Строка, Разделитель);
	Пока Позиция > 0 Цикл
		Подстрока = Лев(Строка, Позиция - 1);
		Если ВключатьПустые Или Не ПустаяСтрока(Подстрока) Тогда
			Если ВключатьПустые Тогда
				Результат.Добавить(Подстрока);				
			Иначе
				Результат.Добавить(СокрЛП(Подстрока));
			КонецЕсли;
		КонецЕсли;
		Строка = Сред(Строка, Позиция + СтрДлина(Разделитель));
		Позиция = ЛокЯдро_СтрНайтиНаСервере(Строка, Разделитель);
	КонецЦикла;
	
	Если ВключатьПустые Или Не ПустаяСтрока(Строка) Тогда
		Если ВключатьПустые Тогда
			Результат.Добавить(Строка);			
		Иначе
			Результат.Добавить(СокрЛП(Строка));
		КонецЕсли;
	КонецЕсли;
	
	Возврат Результат;       
			
КонецФункции

#КонецОбласти

#Область ЛокальныйКонтекст_Настройки_ЗаписьИЧтениеИзФалов

// Вызывает диалог выбора файла для сохранения структуры. Записывает в выбранный файл сериализированные настройки.
// 
// Параметры:
//	СтруктураНастройки - Структура - структура с настройками для сохранения
//	ИмяРаздела - Строка - название раздела настроек
&НаКлиенте
Процедура ЛокЯдро_СохранитьНастройкиВФайл(СтруктураНастройки, ИмяРаздела) Экспорт
	
	СтруктураНастройки.Вставить("_ИмяРазделаНастройки_", ИмяРаздела);
	
	//TODO: Разобраться в природе возникновения предупреждения об ошибки в 1C EDT
	//Не подходит т.к. теряются ссылки
	//ОбъектXDTO = СериализаторXDTO.ЗаписатьXDTO(СтруктураНастройки);
	//ЗаписьXML = Новый ЗаписьXML;
	//ЗаписьXML.ОткрытьФайл(ПутьКФайлу);
	//ФабрикаXDTO.ЗаписатьXML(ЗаписьXML, ОбъектXDTO);
	//ЗаписьXML.Закрыть();
	ТекстФайла = ЛокЯдро_ЗначениеВСтрокуXML(СтруктураНастройки);
		
	ДиалогВыбораФайла = Новый ДиалогВыбораФайла(РежимДиалогаВыбораФайла.Сохранение);
	ДиалогВыбораФайла.ПолноеИмяФайла = "";
	ДиалогВыбораФайла.Фильтр = "(*.txt)|*.txt";
	ДиалогВыбораФайла.Заголовок = "Сохранить в файл";
	
	АдресФайла 	= Транзит_ПоместитьЗначениеВХранилищеНаСервере(ТекстФайла);
	ИмяФайла 	= "";
	ДанныеФайла = Новый ОписаниеПередаваемогоФайла(ИмяФайла, АдресФайла);
	
	СохраняемыеФайлы = Новый Массив;
	СохраняемыеФайлы.Добавить(ДанныеФайла);
	
	Контекст = Новый Структура();
	Контекст.Вставить("Диалог", 			ДиалогВыбораФайла);
	Контекст.Вставить("Интерактивно", 		Истина);
	Контекст.Вставить("ТекстПредложения", 	"");
	Контекст.Вставить("ПолучаемыеФайлы", 	СохраняемыеФайлы);
	
	ДополнительныеПараметры = Новый Структура;
	
	ДополнительныеПараметры.Вставить("УстановитьЕслиНеПодключено", 	Истина);
	ДополнительныеПараметры.Вставить("ОбработчикЗавершения", 		"ЛокЯдро_СохранитьНастройкиВФайлЗавершение");
	ДополнительныеПараметры.Вставить("Контекст",					Контекст);
	ДополнительныеПараметры.Вставить("ВыборЗавершение", 			Новый ОписаниеОповещения("ЛокЯдро_ПоказатьПолучениеФайлов", ЭтаФорма));
	
	#Если Не ВебКлиент Тогда
		// В мобильном, тонком и толстом клиентах расширение подключено всегда.
		ВыполнитьОбработкуОповещения(ДополнительныеПараметры.ВыборЗавершение, ДополнительныеПараметры); 
	#Иначе
		ЛокЯдро_ПередПодключениемРасширенияРаботыСФайлами(ДополнительныеПараметры);
	#КонецЕсли
	
КонецПроцедуры

// Продолжение процедуры ЛокЯдро_СохранитьНастройкиВФайл
// 
// Параметры:
//	МассивФайлов - Массив - массив элементов ОписаниеПереданногоФайла 
//	ДополнительныеПараметры - Структура - дополнительные параметры
&НаКлиенте
Процедура ЛокЯдро_СохранитьНастройкиВФайлЗавершение(МассивФайлов, ДополнительныеПараметры) Экспорт
	
	// Заготовка для постобработки сохранения настроек
	
КонецПроцедуры

// Вызывает диалог выбора файла для получения структуры.
// 
// Параметры:
//	ИмяРаздела - Строка - название раздела настроек
//	ОповещениеОЗавершении - ОписаниеОповещения - описание оповещения с методом, который необходимо выполнить после получения настроек
&НаКлиенте
Функция ЛокЯдро_ПолучитьНастройкиИзФайла(ИмяРаздела, ОповещениеОЗавершении) Экспорт
	
	ДиалогВыбораФайла = Новый ДиалогВыбораФайла(РежимДиалогаВыбораФайла.Открытие);
	ДиалогВыбораФайла.ПолноеИмяФайла = "";
	ДиалогВыбораФайла.Фильтр 		 = "(*.txt)|*.txt";
	ДиалогВыбораФайла.Заголовок 	 = "Выберите файл настроек";
			
	ЗагружаемыеФайлы = Новый Массив;
	
	Контекст = Новый Структура();
	Контекст.Вставить("Диалог", 								ДиалогВыбораФайла);
	Контекст.Вставить("Интерактивно", 							Истина);
	Контекст.Вставить("ТекстПредложения", 						"");
	Контекст.Вставить("ЗагружаемыеФайлы", 						ЗагружаемыеФайлы);
	Контекст.Вставить("ДействиеПередНачаломПомещенияФайлов",	Неопределено);
	
	ДополнительныеПараметры = Новый Структура;
	
	ДополнительныеПараметры.Вставить("УстановитьЕслиНеПодключено", 	Истина);
	ДополнительныеПараметры.Вставить("ОбработчикЗавершения", 		"ЛокЯдро_ПолучитьНастройкиИзФайлаЗавершение");
	ДополнительныеПараметры.Вставить("Контекст",					Контекст);
	ДополнительныеПараметры.Вставить("ВыборЗавершение", 			Новый ОписаниеОповещения("ЛокЯдро_ПоказатьПомещениеФайлов", ЭтаФорма));
	ДополнительныеПараметры.Вставить("ИмяРаздела",					ИмяРаздела);
	ДополнительныеПараметры.Вставить("ОповещениеОЗавершении",		ОповещениеОЗавершении);
	
	#Если Не ВебКлиент Тогда
		// В мобильном, тонком и толстом клиентах расширение подключено всегда.
		ВыполнитьОбработкуОповещения(ДополнительныеПараметры.ВыборЗавершение, ДополнительныеПараметры); 
	#Иначе
		ЛокЯдро_ПередПодключениемРасширенияРаботыСФайлами(ДополнительныеПараметры);
	#КонецЕсли
	
КонецФункции

// Продолжение процедуры ЛокЯдро_ПолучитьНастройкиИзФайла
// 
// Параметры:
//	МассивФайлов - Массив, Неопределено - массив элементов ОписаниеПереданногоФайла 
//	ДополнительныеПараметры - Структура - дополнительные параметры
&НаКлиенте
Процедура ЛокЯдро_ПолучитьНастройкиИзФайлаЗавершение(МассивФайлов, ДополнительныеПараметры) Экспорт
	
	Если МассивФайлов = Неопределено Тогда
		Сообщить("Не выбран файл для загрузки");
		Возврат;
	КонецЕсли;
	
	ИмяРаздела = ДополнительныеПараметры.ИмяРаздела;
	
	Если МассивФайлов.Количество() <> 0 Тогда
		ПутьКФайлу = ЛокЯдро_КопияФайлаНаСервере(МассивФайлов[0].Хранение);
		
		ТекстФайла = ЛокЯдро_ПрочитатьТекстФайлаНаСервере(ПутьКФайлу);
		
		//СтруктураНастройки = СериализаторXDTO.ПрочитатьXDTO(ОбъектXDTO);	
		СтруктураНастройки = ЛокЯдро_ЗначениеИзСтрокиXML(ТекстФайла);	
		
		Если СтруктураНастройки.Свойство("_ИмяРазделаНастройки_") И СтруктураНастройки._ИмяРазделаНастройки_ = ИмяРаздела Тогда
			СтруктураНастройки.Удалить("_ИмяРазделаНастройки_");
		Иначе
			СтруктураНастройки = Неопределено;
		КонецЕсли;
		
		ВыполнитьОбработкуОповещения(ДополнительныеПараметры.ОповещениеОЗавершении, СтруктураНастройки);
	КонецЕсли;
		
КонецПроцедуры

#КонецОбласти

#Область ЛокальныйКонтекст_Настройки_ПрочиеМетоды

// Получает подходящую настройку (настройки) бизнес-процесса
//
// Параметры:
//	НастройкиОбмена - Неопределено, ТаблицаЗначений, Массив из Структура - таблица настроек бизнес-процессов
//	ID_БизнесПроцесса - Строка - идентификатор бизнес-процесса, настройку которого необходимо получить	
//  ИмяТипаДокумента - Строка - тип документа Mobile Smarts, для которого выполняется получение настройки
//	ДанныеДокументаMS - Структура - данные документа Mobile Smarts
//
// Возвращаемое значение:
//	- Неопределено - если получить подходящую настройку бизнес-процесса не удалось
//	- Структура - содержит:
//		* Статус - Булево - признак того, что получена единственная настройки
//      * Данные - Структура - содержит настройку бизнес-процесса, если она единственная
//				 - Массив из СтрокаТаблицыЗначений - если настройки бизнес-процессов хранятся в виде таблицы значений
//				 - Массив из Структура - если настройки бизнес-процессов хранятся в виде массива структур
&НаКлиенте 
Функция ЛокЯдро_ПолучитьНастройкуБизнесПроцесса(НастройкиОбмена, ID_БизнесПроцесса, ИмяТипаДокумента, ДанныеДокументаMS) Экспорт
	
	Если НЕ ЗначениеЗаполнено(ID_БизнесПроцесса) И ЗначениеЗаполнено(ДанныеДокументаMS) Тогда
		Если ДанныеДокументаMS.ШапкаДокумента.Свойство("НастройкаБизнесПроцесса") Тогда
			ID_БизнесПроцесса = ДанныеДокументаMS.ШапкаДокумента.НастройкаБизнесПроцесса;
		КонецЕсли;
	КонецЕсли;
	Если НЕ ЗначениеЗаполнено(ИмяТипаДокумента) И ЗначениеЗаполнено(ДанныеДокументаMS) Тогда
		ИмяТипаДокумента = ДанныеДокументаMS.ШапкаДокумента.ИмяТипаДокумента;
	КонецЕсли;
	
	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода", "Функция");
	СтруктураВызова.Вставить("ИмяМетода", "ПолучитьНастройкуБизнесПроцесса");
	ПараметрыМетода = Новый Структура;
	ПараметрыМетода.Вставить("ID_БизнесПроцесса", ID_БизнесПроцесса);
	ПараметрыМетода.Вставить("ТипДокументаMS", ИмяТипаДокумента);
	ПараметрыМетода.Вставить("НастройкиОбмена", НастройкиОбмена);
	ПараметрыМетода.Вставить("ВключаяОтключенные", Ложь);
	СтруктураВызова.Вставить("ПараметрыМетода", ПараметрыМетода);
	
	Возврат Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,,АдресаПеременных);
	
КонецФункции

// Получает сведения о внешней обработке по заданному ключу
//
// Параметры:
//	КлючИнформации - Строка - ключ сведений о внешней обработке, которые необходимо получить	
//
// Возвращаемое значение:
//  - Произвольный - значение, полученное из сведений о внешней обработке
//	- Неопределено - если в сведениях о внешней обработке нет ключа, переданного в параметре КлючИнформации
&НаКлиенте 
Функция ЛокЯдро_ПолучитьИнформациюОВнешнейОбработке(КлючИнформации) Экспорт
	
	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода", "Функция");
	СтруктураВызова.Вставить("ИмяМетода", "ПолучитьИнформациюОВнешнейОбработке");
	СтруктураВызова.Вставить("ПараметрыМетода", Новый Структура("КлючИнформации", КлючИнформации));
	
	Возврат Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова);
	
КонецФункции

// Возвращает имя и версию из метаданных конфигурации
//
// Возвращаемое значение:
//	Строка
&НаСервере 
Функция ЛокЯдро_ПодключеннаяКонфигурация() Экспорт
	Возврат Метаданные.Имя + ", " + Метаданные.Версия;
КонецФункции

// Получает сведения о подключенных расширениях Клеверенс
//
// Возвращаемое значение:
//   Строка   - информация о подключенных расширениях
//
&НаКлиенте 
Функция ЛокЯдро_ПолучитьИнформациюОПодключенныхРасширениях() Экспорт
	
	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода", "Функция");
	СтруктураВызова.Вставить("ИмяМетода", "ПолучитьИнформациюОПодключенныхРасширениях");
	
	Возврат Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова);
	
КонецФункции

// Выполняет запись события в журнал регистрации
//
// Параметры:
//	ИмяСобытия - Строка - имя события	
//  УровеньСтрокой - Строка - уровень события строкой
//  Комментарий - Строка - комментарий
//  НачалоСобытия - Неопределено, Число - универсальная дата начала события в миллисекундах
&НаКлиенте 
Процедура ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, УровеньСтрокой, Комментарий, НачалоСобытия = Неопределено) Экспорт
	
	// Режимы отладки:
	// "Полный"
	// "ТолькоОшибки", по умолчанию и если режим не задан, то режим "ТолькоОшибки",
	// "БезОтладки", никакая интформация не пишется в ЖР
	РежимОтладки = ЛокЯдро_ПолучитьИзКэшаНастройкуSMARTS("РежимОтладки");
	
	АвтотестКлеверенс = КомЯдро_ПолучитьЗначениеПеременной("Автотест");
	Если АвтотестКлеверенс = Неопределено Тогда
		АвтотестКлеверенс = Ложь;
	КонецЕсли;
	
	Если АвтотестКлеверенс И Ложь //Пока закрою этот кусок. Пригодится когда понадобится дублирование записей в ЖР и в лог не только в автотестах 
		И РасположениеКомпоненты = "НаКлиенте" Тогда
		
		ПутьКОбщемуЛогу = КомЯдро_ПолучитьЗначениеПеременной("ПутьКОбщемуЛогу");
		ПутьКЛогуОшибок = КомЯдро_ПолучитьЗначениеПеременной("ПутьКЛогуОшибок");
		
		Если ПутьКОбщемуЛогу <> Неопределено И ПутьКЛогуОшибок <> Неопределено Тогда
			ЛокЯдро_ДобавитьЗаписьВЛог(ПутьКОбщемуЛогу,ИмяСобытия +". "+Комментарий);
			
			Если УровеньСтрокой = "Ошибка" Тогда
				ЛокЯдро_ДобавитьЗаписьВЛог(ПутьКЛогуОшибок,ИмяСобытия +". "+Комментарий);
			КонецЕсли;
		КонецЕсли
	КонецЕсли;
	
	Если РежимОтладки = Неопределено ИЛИ РежимОтладки = Ложь Тогда
		РежимОтладки = "ТолькоОшибки";
	ИначеЕсли РежимОтладки = "БезОтладки" И Не АвтотестКлеверенс Тогда
		Возврат
	КонецЕсли;
		
	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода", "Процедура");
	СтруктураВызова.Вставить("ИмяМетода", "ЗаписатьСобытиеВЖурналРегистрации");
	СтруктураВызова.Вставить("ПараметрыМетода", Новый Структура("ИмяСобытия, УровеньСтрокой, Комментарий, НачалоСобытия, АдресаПеременных", ИмяСобытия, УровеньСтрокой, Комментарий, НачалоСобытия,АдресаПеременных));
	
	Если (РежимОтладки = "ТолькоОшибки" И УровеньСтрокой = "Ошибка")
		ИЛИ РежимОтладки = "Полный" 
		ИЛИ РежимОтладки = "ВсяИнформация"
		Или УровеньСтрокой = "Предупреждение"
		ИЛИ АвтотестКлеверенс Тогда	
		Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова);
	Иначе
		Возврат;
	КонецЕсли;	
	
КонецПроцедуры

// Получает список отборов используемых бизнес-процессов и их отборов
//
&НаКлиенте
Функция ЛокЯдро_ПолучитьСписокОтборовБизнесПроцесса(ID_БизнесПроцесса) Экспорт
	
	ИмяСобытия = "ЛокЯдро_ПолучитьСписокОтборовБизнесПроцесса";
	
	// Проверим интерактивные отборы
	ЛокЯдро_ПолучениеОтборовБизнесПроцесса(ИмяСобытия, ID_БизнесПроцесса);
	
	// Проверим онлайн отборы
	ЛокЯдро_ПолучениеОтборовБизнесПроцесса(ИмяСобытия, ID_БизнесПроцесса, Истина);
		
КонецФункции

// Получает список отборов используемых бизнес-процессов и их отборов
//
&НаКлиенте
Функция ЛокЯдро_ПолучениеОтборовБизнесПроцесса(ИмяСобытия, ID_БизнесПроцесса, Онлайн = Ложь)
	
	// Получение списка отоборов БП
	Если Онлайн Тогда
		НастройкиОтбораБизнесПроцессов = ЛокЯдро_ПолучитьИзКэшаНастройкуSMARTS("НастройкиОтборовУзлов_Онлайн");
	Иначе
		НастройкиОтбораБизнесПроцессов = ЛокЯдро_ПолучитьИзКэшаНастройкуSMARTS("НастройкиОтборовУзлов_Интерактивный");
	КонецЕсли;
	
	Если НастройкиОтбораБизнесПроцессов <> Ложь Тогда
		
		НастройкиОтбораБП = ЛокЯдро_НайтиВМассивеСтруктурПоОтбору(НастройкиОтбораБизнесПроцессов, Новый Структура("ID_БизнесПроцесса", ID_БизнесПроцесса));
		
		Если ТипЗнч(НастройкиОтбораБП) = Тип("Массив") И НастройкиОтбораБП.Количество() Тогда
			
			НастройкиКомпоновкиСтрокой = НастройкиОтбораБП[0].НастройкаКомпоновщикаСтрокой;
			НастройкиКомпоновки = ЛокЯдро_ЗначениеИзСтрокиXML(СтрЗаменить(НастройкиКомпоновкиСтрокой, Символы.ВК, ""));
			
			Если НастройкиКомпоновки <> Неопределено Тогда
				ЭлементыОтбора = НастройкиКомпоновки.Отбор.Элементы;
				Если ЭлементыОтбора.Количество() Тогда
					Если НастройкиОтбораБП[0].Используется Тогда
						ТекстИспользования = " (включены) ";
					Иначе
						ТекстИспользования = " (не включены) ";
					КонецЕсли;
					ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", ?(Онлайн, "Онлайн", "Интерактивные") + " отборы бизнес-процесса" + ТекстИспользования + ":");
					Для Каждого ЭлементОтбора Из ЭлементыОтбора Цикл							
						ТекстСобытия = " - " + ЭлементОтбора.ЛевоеЗначение + " " + ЭлементОтбора.ВидСравнения + " " + ЭлементОтбора.ПравоеЗначение;
						ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", ТекстСобытия);									
					КонецЦикла;			
				КонецЕсли;     			
			КонецЕсли;	
			
			Возврат НастройкиОтбораБП[0].Используется;
			
		Иначе
			
			ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", ?(Онлайн, "Онлайн", "Интерактивные") + " отборы бизнес-процесса отсутствуют");			
			
			Возврат Неопределено;
			
		КонецЕсли;
		
	КонецЕсли;
		
КонецФункции

// Проверяет корректность передавамого типа метаданных и записывает результат контроля
//
// Параметры:
//  ТипДокумента		- Строка 	- Имя проверяемого объекта метаданных
//  ТаблицаМетаданных	- Строка 	- Имя свойства гл. переменной СтруктураМетаданных ("Документы1С" или "ДокументыMS")
//  МассивИменТипов		- Массив 	- Массив строковых значений, отражающих имена типов документов
//  СтруктураПроверки	- Структура - Структура проверки текущего бизнес-процесса
//  МассивОшибок		- Массив 	- Массив строковых значений, содержащих описание возникших ошибок
//
&НаКлиенте
Процедура ЛокЯдро_ПроверитьКорректностьТипаМетаданных(ТипДокумента, ТаблицаМетаданных, МассивИменТипов, ТекМетаданные, СтруктураПроверки, МассивОшибок)	
	
	Если ЗначениеЗаполнено(ТипДокумента) И МассивИменТипов.Найти(ТипДокумента) = Неопределено Тогда
		Если Не СтруктураМетаданных[ТаблицаМетаданных].Свойство(ТипДокумента, ТекМетаданные) Тогда
			// Документа нет в метаданных
			СторонаВзаимодействия = Прав(ТаблицаМетаданных, 2);
			Если СторонаВзаимодействия = "MS" Тогда
				СтруктураПроверки.Вставить("СтороннийБП", Истина);
			Иначе
				ТекстОшибки = "Документ " + ТипДокумента + " отсутствует в метаданных " + СторонаВзаимодействия;
				СтруктураПроверки.Вставить("ОшибкаБП", Истина);
				МассивОшибок.Добавить(ТекстОшибки);			
			КонецЕсли;
		Иначе 			
			МассивИменТипов.Добавить(ТипДокумента);
		КонецЕсли;
	ИначеЕсли МассивИменТипов.Найти(ТипДокумента) <> Неопределено Тогда
		// Документ уже был проверен, но переменная текущих метаданных очищается в каждой итерации обхода БП, поэтому заполним ее
		СтруктураМетаданных[ТаблицаМетаданных].Свойство(ТипДокумента, ТекМетаданные);
	КонецЕсли;	
	
КонецПроцедуры

// Проверяет доступность обработчиков загрузки
//
// Параметры:
//  НастройкаБизнесПроцесса			- Структура 	- Структура свойств текущего бизнес-процесса
//  МассивПроверенныхОбработчиков	- Массив 		- Массив уже проверенных методов интеграционной обработки (вне зависимости от бизнес-процесса)
//  СтруктураПроверки				- Структура 	- Структура проверки текущего бизнес-процесса
//  МассивОшибок					- Массив 		- Массив строковых значений, содержащих описание возникших ошибок
//
&НаКлиенте
Процедура ЛокЯдро_ПроверитьДоступностьОбработчиковЗагрузки(НастройкаБизнесПроцесса, МассивПроверенныхОбработчиков, СтруктураПроверки, МассивОшибок)
	
	МассивОбработчиков = Новый Массив;
	
	МассивТиповОбработчиков = Новый Массив;
	МассивТиповОбработчиков.Добавить("ПередЗаполнениемДокумента");
	МассивТиповОбработчиков.Добавить("ПослеЗаполненияДокумента");
		
	Для Каждого ТипОбработчика Из МассивТиповОбработчиков Цикл
		
		ВидОбработчика 	= "ВидОбработчика_" + ТипОбработчика;
		Обработчик 		= "Обработчик_" + ТипОбработчика;
		
		Если НастройкаБизнесПроцесса.Свойство(ВидОбработчика) Тогда
			Если НастройкаБизнесПроцесса[ВидОбработчика] = 1
				ИЛИ НастройкаБизнесПроцесса[ВидОбработчика] = 2 Тогда			
				МассивОбработчиков.Добавить(НастройкаБизнесПроцесса[Обработчик]);
			КонецЕсли;
		Иначе
			МассивОбработчиков.Добавить(НастройкаБизнесПроцесса[Обработчик]);
		КонецЕсли; 
		
	КонецЦикла;
	
	// Удаление пустых обработчиков из массива
	ЛокЯдро_УдалитьВсеВхожденияЗначенияИзМассива(МассивОбработчиков, "");
	
	// Проверка серверных обработчиков загрузки
	Если МассивОбработчиков.Количество() <> 0 Тогда			
		ЛокЯдро_ПроверкаДоступностиОбработчиковИнтеграционнойОбработки(МассивОбработчиков, МассивПроверенныхОбработчиков, СтруктураПроверки, МассивОшибок);		
	КонецЕсли;
		
	Если НастройкаБизнесПроцесса.Свойство("Обработчик_ПослеОткрытияФормыДокумента") Тогда
		// Проверка клиентских обработчиков загрузки формы
		РезультатПроверки = ЛокЯдро_ПроверитьДоступностьОбработчикаФормы(НастройкаБизнесПроцесса.Обработчик_ПослеОткрытияФормыДокумента);
		Если Не РезультатПроверки.Статус Тогда
			
			СтруктураПроверки.ОшибкаБП = Истина;
			ТекстОшибки = "Обработчик " + НастройкаБизнесПроцесса.Обработчик_ПослеОткрытияФормыДокумента + " не найден в интеграционной обработке";
			МассивОшибок.Добавить(ТекстОшибки);						
			
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

// Проверяет доступность и корректность произвольных кодов и обработчиков в общем по документу
//
// Параметры:
//  НастройкаБизнесПроцесса			- Структура 	- Структура свойств текущего бизнес-процесса
//  СтруктураПроверки				- Структура 	- Структура проверки текущего бизнес-процесса
//  МассивОшибок					- Массив 		- Массив строковых значений, содержащих описание возникших ошибок
//
&НаКлиенте
Процедура ЛокЯдро_ПроверитьДоступностьИКорректностьПроизвольныхОбработчиков(НастройкаБизнесПроцесса, СтруктураПроверки, МассивОшибок)
	
	// Выгрузка
	Если НастройкаБизнесПроцесса.Свойство("ВыполнитьТолькоПроизвольныйКодВыгрузка") И НастройкаБизнесПроцесса.ВыполнитьТолькоПроизвольныйКодВыгрузка = Истина Тогда
		
		Если НастройкаБизнесПроцесса.ТипОбработчикаВыгрузки = 0 Тогда			
			// Произвольный код
			ЛокЯдро_ПроверкаПроизвольногоКодаОбработкиДокумента(НастройкаБизнесПроцесса.ID_ПроизвольногоКода_Выгрузка_Документ, СтруктураПроверки, МассивОшибок);						
		ИначеЕсли НастройкаБизнесПроцесса.ТипОбработчикаВыгрузки = 1 Тогда                                                                                                  			
			// Обработчик
			ЛокЯдро_ПроверкаПроизвольногоОбработчикаДокумента(НастройкаБизнесПроцесса.ОбработчикВыгрузкиДокумента, СтруктураПроверки, МассивОшибок);			            			
		КонецЕсли;
		
	КонецЕсли;
	
	// Загрузка
	Если НастройкаБизнесПроцесса.Свойство("ВыполнитьТолькоПроизвольныйКод") И НастройкаБизнесПроцесса.ВыполнитьТолькоПроизвольныйКод = Истина Тогда
		
		Если НастройкаБизнесПроцесса.ТипОбработчикаЗагрузки = 0 Тогда			
			// Произвольный код
			ЛокЯдро_ПроверкаПроизвольногоКодаОбработкиДокумента(НастройкаБизнесПроцесса.ID_ПроизвольногоКода_Загрузка_Документ, СтруктураПроверки, МассивОшибок, Истина);						
		ИначеЕсли НастройкаБизнесПроцесса.ТипОбработчикаЗагрузки = 1 Тогда                                                                                                  			
			// Обработчик
			ЛокЯдро_ПроверкаПроизвольногоОбработчикаДокумента(НастройкаБизнесПроцесса.ОбработчикЗагрузкиДокумента, СтруктураПроверки, МассивОшибок, Истина);			            			
		КонецЕсли;
		
	КонецЕсли;
			
КонецПроцедуры

// Проверяет доступность и корректность произвольного кода
//
// Параметры:
//  ID_ПроизвольногоКода	- Строка 	- Идентификатор текущего произвольного кода
//  СтруктураПроверки		- Структура - Структура проверки текущего бизнес-процесса
//  МассивОшибок			- Массив 	- Массив строковых значений, содержащих описание возникших ошибок
//	ТекстОбластиПроверки	- Строка	- Текстовое описание текущей области проверки (для сообщения об ошибке)
//
&НаКлиенте
Процедура ЛокЯдро_ПроверкаПроизвольногоКодаОбработкиДокумента(ID_ПроизвольногоКода, СтруктураПроверки, МассивОшибок, Загрузка = Ложь, ТекстОбластиПроверки = "")
	 	
	СтруктураОтбора = Новый Структура("ID_ПроизвольногоКода", ID_ПроизвольногоКода);
	
	ПроизвольныеКоды_ПоУмолчанию 		= ЛокЯдро_ПолучитьИзКэшаНастройкуSMARTS("ПроизвольныеКоды_ПоУмолчанию");
	ПроизвольныеКоды_Пользовательские 	= ЛокЯдро_ПолучитьИзКэшаНастройкуSMARTS("ПроизвольныеКоды_Пользовательские");
	
	ПроизвольныеКоды = Новый Массив;
	Если ПроизвольныеКоды_ПоУмолчанию <> Ложь Тогда
		ЛокЯдро_ДополнитьМассив(ПроизвольныеКоды, ПроизвольныеКоды_ПоУмолчанию);
	КонецЕсли;
	
	Если ПроизвольныеКоды_Пользовательские <> Ложь Тогда
		ЛокЯдро_ДополнитьМассив(ПроизвольныеКоды, ПроизвольныеКоды_Пользовательские);
	КонецЕсли;
	
	МассивПроизвольногоКода = ЛокЯдро_НайтиВМассивеСтруктурПоОтбору(ПроизвольныеКоды, СтруктураОтбора);
	
	Если МассивПроизвольногоКода <> Неопределено И МассивПроизвольногоКода.Количество() Тогда		
		
		ТекстПК = МассивПроизвольногоКода[0].ТекстПроизвольногоКода;
		ИмяПК	= МассивПроизвольногоКода[0].Наименование;
		
		Если Не ЗначениеЗаполнено(ТекстПК) Тогда					
			СтруктураПроверки.ОшибкаБП = Истина;
			ТекстОшибки = "Не заполнено значение произвольного кода " + ?(Загрузка, "загрузки", "выгрузки") + " <" + ИмяПК + "> ";					
			МассивОшибок.Добавить(ТекстОшибки);					
		Иначе
			// Проверка синтаксиса произвольного кода
			РезультатПроверки = ЛокЯдро_ПроверитьСинтакическоеВыполнениеКода(ТекстПК, ИмяПК, ?(Загрузка, "загрузки", "выгрузки"));							
			Если РезультатПроверки.ЕстьОшибки Тогда
				СтруктураПроверки.ОшибкаБП = Истина;
				ТекстОшибки = РезультатПроверки.ТекстОшибки;				
				МассивОшибок.Добавить(ТекстОшибки);		
			КонецЕсли;
		КонецЕсли;		
		
	Иначе                                  		
		
		СтруктураПроверки.ОшибкаБП = Истина;
		ТекстОшибки = "Не найден произвольный код " + ?(Загрузка, "загрузки ", "выгрузки ") + ТекстОбластиПроверки;				
		МассивОшибок.Добавить(ТекстОшибки);		
		
	КонецЕсли;	
	
КонецПроцедуры

// Проверяет корректность настроек загрузкивыгрузки полей и ТЧ
//
// Параметры:
//  НастройкаБизнесПроцесса			- Структура 	- Структура свойств текущего бизнес-процесса
//  СтрМетаданных			- Структура - Структура, содержащая структуры метаданных документов данного БП:
//			* МетаданныеДокMS 			- Структура
//			* МетаданныеДок1СЗагрузка 	- Структура
//			* МетаданныеДок1СВыгрузка 	- Структура
//  СтруктураПроверки				- Структура 	- Структура проверки текущего бизнес-процесса
//  МассивОшибок					- Массив 		- Массив строковых значений, содержащих описание возникших ошибок
//
&НаКлиенте
Процедура ЛокЯдро_ПроверитьКорректностьНастроекОбработкиПолейИТабличныхЧастей(НастройкаБизнесПроцесса, СтрМетаданных, СтруктураПроверки, МассивОшибок)
	
	// Выгрузка
	Если (Не НастройкаБизнесПроцесса.Свойство("ВыполнитьТолькоПроизвольныйКодВыгрузка") Или НастройкаБизнесПроцесса.ВыполнитьТолькоПроизвольныйКодВыгрузка = Ложь)
		И ЗначениеЗаполнено(НастройкаБизнесПроцесса.ТипИсходногоДокумента1С) Тогда                                                    				
		
		СтрДокументов = Новый Структура("МетаданныеИсточника, МетаданныеПриемника", СтрМетаданных.МетаданныеДок1СВыгрузка, СтрМетаданных.МетаданныеДокMS); 
		
		ЛокЯдро_ПроверкаКорректностиНастроекТаблицыПолейДокумента(
			НастройкаБизнесПроцесса.НастройкаВыгрузкиПолей, 
			СтрДокументов,
			СтруктураПроверки, 
			МассивОшибок);
				
		ЛокЯдро_ПроверкаКорректностиНастроекТабличныхЧастейДокумента(НастройкаБизнесПроцесса, СтрМетаданных, СтруктураПроверки, МассивОшибок);
		
	КонецЕсли;
	
	// Загрузка
	Если Не НастройкаБизнесПроцесса.Свойство("ВыполнитьТолькоПроизвольныйКод") Или НастройкаБизнесПроцесса.ВыполнитьТолькоПроизвольныйКод = Ложь Тогда
		
		СтрДокументов = Новый Структура("МетаданныеИсточника, МетаданныеПриемника", СтрМетаданных.МетаданныеДокMS, СтрМетаданных.МетаданныеДок1СЗагрузка);
		
		ЛокЯдро_ПроверкаКорректностиНастроекТаблицыПолейДокумента(
			НастройкаБизнесПроцесса.НастройкаЗагрузкиПолей,
			СтрДокументов,
			СтруктураПроверки, 
			МассивОшибок,
			Истина);	
		
		ЛокЯдро_ПроверкаКорректностиНастроекТабличныхЧастейДокумента(НастройкаБизнесПроцесса, СтрМетаданных, СтруктураПроверки, МассивОшибок, Истина);
			
	КонецЕсли;
			
КонецПроцедуры

// Проверяет корректность настроек выгрузки/загрузки табличных полей документа бизнес-процесса
//
// Параметры:
//  НастройкиПолей			- Массив 	- Массив соответствий конвертируемых реквизитов
//	СтрДокументов			- Структура - Структура из метаданных источника и приемника данной настройки БП
//  СтруктураПроверки		- Структура - Структура проверки текущего бизнес-процесса
//  МассивОшибок			- Массив 	- Массив строковых значений, содержащих описание возникших ошибок
//  Загрузка				- Булево 	- Признак направления обработчика
//
&НаКлиенте
Процедура ЛокЯдро_ПроверкаКорректностиНастроекТаблицыПолейДокумента(НастройкиПолей, СтрДокументов, СтруктураПроверки, МассивОшибок, Загрузка = Ложь, ОбластьПроверки = "")
	
	Если Загрузка Тогда
		РеквизитИсточника = "РеквизитMS";
		РеквизитПриемника = "Реквизит1С";
	Иначе
		РеквизитИсточника = "Реквизит1С";
		РеквизитПриемника = "РеквизитMS";
	КонецЕсли;
	
	Если ПустаяСтрока(ОбластьПроверки) Тогда
		ТекстОбластиПроверки = "в шапке документа" + ?(Загрузка, " настроек загрузки", " настроек выгрузки");
	Иначе
		ТекстОбластиПроверки = "в ТЧ <" + ОбластьПроверки + "> документа" + ?(Загрузка, " настроек загрузки", " настроек выгрузки");
	КонецЕсли;
	
	Если ТипЗнч(НастройкиПолей) = Тип("Массив") Тогда
		
		Для Каждого НастройкаПолей Из НастройкиПолей Цикл
			
			Если НастройкаПолей.Свойство("ЭтоТаблицаЗначений") И НастройкаПолей.ЭтоТаблицаЗначений Тогда
				Продолжить;
			КонецЕсли;
			
			// Проверка корректности полей источника
			Если НастройкаПолей.ТипИсточника = РеквизитИсточника Тогда					
				Если НастройкаПолей.ТипИсточника = НастройкаПолей.ТипИсточникаСиноним Тогда
					ТекстОшибки = "Некорретное отображение типа источника для строки приемника <" + НастройкаПолей.ИмяПриемника + "> " + ТекстОбластиПроверки +
						". Возможны проблемы при сопоставлении данных";
					СтруктураПроверки.ОшибкаБП = Истина;
					МассивОшибок.Добавить(ТекстОшибки);	
				Иначе
					
					ЛокЯдро_ПроверкаКорректностиПолейНастроекНаПринадлежностьМетаданным(
						СтрДокументов.МетаданныеИсточника,
						РеквизитИсточника,
						НастройкаПолей.ИмяИсточника,
						НастройкаПолей,
						СтруктураПроверки,
						МассивОшибок,
						ТекстОбластиПроверки,
						ОбластьПроверки);		
				КонецЕсли;

			ИначеЕсли НастройкаПолей.ТипИсточника = "ПроизвольныйКод" Тогда                                         										
				// На заполненость и синтаксический контроль
				ID_ПроизвольногоКода = ?(ЗначениеЗаполнено(НастройкаПолей.ЗначениеИсточника), НастройкаПолей.ЗначениеИсточника, НастройкаПолей.ИмяИсточника);				
				ЛокЯдро_ПроверкаПроизвольногоКодаОбработкиДокумента(ID_ПроизвольногоКода, СтруктураПроверки, МассивОшибок, Загрузка, ТекстОбластиПроверки);	
				
			ИначеЕсли НастройкаПолей.ТипИсточника = "ПроизвольноеЗначение" Тогда                                                        					
				// На заполненность значения
				НеЗаполненоИсЗначение 			= Не НастройкаПолей.Свойство("ИсЗначение") Или Не ЗначениеЗаполнено(НастройкаПолей.ИсЗначение);
				НеЗаполненоЗначениеИсточника 	= Не НастройкаПолей.Свойство("ЗначениеИсточника") Или Не ЗначениеЗаполнено(НастройкаПолей.ЗначениеИсточника);				
				Если НеЗаполненоИсЗначение И НеЗаполненоЗначениеИсточника Тогда						
					ТекстОшибки = "Не заполнено произвольное значение для строки приемника <" + НастройкаПолей.ИмяПриемника + "> " + ТекстОбластиПроверки;
					СтруктураПроверки.ОшибкаБП = Истина;
					МассивОшибок.Добавить(ТекстОшибки);							
				КонецЕсли;
				
			ИначеЕсли НастройкаПолей.ТипИсточника = "ГлобальныйПараметр" Тогда                                                         					
				// На заполненность и наличие в базе
				НеЗаполненоИсЗначение 			= Не НастройкаПолей.Свойство("ИсЗначение") Или Не ЗначениеЗаполнено(НастройкаПолей.ИсЗначение);
				НеЗаполненоЗначениеИсточника 	= Не НастройкаПолей.Свойство("ЗначениеИсточника") Или Не ЗначениеЗаполнено(НастройкаПолей.ЗначениеИсточника);				
				Если НеЗаполненоИсЗначение И НеЗаполненоЗначениеИсточника Тогда						
					ТекстОшибки = "Не заполнен глобальный параметр для строки приемника <" + НастройкаПолей.ИмяПриемника + "> " + ТекстОбластиПроверки;
					СтруктураПроверки.ОшибкаБП = Истина;
					МассивОшибок.Добавить(ТекстОшибки);							
				КонецЕсли;
				
			Иначе
				ТекстОшибки = "Указан некорретный тип источника <" + НастройкаПолей.ИмяИсточника + "> " + ТекстОбластиПроверки;
					СтруктураПроверки.ОшибкаБП = Истина;
					МассивОшибок.Добавить(ТекстОшибки);									
			КонецЕсли;
			
			// Проверка наличия полей приемника
			Если НастройкаПолей.ТипПриемника = РеквизитПриемника Тогда
				Если НастройкаПолей.ТипПриемника = НастройкаПолей.ТипПриемникаСиноним Тогда
					ТекстОшибки = "Некорретное отображение типа приемника для строки приемника <" + НастройкаПолей.ИмяПриемника + "> " + ТекстОбластиПроверки +
						". Возможны проблемы при сопоставлении данных";
					СтруктураПроверки.ОшибкаБП = Истина;
					МассивОшибок.Добавить(ТекстОшибки);	
				Иначе				
					ЛокЯдро_ПроверкаКорректностиПолейНастроекНаПринадлежностьМетаданным(
						СтрДокументов.МетаданныеПриемника,
						РеквизитПриемника,
						НастройкаПолей.ИмяПриемника,
						НастройкаПолей,
						СтруктураПроверки,
						МассивОшибок,
						ТекстОбластиПроверки,
						ОбластьПроверки);		
				КонецЕсли;     
				
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЕсли;	
	
КонецПроцедуры

// Вспомогательная обработка
//
&НаКлиенте
Процедура ЛокЯдро_ПроверкаКорректностиПолейНастроекНаПринадлежностьМетаданным(ТекМетаданные, ТекРеквизит, ИмяРеквизита, НастройкаПолей, СтруктураПроверки, МассивОшибок, ТекстОбластиПроверки, ОбластьПроверки)
	
	КлючСвязиВИмени 	= НастройкаПолей.ИмяИсточника = "КлючСвязи" Или НастройкаПолей.ИмяПриемника = "КлючСвязи";
	КлючСвязиВЗначении 	= НастройкаПолей.Свойство("ИсЗначение") И Найти(НастройкаПолей.ИсЗначение, "Ключ связи") > 0;
	Если КлючСвязиВИмени Или КлючСвязиВЗначении Тогда
		// Ключи связи не являются реквизитами метаданных, пропускаем их
		Возврат;
	КонецЕсли;
	
	Если ПустаяСтрока(ОбластьПроверки) Тогда
		МассивРеквизитов = ТекМетаданные.Реквизиты;
	ИначеЕсли ТекРеквизит = "РеквизитMS" Тогда  					
		МассивРеквизитов = ТекМетаданные.РеквизитыТЧ;					
	Иначе 
		МассивРеквизитов = ТекМетаданные.ТабличныеЧасти[ОбластьПроверки].Реквизиты					
	КонецЕсли;	                               				
	
	ЛокЯдро_ПроверитьНаличиеРеквизита(ИмяРеквизита, МассивРеквизитов, СтруктураПроверки, МассивОшибок, ТекстОбластиПроверки, ТекРеквизит);					
	
КонецПроцедуры

// Проверяет корректность настроек выгрузки/загрузки шапки документа бизнес-процесса
//
// Параметры:
//  НастройкаБизнесПроцесса	- Структура - Структура свойств текущего бизнес-процесса
//  СтрМетаданных			- Структура - Структура, содержащая структуры метаданных документов данного БП:
//			* МетаданныеДокMS 			- Структура
//			* МетаданныеДок1СЗагрузка 	- Структура
//			* МетаданныеДок1СВыгрузка 	- Структура
//  СтруктураПроверки		- Структура - Структура проверки текущего бизнес-процесса
//  МассивОшибок			- Массив 	- Массив строковых значений, содержащих описание возникших ошибок
//  Загрузка				- Булево 	- Признак направления обработчика
//
&НаКлиенте
Процедура ЛокЯдро_ПроверкаКорректностиНастроекТабличныхЧастейДокумента(НастройкаБизнесПроцесса, СтрМетаданных, СтруктураПроверки, МассивОшибок, Загрузка = Ложь)
	
	Если Загрузка Тогда
		НастройкиТЧ 		= НастройкаБизнесПроцесса.НастройкаЗагрузкиТЧ;
		Метаданные1С 		= СтрМетаданных.МетаданныеДок1СЗагрузка;
		МетаданныеИсточника = СтрМетаданных.МетаданныеДокMS;		
		МетаданныеПриемника = СтрМетаданных.МетаданныеДок1СЗагрузка;
	Иначе
		НастройкиТЧ 		= НастройкаБизнесПроцесса.НастройкаВыгрузкиТЧ;
		Метаданные1С 		= СтрМетаданных.МетаданныеДок1СВыгрузка;
		МетаданныеИсточника = СтрМетаданных.МетаданныеДок1СВыгрузка;		
		МетаданныеПриемника = СтрМетаданных.МетаданныеДокMS;
	КонецЕсли; 	
	
	Если ТипЗнч(НастройкиТЧ) = Тип("Массив") Тогда
		
		Для Каждого НастройкаТЧ Из НастройкиТЧ Цикл
			
			Если НастройкаТЧ.Свойство("ЭтоТаблицаЗначений") И НастройкаТЧ.ЭтоТаблицаЗначений Тогда
				Продолжить;
			КонецЕсли;
			
			ИмяТабличнойЧасти1С = НастройкаТЧ.НастройкаТЧСтрокой;
			ИмяТабличнойЧастиMS = НастройкаТЧ.ТабличнаяЧастьДокументаMS;
			
			Если Не Загрузка Тогда
				ТекстЗапросаВыгрузкиНаТСД = НастройкаТЧ.ТекстЗапросаВыгрузкиНаТСД;
			КонецЕсли;			
			
			Если Найти(ИмяТабличнойЧасти1С, "Запрос") Тогда
				
				Если Не Загрузка И ЗначениеЗаполнено(ТекстЗапросаВыгрузкиНаТСД) Тогда
					
					ЛокЯдро_ПроверкаКорректностиНастроекЗапросаВыгрузкиТабличнойЧасти(ТекстЗапросаВыгрузкиНаТСД, НастройкаТЧ, Метаданные1С.Имя, СтруктураПроверки, МассивОшибок);
					
				КонецЕсли;	
				
			ИначеЕсли ЗначениеЗаполнено(Метаданные1С) И ЗначениеЗаполнено(ИмяТабличнойЧасти1С) Тогда
				
				МетаданныеТабличнойЧасти1С = Неопределено;
				
				Если Не Метаданные1С.ТабличныеЧасти.Свойство(ИмяТабличнойЧасти1С, МетаданныеТабличнойЧасти1С) Тогда
					
					// Если не найденная ТЧ является программно добавляемой ТЧ для маркировок, то пропускаем, 
					// оборачиваю в попытку на случай отсутствия процедуры в ИО
					Попытка
						
						Результат = ЛокЯдро_ПолучитьСписокДополнительныхОбработчиковПолученияТЧ(Метаданные1С.Имя);	
												
						Если Результат <> Неопределено И Результат[ИмяТабличнойЧасти1С] <> Неопределено Тогда
							Продолжить;
						КонецЕсли;
						
						ТекстОшибки = "Не найдена табличная часть <" + ИмяТабличнойЧасти1С + "> документа 1С <" + Метаданные1С.Имя + ">";
						СтруктураПроверки.ОшибкаБП = Истина;
						МассивОшибок.Добавить(ТекстОшибки);
					Исключение
						ТекстОшибки = "Не найдена табличная часть <" + ИмяТабличнойЧасти1С + "> документа 1С <" + Метаданные1С.Имя + ">";
						СтруктураПроверки.ОшибкаБП = Истина;
						МассивОшибок.Добавить(ТекстОшибки);
					КонецПопытки;
					
				Иначе
					// Проверка реквизитов ТЧ
					ТабличнаяЧастьДокумента1С = Неопределено;
					Если НастройкаТЧ.Свойство("ТабличнаяЧастьДокумента1С") Тогда
						ТабличнаяЧастьДокумента1С = НастройкаТЧ.ТабличнаяЧастьДокумента1С;
					ИначеЕсли НастройкаТЧ.Свойство("ТабличнаяЧастьДокумента1ССтрокой") Тогда
						ТабличнаяЧастьДокумента1С = ЛокЯдро_ЗначениеИзСтрокиXML(НастройкаТЧ.ТабличнаяЧастьДокумента1ССтрокой, Истина);
					КонецЕсли;					
					
					Если ТабличнаяЧастьДокумента1С <> Неопределено Тогда
						
						СтрДокументов = Новый Структура("МетаданныеИсточника, МетаданныеПриемника", МетаданныеИсточника, МетаданныеПриемника); 
						ЛокЯдро_ПроверкаКорректностиНастроекТаблицыПолейДокумента(ТабличнаяЧастьДокумента1С, СтрДокументов, СтруктураПроверки, МассивОшибок, Загрузка, НастройкаТЧ.НастройкаТЧСтрокой);
						
					КонецЕсли;
					
				КонецЕсли;
				
			КонецЕсли;    				
			
		КонецЦикла;
		
	КонецЕсли;

	
КонецПроцедуры

&НаСервере
Процедура ЛокЯдро_ПроверкаКорректностиНастроекЗапросаВыгрузкиТабличнойЧасти(ТекстЗапросаВыгрузкиНаТСД, НастройкаТЧ, ТипДокумента1С, СтруктураПроверки, МассивОшибок)
	
	Запрос = Новый Запрос(СтрЗаменить(ТекстЗапросаВыгрузкиНаТСД, "¶", ""));
	Запрос.УстановитьПараметр("Ссылка", Документы[ТипДокумента1С].ПустаяСсылка());
	
	ЕстьОшибки = Ложь;
	
	ПараметрыЗапроса = Новый Структура;
	// Проверяем корректность заполненного кода по параметрам запроса
	Попытка
		Если НастройкаТЧ.Свойство("ТекстКодаПолучениеПараметров") И Не ПустаяСтрока(НастройкаТЧ.ТекстКодаПолучениеПараметров) Тогда
			//Выполнить(СтрЗаменить(НастройкаТЧ.ТекстКодаПолучениеПараметров, "ДокументДляВыгрузки", "Документы[ТипДокумента1С].ПустаяСсылка()"));
			СтрокаВызова = НастройкаТЧ.ТекстКодаПолучениеПараметров;
			СтрокаВызова = СтрЗаменить(СтрокаВызова, "ДокументДляВыгрузки", "Документы[""" + ТипДокумента1С + """].ПустаяСсылка()");
			ПараметрыАлгоритма = Новый Структура;
			ПараметрыАлгоритма.Вставить("ПараметрыЗапроса", ПараметрыЗапроса);
			ПараметрыЗапроса = ЛокЯдро_ВыполнитьКодПолученияПараметровЗапроса(СтрокаВызова, ПараметрыАлгоритма);
			Если ПараметрыЗапроса.Количество() Тогда
				Для Каждого ПараметрЗапроса Из ПараметрыЗапроса Цикл
					Запрос.УстановитьПараметр(ПараметрЗапроса.Ключ, ПараметрЗапроса.Значение);	
				КонецЦикла;
			КонецЕсли;			
		КонецЕсли;
	Исключение
		ЕстьОшибки = Истина;
		ТекстОшибки = "Ошибка инициализации параметров запроса для выгрузки табличной части документа 1С" + Символы.ПС + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		СтруктураПроверки.ОшибкаБП = Истина;
		МассивОшибок.Добавить(ТекстОшибки);		
	КонецПопытки;
	
	// Если параметры проверены, переходим к проверке корректности заполненного текста запроса, в противном случае смысла нет
	Если Не ЕстьОшибки Тогда	                                                                                             	
		Попытка
			РезультатЗапроса = Запрос.Выполнить();		
		Исключение
			ТекстОшибки = "Ошибка выполнения запроса для выгрузки табличной части документа 1С:" + Символы.ПС + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
			СтруктураПроверки.ОшибкаБП = Истина;
			МассивОшибок.Добавить(ТекстОшибки);		
		КонецПопытки;
	КонецЕсли;
	
КонецПроцедуры

// Проверяет, существует ли объект метаданных
//
// Параметры:
//  ПолноеИмя  - Строка - полное имя объекта метаданных (например, Справочник.Номенклатура, Документ.ПриемНаРаботу.)
//
// Возвращаемое значение:
//   Булево   - признак наличия объекта метаданных
//
&НаКлиенте
Функция ЛокЯдро_ПроверитьОбъектМетаданныхСуществует(ПолноеИмя) Экспорт

	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода", "Функция");
	СтруктураВызова.Вставить("ИмяМетода", "ПроверитьОбъектМетаданныхСуществует");
	СтруктураПараметров = Новый Структура;
	СтруктураПараметров.Вставить("ПолноеИмя", ПолноеИмя);
	СтруктураВызова.Вставить("ПараметрыМетода", СтруктураПараметров);
	
	РезультатПроверки = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,, АдресаПеременных);
	
	Возврат РезультатПроверки;

КонецФункции

&НаКлиенте
Процедура ЛокЯдро_ПоместитьФайлВнешнейОбработки(ДополнительныеПараметры, ДопПараметр = Неопределено) Экспорт

	#Если НЕ ТолстыйКлиентОбычноеПриложение Тогда	
		
		ЭтоВнешняяОбработка = ЛокЯдро_ЭтоВнешняяОбработка();
		Если ЭтоВнешняяОбработка Тогда
			ФайлОбработки = Новый Файл(ИспользуемоеИмяФайла);
			
			Если Не ФайлОбработки.Существует() И
				Не ЗначениеЗаполнено(ОбъектСсылка) Тогда
				// Если после актуализации ОО основная обработка не отлаживается, то значит, что
				// в процессе актуализации создалась и подключилась идентичная ОО под тем же именем, 
				// поэтому весь код выполняется из обработки из справочника.
				// В этом случае для работы ФЗ необходим заполненный реквизит ОбъектСсылка
				ЗаполнитьСсылкуНаОбъект();	
			КонецЕсли;
			
			Если ЗначениеЗаполнено(ХранениеФайлаОбработки) Тогда
				// Значение теряется после 20 минут. Проверка, что файл существует
				ФайлОбработкиНаСервере = Новый Файл(ХранениеФайлаОбработки);
				Если Не ФайлОбработкиНаСервере.Существует() Тогда
					// Очистка пути для последующего перепомещения файла
					ХранениеФайлаОбработки = "";
				КонецЕсли;
			КонецЕсли;
			
		КонецЕсли;	
		
		Если ЭтоВнешняяОбработка И
			Не ЗначениеЗаполнено(ОбъектСсылка) И
			Не ЗначениеЗаполнено(ХранениеФайлаОбработки) Тогда
			
			ПутьВоВременномХранилище = "";
			ОписаниеОповещения = Новый ОписаниеОповещения("ЛокЯдро_ПоместитьФайлВнешнейОбработкиЗавершение", ЭтаФорма, ДополнительныеПараметры);
			НачатьПомещениеФайлов(ОписаниеОповещения, 
			ИспользуемоеИмяФайла, Ложь, УникальныйИдентификатор);	
		Иначе
			ЛокЯдро_НачатьВыполнениеФоновогоЗаданияПродолжение(ДополнительныеПараметры);	
		КонецЕсли;
	#КонецЕсли	

КонецПроцедуры

&НаКлиенте
Процедура ЛокЯдро_ПоместитьФайлВнешнейОбработкиЗавершение(ПомещенныеФайлы, ДополнительныеПараметры) Экспорт
    
	Если ПомещенныеФайлы <> Неопределено Тогда
		Для Каждого ПомещенныйФайл Из ПомещенныеФайлы Цикл
			ХранениеФайлаОбработки = ЛокЯдро_КопияФайлаНаСервере(ПомещенныйФайл.Хранение);
		КонецЦикла;
	КонецЕсли;
	
	ЛокЯдро_НачатьВыполнениеФоновогоЗаданияПродолжение(ДополнительныеПараметры);
	
КонецПроцедуры

&НаСервереБезКонтекста
Функция ЛокЯдро_КопияФайлаНаСервере(Хранение)

	Результат = ПолучитьИмяВременногоФайла();
	ДвоичныеДанные = ПолучитьИзВременногоХранилища(Хранение);
	ДвоичныеДанные.Записать(Результат);
	
	Возврат Результат;

КонецФункции

&НаСервере
Функция ЛокЯдро_ЭтоВнешняяОбработка()
	
	ПолноеИмя = "";
	
	#Если НЕ ТолстыйКлиентОбычноеПриложение Тогда
		ПолноеИмя = ПолноеИмяОбъекта;
	#КонецЕсли

	ЧастиИмени = ЛокЯдро_СтрРазделитьНаСервере(ПолноеИмя, ".");
	Возврат (ВРег(ЧастиИмени[0]) = "ВНЕШНЯЯОБРАБОТКА");
	
КонецФункции

&НаСервереБезКонтекста
Функция ЛокЯдро_ПрочитатьТекстФайлаНаСервере(ПутьКФайлу)

	Файл = Новый ЧтениеТекста(ПутьКФайлу);
	Текст = Файл.Прочитать();
	Файл.Закрыть();
	
	Возврат Текст;

КонецФункции

#КонецОбласти

// Записывает новый файл, в который в последующем будут добавляться записи лога
//
// Возвращаемое значение:
//	Булево, Неопределено - при удачной записи возвращается значение Истина.
&НаКлиенте
Функция ЛокЯдро_ЗаписатьНачалоЛога(РабочийКаталог = Неопределено) Экспорт
	Если РасположениеКомпоненты = "НаСервере" Тогда
		СтруктураВызова = Новый Структура;
		СтруктураВызова.Вставить("ТипМетода", "Функция");
		СтруктураВызова.Вставить("ИмяМетода", "ЗаписатьНачалоЛога");
		СтруктураПараметров = Новый Структура;
		СтруктураПараметров.Вставить("РабочийКаталог", РабочийКаталог);
		СтруктураВызова.Вставить("ПараметрыМетода", СтруктураПараметров);
		
		РезультатЗаписи = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,,АдресаПеременных);	
		
		Возврат РезультатЗаписи;
	Иначе
		СтруктураВызова = Новый Структура;
		СтруктураВызова.Вставить("ТипМетода", "Функция");
		СтруктураВызова.Вставить("ИмяМетода", "ПолучитьСистемнуюИнформациюДляШапкиЛога");	
		СисИнфо = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,,АдресаПеременных);
		
		ШапкаЛога 		= СисИнфо.ШапкаЛога;
		Если РабочийКаталог = Неопределено Тогда
			РабочийКаталог 	= СисИнфо.РабочийКаталог;
		КонецЕсли;
		
		ИмяФайлаОбщегоЛога = КомЯдро_ПолучитьЗначениеПеременной("ИмяФайлаОбщегоЛога");
		ИмяФайлаЛогаОшибок = КомЯдро_ПолучитьЗначениеПеременной("ИмяФайлаЛогаОшибок");
		Если ИмяФайлаЛогаОшибок = Неопределено
			Или ИмяФайлаЛогаОшибок = Неопределено Тогда
			ВызватьИсключение "Не удалось получить имя файла лога";
		КонецЕсли;

		ПутьКОбщемуЛогу = РабочийКаталог+ИмяФайлаОбщегоЛога+Формат(ТекущаяДата(),"ДФ=dd.MM.yy")+".txt";
		ПутьКЛогуОшибок = РабочийКаталог+ИмяФайлаЛогаОшибок+Формат(ТекущаяДата(),"ДФ=dd.MM.yy")+".txt";
		
		ЛогОбщий = Новый ЗаписьТекста(ПутьКОбщемуЛогу,КодировкаТекста.UTF8,,Ложь);
		ЛогОбщий.Записать(ШапкаЛога);
		ЛогОбщий.Закрыть();
		
		ЛогОшибок = Новый ЗаписьТекста(ПутьКЛогуОшибок,КодировкаТекста.UTF8,,Ложь);
		ЛогОшибок.Записать(ШапкаЛога);
		ЛогОшибок.Закрыть();
		
		КомЯдро_СохранитьЗначениеПеременной("ПутьКОбщемуЛогу",ПутьКОбщемуЛогу);
		КомЯдро_СохранитьЗначениеПеременной("ПутьКЛогуОшибок",ПутьКЛогуОшибок);
		
		Возврат Истина;
	КонецЕсли;
КонецФункции

// Выполняет запись события в файл лога в базе Mobile SMARTS
//
// Параметры:
//	ПутьКФайлу - Строка - путь к файлу	
//  ТекстЗаписи - Строка - текст ошибки
//	СТаймштампом - Булево (необязательный) - с добавлением даты к тексту. Значение по умолчанию:Истина.
&НаКлиенте
Процедура ЛокЯдро_ДобавитьЗаписьВЛог(ПутьКФайлу, ТекстЗаписи,СТаймштампом = Истина) Экспорт
	
	Если РасположениеКомпоненты = "НаСервере" Тогда
		СтруктураВызова = Новый Структура;
		СтруктураВызова.Вставить("ТипМетода", "Процедура");
		СтруктураВызова.Вставить("ИмяМетода", "ДобавитьЗаписьВЛог");
		СтруктураПараметров = Новый Структура;
		СтруктураПараметров.Вставить("ПутьКФайлу", ПутьКФайлу);
		СтруктураПараметров.Вставить("ТекстЗаписи", ТекстЗаписи);
		СтруктураВызова.Вставить("ПараметрыМетода", СтруктураПараметров);
		
		Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,,АдресаПеременных);	
	Иначе
		ФайлЛога = Новый Файл(ПутьКФайлу);
		Если Не ФайлЛога.Существует() Тогда
			Возврат;
		Конецесли;
		
		ВремяСобытия = Формат(ТекущаяДата(),"ДЛФ=DT");
		
		ЗаписьЛога = Новый ЗаписьТекста(ПутьКФайлу,КодировкаТекста.UTF8,,Истина);
		ЗаписьЛога.ЗаписатьСтроку(?(СТаймштампом,ВремяСобытия+Символы.Таб,"")+ТекстЗаписи);
		ЗаписьЛога.Закрыть();
	КонецЕсли;
	
КонецПроцедуры

&НаКлиенте
Процедура ЛокЯдро_УдалитьФайлЛога(ПутьКФайлу) Экспорт
	
	Если РасположениеКомпоненты = "НаСервере" Тогда
		СтруктураВызова = Новый Структура;
		СтруктураВызова.Вставить("ТипМетода", "Процедура");
		СтруктураВызова.Вставить("ИмяМетода", "УдалитьФайлЛога");
		СтруктураПараметров = Новый Структура;
		СтруктураПараметров.Вставить("ПутьКФайлу", ПутьКФайлу);		
		СтруктураВызова.Вставить("ПараметрыМетода", СтруктураПараметров);
		
		Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,,АдресаПеременных);	
	Иначе
		ФайлЛога = Новый Файл(ПутьКФайлу);
		Если Не ФайлЛога.Существует() Тогда
			Возврат;
		Конецесли;
		
		УдалитьФайлы(ПутьКФайлу);		
	КонецЕсли;
	
КонецПроцедуры

&НаКлиенте
Процедура ЛокЯдро_ОтправитьЛогПоПочте(ПутьКФайлу, ПараметрыОтправкиПочты) Экспорт
	
	#Область НесовместимыйКодFresh
	Если РасположениеКомпоненты = "НаСервере" Тогда
		СтруктураВызова = Новый Структура;
		СтруктураВызова.Вставить("ТипМетода", "Процедура");
		СтруктураВызова.Вставить("ИмяМетода", "ОтправитьЛогПоПочте");
		СтруктураПараметров = Новый Структура;
		СтруктураПараметров.Вставить("ПутьКФайлу", 			ПутьКФайлу);
		СтруктураПараметров.Вставить("ПараметрыОтправкиПочты", 	ПараметрыОтправкиПочты);		
		СтруктураВызова.Вставить("ПараметрыМетода", СтруктураПараметров);
		
		Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,,АдресаПеременных);	
	Иначе
		
		Если ПараметрыОтправкиПочты = Неопределено Тогда
			Возврат;
		Конецесли;
		МассивПолучателей 	= ПараметрыОтправкиПочты.МассивПолучателей;				
		АдресSMTP 			= ПараметрыОтправкиПочты.АдресSMTP;
		ПортSMTP 			= ПараметрыОтправкиПочты.ПортSMTP;
		ЛогинSMTP 			= ПараметрыОтправкиПочты.ЛогинSMTP;
		ПарольSMTP 			= ПараметрыОтправкиПочты.ПарольSMTP;
		ОтправительSMTP 	= ПараметрыОтправкиПочты.ОтправительSMTP;
		
		Если МассивПолучателей.Количество() = 0 
			Или Не ЗначениеЗаполнено(АдресSMTP) 
			Или Не ЗначениеЗаполнено(ПортSMTP)
			Или Не ЗначениеЗаполнено(ЛогинSMTP)
			Или Не ЗначениеЗаполнено(ПарольSMTP) Тогда 
			Возврат;
		КонецЕсли;
		
		СтруктураВызова = Новый Структура;
		СтруктураВызова.Вставить("ТипМетода", "Функция");
		СтруктураВызова.Вставить("ИмяМетода", "ПолучитьСистемнуюИнформациюДляШапкиЛога");	
		СисИнфо = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,,АдресаПеременных);
		
		Профиль = Вычислить("Новый ИнтернетПочтовыйПрофиль");				
		Профиль.АдресСервераSMTP 	= АдресSMTP;
		Профиль.ПортSMTP 			= ПортSMTP;
		Профиль.ПользовательSMTP 	= ЛогинSMTP;
		Профиль.ПарольSMTP 			= ПарольSMTP;
		Профиль.ИспользоватьSSLSMTP = Истина;
		Профиль.АутентификацияSMTP 	= Вычислить("СпособSMTPАутентификации.Login");
		
		Если ОтправительSMTP =  "" Тогда
			ОтправительSMTP = "autotest1c@cleverence.ru";
		КонецЕсли;
		
		Письмо = Вычислить("Новый ИнтернетПочтовоеСообщение");
		Текст = Письмо.Тексты.Добавить("Ошибки занесены в лог-файл во вложении, ознакомьтесь и передайте разработчикам!");
		Текст.ТипТекста = Вычислить("ТипТекстаПочтовогоСообщения.ПростойТекст");
		Письмо.Тема = "Автотесты 1С: Ошибка при прохождении тестов в базе "+СисИнфо.ИнформацияСтруктурой.Имябазы1С; 
		Письмо.Отправитель = ОтправительSMTP;		
		Для Каждого Получатель Из МассивПолучателей Цикл
			Письмо.Получатели.Добавить(Получатель);
		КонецЦикла;
		
		Письмо.Вложения.Добавить(ПутьКФайлу);
		
		Почта = Вычислить("Новый ИнтернетПочта");
		ЕстьПодключениеКПочтовомуСерверу = Истина;
		Попытка
			Почта.Подключиться(Профиль);		
		Исключение
			ЕстьПодключениеКПочтовомуСерверу = Ложь;;
			ТекстОшибки = "Не удалось подключиться к почтовому серверу: " + ОписаниеОшибки(); 
			Сообщить(ТекстОшибки);
			ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации("ЛокЯдро_ОтправитьЛогПоПочте", "Ошибка", ТекстОшибки);
		КонецПопытки;
		
		Если ЕстьПодключениеКПочтовомуСерверу Тогда
			Попытка
				РезультатОтправки = Почта.Послать(Письмо);		
			Исключение			
				ТекстОшибки = "Не удалось отправить письмо: " + ОписаниеОшибки(); 
				Сообщить(ТекстОшибки);
				ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации("ЛокЯдро_ОтправитьЛогПоПочте", "Ошибка", ТекстОшибки);
			КонецПопытки;
		КонецЕсли;
		
		Почта.Отключиться();
	   
	КонецЕсли;
	#КонецОбласти //НесовместимыйКодFresh
	
КонецПроцедуры

// Выполняет запись событий из журнала регистрации с отбором по идентификатору автотеста в поле Данные
// в файл лога в базе Mobile SMARTS
//
// Параметры:
//	ДанныеДляОтбораЖР 	- Строка - строка, по которой будет наложен отбор на записи журнала регистрации
//	МассивПолучателей 	- Массив - массив адресов эл почты, на которые необходимо отправить лог
//	ИмяКаталога 		- Строка - имя каталога, в который необходимо сохранить файл
//
&НаКлиенте
Процедура ЛокЯдро_ВыгрузитьЛогИзЖурналаРегистрации(ДанныеДляОтбораЖР, ПараметрыОтправкиПочты = Неопределено, ИмяКаталога = Неопределено) Экспорт
		
	Если РасположениеКомпоненты = "НаСервере" Тогда
		СтруктураВызова = Новый Структура;
		СтруктураВызова.Вставить("ТипМетода", "Процедура");
		СтруктураВызова.Вставить("ИмяМетода", "ВыгрузитьЛогИзЖурналаРегистрации");		
		СтруктураПараметров = Новый Структура;
		СтруктураПараметров.Вставить("ДанныеДляОтбораЖР", ДанныеДляОтбораЖР);		
		СтруктураПараметров.Вставить("ПараметрыОтправкиПочты", ПараметрыОтправкиПочты);	
		СтруктураВызова.Вставить("ПараметрыМетода", СтруктураПараметров);
		
		Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,,АдресаПеременных);
		
		ИмяФайлаОбщегоЛога = КомЯдро_ПолучитьЗначениеПеременной("ИмяФайлаОбщегоЛога");
		ИмяФайлаЛогаОшибок = КомЯдро_ПолучитьЗначениеПеременной("ИмяФайлаЛогаОшибок");

		ПутьКОбщемуЛогу = КомЯдро_ПолучитьЗначениеПеременной("ПутьКОбщемуЛогу");
		ПутьКЛогуОшибок = КомЯдро_ПолучитьЗначениеПеременной("ПутьКЛогуОшибок");

		Если ИмяКаталога <> Неопределено Тогда
			Если ЭтоАдресВременногоХранилища(ПутьКОбщемуЛогу) Тогда
				ПолучитьИзВременногоХранилища(ПутьКОбщемуЛогу).Записать(ИмяКаталога + ИмяФайлаОбщегоЛога + Формат(ТекущаяДата(),"ДФ=dd.MM.yy") + ".txt");
			КонецЕсли;
			Если ЭтоАдресВременногоХранилища(ПутьКЛогуОшибок) Тогда
				ПолучитьИзВременногоХранилища(ПутьКЛогуОшибок).Записать(ИмяКаталога + ИмяФайлаЛогаОшибок + Формат(ТекущаяДата(),"ДФ=dd.MM.yy") + ".txt");
			КонецЕсли;
		КонецЕсли;
		
	Иначе		
		СтруктураВызова = Новый Структура;
		СтруктураВызова.Вставить("ТипМетода", "Функция");
		СтруктураВызова.Вставить("ИмяМетода", "ПолучитьДанныеЖурналаРегистрации");
		СтруктураПараметров = Новый Структура;
		СтруктураПараметров.Вставить("ДанныеДляОтбораЖР", ДанныеДляОтбораЖР);
		СтруктураВызова.Вставить("ПараметрыМетода", СтруктураПараметров);
		
		ДанныеЖурнала = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,,АдресаПеременных);
		ДанныеЖурналаОбщий = ДанныеЖурнала.ДанныеЖурналаОбщий;
		ДанныеЖурналаОшибки = ДанныеЖурнала.ДанныеЖурналаОшибки;
		
		ПутьКОбщемуЛогу = КомЯдро_ПолучитьЗначениеПеременной("ПутьКОбщемуЛогу");
		ПутьКЛогуОшибок = КомЯдро_ПолучитьЗначениеПеременной("ПутьКЛогуОшибок");
		
		Если ПутьКОбщемуЛогу <> Неопределено И ДанныеЖурналаОбщий <> "" Тогда
			ЛокЯдро_ДобавитьЗаписьВЛог(ПутьКОбщемуЛогу,ДанныеЖурналаОбщий,Ложь);						
		КонецЕсли;
		
		Если ПутьКЛогуОшибок <> Неопределено Тогда 
			Если ДанныеЖурналаОшибки <> "" Тогда
				ЛокЯдро_ДобавитьЗаписьВЛог(ПутьКЛогуОшибок,ДанныеЖурналаОшибки,Ложь);				
				ЛокЯдро_ОтправитьЛогПоПочте(ПутьКЛогуОшибок, ПараметрыОтправкиПочты);				
			Иначе
				ЛокЯдро_УдалитьФайлЛога(ПутьКЛогуОшибок);
			КонецЕсли;
		КонецЕсли
	КонецЕсли;
	
КонецПроцедуры

// Записывает шапку файла лога в который в последующем будут добавляться записи лога
//
// Возвращаемое значение:
//	Булево - при удачной записи возвращается значение Истина.
&НаКлиенте
Функция ЛокЯдро_ЗаписатьШапкуЛога(ИмяФайлаОбщегоЛога, ИмяФайлаЛогаОшибок, ИмяКаталога = Неопределено) Экспорт
	
	Попытка
		КомЯдро_СохранитьЗначениеПеременной("ИмяФайлаОбщегоЛога", ИмяФайлаОбщегоЛога);
		КомЯдро_СохранитьЗначениеПеременной("ИмяФайлаЛогаОшибок", ИмяФайлаЛогаОшибок);
		
		ШапкаЛогаЗаписана = ЛокЯдро_ЗаписатьНачалоЛога(ИмяКаталога);
	Исключение
		ШапкаЛогаЗаписана = Ложь;
		ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации("Автотесты_ЗаписатьЗаголовокЛогаЖРЗаПериод", "Ошибка", "Не удалось записать файл лога журнала регистрации за период, Описание ошибки: " + ТекстОшибки);		
	КонецПопытки;
	
	Возврат ШапкаЛогаЗаписана;
	
КонецФункции

// Получает форму интеграционной обработки
//
// Параметры:
//	ТипОбработки 	- Строка - тип интеграционной обработки: "ФайлНаДиске", "СправочникСсылка", "Встроенная"
//	ИмяИнтеграционнойОбработки 	- Строка - имя интеграционной обработки
//
&НаКлиенте
Функция ПолучитьФормуИнтеграционнойОбработки(ТипОбработки, ИмяИнтеграционнойОбработки)
	
	ФормаИнтеграционнойОбработки = ПолучитьФорму(?(ТипОбработки = "Встроенная","Обработка.","ВнешняяОбработка.") + Строка(СтрЗаменить(ИмяИнтеграционнойОбработки,".epf","")) + ".Форма");
	
	Возврат ФормаИнтеграционнойОбработки;
	
КонецФункции

&НаКлиенте
Функция ЛокЯдро_ПолучитьПользователейSMARTS() Экспорт
	
	ТипБазы 		= ?(ЕстьЧастнаяБаза, "Частная", "Основная");		
	ТипИнтерфейса 	= ЛокЯдро_ПолучитьТипИнтерфейса(ТипБазы);	    
	
	#Если ВебКлиент Тогда                 
		СтруктураВызова = Новый Структура;
		СтруктураВызова.Вставить("ТипМетода", "Функция");
		СтруктураВызова.Вставить("ИмяМетода", "ПолучитьПользователейSMARTS");	
		
		ПараметрыМетода = Новый Структура;
		ПараметрыМетода.Вставить("ТипБазы", 		ТипБазы);
		ПараметрыМетода.Вставить("ТипИнтерфейса", 	ТипИнтерфейса);
		
		СтруктураВызова.Вставить("ПараметрыМетода", ПараметрыМетода);		
		
		Результат = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,,АдресаПеременных);
	#Иначе
		Если РасположениеКомпоненты = "НаСервере" Тогда
			СтруктураВызова = Новый Структура;
			СтруктураВызова.Вставить("ТипМетода", "Функция");
			СтруктураВызова.Вставить("ИмяМетода", "ПолучитьПользователейSMARTS");	
			
			ПараметрыМетода = Новый Структура;
			ПараметрыМетода.Вставить("ТипБазы", 		ТипБазы);
			ПараметрыМетода.Вставить("ТипИнтерфейса", 	ТипИнтерфейса);
			
			СтруктураВызова.Вставить("ПараметрыМетода", ПараметрыМетода);		
			
			Результат = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,,АдресаПеременных);	
		Иначе	       			
			Если ТипИнтерфейса = "REST_API" Тогда
				Результат = REST_API_ПолучитьПользователейSMARTS(ТипБазы);
			Иначе
				Результат = КомЯдро_ПолучитьПользователейSMARTS(ТипБазы);	
			КонецЕсли; 	
		КонецЕсли;     
	#КонецЕсли
	
	Возврат Результат;
	
КонецФункции

&НаКлиенте
Функция ЛокЯдро_ПолучитьСкладыSMARTS() Экспорт
	
	ТипБазы 		= ?(ЕстьЧастнаяБаза, "Частная", "Основная");		
	ТипИнтерфейса 	= ЛокЯдро_ПолучитьТипИнтерфейса(ТипБазы);	  
	
	#Если ВебКлиент Тогда             
		СтруктураВызова = Новый Структура;
		СтруктураВызова.Вставить("ТипМетода", "Функция");
		СтруктураВызова.Вставить("ИмяМетода", "ПолучитьСкладыSMARTS");	
		
		ПараметрыМетода = Новый Структура;
		ПараметрыМетода.Вставить("ТипБазы", 		ТипБазы);
		ПараметрыМетода.Вставить("ТипИнтерфейса", 	ТипИнтерфейса);
		
		СтруктураВызова.Вставить("ПараметрыМетода", ПараметрыМетода);		
		
		Результат = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,,АдресаПеременных);	
	#Иначе
		Если РасположениеКомпоненты = "НаСервере" Тогда
			СтруктураВызова = Новый Структура;
			СтруктураВызова.Вставить("ТипМетода", "Функция");
			СтруктураВызова.Вставить("ИмяМетода", "ПолучитьСкладыSMARTS");	
			
			ПараметрыМетода = Новый Структура;
			ПараметрыМетода.Вставить("ТипБазы", 		ТипБазы);
			ПараметрыМетода.Вставить("ТипИнтерфейса", 	ТипИнтерфейса);
			
			СтруктураВызова.Вставить("ПараметрыМетода", ПараметрыМетода);		
			
			Результат = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,,АдресаПеременных);	
		Иначе
			Если ТипИнтерфейса = "REST_API" Тогда
				Результат = REST_API_ПолучитьСкладыSMARTS(ТипБазы);
			Иначе
				Результат = КомЯдро_ПолучитьСкладыSMARTS(ТипБазы);	
			КонецЕсли;
		КонецЕсли;
	#КонецЕсли
	
	Возврат Результат;
	
КонецФункции

&НаКлиенте
Функция ЛокЯдро_ПолучитьГруппыПользователейSMARTS() Экспорт
	
	ТипБазы 		= ?(ЕстьЧастнаяБаза, "Частная", "Основная");		
	ТипИнтерфейса 	= ЛокЯдро_ПолучитьТипИнтерфейса(ТипБазы);	
	
	#Если ВебКлиент Тогда              
		СтруктураВызова = Новый Структура;
		СтруктураВызова.Вставить("ТипМетода", "Функция");
		СтруктураВызова.Вставить("ИмяМетода", "ПолучитьГруппыПользователейSMARTS");	
		
		ПараметрыМетода = Новый Структура;
		ПараметрыМетода.Вставить("ТипБазы", 		ТипБазы);
		ПараметрыМетода.Вставить("ТипИнтерфейса", 	ТипИнтерфейса);
		
		СтруктураВызова.Вставить("ПараметрыМетода", ПараметрыМетода);		
		
		Результат = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,,АдресаПеременных);
	#Иначе
		Если РасположениеКомпоненты = "НаСервере" Тогда
			СтруктураВызова = Новый Структура;
			СтруктураВызова.Вставить("ТипМетода", "Функция");
			СтруктураВызова.Вставить("ИмяМетода", "ПолучитьГруппыПользователейSMARTS");	
			
			ПараметрыМетода = Новый Структура;
			ПараметрыМетода.Вставить("ТипБазы", 		ТипБазы);
			ПараметрыМетода.Вставить("ТипИнтерфейса", 	ТипИнтерфейса);
			
			СтруктураВызова.Вставить("ПараметрыМетода", ПараметрыМетода);		
			
			Результат = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,,АдресаПеременных);	
		Иначе	
			Если ТипИнтерфейса = "REST_API" Тогда
				Результат = REST_API_ПолучитьГруппыПользователейSMARTS(ТипБазы);
			Иначе
				Результат = КомЯдро_ПолучитьГруппыПользователейSMARTS(ТипБазы);	
			КонецЕсли;
		КонецЕсли;
	#КонецЕсли
	
	Возврат Результат;
	
КонецФункции

&НаКлиенте
Функция ЛокЯдро_ЗагрузитьПользователейВSMARTS(ПараметрыПользователя) Экспорт
	
	ТипБазы 		= ?(ЕстьЧастнаяБаза, "Частная", "Основная");		
	ТипИнтерфейса 	= ЛокЯдро_ПолучитьТипИнтерфейса(ТипБазы);	

	#Если ВебКлиент Тогда  
		СтруктураВызова = Новый Структура;
		СтруктураВызова.Вставить("ТипМетода", "Функция");
		СтруктураВызова.Вставить("ИмяМетода", "ЗагрузитьПользователейВSMARTS");	
		
		ПараметрыМетода = Новый Структура;                                          		
		ПараметрыМетода.Вставить("ПараметрыПользователя",	ПараметрыПользователя);	
		ПараметрыМетода.Вставить("ТипБазы", 				ТипБазы);           
		ПараметрыМетода.Вставить("ТипИнтерфейса", 			ТипИнтерфейса);
		
		СтруктураВызова.Вставить("ПараметрыМетода", ПараметрыМетода);
		
		Результат = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,,АдресаПеременных);
	#Иначе
		Если РасположениеКомпоненты = "НаСервере" Тогда
			СтруктураВызова = Новый Структура;
			СтруктураВызова.Вставить("ТипМетода", "Функция");
			СтруктураВызова.Вставить("ИмяМетода", "ЗагрузитьПользователейВSMARTS");	
			
			ПараметрыМетода = Новый Структура;                                          		
			ПараметрыМетода.Вставить("ПараметрыПользователя",	ПараметрыПользователя);	
			ПараметрыМетода.Вставить("ТипБазы", 				ТипБазы);           
			ПараметрыМетода.Вставить("ТипИнтерфейса", 			ТипИнтерфейса);
			
			СтруктураВызова.Вставить("ПараметрыМетода", ПараметрыМетода);
			
			Результат = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,,АдресаПеременных);	
		Иначе
			Если ТипИнтерфейса = "REST_API" Тогда
				ПараметрыПользователя.Удалить("allWarehouses"); // Это спец. свойство для Кома, в Ресте оно недопустимо
				Результат = REST_API_ЗагрузитьПользователейВSMARTS(ПараметрыПользователя, ТипБазы);
			Иначе
				Результат = КомЯдро_ЗагрузитьПользователейВSMARTS(ПараметрыПользователя, ТипБазы);	
			КонецЕсли;
		КонецЕсли;  
	#КонецЕсли

	Возврат Результат;
	
КонецФункции

&НаКлиенте
Функция ЛокЯдро_ЗагрузитьГруппыПользователейВSMARTS(ПараметрыГруппы) Экспорт
	
	ТипБазы 		= ?(ЕстьЧастнаяБаза, "Частная", "Основная");		
	ТипИнтерфейса 	= ЛокЯдро_ПолучитьТипИнтерфейса(ТипБазы);	
	
	#Если ВебКлиент Тогда
		СтруктураВызова = Новый Структура;
		СтруктураВызова.Вставить("ТипМетода", "Функция");
		СтруктураВызова.Вставить("ИмяМетода", "ЗагрузитьГруппыПользователейВSMARTS");	
		
		ПараметрыМетода = Новый Структура;
		ПараметрыМетода.Вставить("ПараметрыГруппы",	ПараметрыГруппы);
		ПараметрыМетода.Вставить("ТипБазы", 		ТипБазы);           
		ПараметрыМетода.Вставить("ТипИнтерфейса", 	ТипИнтерфейса);
		
		СтруктураВызова.Вставить("ПараметрыМетода", ПараметрыМетода);
		
		Результат = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,,АдресаПеременных);			
	#Иначе
		Если РасположениеКомпоненты = "НаСервере" Тогда
			СтруктураВызова = Новый Структура;
			СтруктураВызова.Вставить("ТипМетода", "Функция");
			СтруктураВызова.Вставить("ИмяМетода", "ЗагрузитьГруппыПользователейВSMARTS");	
			
			ПараметрыМетода = Новый Структура;
			ПараметрыМетода.Вставить("ПараметрыГруппы",	ПараметрыГруппы);
			ПараметрыМетода.Вставить("ТипБазы", 		ТипБазы);           
			ПараметрыМетода.Вставить("ТипИнтерфейса", 	ТипИнтерфейса);
			
			СтруктураВызова.Вставить("ПараметрыМетода", ПараметрыМетода);
			
			Результат = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,,АдресаПеременных);	
		Иначе	
			Если ТипИнтерфейса = "REST_API" Тогда
				ПараметрыГруппы.Удалить("AlldocumentTypeNames"); // Это спец. свойство для Кома, в Ресте оно недопустимо
				Результат = REST_API_ЗагрузитьГруппыПользователейВSMARTS(ПараметрыГруппы, ТипБазы);
			Иначе
				Результат = КомЯдро_ЗагрузитьГруппыПользователейВSMARTS(ПараметрыГруппы, ТипБазы);	
			КонецЕсли;
		КонецЕсли; 
	#КонецЕсли
	
	Возврат Результат;
	
КонецФункции    

&НаКлиенте
Функция ЛокЯдро_УдалитьПользователейВSMARTS(ПараметрыПользователя) Экспорт
	
	ТипБазы 		= ?(ЕстьЧастнаяБаза, "Частная", "Основная");		
	ТипИнтерфейса 	= ЛокЯдро_ПолучитьТипИнтерфейса(ТипБазы);	
	
	#Если ВебКлиент Тогда            
		СтруктураВызова = Новый Структура;
		СтруктураВызова.Вставить("ТипМетода", "Функция");
		СтруктураВызова.Вставить("ИмяМетода", "УдалитьПользователейВSMARTS");	
		
		ПараметрыМетода = Новый Структура;                                          		
		ПараметрыМетода.Вставить("ПараметрыПользователя",	ПараметрыПользователя);	
		ПараметрыМетода.Вставить("ТипБазы", 				ТипБазы);           
		ПараметрыМетода.Вставить("ТипИнтерфейса", 			ТипИнтерфейса);
		
		СтруктураВызова.Вставить("ПараметрыМетода", ПараметрыМетода);
		
		Результат = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,,АдресаПеременных);
	#Иначе
		Если РасположениеКомпоненты = "НаСервере" Тогда
			СтруктураВызова = Новый Структура;
			СтруктураВызова.Вставить("ТипМетода", "Функция");
			СтруктураВызова.Вставить("ИмяМетода", "УдалитьПользователейВSMARTS");	
			
			ПараметрыМетода = Новый Структура;                                          		
			ПараметрыМетода.Вставить("ПараметрыПользователя",	ПараметрыПользователя);	
			ПараметрыМетода.Вставить("ТипБазы", 				ТипБазы);           
			ПараметрыМетода.Вставить("ТипИнтерфейса", 			ТипИнтерфейса);
			
			СтруктураВызова.Вставить("ПараметрыМетода", ПараметрыМетода);
			
			Результат = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,,АдресаПеременных);	
		Иначе
			Если ТипИнтерфейса = "REST_API" Тогда
				Результат = REST_API_УдалитьПользователейВSMARTS(ПараметрыПользователя, ТипБазы);
			Иначе
				Результат = КомЯдро_УдалитьПользователейВSMARTS(ПараметрыПользователя, ТипБазы);	
			КонецЕсли;
		КонецЕсли; 
	#КонецЕсли
	
	Возврат Результат;
	
КонецФункции

&НаКлиенте
Функция ЛокЯдро_УдалитьГруппыПользователейВSMARTS(ПараметрыГруппы) Экспорт
	
	ТипБазы 		= ?(ЕстьЧастнаяБаза, "Частная", "Основная");		
	ТипИнтерфейса 	= ЛокЯдро_ПолучитьТипИнтерфейса(ТипБазы);	

	#Если ВебКлиент Тогда         
		СтруктураВызова = Новый Структура;
		СтруктураВызова.Вставить("ТипМетода", "Функция");
		СтруктураВызова.Вставить("ИмяМетода", "УдалитьГруппыПользователейВSMARTS");	
		
		ПараметрыМетода = Новый Структура;
		ПараметрыМетода.Вставить("ПараметрыГруппы",	ПараметрыГруппы);
		ПараметрыМетода.Вставить("ТипБазы", 		ТипБазы);           
		ПараметрыМетода.Вставить("ТипИнтерфейса", 	ТипИнтерфейса);
		
		СтруктураВызова.Вставить("ПараметрыМетода", ПараметрыМетода);
		
		Результат = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,,АдресаПеременных);	
	#Иначе
		Если РасположениеКомпоненты = "НаСервере" Тогда
			СтруктураВызова = Новый Структура;
			СтруктураВызова.Вставить("ТипМетода", "Функция");
			СтруктураВызова.Вставить("ИмяМетода", "УдалитьГруппыПользователейВSMARTS");	
			
			ПараметрыМетода = Новый Структура;
			ПараметрыМетода.Вставить("ПараметрыГруппы",	ПараметрыГруппы);
			ПараметрыМетода.Вставить("ТипБазы", 		ТипБазы);           
			ПараметрыМетода.Вставить("ТипИнтерфейса", 	ТипИнтерфейса);
			
			СтруктураВызова.Вставить("ПараметрыМетода", ПараметрыМетода);
			
			Результат = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,,АдресаПеременных);	
		Иначе
			Если ТипИнтерфейса = "REST_API" Тогда
				Результат = REST_API_УдалитьГруппыПользователейВSMARTS(ПараметрыГруппы, ТипБазы);
			Иначе
				Результат = КомЯдро_УдалитьГруппыПользователейВSMARTS(ПараметрыГруппы, ТипБазы);	
			КонецЕсли;
		КонецЕсли; 
	#КонецЕсли
	
	Возврат Результат;
	
КонецФункции

&НаКлиенте
Функция ЛокЯдро_ПолучитьМобильныеУстройстваSMARTS() Экспорт
	
	ТипБазы 		= ?(ЕстьЧастнаяБаза, "Частная", "Основная");		
	ТипИнтерфейса 	= ЛокЯдро_ПолучитьТипИнтерфейса(ТипБазы);	    
	
	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода", "Функция");
	СтруктураВызова.Вставить("ИмяМетода", "ПолучитьМобильныеУстройстваSMARTS");	
	
	ПараметрыМетода = Новый Структура;
	ПараметрыМетода.Вставить("ТипБазы", 		ТипБазы);
	ПараметрыМетода.Вставить("ТипИнтерфейса", 	ТипИнтерфейса);
		
	СтруктураВызова.Вставить("ПараметрыМетода", ПараметрыМетода);		
		
	Результат = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,,АдресаПеременных);
	
	Возврат Результат;
	
КонецФункции

&НаСервере
Процедура ЗаполнитьСсылкуНаОбъект()
	
	// Получение версии запущенной обработки
	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода", "Функция");
	СтруктураВызова.Вставить("ИмяМетода", "ПолучитьИнформациюОВнешнейОбработке");
	СтруктураВызова.Вставить("ПараметрыМетода", Новый Структура("КлючИнформации", "Версия"));
	
	ПередаваемыеПараметры = Транзит_ПоместитьЗначениеВХранилищеНаСервере(СтруктураВызова);
	
	АдресРезультата = Транзит_ВызватьГлобальныйМетодНаСервере(ПередаваемыеПараметры);
	ВерсияОО = ПолучитьИзВременногоХранилища(АдресРезультата);
	
	// Поиск осуществляется по части версии, т.к. в справочнике реквизит Версия заполнен по маске х.х.х.х
	// Выбираем самую позднюю обработку с подходящей версией
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	МАКСИМУМ(ИмяСправочника.Ссылка) КАК Ссылка
	|ИЗ
	|	Справочник.ИмяСправочника КАК ИмяСправочника
	|ГДЕ
	|	&Версия ПОДОБНО ""%"" + ИмяСправочника.Версия + ""%""";
	
	#Если Не ТолстыйКлиентОбычноеПриложение Тогда
		ИмяСправочника = "ДополнительныеОтчетыИОбработки";
	#Иначе
		ИмяСправочника = "ВнешниеОбработки";	
	#КонецЕсли
	
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "ИмяСправочника", ИмяСправочника);
	
	Запрос.УстановитьПараметр("ИмяСправочника", ИмяСправочника);
	Запрос.УстановитьПараметр("Версия", 		ВерсияОО);
	Результат = Запрос.Выполнить();
	
	Выборка = Результат.Выбрать();
	
	Если Выборка.Следующий() Тогда
		ОбъектСсылка = Выборка.Ссылка;
	КонецЕсли;
		
КонецПроцедуры

#КонецОбласти

#Область ЛокальныйКонтекст_СправочникиИТаблицы

// Вызывает функции преобразования данных выгружаемой таблицы и выгрузки подготовленной таблицы на сервер Mobile Smarts 
//
// Параметры:
//	ИмяТаблицы - Строка - имя выгружаемой таблицы
//	ТаблицаДляВыгрузкиАдрес - ТаблицаЗначений, Массив из Структура, Структура - данные выгружаемой таблицы
//	ТипБазы - Строка - "Частная", "Временная", "Основная"
//
// Возвращаемое значение:
//	Структура - содержит:
//		* Статус - Булево - признак успешности выгрузки таблицы		
//		* Сообщение - Строка - информационное сообщение о результате выгрузки таблицы
&НаКлиенте
Процедура ЛокЯдро_ВыгрузитьПодготовленнуюТаблицуНаСерверSMARTS(ИмяТаблицы, ТаблицаДляВыгрузкиАдрес, ТипБазы = "Основная") Экспорт
	
	// Проверка на существование таблицы в конфигурации MS
	Если Не (ИмяТаблицы = "Ячейки" Или ИмяТаблицы = "Номенклатура") 
		И СтруктураМетаданных.Свойство("Tables") Тогда
		
		ТаблицыMS = СтруктураМетаданных.Tables;
		ТаблицаНайдена = Ложь;
		Для Каждого Таблица из ТаблицыMS Цикл
			Если Таблица.Представление = ИмяТаблицы Тогда
				ТаблицаНайдена = Истина;
				Прервать;
			КонецЕсли;
		КонецЦикла;
		Если Не ТаблицаНайдена Тогда
			Возврат;
		КонецЕсли;
		
	КонецЕсли;
	
	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода", "Функция");
	
	Если РасположениеКомпоненты = "НаСервере" Тогда
		СтруктураВызова.Вставить("ИмяМетода", "ВыгрузитьПодготовленнуюТаблицуНаСерверSMARTS");
		СтруктураВызова.Вставить("ПараметрыМетода", Новый Структура("ИмяТаблицы", ИмяТаблицы));
		СтруктураВызова.ПараметрыМетода.Вставить("ТаблицаДляВыгрузки", ТаблицаДляВыгрузкиАдрес);
		СтруктураВызова.ПараметрыМетода.Вставить("ТипБазы", ТипБазы);
		РезультатВыгрузки = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,,АдресаПеременных);
	Иначе
		СтруктураВызова.Вставить("ИмяМетода", "СформироватьМассивыДляВыгрузкиТаблиц");
		СтруктураВызова.Вставить("ПараметрыМетода", Новый Структура("ИмяТаблицы,ТаблицаДляВыгрузки,ТипБазы", ИмяТаблицы, ТаблицаДляВыгрузкиАдрес, ТипБазы));
		
		ПереписыватьНоменклатуруПриВыгрузке = ЛокЯдро_ПолучитьИзКэшаНастройкуSMARTS("ПереписыватьНоменклатуруПриВыгрузке");		
		ДанныеДляВыгрузки = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,,АдресаПеременных);
		
		Отбор = Новый Структура("ИмяТаблицы", ИмяТаблицы);
		ОчищатьСправочникПередВыгрузкой = ЛокЯдро_ПолучитьИзКэшаЗначениеТабличнойНастройкиSMARTS("НастройкиОбменаСправочников", Отбор, "ОчищатьПередВыгрузкой");
		Если ИмяТаблицы = "Узлы"
			ИЛИ ИмяТаблицы = "БизнесПроцессы" Тогда
			ОчищатьСправочникПередВыгрузкой = Истина; // Эти таблицы всегда очищаются принудительно
		ИначеЕсли ОчищатьСправочникПередВыгрузкой = Неопределено Тогда
			ОчищатьСправочникПередВыгрузкой = ?(ПереписыватьНоменклатуруПриВыгрузке = Неопределено, Ложь, ПереписыватьНоменклатуруПриВыгрузке);	
		КонецЕсли;		
		
		ТипИнтерфейса = ЛокЯдро_ПолучитьТипИнтерфейса(ТипБазы); // ТипИнтерфейса = КомЯдро_ПолучитьЗначениеПеременной("ТипИнтерфейса");
		Если ТипИнтерфейса = "REST_API" Тогда
			РезультатВыгрузки = REST_API_ВыгрузитьТаблицуНаСерверSMARTS(ИмяТаблицы, ДанныеДляВыгрузки, ТипБазы, ОчищатьСправочникПередВыгрузкой);		
		Иначе
			РезультатВыгрузки = КомЯдро_ВыгрузитьТаблицуНаСерверSMARTS(ТипБазы, ИмяТаблицы, ДанныеДляВыгрузки, ОчищатьСправочникПередВыгрузкой);
		КонецЕсли;		
	КонецЕсли;
	
	Сообщить(РезультатВыгрузки.Сообщение);
	
КонецПроцедуры

// Вызывает функцию выгрузки таблицы на сервер Mobile Smarts для всех справочников, участвующих в интеграции
&НаКлиенте
Процедура ЛокЯдро_ВыгрузитьТаблицыНаСерверSMARTS() Экспорт

	ЗапущенаВыгрузкаТаблицыВФоне = ЛокЯдро_ПроверитьЗапускВыгрузкиТаблицыВФоне();
	Если ЗапущенаВыгрузкаТаблицыВФоне Тогда
		Сообщить("Таблицы уже выгружаются в фоне");
		Возврат;
	КонецЕсли;
	
	МетаданныеНСИ = ЛокЯдро_ПолучитьМетаданныеНСИ();
	
	СписокИспользуемыхСправочников = ЛокЯдро_ПолучитьСписокИспользуемыхСправочников();
	
	//Может вернуться неопределено в случае, если нет интеграционной обработки
	//Попробуем получить ИО снова
	Если  МетаданныеНСИ = Неопределено
		ИЛИ СписокИспользуемыхСправочников = Неопределено Тогда
		
		Если РасположениеКомпоненты = Неопределено Тогда
			РасположениеКомпоненты = ЛокЯдро_ПолучитьДанныеИзХранилища1С("Cleverence_РасположениеКомпоненты");
		КонецЕсли;
		ЛокЯдро_ПодключитьИнтеграционнуюОбработку(РасположениеКомпоненты);
		
		МетаданныеНСИ = ЛокЯдро_ПолучитьМетаданныеНСИ();
		СписокИспользуемыхСправочников = ЛокЯдро_ПолучитьСписокИспользуемыхСправочников();
		Если  МетаданныеНСИ = Неопределено
			ИЛИ СписокИспользуемыхСправочников = Неопределено Тогда
			Возврат;
		КонецЕсли;
		
	КонецЕсли;
	
	АвтотестКлеверенс = КомЯдро_ПолучитьЗначениеПеременной("Автотест");
	Если АвтотестКлеверенс = Неопределено Тогда
		АвтотестКлеверенс = Ложь;
	КонецЕсли;
	
	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ИмяМетода", "СоответствиеСправочниковКлючамИспользованияПоУмолчанию");
	СтруктураВызова.Вставить("ТипМетода", "Функция");
	СоответствиеСправочниковКлючамИспользования = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,,АдресаПеременных);
	
	Для Каждого ИмяСправочника ИЗ СписокИспользуемыхСправочников Цикл
		
		СправочникИмя 				= ИмяСправочника.Значение;
		ПараметрыВыгрузки 			= ЛокЯдро_ПолучитьЗаполнитьСтруктуруПараметровВыгрузкиСправочника(СправочникИмя);
        КлючНастройкиПоУмолчанию 	= СоответствиеСправочниковКлючамИспользования.Получить(СправочникИмя);
		НастройкаВыгружатьСразу 	= ЛокЯдро_ПолучитьИзКэшаНастройкуSMARTS(КлючНастройкиПоУмолчанию); 
		
		Если СправочникИмя = "Номенклатура" Тогда			
			
			Если (НастройкаВыгружатьСразу Или АвтотестКлеверенс) Тогда			
				РазмерПорцииНоменклатуры = ЛокЯдро_ПолучитьИзКэшаНастройкуSMARTS("РазмерПорцииНоменклатуры");
				
				Если РазмерПорцииНоменклатуры <> Ложь И ЗначениеЗаполнено(РазмерПорцииНоменклатуры) Тогда
					ЛокЯдро_ВыгрузитьТаблицуНаСерверSMARTSПорциями("Номенклатура",,,ПараметрыВыгрузки);
				Иначе
					ЛокЯдро_ВыгрузитьТаблицуНаСерверSMARTS("Номенклатура",,,ПараметрыВыгрузки);	
				КонецЕсли;
			КонецЕсли;
			
		ИначеЕсли СправочникИмя = "Характеристики" Тогда 
			
			Если (НастройкаВыгружатьСразу Или АвтотестКлеверенс) И МетаданныеНСИ.Характеристики.Использование Тогда			
				ЛокЯдро_ВыгрузитьТаблицуНаСерверSMARTS("Характеристики",,,ПараметрыВыгрузки);													
			КонецЕсли;
			
		ИначеЕсли СправочникИмя = "ДопРеквизиты" Тогда 
			
			ВыгружатьИнформациюДляЦенниковСразу = ЛокЯдро_ПолучитьИзКэшаНастройкуSMARTS("ВыгружатьИнформациюДляЦенниковСразу");
			Если ВыгружатьИнформациюДляЦенниковСразу = Неопределено Тогда
				ВыгружатьИнформациюДляЦенниковСразу = Ложь;				
			КонецЕсли;
			
			Если (НастройкаВыгружатьСразу ИЛИ ВыгружатьИнформациюДляЦенниковСразу ИЛИ АвтотестКлеверенс) Тогда			
				ЛокЯдро_ВыгрузитьТаблицуНаСерверSMARTS("ДопРеквизиты",,,ПараметрыВыгрузки);					
			КонецЕсли;
			
		ИначеЕсли НастройкаВыгружатьСразу = Истина Или АвтотестКлеверенс Тогда
			
			ЛокЯдро_ВыгрузитьТаблицуНаСерверSMARTS(СправочникИмя,,,ПараметрыВыгрузки);
			
		КонецЕсли;
		
	КонецЦикла;
	
	// Пользовательские настройки выгрузки справочников
	ЗначениеНастройки = ЛокЯдро_ПолучитьИзКэшаНастройкуSMARTS("НастройкиОбменаСправочников");
	Если НЕ ЗначениеНастройки = Ложь И ЗначениеЗаполнено(ЗначениеНастройки) Тогда
		Для Каждого СтрокаНастройки Из ЗначениеНастройки Цикл
			Если СтрокаНастройки.Свойство("КолонкиТаблицыЗначений")
				ИЛИ НЕ СтрокаНастройки.Свойство("Типовой") ИЛИ СтрокаНастройки.Типовой
				ИЛИ НЕ СтрокаНастройки.Свойство("Выгружать") ИЛИ НЕ СтрокаНастройки.Выгружать
				ИЛИ СписокИспользуемыхСправочников.НайтиПоЗначению(СтрокаНастройки.ИмяТаблицы) <> Неопределено Тогда
				Продолжить;
			КонецЕсли;
			
			СправочникИмя 		= СтрокаНастройки.ИмяТаблицы;
			ПараметрыВыгрузки 	= ЛокЯдро_ПолучитьЗаполнитьСтруктуруПараметровВыгрузкиСправочника(СправочникИмя);
			ЛокЯдро_ВыгрузитьТаблицуНаСерверSMARTS(СправочникИмя,,,ПараметрыВыгрузки);
		КонецЦикла;
	КонецЕсли;
	
КонецПроцедуры

// Последовательно вызывает функции получения данных таблицы и выгрузки полученных данных на сервер Mobile Smarts
//
// Параметры:
//	ИмяТаблицы - Строка - имя выгружаемой таблицы
//  НастройкаКомпоновщикаСтрокой - Строка - содержит настройки, установленные для схемы компоновки данных, описанной в интеграционной
//											обработке и используемой для получения данных таблицы при выгрузке на сервер Mobile Smarts
//  ПараметрыКомпоновщика - Неопределено, Булево, Массив из Структура - содержит параметры схемы компоновки данных, описанной в интеграционной 
//																		обработке и используемой для получения данных таблицы при выгрузке на сервер Mobile Smarts
//	ПараметрыВыгрузки - Структура - параметры выгрузки справочника
//
// Возвращаемое значение:
//	Структура - содержит:
//		* Статус - Булево - признак успешности выгрузки таблицы
//		* Сообщение - Строка - информационное сообщение о результате выгрузки таблицы
&НаКлиенте
Процедура ЛокЯдро_ВыгрузитьТаблицуНаСерверSMARTS(ИмяТаблицы, НастройкаКомпоновщикаСтрокой = "", ПараметрыКомпоновщика = Ложь, ПараметрыВыгрузки = Неопределено) Экспорт

	ЗапущенаВыгрузкаТаблицыВФоне = ЛокЯдро_ПроверитьЗапускВыгрузкиТаблицыВФоне(ИмяТаблицы);
	Если ЗапущенаВыгрузкаТаблицыВФоне Тогда
		Сообщить("Таблица [" + ИмяТаблицы + "] уже выгружается в фоне");
		Возврат;
	КонецЕсли;
	
	НачалоВыгрузки = ТекущаяУниверсальнаяДатаВМиллисекундах();
	ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации("ВыгрузкаСправочника.Начало","Информация","ИмяТаблицы="+ИмяТаблицы);	
	
	ВыполняетсяВФоне = ДоступноВыполнениеВФоне;
	
	// Если включено фоновое выполенние, то надо обязательно проверить не пропала ли из кэша переменная ИнтеграционнаяОбработка.ИнтеграционнаяОбработкаДвоичныеДанные
	// В случае обнуления кэша обработку надо переподключить.
	Если ВыполняетсяВФоне = Истина Тогда
		//СтруктураИО = КомЯдро_ПолучитьЗначениеПеременной("ИнтеграционнаяОбработка");
		Если ЛокЯдро_ПроверитьСуществованиеИнтеграционнаяОбработкаДвоичныеДанные() = Ложь Тогда
				РезультатПодключенияИО = ЛокЯдро_ПодключитьИнтеграционнуюОбработку();
				Если РезультатПодключенияИО = Ложь Тогда 
					ВыполняетсяВФоне = Ложь;
					ДоступноВыполнениеВФоне = Ложь;
				КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	Отбор = Новый Структура("ИмяТаблицы", ИмяТаблицы);
	Если НастройкаКомпоновщикаСтрокой = "" Тогда
		НастройкаКомпоновщикаСтрокой = ЛокЯдро_ПолучитьИзКэшаЗначениеТабличнойНастройкиSMARTS("НастройкиОбменаСправочников", Отбор, "НастройкаКомпоновщикаСтрокой");
	КонецЕсли;
	
	Если ПараметрыВыгрузки <> Неопределено И ПараметрыВыгрузки.Свойство("ОчищатьПередВыгрузкой") Тогда
		ОчищатьСправочникПередВыгрузкой = ПараметрыВыгрузки.ОчищатьПередВыгрузкой;		
	Иначе
		ОчищатьСправочникПередВыгрузкой = ЛокЯдро_ПолучитьИзКэшаЗначениеТабличнойНастройкиSMARTS("НастройкиОбменаСправочников", Отбор, "ОчищатьПередВыгрузкой");
    КонецЕсли;	
		
	Если ЗначениеЗаполнено(НастройкаКомпоновщикаСтрокой) Тогда
		НастройкиКомпоновщика = ЛокЯдро_ЗначениеИзСтрокиXML(НастройкаКомпоновщикаСтрокой);
	КонецЕслИ;
	
	Если ПараметрыКомпоновщика = Ложь Тогда
		ПараметрыКомпоновщика = ЛокЯдро_ПолучитьЗначенияГлобальныхПараметров();
	КонецЕсли;
	
	ТипБазы = ?(ЕстьЧастнаяБаза,"Частная","Основная");
	
	ПереписыватьНоменклатуруПриВыгрузке 	= ЛокЯдро_ПолучитьИзКэшаНастройкуSMARTS("ПереписыватьНоменклатуруПриВыгрузке");		
	РаботаБезАлкоголя 						= ЛокЯдро_ПолучитьИзКэшаНастройкуSMARTS("РаботаБезАлкоголя");
	
	Если ИмяТаблицы = "Узлы"
		ИЛИ ИмяТаблицы = "БизнесПроцессы" Тогда // Эти таблицы всегда очищаются принудительно
		ОчищатьСправочникПередВыгрузкой = Истина;
	ИначеЕсли ОчищатьСправочникПередВыгрузкой = Неопределено Тогда
		ОчищатьСправочникПередВыгрузкой = ?(ПереписыватьНоменклатуруПриВыгрузке = Неопределено, Ложь, ПереписыватьНоменклатуруПриВыгрузке);	
	КонецЕсли;
		
	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода", "Функция");
	СтруктураВызова.Вставить("ПараметрыМетода", Новый Структура("ИмяТаблицы", ИмяТаблицы));
	СтруктураВызова.ПараметрыМетода.Вставить("НастройкиКомпоновщика", НастройкиКомпоновщика);
	СтруктураВызова.ПараметрыМетода.Вставить("ПараметрыКомпоновщика", ПараметрыКомпоновщика);
		
	Если РасположениеКомпоненты = "НаСервере" Тогда
		СтруктураВызова.Вставить("ИмяМетода", "ВыгрузитьТаблицуНаСерверSMARTS");
		СтруктураВызова.ПараметрыМетода.Вставить("ТипБазы", ТипБазы);
		СтруктураВызова.ПараметрыМетода.Вставить("ОчищатьСправочникПередВыгрузкой", 	ОчищатьСправочникПередВыгрузкой);		
		СтруктураВызова.ПараметрыМетода.Вставить("РаботаБезАлкоголя", 					РаботаБезАлкоголя);
		СтруктураВызова.ПараметрыМетода.Вставить("ПараметрыВыгрузки", 					ПараметрыВыгрузки);
		
		Если Не ВыполняетсяВФоне Тогда
			РезультатВыгрузки = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,,АдресаПеременных);
			ПодробноеСообщение = РезультатВыгрузки.Сообщение;
		Иначе
			ВыполняетсяВФоне = Истина;
			
			СтруктураВызова.ПараметрыМетода.Вставить("АдресаПеременных", АдресаПеременных);
			
			ТекстСообщения = "Выгрузка таблицы [" + ИмяТаблицы + "] в фоне";
			
			ПараметрыФЗ = Новый Структура;
			ПараметрыФЗ.Вставить("ИмяМетода", 				"ГлЯдро_ВыгрузитьТаблицуНаСерверSMARTSВФоне");
			ПараметрыФЗ.Вставить("ПараметрыМетода", 		СтруктураВызова.ПараметрыМетода);		
			ПараметрыФЗ.Вставить("НаименованиеФЗ",			ТекстСообщения);
			ПараметрыФЗ.Вставить("ТекстСообщения", 			ТекстСообщения);
			ПараметрыФЗ.Вставить("ВыводитьОкноОжидания", 	Ложь);
						
			ДополнительныеПараметры = Новый Структура;
			ДополнительныеПараметры.Вставить("ИмяТаблицы", 		ИмяТаблицы);
			ДополнительныеПараметры.Вставить("НачалоВыгрузки", 	НачалоВыгрузки);
			ОписаниеОповещенияЗавершенияФЗ 	= Новый ОписаниеОповещения("ЛокЯдро_ВыгрузитьТаблицуНаСерверSMARTSВФонеЗавершение", ЭтаФорма, ДополнительныеПараметры);
			ОписаниеОповещенияОшибкиФЗ 		= Новый ОписаниеОповещения("ЛокЯдро_ОбработатьОшибкиВыгрузкиТаблицыВФоне", ЭтаФорма, ДополнительныеПараметры);
			
			Сообщить(ТекстСообщения);
			СписокТаблицВыгружаемыхВФоне.Добавить(ИмяТаблицы);
			
			ЛокЯдро_НачатьВыполнениеФоновогоЗадания(ПараметрыФЗ, ОписаниеОповещенияЗавершенияФЗ, ОписаниеОповещенияОшибкиФЗ);
		КонецЕсли;
	Иначе
		ВыполняетсяВФоне = Ложь;
		
		СтруктураВызова.Вставить("ИмяМетода", "ПолучитьМассивыТаблицыДляВыгрузкиНаСерверSMARTS");
		СтруктураВызова.ПараметрыМетода.Вставить("РаботаБезАлкоголя", 	РаботаБезАлкоголя);
		СтруктураВызова.ПараметрыМетода.Вставить("ПараметрыВыгрузки", 	ПараметрыВыгрузки);
		СтруктураВызова.ПараметрыМетода.Вставить("ТипБазы", 			ТипБазы);
		
		// *****************************************************************************************************************************
		
		НачалоПолученияДанныхИз1С 		= ТекущаяДата();
		
		ДанныеДляВыгрузки 				= Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,,АдресаПеременных);			
		
		Если ДанныеДляВыгрузки = Неопределено Тогда
			Сообщить("Не удалось получить данные для выгрузки таблицы ["+ИмяТаблицы+"]. Подробности смотрите в журнале регистрации");
			Возврат;
		КонецЕсли;
		
		ОкончаниеПолученияДанныхИз1С 	= ТекущаяДата();
		ВремяПолученияДанныхИз1С 		= ОкончаниеПолученияДанныхИз1С - НачалоПолученияДанныхИз1С;
		
		// *****************************************************************************************************************************
		
		НачалоВыгрузкиДанныхНаСерверSMARTS 		= ТекущаяДата();
		ТипИнтерфейса = ЛокЯдро_ПолучитьТипИнтерфейса(?(ЕстьЧастнаяБаза, "Частная", "Основная")); // ТипИнтерфейса = КомЯдро_ПолучитьЗначениеПеременной("ТипИнтерфейса");
		Если ТипИнтерфейса = "REST_API" Тогда
			РезультатВыгрузки = REST_API_ВыгрузитьТаблицуНаСерверSMARTS(ИмяТаблицы, ДанныеДляВыгрузки, ?(ЕстьЧастнаяБаза,"Частная","Основная"), ОчищатьСправочникПередВыгрузкой);		
		Иначе
			РезультатВыгрузки = КомЯдро_ВыгрузитьТаблицуНаСерверSMARTS(?(ЕстьЧастнаяБаза,"Частная","Основная"), ИмяТаблицы, ДанныеДляВыгрузки, ОчищатьСправочникПередВыгрузкой);
		КонецЕсли;
		
		ОкончаниеВыгрузкиДанныхНаСерверSMARTS 	= ТекущаяДата();
		ВремяВыгрузкиДанныхНаСерверSMARTS		= ОкончаниеВыгрузкиДанныхНаСерверSMARTS - НачалоВыгрузкиДанныхНаСерверSMARTS;
		
		ОбщееВремяВыгрузки						= ВремяПолученияДанныхИз1С + ВремяВыгрузкиДанныхНаСерверSMARTS; 
		
		// *****************************************************************************************************************************
		
		ПодробноеСообщение = РезультатВыгрузки.Сообщение;
		
		// Если выгрузка прошла успешно, добавляем в сообщение дополнительную информацию о выгрузке
		Если РезультатВыгрузки.Статус Тогда									
			
			ПредставлениеВремени1С 		= ЛокЯдро_ПредставлениеВремени(ВремяПолученияДанныхИз1С);
			ПредставлениеВремениMS 		= ЛокЯдро_ПредставлениеВремени(ВремяВыгрузкиДанныхНаСерверSMARTS);
			ПредставлениеВремениОбщее 	= ЛокЯдро_ПредставлениеВремени(ОбщееВремяВыгрузки);			
			
			ПодробноеСообщение = ЛокЯдро_СформироватьПодробноеСообщениеОВыгрузкеТаблицы(ПодробноеСообщение, ПредставлениеВремениОбщее, ПредставлениеВремени1С, ПредставлениеВремениMS);
			
		КонецЕсли;			
		
	КонецЕсли;		
	
	Если Не ВыполняетсяВФоне Тогда
		СтруктураПараметров = Новый Структура;
		СтруктураПараметров.Вставить("РезультатВыгрузки", 	РезультатВыгрузки);
		СтруктураПараметров.Вставить("ПодробноеСообщение", 	ПодробноеСообщение);
		СтруктураПараметров.Вставить("ИмяТаблицы", 			ИмяТаблицы);
		СтруктураПараметров.Вставить("НачалоВыгрузки", 		НачалоВыгрузки);
		
		ЛокЯдро_ВыгрузитьТаблицуНаСерверSMARTSЗавершение(СтруктураПараметров);
	КонецЕсли;
	
КонецПроцедуры

// Выгружает на сервер Mobile SMARTS данные таблицы порциями. Работает только для справочника "Номенклатура"
// Некорректен с точки зрения инкапсуляции - в одном методе смешался функционал получения данных из базы 1С и функционал выгрузки данных в Mobile SMARTS
// Это вынужденная реализация, потому что методы "TerminalConnector.НачатьВыгрузкуТоваров()" и "TerminalConnector.ЗавершитьВыгрузкуТоваров()"
// можно вызывать только по 1 разу во время всего процесса выгрузки справочника номенклатуры
//
// Параметры:
//	ИмяТаблицы - Строка - имя выгружаемой таблицы
//	НастройкиКомпоновщика - Неопределено, Булево, НастройкиКомпоновкиДанных - содержит настройки, установленные для схемы компоновки данных, описанной в интеграционной
//															          		  обработке и используемой для получения данных таблицы при выгрузке на сервер Mobile Smarts
//  ПараметрыКомпоновщика - Неопределено, Булево, Массив из Структура - содержит параметры схемы компоновки данных, описанной в интеграционной 
//																		обработке и используемой для получения данных таблицы при выгрузке на сервер Mobile Smarts
//	ПараметрыВыгрузки - Структура - параметры выгрузки справочника
//
// Возвращаемое значение:
//	Структура - содержит:
//		* Статус - Булево - признак успешности выгрузки таблицы
//		* Сообщение - Строка - информационное сообщение о результате выгрузки таблицы
&НаКлиенте
Процедура ЛокЯдро_ВыгрузитьТаблицуНаСерверSMARTSПорциями(ИмяТаблицы, НастройкиКомпоновщика = "", ПараметрыКомпоновщика = Ложь, ПараметрыВыгрузки = Неопределено) Экспорт
	
	ЗапущенаВыгрузкаТаблицыВФоне = ЛокЯдро_ПроверитьЗапускВыгрузкиТаблицыВФоне(ИмяТаблицы);
	Если ЗапущенаВыгрузкаТаблицыВФоне Тогда
		Сообщить("Таблица [" + ИмяТаблицы + "] уже выгружается в фоне");
		Возврат;
	КонецЕсли;
	
	Отбор = Новый Структура("ИмяТаблицы", ИмяТаблицы);
	Если НастройкиКомпоновщика = "" Тогда
		НастройкаКомпоновщикаСтрокой = ЛокЯдро_ПолучитьИзКэшаЗначениеТабличнойНастройкиSMARTS("НастройкиОбменаСправочников", Отбор, "НастройкаКомпоновщикаСтрокой");
		Если ЗначениеЗаполнено(НастройкаКомпоновщикаСтрокой) Тогда
			НастройкиКомпоновщика = ЛокЯдро_ЗначениеИзСтрокиXML(НастройкаКомпоновщикаСтрокой);
		КонецЕслИ;
	КонецЕсли;
	
	Если ПараметрыВыгрузки <> Неопределено И ПараметрыВыгрузки.Свойство("ОчищатьПередВыгрузкой") Тогда
		ОчищатьСправочникПередВыгрузкой = ПараметрыВыгрузки.ОчищатьПередВыгрузкой;		
	Иначе
		ОчищатьСправочникПередВыгрузкой = ЛокЯдро_ПолучитьИзКэшаЗначениеТабличнойНастройкиSMARTS("НастройкиОбменаСправочников", Отбор, "ОчищатьПередВыгрузкой");
	КонецЕсли;
	
	Если ПараметрыКомпоновщика = Ложь Тогда
		ПараметрыКомпоновщика = ЛокЯдро_ПолучитьЗначенияГлобальныхПараметров();
	КонецЕсли;
	
	РазмерПорцииНоменклатуры = ЛокЯдро_ПолучитьИзКэшаНастройкуSMARTS("РазмерПорцииНоменклатуры");
	Если РазмерПорцииНоменклатуры = Ложь ИЛИ НЕ ЗначениеЗаполнено(РазмерПорцииНоменклатуры) Тогда
		РазмерПорцииНоменклатуры = 1000;
	КонецЕсли;
	
	ТипБазы = ?(ЕстьЧастнаяБаза,"Частная","Основная");
	
	ПереписыватьНоменклатуруПриВыгрузке = ЛокЯдро_ПолучитьИзКэшаНастройкуSMARTS("ПереписыватьНоменклатуруПриВыгрузке");
	РаботаБезАлкоголя 					= ЛокЯдро_ПолучитьИзКэшаНастройкуSMARTS("РаботаБезАлкоголя");		

	Если ИмяТаблицы = "Узлы"
		ИЛИ ИмяТаблицы = "БизнесПроцессы" Тогда
		ОчищатьСправочникПередВыгрузкой = Истина;	
	ИначеЕсли ОчищатьСправочникПередВыгрузкой = Неопределено Тогда
		ОчищатьСправочникПередВыгрузкой = ?(ПереписыватьНоменклатуруПриВыгрузке = Неопределено, Ложь, ПереписыватьНоменклатуруПриВыгрузке);
	КонецЕсли;
	
	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода", "Функция");
	СтруктураВызова.Вставить("ПараметрыМетода", Новый Структура("ИмяТаблицы", ИмяТаблицы));
	СтруктураВызова.ПараметрыМетода.Вставить("НастройкиКомпоновщика", НастройкиКомпоновщика);
	СтруктураВызова.ПараметрыМетода.Вставить("ПараметрыКомпоновщика", ПараметрыКомпоновщика);
	СтруктураВызова.ПараметрыМетода.Вставить("ТипБазы", ТипБазы);	
	
	Если РасположениеКомпоненты = "НаСервере" Тогда
		СтруктураВызова.ПараметрыМетода.Вставить("ОчищатьСправочникПередВыгрузкой",		ОчищатьСправочникПередВыгрузкой);
		СтруктураВызова.ПараметрыМетода.Вставить("РазмерПорцииНоменклатуры", 			РазмерПорцииНоменклатуры);
		СтруктураВызова.ПараметрыМетода.Вставить("РаботаБезАлкоголя", 					РаботаБезАлкоголя);
		СтруктураВызова.ПараметрыМетода.Вставить("ПараметрыВыгрузки", 					ПараметрыВыгрузки);
		СтруктураВызова.Вставить("ИмяМетода", "ВыгрузитьТаблицуНаСерверSMARTSПорциями");
		
		Если Не ДоступноВыполнениеВФоне Тогда	
			РезультатВыгрузки = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,,АдресаПеременных);
			Сообщить(РезультатВыгрузки.Сообщение);
		Иначе
			СтруктураВызова.ПараметрыМетода.Вставить("АдресаПеременных", АдресаПеременных);
			
			ТекстСообщения = "Начало выгрузки таблицы [" + ИмяТаблицы + "] порциями в фоне";
			
			ПараметрыФЗ = Новый Структура;
			ПараметрыФЗ.Вставить("ИмяМетода", 				"ГлЯдро_ВыгрузитьТаблицуНаСерверSMARTSПорциямиВФоне");
			ПараметрыФЗ.Вставить("ПараметрыМетода", 		СтруктураВызова.ПараметрыМетода);		
			ПараметрыФЗ.Вставить("НаименованиеФЗ",			ТекстСообщения);
			ПараметрыФЗ.Вставить("ТекстСообщения", 			ТекстСообщения);
			ПараметрыФЗ.Вставить("ВыводитьОкноОжидания", 	Ложь);
			
			ДополнительныеПараметры = Новый Структура;
			ДополнительныеПараметры.Вставить("ИмяТаблицы", 		ИмяТаблицы);
			ОписаниеОповещенияЗавершенияФЗ 	= Новый ОписаниеОповещения("ЛокЯдро_ВыгрузитьТаблицуНаСерверSMARTSПорциямиВФонеЗавершение", ЭтаФорма, ДополнительныеПараметры);
			ОписаниеОповещенияОшибкиФЗ 		= Новый ОписаниеОповещения("ЛокЯдро_ОбработатьОшибкиВыгрузкиТаблицыВФоне", ЭтаФорма);
			
			Сообщить(ТекстСообщения);
			СписокТаблицВыгружаемыхВФоне.Добавить(ИмяТаблицы);
			
			ЛокЯдро_НачатьВыполнениеФоновогоЗадания(ПараметрыФЗ, ОписаниеОповещенияЗавершенияФЗ, ОписаниеОповещенияОшибкиФЗ);

		КонецЕсли;
	Иначе									
	
		РезультатВыгрузки = Новый Структура;
		Сообщение = "Начало выгрузки таблицы [" + ИмяТаблицы + "] порциями";
		РезультатВыгрузки.Вставить("Сообщение"	, Сообщение);
		РезультатВыгрузки.Вставить("Статус"		, Истина);	
		Сообщить(Сообщение);
		
		ТипИнтерфейса = ЛокЯдро_ПолучитьТипИнтерфейса(ТипБазы); // ТипИнтерфейса = КомЯдро_ПолучитьЗначениеПеременной("ТипИнтерфейса");
		ЭтоREST_API = ТипИнтерфейса = "REST_API";
		
		Если Не ЭтоREST_API Тогда
			Если НЕ КомЯдро_ПодключитьсяКСерверуSMARTS(Ложь,ТипБазы) Тогда		
				
				Сообщение = "База Mobile SMARTS недоступна!";
				РезультатВыгрузки.Вставить("Статус"		, Ложь);				
				РезультатВыгрузки.Вставить("Сообщение"	, Сообщение);
				Сообщить(Сообщение);
				Возврат;		
				
			КонецЕсли;
		КонецЕсли;
		
		МассивСсылокНоменклатуры 			= ЛокЯдро_ПолучитьМассивСсылокНоменклатуры();		
		
		КоличествоСтрок 					= МассивСсылокНоменклатуры.Количество();
		КоличествоПорций 					= (КоличествоСтрок - КоличествоСтрок % РазмерПорцииНоменклатуры) / РазмерПорцииНоменклатуры + ?(КоличествоСтрок % РазмерПорцииНоменклатуры <> 0, 1, 0);							
		
		ВсегоСтрок 							= 0;
		ОтборПоНоменклатуре 				= Новый Массив;
		НачатаВыгрузкаТаблицы 				= Ложь;
		ВремяПолученияДанныхИз1С			= 0;
		ВремяВыгрузкиДанныхНаСерверSMARTS 	= 0;		
		СоответствиеРазличныхТоваров		= Новый Соответствие;
		ИндексИдТовара						= -1;		
		
		СтруктураВызова.ПараметрыМетода.Вставить("ОтборПоНоменклатуре", ОтборПоНоменклатуре);
		СтруктураВызова.ПараметрыМетода.Вставить("РаботаБезАлкоголя", 	РаботаБезАлкоголя);
		СтруктураВызова.ПараметрыМетода.Вставить("ПараметрыВыгрузки", 	ПараметрыВыгрузки);
		СтруктураВызова.ПараметрыМетода.Вставить("ID_БазыSMARTS", 		"");
		СтруктураВызова.Вставить("ИмяМетода", "ПолучитьПорциюДанныхДляВыгрузки");
		
		Для НомерПорции = 1 По КоличествоПорций Цикл				
			
			НачалоВыгрузкиПорции 		= ТекущаяДата();
			НачалоПолученияДанныхИз1С 	= ТекущаяДата();
			
			ОтборПоНоменклатуре.Очистить();
			
			Для Сч = 1 По РазмерПорцииНоменклатуры Цикл
				
				ИндексСтроки = (НомерПорции - 1) * РазмерПорцииНоменклатуры + Сч - 1;
				
				Если ИндексСтроки > КоличествоСтрок - 1 Тогда
					Прервать;
				КонецЕсли;	
				
				ОтборПоНоменклатуре.Добавить(МассивСсылокНоменклатуры[ИндексСтроки]);
				
			КонецЦикла;							
			
			ДанныеДляВыгрузки = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,,АдресаПеременных);			
			
			ОкончаниеПолученияДанныхИз1С 	= ТекущаяДата();
			ВремяПолученияДанныхИз1С 		= ВремяПолученияДанныхИз1С + (ОкончаниеПолученияДанныхИз1С - НачалоПолученияДанныхИз1С);			
			
			НачалоВыгрузкиДанныхНаСерверSMARTS = ТекущаяДата();
			
			КоличествоСтрокВПорции = ДанныеДляВыгрузки.МассивыСтрок.Количество();			
			
			// Если данных в порции нет, то и выгружать нечего
			Если КоличествоСтрокВПорции = 0 Тогда
				Продолжить;
			КонецЕсли;
			
			// Для того чтобы искать индекс только один раз, а не на каждой итерации
			Если ИмяТаблицы = "Номенклатура" И ИндексИдТовара = -1 Тогда
				ИндексИдТовара = ЛокЯдро_НайтиИндексИдТовараВМассивеИмен(ДанныеДляВыгрузки.МассивИмен);
			КонецЕсли;	
			
			// Если выгружается первая порция (до этого не было порций с данными), содержащая ненулевое количество строк, то используем флаг из настроек, иначе - дописываем номенклатуру
			ОчищатьСправочникПередВыгрузкой = ?(ВсегоСтрок = 0 И КоличествоСтрокВПорции > 0, ОчищатьСправочникПередВыгрузкой, Ложь);
			
			Если ЭтоREST_API Тогда
				РезультатВыгрузкиПорции = REST_API_ВыгрузитьТаблицуНаСерверSMARTS(ИмяТаблицы, ДанныеДляВыгрузки, ?(ЕстьЧастнаяБаза, "Частная", "Основная"), ОчищатьСправочникПередВыгрузкой);
				
				Если Не РезультатВыгрузкиПорции.Статус Тогда
					Сообщить(РезультатВыгрузкиПорции.Сообщение);
					РезультатВыгрузки.Вставить("Сообщение", РезультатВыгрузкиПорции.Сообщение);
					РезультатВыгрузки.Вставить("Статус", Ложь);					
					Прервать;
				КонецЕсли;
				
			Иначе
				
				// При получении из 1С первой непустой порции данных вызываем соответствующий метод для начала выгрузки таблицы
				Если НЕ НачатаВыгрузкаТаблицы Тогда
					
					Если ЕстьЧастнаяБаза Тогда
						СтруктураПодключенияMS = COMЧастнойБазыMS;
					Иначе
						СтруктураПодключенияMS = COMБазыMS;
					КонецЕсли;
					
					Если ИмяТаблицы = "Номенклатура" Тогда
						СтруктураПодключенияMS.TerminalConnector.ПерезаписыватьНоменклатуру(ОчищатьСправочникПередВыгрузкой);
						РезультатПопытки = СтруктураПодключенияMS.TerminalConnector.НачатьВыгрузкуТоваров(ДанныеДляВыгрузки.МассивИмен);
					Иначе
						РезультатПопытки = СтруктураПодключенияMS.TerminalConnector.НачатьВыгрузкуТаблицы(ИмяТаблицы, ДанныеДляВыгрузки.МассивИмен, Истина);
					КонецЕсли;
					
					Если НЕ РезультатПопытки Тогда
						
						ОписаниеОшибки = КомЯдро_ПолучитьОшибку(ТипБазы);		
						Сообщение = "Таблица [" + ИмяТаблицы + "] не выгружается!" + Символы.ВК + ОписаниеОшибки;
						РезультатВыгрузки.Вставить("Статус"		, Ложь);				
						РезультатВыгрузки.Вставить("Сообщение"	, Сообщение);
						Сообщить(Сообщение);					
						Возврат;
						
					Иначе
						НачатаВыгрузкаТаблицы = РезультатПопытки; 
					КонецЕсли;		
					
				КонецЕсли;
				
				Если РезультатВыгрузки.Статус Тогда
					
					Для Каждого МассивСтрокиВыгрузки из ДанныеДляВыгрузки.МассивыСтрок Цикл
						
						Если ИмяТаблицы = "Номенклатура" Тогда
							РезультатПопытки = СтруктураПодключенияMS.TerminalConnector.ДобавитьВВыгрузкуТоваров(МассивСтрокиВыгрузки);
							// Подсчет количества различных товаров в выгрузке
							Если ИндексИдТовара <> -1 Тогда
								СоответствиеРазличныхТоваров.Вставить(МассивСтрокиВыгрузки[ИндексИдТовара]);
							КонецЕсли;						
						Иначе
							РезультатПопытки = СтруктураПодключенияMS.TerminalConnector.ДобавитьВВыгрузкуТаблицы(МассивСтрокиВыгрузки);
						КонецЕсли;
						
						Если НЕ РезультатПопытки Тогда
							
							ОписаниеОшибки = КомЯдро_ПолучитьОшибку(ТипБазы);		
							Сообщение = "Ошибка выгрузки таблицы [" + ИмяТаблицы + "]." + Символы.ВК + ОписаниеОшибки;
							РезультатВыгрузки.Вставить("Статус"		, Ложь);				
							РезультатВыгрузки.Вставить("Сообщение"	, Сообщение);
							Сообщить(Сообщение);																	
							СтруктураПодключенияMS.TerminalConnector.ПрерватьВыгрузкуТаблицы();			
							Прервать;
							
						КонецЕсли;
						
					КонецЦикла;
					
				КонецЕсли;		
			КонецЕсли;
			
			ВсегоСтрок = ВсегоСтрок + КоличествоСтрокВПорции;										

			ОкончаниеВыгрузкиДанныхНаСерверSMARTS 	= ТекущаяДата();
			ВремяВыгрузкиДанныхНаСерверSMARTS		= ВремяВыгрузкиДанныхНаСерверSMARTS + (ОкончаниеВыгрузкиДанныхНаСерверSMARTS - НачалоВыгрузкиДанныхНаСерверSMARTS);			
			
			ОкончаниеВыгрузкиПорции = ТекущаяДата();
			ВремяВыгрузкиПорции		= ОкончаниеВыгрузкиПорции - НачалоВыгрузкиПорции;			
			
			ПредставлениеВремениВыгрузки = ЛокЯдро_ПредставлениеВремени(ВремяВыгрузкиПорции);
			
			Сообщить("Выгрузка таблицы [" + ИмяТаблицы + "] порциями. Выгружена порция №" + СокрЛП(НомерПорции) + " из " + СокрЛП(КоличествоПорций) + ", содержащая " + СокрЛП(КоличествоСтрокВПорции) + " строк. Всего выгружено " + СокрЛП(ВсегоСтрок) + " строк. Затраченное время: " + ПредставлениеВремениВыгрузки);		
			
		КонецЦикла;			
		
		Если РезультатВыгрузки.Статус Тогда
			
			НачалоЗавершенияВыгрузкиНаСерверSMARTS = ТекущаяДата();
			
			Если Не ЭтоREST_API Тогда
				Если ИмяТаблицы = "Номенклатура" Тогда
					РезультатПопытки = СтруктураПодключенияMS.TerminalConnector.ЗавершитьВыгрузкуТоваров();	
				Иначе
					РезультатПопытки = СтруктураПодключенияMS.TerminalConnector.ЗавершитьВыгрузкуТаблицы();	
				КонецЕсли;
				
				Если НЕ РезультатПопытки Тогда
					ОписаниеОшибки = КомЯдро_ПолучитьОшибку(ТипБазы);		
					Сообщение = "Не удалось закончить выгрузку таблицы [" + ИмяТаблицы + "]." + Символы.ВК + ОписаниеОшибки;
					РезультатВыгрузки.Вставить("Статус"		, Ложь);				
					РезультатВыгрузки.Вставить("Сообщение"	, Сообщение);
					Сообщить(Сообщение);										
				КонецЕсли;
			Иначе
				РезультатПопытки = Истина;
			КонецЕсли;
			
			Если РезультатПопытки Тогда
				
				ОкончаниеЗавершенияВыгрузкиНаСерверSMARTS 	= ТекущаяДата();
				ВремяЗавершенияВыгрузкиНаСерверSMARTS		= ОкончаниеЗавершенияВыгрузкиНаСерверSMARTS - НачалоЗавершенияВыгрузкиНаСерверSMARTS;
				
				ВремяВыгрузкиДанныхНаСерверSMARTS 			= ВремяВыгрузкиДанныхНаСерверSMARTS + ВремяЗавершенияВыгрузкиНаСерверSMARTS;
				
				ПредставлениеВремениЗавершенияВыгрузкиНаСерверSMARTS = ЛокЯдро_ПредставлениеВремени(ВремяЗавершенияВыгрузкиНаСерверSMARTS);
				
				Сообщить("Завершение выгрузки таблицы [" + ИмяТаблицы + "] порциями. Затраченное время: " + ПредставлениеВремениЗавершенияВыгрузкиНаСерверSMARTS);		
				
				ПодробноеСообщение = Символы.ВК + "Таблица [" + ИмяТаблицы + "] успешно выгружена порциями по " + СокрЛП(РазмерПорцииНоменклатуры) + " позиций. Выгружено:"
				+ Символы.ВК + Символы.Таб + "- " + Формат(ВсегоСтрок, "ЧН=0; ЧГ=3,0") + " строк";
				
				Если ИмяТаблицы = "Номенклатура" Тогда																					
					ПодробноеСообщение = ПодробноеСообщение 
					+ Символы.ВК + Символы.Таб + "- " + Формат(СоответствиеРазличныхТоваров.Количество(), "ЧН=0; ЧГ=3,0") + " товаров";
				КонецЕсли;																				
				
				ОбщееВремяВыгрузки 			= ВремяПолученияДанныхИз1С + ВремяВыгрузкиДанныхНаСерверSMARTS; 				
				
				ПредставлениеВремени1С 		= ЛокЯдро_ПредставлениеВремени(ВремяПолученияДанныхИз1С);
				ПредставлениеВремениMS 		= ЛокЯдро_ПредставлениеВремени(ВремяВыгрузкиДанныхНаСерверSMARTS);
				ПредставлениеВремениОбщее 	= ЛокЯдро_ПредставлениеВремени(ОбщееВремяВыгрузки);			
				
				ПодробноеСообщение = ЛокЯдро_СформироватьПодробноеСообщениеОВыгрузкеТаблицы(ПодробноеСообщение, ПредставлениеВремениОбщее, ПредставлениеВремени1С, ПредставлениеВремениMS);				
				
				РезультатВыгрузки.Вставить("Статус"		, Истина);				
				РезультатВыгрузки.Вставить("Сообщение"	, ПодробноеСообщение);
				Сообщить(ПодробноеСообщение);
			КонецЕсли;
			
		КонецЕсли;	
		
		Если Не ЭтоREST_API Тогда
			СтруктураПодключенияMS.TerminalConnector.ОсвободитьРесурсы();
		КонецЕсли;
		
	КонецЕсли;	
	
КонецПроцедуры

&НаКлиенте
Функция ЛокЯдро_ПолучитьМассивСсылокНоменклатуры()
	
	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода", "Функция");
	СтруктураВызова.Вставить("ИмяМетода", "ПолучитьМассивСсылокНоменклатуры");	
	РезультатВыгрузки = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,,АдресаПеременных);	
	
	Возврат РезультатВыгрузки;
	
КонецФункции	

// Вызывает функцию очистки таблицы на сервере Mobile Smarts для всех справочников, участвующих в интеграции
&НаКлиенте
Процедура ЛокЯдро_ОчиститьВсеСправочники() Экспорт
	МетаданныеНСИ = ЛокЯдро_ПолучитьМетаданныеНСИ();
	
	СписокИспользуемыхСправочников = ЛокЯдро_ПолучитьСписокИспользуемыхСправочников();
	
	//Может вернуться неопределено в случае, если нет интеграционной обработки
	//Попробуем получить ИО снова
	Если  МетаданныеНСИ = Неопределено
		ИЛИ СписокИспользуемыхСправочников = Неопределено Тогда
		
		Если РасположениеКомпоненты = Неопределено Тогда
			РасположениеКомпоненты = ЛокЯдро_ПолучитьДанныеИзХранилища1С("Cleverence_РасположениеКомпоненты");
		КонецЕсли;
		ЛокЯдро_ПодключитьИнтеграционнуюОбработку(РасположениеКомпоненты);
		
		МетаданныеНСИ = ЛокЯдро_ПолучитьМетаданныеНСИ();
		СписокИспользуемыхСправочников = ЛокЯдро_ПолучитьСписокИспользуемыхСправочников();
		Если  МетаданныеНСИ = Неопределено
			ИЛИ СписокИспользуемыхСправочников = Неопределено Тогда
			Возврат;
		КонецЕсли;
		
	КонецЕсли;		
	
	Для Каждого ИмяСправочника ИЗ СписокИспользуемыхСправочников Цикл	
		ЛокЯдро_ОчиститьТаблицуНаСервереSMARTS(ИмяСправочника.Значение);	
	КонецЦикла;
	
КонецПроцедуры

// Вызывает функцию очистки данных из таблицы на сервере Mobile Smarts
//
// Параметры:
//	ИмяТаблицы - Строка - имя выгружаемой таблицы	
//
// Возвращаемое значение:
//  Структура - содержит:
//		* Статус - Булево - признак успешности очистки таблицы
//		* Сообщение - Строка - информационное сообщение о результате очистки таблицы
&НаКлиенте
Процедура ЛокЯдро_ОчиститьТаблицуНаСервереSMARTS(ИмяТаблицы) Экспорт
	НачалоОчистки = ТекущаяУниверсальнаяДатаВМиллисекундах();
	ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации("ОчисткаСправочника.Начало","Информация","ИмяТаблицы="+ИмяТаблицы);
	
	Если РасположениеКомпоненты = "НаСервере" Тогда
		СтруктураВызова = Новый Структура;
		СтруктураВызова.Вставить("ТипМетода", "Функция");
		СтруктураВызова.Вставить("ИмяМетода", "ОчиститьТаблицуНаСервереSMARTS");
		СтруктураВызова.Вставить("ПараметрыМетода", Новый Структура("ИмяТаблицы,ТипБазы", ИмяТаблицы, ?(ЕстьЧастнаяБаза,"Частная","Основная")));
		РезультатВыгрузки = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,,АдресаПеременных);	
	Иначе
		ТипИнтерфейса = ЛокЯдро_ПолучитьТипИнтерфейса(?(ЕстьЧастнаяБаза, "Частная", "Основная")); // ТипИнтерфейса = КомЯдро_ПолучитьЗначениеПеременной("ТипИнтерфейса");
		Если ТипИнтерфейса = "REST_API" Тогда
			РезультатВыгрузки = REST_API_ОчиститьТаблицуНаСервереSMARTS(ИмяТаблицы, ?(ЕстьЧастнаяБаза,"Частная","Основная"));
		Иначе
			РезультатВыгрузки = КомЯдро_ОчиститьТаблицуНаСервереSMARTS(ИмяТаблицы, ?(ЕстьЧастнаяБаза,"Частная","Основная"));
		КонецЕсли;
		Сообщить(РезультатВыгрузки.Сообщение);
	КонецЕсли;		
	
	ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации("ОчисткаСправочника.Конец","Информация","ИмяТаблицы="+ИмяТаблицы,НачалоОчистки);
КонецПроцедуры

// Вызывает из модуля обработки функцию получения схемы компоновки данных, используемой для выгрузки таблицы на сервер Mobile Smarts.
// Устанавливает параметры полученной схемы компоновки данных.
//
// Параметры:
//	ИмяТаблицы - Строка - имя выгружаемой таблицы
//	ПараметрыВыгрузки - Структура - параметры выгрузки справочника
//
// Возвращаемое значение:
//	- СхемаКомпоновкиДанных - схема компоновки данных для выгрузки таблицы на сервер Mobile Smarts
//  - Неопределено - если не удалось получить интеграционную обработку
&НаКлиенте
Функция ЛокЯдро_ПолучитьСхемуСКДДляВыгрузкиСправочников(ИмяТаблицы, ПараметрыВыгрузки = Неопределено) Экспорт
	
	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода", "Функция");
	СтруктураВызова.Вставить("ИмяМетода", "ПолучитьСхемуСКДДляВыгрузкиСправочников");
	ПараметрыКомпоновщика = ЛокЯдро_ПолучитьЗначенияГлобальныхПараметров();
	ПараметрыМетода = Новый Структура;
	ПараметрыМетода.Вставить("ИмяТаблицы", ИмяТаблицы);
	ПараметрыМетода.Вставить("ПараметрыКомпоновщика", ПараметрыКомпоновщика);
	ПараметрыПолученияМакета = Новый Структура("РаботаБезАлкоголя, ПараметрыОнлайн", ЛокЯдро_ПолучитьИзКэшаНастройкуSMARTS("РаботаБезАлкоголя"));
	ПараметрыМетода.Вставить("ПараметрыПолученияМакета", ПараметрыПолученияМакета);	
	ПараметрыМетода.Вставить("ПараметрыВыгрузки", ПараметрыВыгрузки);	
	СтруктураВызова.Вставить("ПараметрыМетода", ПараметрыМетода);
	
	СхемаСКД = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова, Истина,АдресаПеременных);	
	
	//Может вернуться неопределено в случае, если нет интеграционной обработки
	//Попробуем получить ИО снова
	Если СхемаСКД = Неопределено Тогда
		Если РасположениеКомпоненты = Неопределено Тогда
			РасположениеКомпоненты = ЛокЯдро_ПолучитьДанныеИзХранилища1С("Cleverence_РасположениеКомпоненты");
		КонецЕсли;
		ЛокЯдро_ПодключитьИнтеграционнуюОбработку(РасположениеКомпоненты);
		СхемаСКД = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова, Истина);
	КонецЕсли;
	
	Возврат СхемаСКД;
	
КонецФункции

// Вызывает функцию получения запроса для выгрузки таблицы на сервер Mobile Smarts, выполняет его и обрабатывает полученную таблицу значений
//
// Параметры:
//	ИмяТаблицы - Строка - имя выгружаемой таблицы	
//  НастройкиКомпоновщика - Неопределено, Булево, НастройкиКомпоновкиДанных - содержит настройки, установленные для схемы компоновки данных, описанной в интеграционной
//															          		  обработке и используемой для получения данных таблицы при выгрузке на сервер Mobile Smarts
//  ПараметрыКомпоновщика - Неопределено, Булево, Массив из Структура - содержит параметры схемы компоновки данных, описанной в интеграционной 
//																		обработке и используемой для получения данных таблицы при выгрузке на сервер Mobile Smarts
//	ПараметрыВыгрузки - Структура - параметры выгрузки справочника
//
// Возвращаемое значение:
//	ТаблицаЗначений - содержит данные таблицы для выгрузки на сервер Mobile Smarts
&НаКлиенте
Функция ЛокЯдро_ПолучитьДанныеТаблицыДляВыгрузкиНаСерверSMARTS(ИмяТаблицы, НастройкиКомпоновщика, ПараметрыКомпоновщика, ПараметрыВыгрузки = Неопределено) Экспорт

	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода", "Функция");
	СтруктураВызова.Вставить("ИмяМетода", "ПолучитьДанныеТаблицыДляВыгрузкиНаСерверSMARTS");
	СтруктураВызова.Вставить("ПараметрыМетода", Новый Структура("ИмяТаблицы,НастройкиКомпоновщика,ПараметрыКомпоновщика,ПараметрыОнлайн", ИмяТаблицы, НастройкиКомпоновщика, ПараметрыКомпоновщика, ""));
	СтруктураВызова.ПараметрыМетода.Вставить("РаботаБезАлкоголя", ЛокЯдро_ПолучитьИзКэшаНастройкуSMARTS("РаботаБезАлкоголя"));
	СтруктураВызова.ПараметрыМетода.Вставить("ПараметрыВыгрузки", ПараметрыВыгрузки);
	
	ДанныеДляВыгрузки = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,Истина,АдресаПеременных);	
	
	Возврат ДанныеДляВыгрузки;
	
КонецФункции

// Вызывает из модуля обработки функцию получения списка имен справочников, участвующих в интеграции с Mobile Smarts
//
// Параметры:
//	АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
//
// Возвращаемое значение:
//	СписокЗначений - содержит имена справочников в базе 1С, участвующих в интеграции с Mobile Smarts
&НаКлиенте
Функция ЛокЯдро_ПолучитьСписокИспользуемыхСправочников() Экспорт
	
	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода", "Функция");
	СтруктураВызова.Вставить("ИмяМетода", "ПолучитьСписокИспользуемыхСправочников");	
	СписокИспользуемыхСправочников = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,,АдресаПеременных);
	Если  РасположениеКомпоненты = "НаСервере" Тогда
		СтруктураВызова = Новый Структура;
		СтруктураВызова.Вставить("ТипМетода", "Функция");
		СтруктураВызова.Вставить("ИмяМетода", "ПолучитьСписокСправочниковВКонфигурацииSMARTS");				
		СписокСправочниковВКонфигурацииСмартс = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,,АдресаПеременных);	
	Иначе
		СписокСправочниковВКонфигурацииСмартс = КомЯдро_ПолучитьСписокСправочниковВКонфигурацииSMARTS();
	КонецЕсли;
	// Отфильтруем из списка отсутствующие справочники
	Если ЗначениеЗаполнено(СписокИспользуемыхСправочников) И СписокИспользуемыхСправочников.Количество() > 0 Тогда
		СправочникиКУдалению = Новый Массив;
		Для Каждого Справочник Из  СписокИспользуемыхСправочников Цикл
			Если Справочник.Значение = "Номенклатура" Тогда
				Продолжить;
			КонецЕсли;
			Если Справочник.Значение ="Ячейки" Тогда
				Если ПараметрыПодключенияMS.Свойство("ТипУстановленногоПродукта") И ПараметрыПодключенияMS.Свойство("УровеньПриложенияСтрокой") Тогда
					Если  (ПараметрыПодключенияMS.ТипУстановленногоПродукта = "Склад" ИЛИ ПараметрыПодключенияMS.ТипУстановленногоПродукта ="Не удалось определить...")
					И Не ПараметрыПодключенияMS.УровеньПриложенияСтрокой = "Минимум" Тогда
						Продолжить;
					КонецЕсли;
				Иначе
					Продолжить;
				КонецЕсли;
			КонецЕсли;
			
			Если СписокСправочниковВКонфигурацииСмартс.Найти(Справочник.Значение) = Неопределено Тогда
				СправочникиКУдалению.Добавить(Справочник);
			КонецЕсли;
		КонецЦикла;
		Если СправочникиКУдалению.Количество() > 0 Тогда
			Для Каждого ОтсутствующийСправочник Из СправочникиКУдалению Цикл
				СписокИспользуемыхСправочников.Удалить(ОтсутствующийСправочник);
			КонецЦикла;
		КонецЕсли;
	КонецЕсли;
	
	Возврат СписокИспользуемыхСправочников;
	
КонецФункции

// Возвращает индекс колонки "Product.Id" в массиве имен колонок таблицы, выгружаемой на сервер Mobile Smarts
//
// Параметры:
//	МассивИмен - Массив из Строка - содержит имена колонок таблицы
//
// Возвращаемое значение:
//	Число - индекс колонки "Product.Id" в массиве имен колонок таблицы
&НаКлиенте
Функция ЛокЯдро_НайтиИндексИдТовараВМассивеИмен(МассивИмен) Экспорт
	
	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода"		, "Функция");
	СтруктураВызова.Вставить("ИмяМетода"		, "НайтиИндексИдТовараВМассивеИмен");	
	СтруктураВызова.Вставить("ПараметрыМетода"	, Новый Структура("МассивИмен", МассивИмен));
	
	Возврат Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова);
		
КонецФункции

&НаКлиенте
Процедура ЛокЯдро_ВыгрузитьТаблицуНаСерверSMARTSЗавершение(СтруктураПараметров, ДополнительныеПараметры = Неопределено) Экспорт
	
	РезультатВыгрузки 	= СтруктураПараметров.РезультатВыгрузки;
	ПодробноеСообщение 	= СтруктураПараметров.ПодробноеСообщение;
	ИмяТаблицы 			= СтруктураПараметров.ИмяТаблицы;
	НачалоВыгрузки 		= СтруктураПараметров.НачалоВыгрузки;
	
	ТипСообщения = ?(РезультатВыгрузки.Статус, "Информация", "Ошибка");
	
	Сообщить(ПодробноеСообщение);
	
	ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации("ВыгрузкаСправочника.Конец", ТипСообщения, 
		"ИмяТаблицы=" + ИмяТаблицы + ". " + ПодробноеСообщение, НачалоВыгрузки);	

КонецПроцедуры

&НаКлиенте
Процедура ЛокЯдро_ВыгрузитьТаблицуНаСерверSMARTSВФонеЗавершение(Результат, ДополнительныеПараметры) Экспорт
	
	Если ЭтоАдресВременногоХранилища(Результат) Тогда
		СтруктураРезультата = ПолучитьИзВременногоХранилища(Результат);
		ИмяТаблицы 			= ДополнительныеПараметры.ИмяТаблицы;
		
		ЭлементСписка = СписокТаблицВыгружаемыхВФоне.НайтиПоЗначению(ИмяТаблицы);
		Если ЭлементСписка <> Неопределено Тогда
			СписокТаблицВыгружаемыхВФоне.Удалить(ЭлементСписка);
		КонецЕсли;
		
		// Актуализируем кэш, т.к. он мог измениться в сеансе фонового задания
		// TODO. Проверить, надо ли 3-й параметр ЛокЯдро_ДополнитьСтруктуру перевести в Истина 
		ЛокЯдро_ДополнитьСтруктуру(АдресаПеременных, СтруктураРезультата.АдресаПеременных, Ложь); 
		
		СтруктураПараметров = Новый Структура;
		СтруктураПараметров.Вставить("РезультатВыгрузки", 	СтруктураРезультата.РезультатВыгрузки);
		СтруктураПараметров.Вставить("ПодробноеСообщение", 	СтруктураРезультата.РезультатВыгрузки.Сообщение);
		СтруктураПараметров.Вставить("ИмяТаблицы", 			ИмяТаблицы);
		СтруктураПараметров.Вставить("НачалоВыгрузки", 		ДополнительныеПараметры.НачалоВыгрузки);
		
		ЛокЯдро_ВыгрузитьТаблицуНаСерверSMARTSЗавершение(СтруктураПараметров);
	КонецЕсли;
		
КонецПроцедуры

&НаКлиенте
Процедура ЛокЯдро_ВыгрузитьТаблицуНаСерверSMARTSПорциямиВФонеЗавершение(Результат, ДополнительныеПараметры) Экспорт
	
	Если ЭтоАдресВременногоХранилища(Результат) Тогда
		СтруктураРезультата = ПолучитьИзВременногоХранилища(Результат);
		ИмяТаблицы 			= ДополнительныеПараметры.ИмяТаблицы;
		
		ЭлементСписка = СписокТаблицВыгружаемыхВФоне.НайтиПоЗначению(ИмяТаблицы);
		Если ЭлементСписка <> Неопределено Тогда
			СписокТаблицВыгружаемыхВФоне.Удалить(ЭлементСписка);
		КонецЕсли;
		
		// Актуализируем кэш, т.к. он мог измениться в сеансе фонового задания
		// TODO. Проверить, надо ли 3-й параметр ЛокЯдро_ДополнитьСтруктуру перевести в Истина 
		ЛокЯдро_ДополнитьСтруктуру(АдресаПеременных, СтруктураРезультата.АдресаПеременных, Ложь); 
		
		РезультатВыгрузки =	СтруктураРезультата.РезультатВыгрузки;
		Если РезультатВыгрузки.Свойство("Сообщение") Тогда
			Сообщить(РезультатВыгрузки.Сообщение);
		КонецЕсли;
		
	КонецЕсли;
		
КонецПроцедуры

#КонецОбласти

#Область ЛокальныйКонтекст_Документы

// Вызывает функцию получения таблицы документов из базы Mobile Smarts
//
// Параметры:
//	ТипБазы 		- Строка 	- "Частная", "Временная", "Основная"
//  РазмерВыборки 	- Число 	- если отличен от нуля, ограничивать выборку этим числом документов
//
// Возвращаемое значение:
//	Массив из Структура - ключами являются имена колонок таблицы документов Mobile Smarts,
//						  значениями - значения соответствующих реквизитов документов Mobile Smarts
&НаКлиенте
Функция ЛокЯдро_ПолучитьСписокДокументовНаСервереSMARTS(ТипБазы = Неопределено, РазмерВыборки = 0, ОтборПоПериоду = Неопределено, ОтборПоУзлу = Неопределено) Экспорт
	
	Если ТипБазы = Неопределено Тогда
		ТипБазы = ?(ЕстьЧастнаяБаза,"Частная","Основная");
	КонецЕсли;
	
	Если РасположениеКомпоненты = "НаСервере" Тогда
		СтруктураВызова = Новый Структура;
		СтруктураВызова.Вставить("ТипМетода", "Функция");
		СтруктураВызова.Вставить("ИмяМетода", "ПолучитьСписокДокументовНаСервереSMARTS");		
		СтруктураПараметров = Новый Структура;
		СтруктураПараметров.Вставить("ТипБазы", 		ТипБазы);	
		СтруктураПараметров.Вставить("РазмерВыборки", 	РазмерВыборки);
		СтруктураПараметров.Вставить("ОтборПоПериоду", 	ОтборПоПериоду);
		СтруктураПараметров.Вставить("ОтборПоУзлу",		ОтборПоУзлу);

		СтруктураВызова.Вставить("ПараметрыМетода", СтруктураПараметров);				
		СписокДокументов = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,,АдресаПеременных);	
	Иначе
		ПустаяТаблица = ЛокЯдро_ПолучитьПустуюТаблицуДокументовSMARTS();
	
		ТипИнтерфейса = ЛокЯдро_ПолучитьТипИнтерфейса(ТипБазы); // ТипИнтерфейса = КомЯдро_ПолучитьЗначениеПеременной("ТипИнтерфейса");
		Если ТипИнтерфейса = "REST_API" Тогда
			СписокДокументов = REST_API_ПолучитьСписокДокументовНаСервереSMARTS(ПустаяТаблица, ТипБазы, РазмерВыборки, ОтборПоПериоду, ОтборПоУзлу);
		Иначе
			СписокДокументов = КомЯдро_ПолучитьСписокДокументовНаСервереSMARTS(ПустаяТаблица, ТипБазы, РазмерВыборки, ОтборПоПериоду, ОтборПоУзлу);
		КонецЕсли;
	КонецЕсли;
	
	Возврат СписокДокументов;
	
КонецФункции

// Вызывает функцию получения данных документа 1С для выгрузки и процедуру записи полученных данных в базу Mobile Smarts
//
// Параметры:
//	Документ1С - ДокументСсылка - документ в базе, выгружаемый на сервер Mobile Smarts
//  ID_БизнесПроцесса - Строка - идентификатор бизнес-процесса
//  НазначенныеПользователи - Неопределено
//							- Строка - идентификторы пользователей или устройств Mobile Smarts, которым назначается документ, разделенные "|"
//							- Массив из Структура - содержит:
//								* Ид - Строка - идентификатор пользователя или устройства Mobile Smarts, которому назначается документ
//                              * Имя - Строка - наименование пользователя или устройства Mobile Smarts, которому назначается документ
//  ТипБазы - Строка - "Частная", "Временная", "Основная"
&НаКлиенте
Процедура ЛокЯдро_ВыгрузитьДокументВБазуSMARTS(Документ1С, ID_БизнесПроцесса,НазначенныеПользователи,ТипБазы) Экспорт
	
	НачалоСобытия = ТекущаяУниверсальнаяДатаВМиллисекундах();
	ИмяСобытия = "ЛокЯдро_ВыгрузитьДокументВБазуSMARTS";
	
	ДанныеНастроекИзКэша = Новый Структура();
	
	Отбор = Новый Структура("Используется,ТипИсходногоДокумента1С,ID_БизнесПроцесса", Истина, ЛокЯдро_ПолучитьТипДокументаПоСсылке(Документ1С), ID_БизнесПроцесса);
	ОтобранныеБизнесПроцессы = ЛокЯдро_ПолучитьИзКэшаЗначениеТабличнойНастройкиSMARTS("НастройкиБизнесПроцессов", Отбор, "");
	Если ОтобранныеБизнесПроцессы = Неопределено
		Или ОтобранныеБизнесПроцессы.Количество() = 0 Тогда
		
		АвтотестКлеверенс = КомЯдро_ПолучитьЗначениеПеременной("Автотест");
		// Для автотеста не важно, включен ли бизнес-процесс, поэтому не будем накладывать отбор по использованию
		Если АвтотестКлеверенс = Истина Тогда
			Если Отбор.Свойство("Используется") Тогда
				Отбор.Удалить("Используется");
				ОтобранныеБизнесПроцессы = ЛокЯдро_ПолучитьИзКэшаЗначениеТабличнойНастройкиSMARTS("НастройкиБизнесПроцессов", Отбор, "");
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	Если ОтобранныеБизнесПроцессы = Неопределено
		Или ОтобранныеБизнесПроцессы.Количество() = 0 Тогда
		ТекстОшибки = "Не удалось получить бизнес-процесс при выгрузке документа " + Документ1С;
		ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", ТекстОшибки);
		Сообщить(ТекстОшибки);
		Возврат;
	Иначе
		ДанныеНастроекИзКэша.Вставить("СписокБизнесПроцессов",  ОтобранныеБизнесПроцессы);		
	КонецЕсли;
	
	Отбор = Новый Структура("Направление,ТипОбъекта", "Выгрузка", "Шапка");
	ПроизвольныеКодыШапки = ЛокЯдро_ПолучитьИзКэшаЗначениеТабличнойНастройкиSMARTS("ПроизвольныеКоды", Отбор);
	ДанныеНастроекИзКэша.Вставить("ПроизвольныеКодыШапки",ПроизвольныеКодыШапки);
	
	Отбор = Новый Структура("Направление,ТипОбъекта", "Выгрузка", "ТабличнаяЧасть");
	ПроизвольныеКодыТабличнойЧасти = ЛокЯдро_ПолучитьИзКэшаЗначениеТабличнойНастройкиSMARTS("ПроизвольныеКоды", Отбор);
	ДанныеНастроекИзКэша.Вставить("ПроизвольныеКодыТабличнойЧасти",ПроизвольныеКодыТабличнойЧасти);
	
	МассивТиповОбъектов = Новый Массив;
	МассивТиповОбъектов.Добавить("ПередВыгрузкойДокумента");
	МассивТиповОбъектов.Добавить("ПослеВыгрузкиДокумента");
	МассивТиповОбъектов.Добавить("ПослеОтправкиДокумента");
	Отбор = Новый Структура("Направление,ТипОбъекта", "Выгрузка", МассивТиповОбъектов);
	ПроизвольныеКодыОбработчикаЗагрузки = ЛокЯдро_ПолучитьИзКэшаЗначениеТабличнойНастройкиSMARTS("ПроизвольныеКоды", Отбор);
	ДанныеНастроекИзКэша.Вставить("ПроизвольныеКодыОбработчикаВыгрузки",ПроизвольныеКодыОбработчикаЗагрузки);
	
	МассивТиповОбъектов.Очистить();
	МассивТиповОбъектов.Добавить("ПередВыгрузкойТЧ");
	МассивТиповОбъектов.Добавить("ПослеВыгрузкиТЧ");
	МассивТиповОбъектов.Добавить("ПослеОбъединенияТЧ");
	Отбор = Новый Структура("Направление,ТипОбъекта", "Выгрузка", МассивТиповОбъектов);
	ПроизвольныеКодыОбработчикаТЧ = ЛокЯдро_ПолучитьИзКэшаЗначениеТабличнойНастройкиSMARTS("ПроизвольныеКоды", Отбор);
	ДанныеНастроекИзКэша.Вставить("ПроизвольныеКодыОбработчикаТЧ",ПроизвольныеКодыОбработчикаТЧ);
	
	МассивТиповОбъектов.Очистить();
	МассивТиповОбъектов.Добавить("ПередВыгрузкойСтрокиТЧ");
	МассивТиповОбъектов.Добавить("ПослеВыгрузкиСтрокиТЧ");
	МассивТиповОбъектов.Добавить("ПослеОбъединенияСтрокиТЧ");
	Отбор = Новый Структура("Направление,ТипОбъекта", "Выгрузка", МассивТиповОбъектов);
	ПроизвольныеКодыОбработчикаСтрокиТЧ = ЛокЯдро_ПолучитьИзКэшаЗначениеТабличнойНастройкиSMARTS("ПроизвольныеКоды", Отбор);
	ДанныеНастроекИзКэша.Вставить("ПроизвольныеКодыОбработчикаСтрокиТЧ",ПроизвольныеКодыОбработчикаСтрокиТЧ);
	  	
	ДанныеНастроекИзКэша.Вставить("ЗначенияПараметров", ЛокЯдро_ПолучитьЗначенияГлобальныхПараметров());
	
	флУказатьПользователя = ДанныеНастроекИзКэша.СписокБизнесПроцессов[0].НазначитьПользователю =  "Спрашивать при выгрузке";	
	флКопияДляКаждогоПользователя = ?(флУказатьПользователя, ДанныеНастроекИзКэша.СписокБизнесПроцессов[0].КопияДокументаДляКаждогоПользователя, Ложь);
	НазначенныеПользователи = ?(ДанныеНастроекИзКэша.СписокБизнесПроцессов[0].НазначитьПользователю = "Выгружать всем", Неопределено, НазначенныеПользователи);
	СпособНазначения = ?(ДанныеНастроекИзКэша.СписокБизнесПроцессов[0].Свойство("СпособНазначения"), ДанныеНастроекИзКэша.СписокБизнесПроцессов[0].СпособНазначения, "");
	
	// Выгрузка номенклатуры из документа перед выгрузкой 	
	флВыгрузитьНоменклатуруДокумента = ТекущиеНастройкиMS.Свойство("ВыгружатьНоменклатуруДокументаПередВыгрузкойДокумента") 
		И (ТипЗнч(ТекущиеНастройкиMS.ВыгружатьНоменклатуруДокументаПередВыгрузкойДокумента) = Тип("Булево")) 
		И ТекущиеНастройкиMS.ВыгружатьНоменклатуруДокументаПередВыгрузкойДокумента;
		
	Если флВыгрузитьНоменклатуруДокумента Тогда
		ЛокЯдро_ВыгрузитьНоменклатуруИзДокумента(Документ1С, ДанныеНастроекИзКэша.СписокБизнесПроцессов[0],ТипБазы);	
	КонецЕсли;
	
	Если РасположениеКомпоненты = "НаСервере" Тогда
		ЛокЯдро_СформироватьИЗаписатьДокументВБазуSMARTS(Документ1С, ДанныеНастроекИзКэша, ID_БизнесПроцесса, ТипБазы,НазначенныеПользователи,флКопияДляКаждогоПользователя, СпособНазначения);
	Иначе
		Если ТипЗнч(Документ1С) = Тип("Массив") Тогда
			МассивДанныхДокументовКОбъединению = Новый Массив;
			СтрокаИдИсходныхДокументов = "";
			Для Каждого ДокументКОбъединению Из Документ1С Цикл
				ДанныеДокумента = ЛокЯдро_ПолучитьДанныеДокумента1СДляВыгрузки(ДокументКОбъединению, ДанныеНастроекИзКэша);
				
				Если ДанныеДокумента = Неопределено Тогда
					Продолжить;
				КонецЕсли;     
				
				МассивДанныхДокументовКОбъединению.Добавить(ДанныеДокумента);
				СтрокаИдИсходныхДокументов = СтрокаИдИсходныхДокументов +?(СтрокаИдИсходныхДокументов="","",";")+ ДанныеДокумента.ШапкаДокумента.Ид;
			КонецЦикла;
			
			// Если во всех документах были критические ошибки - завершаем процесс
			Если Не МассивДанныхДокументовКОбъединению.Количество() Тогда
				ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Конец, Выгрузка документа в базу SMARTS", НачалоСобытия);
				Возврат;
			КонецЕсли;                                             
			
			// В шапке будет информация из первого выбранного документа+ список Ид объединенных документов
			ШапкаДокумента = МассивДанныхДокументовКОбъединению[0].ШапкаДокумента;
			ШапкаДокумента.Вставить("ИдИсходныхДокументов",СтрокаИдИсходныхДокументов);
			
			// добавим ключи всех выгружаемых ТЧ по полученной структуре из первого документа
			ТабличныеЧастиОбъединенные = Новый Структура;			
			Для Каждого ТабличнаяЧасть Из МассивДанныхДокументовКОбъединению[0].ТабличныеЧасти Цикл
				ТабличныеЧастиОбъединенные.Вставить(ТабличнаяЧасть.Ключ, Новый Массив);	
			КонецЦикла;
			
			Для Каждого ДокументКОбъединению Из МассивДанныхДокументовКОбъединению Цикл
				Для Каждого ТабличнаяЧасть Из ДокументКОбъединению.ТабличныеЧасти Цикл 
					Для Каждого СтрокаТЧ Из  ТабличнаяЧасть.Значение Цикл
						СтрокаСтруктурой = СтрокаТЧ;
						СтрокаСтруктурой.Вставить("ИдДокумента",ДокументКОбъединению.ШапкаДокумента.Ид);
						ТабличныеЧастиОбъединенные[ТабличнаяЧасть.Ключ].Добавить(СтрокаСтруктурой);
					КонецЦикла;
				КонецЦикла;
			КонецЦикла;
			
			ДанныеОбъединенногоДокумента = Новый Структура;			
			ДанныеОбъединенногоДокумента.Вставить("ШапкаДокумента",ШапкаДокумента);
			ДанныеОбъединенногоДокумента.Вставить("ТабличныеЧасти", ТабличныеЧастиОбъединенные);
			ДанныеДокумента = ДанныеОбъединенногоДокумента;
		Иначе
			
			ДанныеДокумента = ЛокЯдро_ПолучитьДанныеДокумента1СДляВыгрузки(Документ1С, ДанныеНастроекИзКэша);
			// Если в документе были критические ошибки, завершаем процесс
			Если ДанныеДокумента = Неопределено Тогда
				ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Конец, Выгрузка документа в базу SMARTS", НачалоСобытия);
				Возврат;
			КонецЕсли;     
	
		КонецЕсли;
		
		ТипИнтерфейса = ЛокЯдро_ПолучитьТипИнтерфейса(ТипБазы); // ТипИнтерфейса = КомЯдро_ПолучитьЗначениеПеременной("ТипИнтерфейса");
		
		Если ТипЗнч(НазначенныеПользователи) = Тип("Массив")
			И НазначенныеПользователи.Количество() > 0 Тогда
			НазначенныеПользователиМассив = НазначенныеПользователи;
			НазначенныеПользователиСтрокой = "";
			Для Каждого НазначенныйПользователь ИЗ НазначенныеПользователи Цикл
				НазначенныеПользователиСтрокой = НазначенныеПользователиСтрокой+?(НазначенныеПользователиСтрокой = "","","|")+НазначенныйПользователь.Ид;
			КонецЦикла;
		ИначеЕсли ТипЗнч(НазначенныеПользователи) = Тип("Строка")
			И ЗначениеЗаполнено(НазначенныеПользователи) Тогда
			НазначенныеПользователиМассив = ЛокЯдро_РазложитьСтрокуВМассивПодстрок(НазначенныеПользователи, "|");
			НазначенныеПользователиСтрокой = НазначенныеПользователи;
		Иначе
			НазначенныеПользователиМассив = Неопределено;
			НазначенныеПользователиСтрокой = Неопределено;
		КонецЕсли;
		
		Если НазначенныеПользователиМассив <> Неопределено 
			И НазначенныеПользователиСтрокой <> Неопределено Тогда
			Если флКопияДляКаждогоПользователя Тогда
				Если ТипИнтерфейса = "REST_API" Тогда
					Для Каждого НазначенныйПользователь ИЗ НазначенныеПользователиМассив Цикл
						ДокументSMARTS  = REST_API_СформироватьНовыйДокументSMARTS(ДанныеДокумента,НазначенныйПользователь.Ид, СпособНазначения);		
						REST_API_ЗаписатьДокументВБазуSMARTS(ДокументSMARTS, ТипБазы);
					КонецЦикла;
				Иначе
					Для Каждого НазначенныйПользователь ИЗ НазначенныеПользователиМассив Цикл
						ДокументSMARTS  = КомЯдро_СформироватьНовыйДокументSMARTS(ДанныеДокумента,НазначенныйПользователь.Ид, СпособНазначения);
						КомЯдро_ЗаписатьДокументВБазуSMARTS(ДокументSMARTS, ТипБазы);	
					КонецЦикла;
				КонецЕсли;
			Иначе
				Если ТипИнтерфейса = "REST_API" Тогда
					ДокументSMARTS  = REST_API_СформироватьНовыйДокументSMARTS(ДанныеДокумента,НазначенныеПользователиСтрокой, СпособНазначения);
					REST_API_ЗаписатьДокументВБазуSMARTS(ДокументSMARTS, ТипБазы);
				Иначе
					ДокументSMARTS  = КомЯдро_СформироватьНовыйДокументSMARTS(ДанныеДокумента,НазначенныеПользователиСтрокой, СпособНазначения);		
					КомЯдро_ЗаписатьДокументВБазуSMARTS(ДокументSMARTS, ТипБазы);	
				КонецЕсли;	
			КонецЕсли;	
			
		Иначе
			
			Если ТипИнтерфейса = "REST_API" Тогда
				ДокументSMARTS  = REST_API_СформироватьНовыйДокументSMARTS(ДанныеДокумента);		
				REST_API_ЗаписатьДокументВБазуSMARTS(ДокументSMARTS, ТипБазы);
			Иначе
				ДокументSMARTS  = КомЯдро_СформироватьНовыйДокументSMARTS(ДанныеДокумента);
				КомЯдро_ЗаписатьДокументВБазуSMARTS(ДокументSMARTS, ТипБазы);
			КонецЕсли;
			
		КонецЕсли;
		
		ЛокЯдро_ОбработатьДокумент1СПослеВыгрузкиНаСерверSMARTS(Документ1С, ДанныеДокумента, ДанныеНастроекИзКэша, ID_БизнесПроцесса, АдресаПеременных);	
	КонецЕсли;	           	
		      			
КонецПроцедуры

// Вызывает из модуля обработки функцию получения данных документа 1С для выгрузки и процедуру записи полученных данных в базу Mobile Smarts
//
// Параметры:
//	Документ1С - ДокументСсылка - документ в базе, выгружаемый на сервер Mobile Smarts
//  СписокПередаваемыхНастроек - Неопределено, Структура - содержит:
//		* СписокБизнесПроцессов - Неопределено, ТаблицаЗначений, Массив из Структура - содержит настройки отобранных бизнес-процессов
//		* ПроизвольныеКодыШапки - Неопределено, ТаблицаЗначений, Массив из Структура - содержит произвольные коды для выгрузки шапки документа
//		* ПроизвольныеКодыТабличнойЧасти - Неопределено, ТаблицаЗначений, Массив из Структура - содержит произвольные коды для выгрузки табличных частей документа
//		* ГлобальныеПараметры - Неопределено, ТаблицаЗначений, Массив из Структура - содержит значения глобальных параметров
//  ID_БизнесПроцесса - Строка - идентификатор бизнес-процесса
//  ТипБазы - Строка - "Частная", "Временная", "Основная"
//  НазначенныеПользователи - Неопределено
//							- Строка - идентификторы пользователей или устройств Mobile Smarts, которым назначается документ, разделенные "|"
//							- Массив из Структура - содержит:
//								* Ид - Строка - идентификатор пользователя или устройства Mobile Smarts, которому назначается документ
//                              * Имя - Строка - наименование пользователя или устройства Mobile Smarts, которому назначается документ
//  КопияДляКаждогоПользователя - Булево - признак необходимости создавать отдельную копию выгружаемого документа для каждого из назначенных пользователей
//  СпособНазначения - Строка - "", "Устройству", "Пользователям"
&НаКлиенте
Процедура ЛокЯдро_СформироватьИЗаписатьДокументВБазуSMARTS(Документ1С, СписокПередаваемыхНастроек, ID_БизнесПроцесса, ТипБазы ,НазначенныеПользователи,КопияДляКаждогоПользователя = Ложь, СпособНазначения = "")
	
	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода", "Процедура");
	СтруктураВызова.Вставить("ИмяМетода", "СформироватьИЗаписатьДокументВБазуSMARTS");
	СтруктураПараметров = Новый Структура;
	СтруктураПараметров.Вставить("Документ1С", Документ1С);
	СтруктураПараметров.Вставить("СписокПередаваемыхНастроек", СписокПередаваемыхНастроек);
	СтруктураПараметров.Вставить("ID_БизнесПроцесса", ID_БизнесПроцесса);	
	СтруктураПараметров.Вставить("ТипБазы", ТипБазы);	
	СтруктураПараметров.Вставить("НазначенныеПользователи",НазначенныеПользователи);
	СтруктураПараметров.Вставить("КопияДляКаждогоПользователя",КопияДляКаждогоПользователя);
	СтруктураПараметров.Вставить("СпособНазначения", СпособНазначения);
	СтруктураВызова.Вставить("ПараметрыМетода", СтруктураПараметров);
	
	Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,,АдресаПеременных);	
	
КонецПроцедуры

// Формирует схему компоновки данных, которая будет использована для отбора документов 1С
//
// Параметры:
//	ТипДокумента1С - Строка - имя типа документа 1С, для которого требуется сформировать схему компоновки данных 
//  ID_Узла - Строка - идентификатор узла в текущей сессии Mobile Smarts
//
// Возвращаемое значение:
//	СхемаКомпоновкиДанных
&НаКлиенте
Функция ЛокЯдро_ПолучитьКомпоновкуСКДДляОтбораДокументов1С(ТипДокумента1С, ID_Узла) Экспорт
	
	ПараметрыУзла = ЛокЯдро_ПолучитьЗначенияГлобальныхПараметров(ID_Узла);
	
	ПараметрыМетода = Новый Структура;
	ПараметрыМетода.Вставить("ТипДокумента1С", 	ТипДокумента1С);
	ПараметрыМетода.Вставить("ПараметрыУзла", 	ПараметрыУзла);
	ПараметрыМетода.Вставить("ОтборПоПериоду", 	Новый Структура("ДатаНачала,ДатаОкончания", Дата(1, 1, 1), Дата(1, 1, 1)));
	
	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода", "Функция");
	СтруктураВызова.Вставить("ИмяМетода", "ПолучитьКомпоновкуСКДДляОтбораДокументов1С");
	СтруктураВызова.Вставить("ПараметрыМетода", ПараметрыМетода);
	
	Результат = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,Истина,АдресаПеременных);	
	
	Возврат Результат;
	
КонецФункции

// Вызывает функцию получения данных документа Mobile Smarts, при необходимости подбирает настройку бизнес-процесса для загрузки документа
// и вызывает функцию формирования и записи документа 1С на основании данных документа Mobile Smarts
//
// Параметры:
//	ID_Документа - Строка, Массив из Строка - идентификаторы загружаемых документов
//	ТипДокументаMS - Строка - тип документа Mobile Smarts
//  ID_БизнесПроцесса - Строка - идентификатор бизнес-процесса
//  НастройкаБП - Неопределено, Структура - содержит настройку бизнес-процесса, используемую при загрузке
//	ДокументДляЗаполнения - ДокументОбъект - содержит объект документа, который будет перезаписан
//                        - Структура - содержит:
//								* Данные - Строка, ДокументОбъект, ДанныеФормыСтруктура - данные объекта документа, который будет перезаписан, или его адрес во временном хранилище		  												  или их адрес во временном хранилище
//                        - Неопределено
//	Онлайн - Булево - признак того, что обмен выполняется в режиме "Онлайн"
//	ФильтрТЧПоИдДокумента - Неопределено, Строка - идентификатор исходного документа для случая, когда документ Mobile Smarts был сформирован из нескольких документов 1С
//	ВсеВОдин - Булево - признак того, что загружаемые документы Mobile Smarts должны быть загружены в один документ 1С
//
// Возвращаемое значение:
//	Структура - содержит:
//		* Сообщение - Строка - информационное сообщение о результате формирования и записи документа
//		* Статус - Булево - признак успешности формирования и записи документа
//      * Данные - ДокументОбъект - объект сформированного документа - при работе в онлайн-режиме
//				 - ДокументСсылка - ссылка на сформированный документ в случае, если он записан
//				 - Строка - адрес во временном хранилище, куда помещен объект сформированного документа
//		* Ссылка - ДокументСсылка - ссылка на существующий документ, который был перезаписан при загрузке
//      * ДокументЗаписанВОбработчике - Булево - признак того, что документ записан в обработчике интеграционной обработки
//		* ЕстьОшибкиПриВыполненииОбработчиков - Булево - признак того, что при выполнении обработчиков интеграционной обработки возникли ошибки     	
//		* ДокументЗаписан - Булево - признак того, что документ записан в функции - не для онлайн-обмена
//		* ДокументПроведен - Булево - признак того, что документ проведен в функции - не для онлайн-обмена
//      * МетаданныеИмя - Строка - имя объекта метаданных записанного документа	
//      * Дополнение - Строка - идентификатор пользователя документа Mobile Smarts
&НаКлиенте
Функция ЛокЯдро_СформироватьИЗаписатьДокументВБазу1С_ПоID(ID_Документа, ТипДокументаMS, ID_БизнесПроцесса, НастройкаБП, ДокументДляЗаполнения = Неопределено, Онлайн = Ложь, ФильтрТЧПоИдДокумента = Неопределено, ВсеВОдин = Ложь) Экспорт
	
	пТипДокументаMS = ЛокЯдро_ПреобразованиеНаименованияДокументаБезПробелов(ТипДокументаMS);
	СтруктураДанныхДокументаMS = СтруктураМетаданных.ДокументыMS[пТипДокументаMS];
	
	ДанныеНастроекИзКэша = Новый Структура;
	ДанныеНастроекИзКэша.Вставить("НастройкиДляОбмена", ЛокЯдро_ПолучитьИзКэшаНастройкуSMARTS("НастройкиБизнесПроцессов"));
	ДанныеНастроекИзКэша.Вставить("ЗначенияПараметров", ЛокЯдро_ПолучитьЗначенияГлобальныхПараметров());
	
	Отбор = Новый Структура("Направление,ТипОбъекта", "Загрузка", "Шапка");
	ПроизвольныеКодыШапки = ЛокЯдро_ПолучитьИзКэшаЗначениеТабличнойНастройкиSMARTS("ПроизвольныеКоды", Отбор);
	ДанныеНастроекИзКэша.Вставить("ПроизвольныеКодыШапки",ПроизвольныеКодыШапки);
	
	Отбор = Новый Структура("Направление,ТипОбъекта", "Загрузка", "ТабличнаяЧасть");
	ПроизвольныеКодыТабличнойЧасти = ЛокЯдро_ПолучитьИзКэшаЗначениеТабличнойНастройкиSMARTS("ПроизвольныеКоды", Отбор);
	ДанныеНастроекИзКэша.Вставить("ПроизвольныеКодыТабличнойЧасти",ПроизвольныеКодыТабличнойЧасти);
	
	МассивТиповОбъектов = Новый Массив;
	МассивТиповОбъектов.Добавить("ПередЗагрузкойДокумента");
	МассивТиповОбъектов.Добавить("ПослеЗагрузкиДокумента");
	Отбор = Новый Структура("Направление,ТипОбъекта", "Загрузка", МассивТиповОбъектов);
	ПроизвольныеКодыОбработчикаЗагрузки = ЛокЯдро_ПолучитьИзКэшаЗначениеТабличнойНастройкиSMARTS("ПроизвольныеКоды", Отбор);
	ДанныеНастроекИзКэша.Вставить("ПроизвольныеКодыОбработчикаЗагрузки",ПроизвольныеКодыОбработчикаЗагрузки);
	
	МассивТиповОбъектов.Очистить();
	МассивТиповОбъектов.Добавить("ПередЗаполнениемТЧ");
	МассивТиповОбъектов.Добавить("ПослеЗаполненияТЧ");
	Отбор = Новый Структура("Направление,ТипОбъекта", "Загрузка", МассивТиповОбъектов);
	ПроизвольныеКодыОбработчикаТЧ = ЛокЯдро_ПолучитьИзКэшаЗначениеТабличнойНастройкиSMARTS("ПроизвольныеКоды", Отбор);
	ДанныеНастроекИзКэша.Вставить("ПроизвольныеКодыОбработчикаТЧ",ПроизвольныеКодыОбработчикаТЧ);
	
	МассивТиповОбъектов.Очистить();
	МассивТиповОбъектов.Добавить("ПередЗаполнениемСтрокиТЧ");
	МассивТиповОбъектов.Добавить("ПослеЗаполненияСтрокиТЧ");
	Отбор = Новый Структура("Направление,ТипОбъекта", "Загрузка", МассивТиповОбъектов);
	ПроизвольныеКодыОбработчикаСтрокиТЧ = ЛокЯдро_ПолучитьИзКэшаЗначениеТабличнойНастройкиSMARTS("ПроизвольныеКоды", Отбор);
	ДанныеНастроекИзКэша.Вставить("ПроизвольныеКодыОбработчикаСтрокиТЧ",ПроизвольныеКодыОбработчикаСтрокиТЧ);
	
	// Проверяем, нужно ли получать CombinedItems
	ЗапрашиватьCombinedItems = ЛокЯдро_ПроверитьНаличиеСовмещенныхСтрокВНастройкеБП(НастройкаБП);
	
	Если РасположениеКомпоненты = "НаСервере" Тогда
		СтруктураВызова = Новый Структура;
		СтруктураВызова.Вставить("ТипМетода", "Функция");
		СтруктураВызова.Вставить("ИмяМетода", "СформироватьИЗаписатьДокументВБазу1С_ПоID");
		ПараметрыМетода = Новый Структура;
		ПараметрыМетода.Вставить("ID_Документа", ID_Документа);
		ПараметрыМетода.Вставить("СтруктураДанныхДокументаMS", СтруктураДанныхДокументаMS);
		ПараметрыМетода.Вставить("ID_БизнесПроцесса", ID_БизнесПроцесса);
		ПараметрыМетода.Вставить("ДанныеНастроекИзКэша", ДанныеНастроекИзКэша);
		ПараметрыМетода.Вставить("ЧастнаяБазаMS", ?(ЕстьЧастнаяБаза, "Частная", "Основная")); // ДанныеТекущегоУзла.ЧастнаяБазаMS);
		ПараметрыМетода.Вставить("НастройкаБП", НастройкаБП);
		ПараметрыМетода.Вставить("ДокументДляЗаполнения", ДокументДляЗаполнения);
		ПараметрыМетода.Вставить("Онлайн", Онлайн);
		ПараметрыМетода.Вставить("ФильтрТЧПоИдДокумента",ФильтрТЧПоИдДокумента);
		ПараметрыМетода.Вставить("ВсеВОдин",ВсеВОдин);
		СтруктураВызова.Вставить("ПараметрыМетода", ПараметрыМетода);
		РезультатЗаписи = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,,АдресаПеременных);	
	Иначе
		Если ВсеВОдин = Истина И ТипЗнч(ID_Документа) = Тип("Массив") Тогда
			ДанныеДокументаMS = Неопределено;
			Для каждого ДокументКЗагрузке ИЗ ID_Документа Цикл
				пДанныеДокументаMS = ЛокЯдро_ПолучитьДанныеДокументаMS(ДокументКЗагрузке.Ид, ТипДокументаMS, ФильтрТЧПоИдДокумента, ЗапрашиватьCombinedItems);	
				Если ДанныеДокументаMS = Неопределено Тогда
					ДанныеДокументаMS = пДанныеДокументаMS;
					Если НЕ ДанныеДокументаMS.Свойство("СовмещенныеСтроки") 
						ИЛИ НЕ ТипЗнч(ДанныеДокументаMS.СовмещенныеСтроки) = Тип("Массив") Тогда
						ДанныеДокументаMS.Вставить("СовмещенныеСтроки",Новый Массив());
					КонецЕсли;
					Если НЕ ДанныеДокументаMS.Свойство("СтрокиПлан") 
						ИЛИ НЕ ТипЗнч(ДанныеДокументаMS.СтрокиПлан) = Тип("Массив") Тогда
						ДанныеДокументаMS.Вставить("СтрокиПлан",Новый Массив());
					КонецЕсли;
					Если НЕ ДанныеДокументаMS.Свойство("СтрокиФакт") 
						ИЛИ НЕ ТипЗнч(ДанныеДокументаMS.СтрокиФакт) = Тип("Массив") Тогда
						ДанныеДокументаMS.Вставить("СтрокиФакт",Новый Массив());
					КонецЕсли;
				Иначе                                                                     
					Если пДанныеДокументаMS.Свойство("СовмещенныеСтроки") 
						И ТипЗнч(пДанныеДокументаMS.СовмещенныеСтроки) = Тип("Массив") Тогда
						Для каждого СтрокаТЧ ИЗ пДанныеДокументаMS.СовмещенныеСтроки Цикл
							Если СтрокаТЧ.Свойство("ЭтоТаблицаЗначений") Тогда
								Продолжить;
							КонецЕсли;
							ДанныеДокументаMS.СовмещенныеСтроки.Добавить(СтрокаТЧ);
						КонецЦикла;
					КонецЕсли;
					Если пДанныеДокументаMS.Свойство("СтрокиПлан") 
						И ТипЗнч(пДанныеДокументаMS.СтрокиПлан) = Тип("Массив") Тогда
						Для каждого СтрокаТЧ ИЗ пДанныеДокументаMS.СтрокиПлан Цикл
							Если СтрокаТЧ.Свойство("ЭтоТаблицаЗначений") Тогда
								Продолжить;
							КонецЕсли;
							ДанныеДокументаMS.СтрокиПлан.Добавить(СтрокаТЧ);
						КонецЦикла;
					КонецЕсли;
					Если пДанныеДокументаMS.Свойство("СтрокиФакт") 
						И ТипЗнч(пДанныеДокументаMS.СтрокиФакт) = Тип("Массив") Тогда
						Для каждого СтрокаТЧ ИЗ пДанныеДокументаMS.СтрокиФакт Цикл
							Если СтрокаТЧ.Свойство("ЭтоТаблицаЗначений") Тогда
								Продолжить;
							КонецЕсли;
							ДанныеДокументаMS.СтрокиФакт.Добавить(СтрокаТЧ);
						КонецЦикла;
					КонецЕсли;
					// У второго и последующего документа обходим доп. таблицы и дозаполняем их
					Если СтруктураДанныхДокументаMS.Свойство("ДополнительныеТаблицы") Тогда
						Для Каждого ДопТаблица Из СтруктураДанныхДокументаMS.ДополнительныеТаблицы Цикл
							МассивДопТаблицы = Неопределено;														
							Если пДанныеДокументаMS.Свойство(ДопТаблица.Представление) 
								И ТипЗнч(пДанныеДокументаMS[ДопТаблица.Представление]) = Тип("Массив") Тогда								
								// Выгружаем уже имеющие строки таблицы в служебную переменную...
								ДанныеДокументаMS.Свойство(ДопТаблица.Представление, МассивДопТаблицы);
								Для каждого СтрокаТЧ ИЗ пДанныеДокументаMS[ДопТаблица.Представление] Цикл
									Если СтрокаТЧ.Свойство("ЭтоТаблицаЗначений") Тогда
										Продолжить;
									КонецЕсли;
									// ... и дозаполняем ее строками таблицы текущего документа
									МассивДопТаблицы.Добавить(СтрокаТЧ);
								КонецЦикла;								
								ДанныеДокументаMS.Вставить(ДопТаблица.Представление, МассивДопТаблицы);
							КонецЕсли;
						КонецЦикла;						
					КонецЕсли;
				КонецЕсли;
			КонецЦикла;
		Иначе
			ДанныеДокументаMS = ЛокЯдро_ПолучитьДанныеДокументаMS(ID_Документа, ТипДокументаMS, ФильтрТЧПоИдДокумента, ЗапрашиватьCombinedItems);
		КонецЕсли;
		РезультатЗаписи = ЛокЯдро_СформироватьИЗаписатьДокументВБазу1С(ДанныеДокументаMS, ДанныеНастроекИзКэша, НастройкаБП, ДокументДляЗаполнения, Онлайн,ФильтрТЧПоИдДокумента);
	КонецЕсли;
	
	Возврат РезультатЗаписи;
	
КонецФункции

// Вызывает из модуля обработки функцию заполнения документа 1С данными документа Mobile Smarts в соответствии с переданной настройкой бизнес-процесса
//
// Параметры:
//	ДанныеДокументаMS -	Структура - содержит данные документа Mobile Smarts
//  ДанныеНастроекИзКэша - Неопределено, Структура - содержит:
//		* НастройкиБизнесПроцессов - Неопределено, ТаблицаЗначений, Массив из Структура - содержит настройки бизнес-процессов
//		* ПроизвольныеКодыШапки - Неопределено, ТаблицаЗначений, Массив из Структура - содержит произвольные коды загрузки шапки документа
//		* ПроизвольныеКодыТабличнойЧасти - Неопределено, ТаблицаЗначений, Массив из Структура - содержит произвольные коды загрузки табличных частей документа
//		* ЗначенияПараметров - Неопределено, ТаблицаЗначений, Массив из Структура - содержит значения глобальных параметров
//  НастройкаБП - Структура - содержит настройку бизнес-процесса, используемую при загрузке
//  ДокументДляЗаполнения - ДокументОбъект - содержит объект документа, который будет перезаписан
//                        - Структура - содержит:
//								* Данные - Строка, ДокументОбъект, ДанныеФормыСтруктура - данные объекта документа, который будет перезаписан, или его адрес во временном хранилище		  												  или их адрес во временном хранилище
//                        - Неопределено
//  Онлайн - Булево - признак того, что обмен выполняется в режиме "Онлайн"
//  ФильтрТЧПоИдДокумента - Неопределено, Строка - идентификатор исходного документа для случая, когда документ Mobile Smarts был сформирован из нескольких документов 1С
//
// Возвращаемое значение:
//	Структура - содержит:
//		* Сообщение - Строка - информационное сообщение о результате формирования и записи документа
//		* Статус - Булево - признак успешности формирования и записи документа
//      * Данные - ДокументОбъект - объект сформированного документа - при работе в онлайн-режиме
//				 - ДокументСсылка - ссылка на сформированный документ в случае, если он записан
//				 - Строка - адрес во временном хранилище, куда помещен объект сформированного документа
//		* Ссылка - ДокументСсылка - ссылка на существующий документ, который был перезаписан при загрузке
//      * ДокументЗаписанВОбработчике - Булево - признак того, что документ записан в обработчике интеграционной обработки
//		* ЕстьОшибкиПриВыполненииОбработчиков - Булево - признак того, что при выполнении обработчиков интеграционной обработки возникли ошибки     	
//		* ДокументЗаписан - Булево - признак того, что документ записан в функции - не для онлайн-обмена
//		* ДокументПроведен - Булево - признак того, что документ проведен в функции - не для онлайн-обмена
//      * МетаданныеИмя - Строка - имя объекта метаданных записанного документа
&НаКлиенте
Функция ЛокЯдро_СформироватьИЗаписатьДокументВБазу1С(ДанныеДокументаMS, ДанныеНастроекИзКэша = Неопределено, НастройкаБП = Неопределено, ДокументДляЗаполнения = Неопределено, Онлайн = Ложь,ФильтрТЧПоИдДокумента = Неопределено) Экспорт	
		
	Если ДанныеНастроекИзКэша = Неопределено Тогда
		ДанныеНастроекИзКэша = Новый Структура;
	КонецЕсли;
	Если НЕ ДанныеНастроекИзКэша.Свойство("ЗначенияПараметров") Тогда
		ДанныеНастроекИзКэша.Вставить("ЗначенияПараметров", ЛокЯдро_ПолучитьЗначенияГлобальныхПараметров());
	КонецЕсли;
	Если НЕ ДанныеНастроекИзКэша.Свойство("ПроизвольныеКодыШапки") Тогда
		Отбор = Новый Структура("Направление,ТипОбъекта", "Загрузка", "Шапка");
		ПроизвольныеКодыШапки = ЛокЯдро_ПолучитьИзКэшаЗначениеТабличнойНастройкиSMARTS("ПроизвольныеКоды", Отбор);
		ДанныеНастроекИзКэша.Вставить("ПроизвольныеКодыШапки",ПроизвольныеКодыШапки);
	КонецЕсли;
	Если НЕ ДанныеНастроекИзКэша.Свойство("ПроизвольныеКодыТабличнойЧасти") Тогда
		Отбор = Новый Структура("Направление,ТипОбъекта", "Загрузка", "ТабличнаяЧасть");
		ПроизвольныеКодыТабличнойЧасти = ЛокЯдро_ПолучитьИзКэшаЗначениеТабличнойНастройкиSMARTS("ПроизвольныеКоды", Отбор);
		ДанныеНастроекИзКэша.Вставить("ПроизвольныеКодыТабличнойЧасти",ПроизвольныеКодыТабличнойЧасти);
	КонецЕсли;
	Если НЕ ДанныеНастроекИзКэша.Свойство("ПроизвольныеКодыОбработчикаЗагрузки") Тогда
		МассивТиповОбъектов = Новый Массив;
		МассивТиповОбъектов.Добавить("ПередЗагрузкойДокумента");
		МассивТиповОбъектов.Добавить("ПослеЗагрузкиДокумента");
		Отбор = Новый Структура("Направление,ТипОбъекта", "Загрузка", МассивТиповОбъектов);
		ПроизвольныеКодыОбработчикаЗагрузки = ЛокЯдро_ПолучитьИзКэшаЗначениеТабличнойНастройкиSMARTS("ПроизвольныеКоды", Отбор);
		ДанныеНастроекИзКэша.Вставить("ПроизвольныеКодыОбработчикаЗагрузки",ПроизвольныеКодыОбработчикаЗагрузки);
	КонецЕсли;
	Если НЕ ДанныеНастроекИзКэша.Свойство("ПроизвольныеКодыОбработчикаТЧ") Тогда
		МассивТиповОбъектов = Новый Массив;
		МассивТиповОбъектов.Добавить("ПередЗаполнениемТЧ");
		МассивТиповОбъектов.Добавить("ПослеЗаполненияТЧ");
		Отбор = Новый Структура("Направление,ТипОбъекта", "Загрузка", МассивТиповОбъектов);
		ПроизвольныеКодыОбработчикаТЧ = ЛокЯдро_ПолучитьИзКэшаЗначениеТабличнойНастройкиSMARTS("ПроизвольныеКоды", Отбор);
		ДанныеНастроекИзКэша.Вставить("ПроизвольныеКодыОбработчикаТЧ",ПроизвольныеКодыОбработчикаТЧ);
	КонецЕсли;
	Если НЕ ДанныеНастроекИзКэша.Свойство("ПроизвольныеКодыОбработчикаСтрокиТЧ") Тогда
		МассивТиповОбъектов = Новый Массив;
		МассивТиповОбъектов.Добавить("ПередЗаполнениемСтрокиТЧ");
		МассивТиповОбъектов.Добавить("ПослеЗаполненияСтрокиТЧ");
		Отбор = Новый Структура("Направление,ТипОбъекта", "Загрузка", МассивТиповОбъектов);
		ПроизвольныеКодыОбработчикаСтрокиТЧ = ЛокЯдро_ПолучитьИзКэшаЗначениеТабличнойНастройкиSMARTS("ПроизвольныеКоды", Отбор);
		ДанныеНастроекИзКэша.Вставить("ПроизвольныеКодыОбработчикаСтрокиТЧ",ПроизвольныеКодыОбработчикаСтрокиТЧ);
	КонецЕсли;	
	
	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода", "Функция");
	СтруктураВызова.Вставить("ИмяМетода", "СформироватьИЗаписатьДокументВБазу1С");
	ПараметрыМетода = Новый Структура;
	ПараметрыМетода.Вставить("ДанныеДокументаMS", ДанныеДокументаMS);
	ПараметрыМетода.Вставить("НастройкаБП", НастройкаБП);
	ПараметрыМетода.Вставить("ДанныеНастроекИзКэша", ДанныеНастроекИзКэша);
	ПараметрыМетода.Вставить("ДокументДляЗаполнения", ДокументДляЗаполнения);
	ПараметрыМетода.Вставить("Онлайн", Онлайн);
	ПараметрыМетода.Вставить("ФильтрТЧПоИдДокумента",ФильтрТЧПоИдДокумента);
	ПараметрыМетода.Вставить("ДокументОснование",Неопределено);
	ПараметрыМетода.Вставить("РезультатыВыполненияПоследовательныхБП",Неопределено);
	СтруктураВызова.Вставить("ПараметрыМетода", ПараметрыМетода);
	РезультатЗаписи = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,,АдресаПеременных);	
	
	Возврат РезультатЗаписи;
	
КонецФункции

// Вызывает в интеграционной обработке обработчик ПослеОткрытияФормыДокумента
//
// Параметры:
//	ФормаДокумента - Форма - форма документа, для которой нужно выполнить обработчик	
//  НастройкаБизнесПроцесса - Структура - содержит настройку бизнес-процесса, используемую при загрузке
//  СсылкаНаДокумент - ДокументСсылка - ссылка на документ, для формы которого нужно выполнить обработчик
&НаКлиенте
Процедура ЛокЯдро_ВыполнитьОбработчикПослеОткрытияФормыДокумента1С(ФормаДокумента, НастройкаБизнесПроцесса, РезультатЗаписи) Экспорт
	
	ИмяСобытия = "ЛокЯдро_ВыполнитьОбработчикПослеОткрытияФормыДокумента1С";
	
	Если НастройкаБизнесПроцесса.Свойство("Обработчик_ПослеОткрытияФормыДокумента") И ЗначениеЗаполнено(НастройкаБизнесПроцесса.Обработчик_ПослеОткрытияФормыДокумента) Тогда
		
		Отбор = Новый Структура("Направление,ТипОбъекта", "Загрузка", "ПослеОткрытияФормы");
		ПроизвольныеКодыОбработчикаФормы = ЛокЯдро_ПолучитьИзКэшаЗначениеТабличнойНастройкиSMARTS("ПроизвольныеКоды", Отбор);
		
		ОтборПК = Новый Структура("ID_ПроизвольногоКода", НастройкаБизнесПроцесса.Обработчик_ПослеОткрытияФормыДокумента);
		НайденныйПК = ЛокЯдро_НайтиВМассивеСтруктурПоОтбору(ПроизвольныеКодыОбработчикаФормы, ОтборПК);
		
		СтруктураПараметров = Новый Структура;
		СтруктураПараметров.Вставить("ФормаДокумента", 			ФормаДокумента);
		СтруктураПараметров.Вставить("НастройкаБизнесПроцесса", НастройкаБизнесПроцесса);
		СтруктураПараметров.Вставить("СсылкаНаДокумент", 		РезультатЗаписи.Ссылка);
		СтруктураПараметров.Вставить("ДанныеДокументаMS", 		РезультатЗаписи.ДанныеДокументаMS);
		
		Если Не НайденныйПК = Неопределено Тогда			
			
			РезультатВыполненияКода = ЛокЯдро_ВыполнитьПроизвольныйКод(
				НайденныйПК[0].ТекстПроизвольногоКода, 
				СтруктураПараметров,
				НайденныйПК[0].ID_ПроизвольногоКода,
				НайденныйПК[0].Наименование);
			
			Если Не РезультатВыполненияКода.Статус Тогда
				СообщениеОбОшибках = "Не удалось выполнить произвольный код [" + НайденныйПК[0].Наименование + "]";
				Сообщить(СообщениеОбОшибках);
			КонецЕсли;
			
		Иначе
			ВерсияAPI = 0;
			
			ИнформацияСовместимости = КомЯдро_ПолучитьЗначениеПеременной("ИнформацияСовместимости");
			Если ТипЗнч(ИнформацияСовместимости) = Тип("Структура") И
				ИнформацияСовместимости.Свойство("ВерсияAPI") Тогда
				ВерсияAPI = ИнформацияСовместимости.ВерсияAPI;
			КонецЕсли;
			
			Попытка
				Если ВерсияAPI < 3 Тогда
					#Область НесовместимыйКодFresh
					Выполнить("ФормаИнтеграционнойОбработки." + НастройкаБизнесПроцесса.Обработчик_ПослеОткрытияФормыДокумента + "(СтруктураПараметров);");			
					#КонецОбласти //НесовместимыйКодFresh
				Иначе
					ИмяОбработчика = НастройкаБизнесПроцесса.Обработчик_ПослеОткрытияФормыДокумента;
					СтруктураВыполнения = ФормаИнтеграционнойОбработки.ВыполнитьОбработчик_ПослеОткрытияФормыДокумента(ИмяОбработчика, СтруктураПараметров);	
				КонецЕсли;
			Исключение
				ИнфоОбОшибке = ИнформацияОбОшибке();
				ТекстОшибки = ПодробноеПредставлениеОшибки(ИнфоОбОшибке);
				ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Ошибка вызова обработчика ""После открытия формы документа """ + ТекстОшибки);
			КонецПопытки;
		КонецЕсли;
		
	КонецЕсли;	
	
КонецПроцедуры

// Вызывает функцию получения данных документа на сервере Mobile Smarts и - при необходимости -
// преобразует табличные данные документа из таблиц значений в массивы структур
//
// Параметры:
//	ID_Документа - Строка - идентификатор документа в базе Mobile Smarts	
//	ТипДокументаMS - Строка - тип документа Mobile Smarts
//  ФильтрТЧПоИдДокумента - Неопределено, Строка - фильтр получения табличной части для случая, когда она была объединена из нескольких документов
//
// Возвращаемое значение:
//	- Структура	- содержит:
//		* ШапкаДокумента - Структура - содержит значения реквизитов шапки документа Mobile Smarts
//		* СтрокиПлан - ТаблицаЗначений, Массив из Структура - содержит таблицу плановых строк документа Mobile Smarts  	
//		* СтрокиФакт - ТаблицаЗначений, Массив из Структура - содержит таблицу фактических строк документа Mobile Smarts
//		* СовмещенныеСтроки - ТаблицаЗначений, Массив из Структура - содержит таблицу совмещенных строк документа Mobile Smarts
//		* [Имена дополнительных таблиц] - ТаблицаЗначений, Массив из Структура - содержит дополнительные таблицы документа Mobile Smarts
//		* [Имена таблиц Mobile Smarts] - ТаблицаЗначений, Массив из Структура - содержит дополнительные таблицы документа Mobile Smarts, не определенные в метаданных документа Mobile Smarts,
//																				но фактически присутствующие в экземпляре документа
//	- Неопределено - если получить данные документа не удалось
&НаКлиенте
Функция ЛокЯдро_ПолучитьДанныеДокументаMS(ID_Документа, ТипДокументаMS, ФильтрТЧПоИдДокумента = Неопределено, ЗапрашиватьCombinedItems = Истина) Экспорт
	
	ИмяТипаДокумента = ЛокЯдро_ПреобразованиеНаименованияДокументаБезПробелов(ТипДокументаMS);		
	СтруктураДанныхДокументаMS = СтруктураМетаданных.ДокументыMS[ИмяТипаДокумента];
	
	Если РасположениеКомпоненты = "НаСервере" Тогда
		СтруктураВызова = Новый Структура;
		СтруктураВызова.Вставить("ТипМетода", "Функция");
		СтруктураВызова.Вставить("ИмяМетода", "ПолучитьДанныеДокументаMS");
		ПараметрыМетода = Новый Структура;
		ПараметрыМетода.Вставить("ID_Документа", ID_Документа);
		ПараметрыМетода.Вставить("СтруктураДанныхДокументаMS", СтруктураДанныхДокументаMS);
		ПараметрыМетода.Вставить("ТипБазы", ?(ЕстьЧастнаяБаза,"Частная","Основная"));
		ПараметрыМетода.Вставить("КонвертироватьТаблицуЗначенийВМассивСтруктур", Истина);
		ПараметрыМетода.Вставить("ФильтрТЧПоИдДокумента",ФильтрТЧПоИдДокумента);
		ПараметрыМетода.Вставить("ЗапрашиватьCombinedItems", ЗапрашиватьCombinedItems);
		СтруктураВызова.Вставить("ПараметрыМетода", ПараметрыМетода);
		ДанныеДокументаMS = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,,АдресаПеременных);
	Иначе
		ТипИнтерфейса = ЛокЯдро_ПолучитьТипИнтерфейса(?(ЕстьЧастнаяБаза, "Частная", "Основная")); // ТипИнтерфейса = КомЯдро_ПолучитьЗначениеПеременной("ТипИнтерфейса");
		Если ТипИнтерфейса = "REST_API" Тогда
			ДанныеДокументаMS = REST_API_ПолучитьДанныеДокументаНаСервереSMARTS(ID_Документа, СтруктураДанныхДокументаMS, ?(ЕстьЧастнаяБаза,"Частная","Основная"), ФильтрТЧПоИдДокумента, ЗапрашиватьCombinedItems);
		Иначе
			ДанныеДокументаMS = КомЯдро_ПолучитьДанныеДокументаНаСервереSMARTS(ID_Документа, СтруктураДанныхДокументаMS, ?(ЕстьЧастнаяБаза,"Частная","Основная"), ФильтрТЧПоИдДокумента);
		КонецЕсли;
	КонецЕсли;
	
	Возврат ДанныеДокументаMS;
	
КонецФункции

// Вызывает процедуру удаления документа на сервере Mobile Smarts
//
// Параметры:
//	ID_Документа - Строка - идентификатор документа, который требуется удалить	
//
// Возвращаемое значение:
//	Структура - содержит:
//		* Статус - Булево - признак успешности операции удаления
//		* Сообщение - Строка - информационное сообщение о результате удаления документа
&НаКлиенте
Функция ЛокЯдро_УдалитьДокументНаСервереSMARTS(ID_Документа) Экспорт
	
	Если РасположениеКомпоненты = "НаСервере" Тогда
		СтруктураВызова = Новый Структура;
		СтруктураВызова.Вставить("ТипМетода", "Функция");
		СтруктураВызова.Вставить("ИмяМетода", "УдалитьДокументНаСервереSMARTS");
		ПараметрыМетода = Новый Структура("ID_Документа,ТипБазы,ДополнительныеПараметры", ID_Документа, ?(ЕстьЧастнаяБаза,"Частная","Основная"), Неопределено);
		СтруктураВызова.Вставить("ПараметрыМетода", ПараметрыМетода);
		РезультатУдаления = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,,АдресаПеременных);	
	Иначе
		ТипИнтерфейса = ЛокЯдро_ПолучитьТипИнтерфейса(?(ЕстьЧастнаяБаза, "Частная", "Основная")); // ТипИнтерфейса = КомЯдро_ПолучитьЗначениеПеременной("ТипИнтерфейса");
		
		Если ТипИнтерфейса = "REST_API" Тогда
			ДокументУдален = REST_API_УдалитьДокументНаСервереSMARTS(ID_Документа, ?(ЕстьЧастнаяБаза,"Частная","Основная"));
		Иначе
			ДокументУдален = КомЯдро_УдалитьДокументНаСервереSMARTS(ID_Документа, ?(ЕстьЧастнаяБаза,"Частная","Основная"));
		КонецЕсли;
		
		Если ДокументУдален Тогда
			РезультатУдаления = Новый Структура("Сообщение,Статус", "Документ удален с ТСД!", Истина);
		Иначе
			РезультатУдаления = Новый Структура("Сообщение,Статус", "Не удалось удалить документ с ТСД!", Ложь);
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат РезультатУдаления;
	
КонецФункции

&НаКлиенте
Функция ЛокЯдро_ПолучитьДанныеДокумента1СДляВыгрузки(Документ1С, ДанныеНастроекИзКэша)
	
	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода", "Функция");
	СтруктураВызова.Вставить("ИмяМетода", "ПолучитьДанныеДокумента1СДляВыгрузки");
	СтруктураПараметров = Новый Структура;
	СтруктураПараметров.Вставить("Документ1С", Документ1С);
	СтруктураПараметров.Вставить("ДанныеНастроекИзКэша", ДанныеНастроекИзКэша);
	СтруктураВызова.Вставить("ПараметрыМетода", СтруктураПараметров);
	
	Возврат Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,,АдресаПеременных,1);	
	
КонецФункции

&НаКлиенте
Функция ЛокЯдро_ПолучитьПустуюТаблицуДокументовSMARTS()
	
	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода", "Функция");
	СтруктураВызова.Вставить("ИмяМетода", "ПолучитьПустуюТаблицуДокументовSMARTS");
	
	Возврат Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова);	
	
КонецФункции

// Вызывает из модуля обработки функцию получения списка документов 1С
//
// Параметры:
//  РежимОбмена 	- Неопределено, Строка 	- режим обмена - "Интерактивный", "Онлайн", "Автообмен"
//  РазмерВыборки 	- Число 				- если отличен от нуля, ограничивать выборку этим числом документов
//
// Возвращаемое значение:
//	- Массив из Структура - содержит:	
//		* Ссылка - ДокументСсылка - отобранный документ
//      * НастройкаБизнесПроцесса - Строка - идентификатор бизнес-процесса
//		* БизнесПроцесс - Строка - название бизнес-процесса
//		* ТипДокумента1С - Строка - тип исходного документа 1С
//		* ИмяБП - Строка - имя бизнес-процесса (?)
//      * ИмяКонтрагента - Неопределено, СправочникСсылка.Контрагенты - контрагент документа
//		* ИмяСклада - Неопределено, СправочникСсылка.Склады - склад/склад-отправитель документа
//		* ИмяСкладаКуда - Неопределено, СправочникСсылка.Склады - склад-получатель документа
//		* Дата - Дата - дата документа - при онлайн-обмене и автообмене
//		* Номер - Строка - номер документа - при онлайн-обмене и автообмене
//		* Количество - Число - количество строк в документе - при онлайн-обмене и автообмене
//		* [ИменаРеквизитов] - Произвольный - значения реквизитов документа, выбранных для отображения на форме обмена документами в интерактивном режиме
//  - Неопределено - если не удалось получить список документов
&НаКлиенте
Функция ЛокЯдро_ПолучитьСписокДокументов1С(РежимОбмена, РазмерВыборки = 0, ОтборПоПериоду = Неопределено) Экспорт
	
	// на случай пропажи значений переменных на сервере (
	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода", 		"Функция");
	СтруктураВызова.Вставить("ИмяМетода", 		"ПолучитьИзКэшаНастройкуSMARTS");
	СтруктураВызова.Вставить("ПараметрыМетода", Новый Структура("КлючНастройки", "ID_ТекущегоУзла"));
	ОбъектID_ТекущегоУзла = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,,АдресаПеременных,1);
	
	Если ОбъектID_ТекущегоУзла = Неопределено Тогда
		ЛокЯдро_Инициализация();
	КонецЕсли;
	// )
	
	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода", "Функция");
	СтруктураВызова.Вставить("ИмяМетода", "ПолучитьСписокДокументов1С");
	
	АвтотестКлеверенс = КомЯдро_ПолучитьЗначениеПеременной("Автотест");
	Если АвтотестКлеверенс = Неопределено Тогда
		АвтотестКлеверенс = Ложь;
	КонецЕсли;

	ПараметрыМетода = Новый Структура;
	Если Не АвтотестКлеверенс Тогда
		НастройкиБизнесПроцессов = ЛокЯдро_ПолучитьИзКэшаНастройкуSMARTS("НастройкиБизнесПроцессов", Истина);
	Иначе
		СтруктураНастроекБизнесПроцессов_ПоУмолчанию = ЛокЯдро_ПолучитьИзКэшаСтруктуруНастроекПоУмолчаниюБизнесПроцессов();
		НастройкиБизнесПроцессов					 = СтруктураНастроекБизнесПроцессов_ПоУмолчанию.НастройкиБизнесПроцессов;
	КонецЕсли;
	ПараметрыМетода.Вставить("БизнесПроцессы", НастройкиБизнесПроцессов);
	НастройкиОтборов = ЛокЯдро_ПолучитьИзКэшаНастройкуSMARTS("НастройкиОтборовУзлов_" + РежимОбмена);
	Если ТипЗнч(НастройкиОтборов) <> Тип("Массив") Тогда
		НастройкиОтборов = ЛокЯдро_ПолучитьНастройкуНаСервереSMARTS("НастройкиОтборовУзлов_" + РежимОбмена, ОбъектID_ТекущегоУзла);
	КонецЕсли;
	ПараметрыМетода.Вставить("НастройкиОтборов", 	НастройкиОтборов);
	ПараметрыМетода.Вставить("ПараметрыУзлов", 		ЛокЯдро_ПолучитьЗначенияГлобальныхПараметров());
	ПараметрыМетода.Вставить("РежимОбмена", 		РежимОбмена);	
	ПараметрыМетода.Вставить("РазмерВыборки", 		РазмерВыборки);
	ПараметрыМетода.Вставить("ОтборПоПериоду", 		ОтборПоПериоду);
	
	СтруктураВызова.Вставить("ПараметрыМетода", Новый Структура("НастройкиДляМетода", ПараметрыМетода));
	
	Возврат Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,,АдресаПеременных,2);	
	
КонецФункции

// Получает имя типа документа по ссылке на документ
//
// Параметры:
//	СсылкаДокумента - ДокументСсылка, Массив из ДокументСсылка - ссылка или массив ссылок на документы, тип которых необходимо получить		
//
// Возвращаемое значение:
//	Строка
&НаКлиенте
Функция ЛокЯдро_ПолучитьТипДокументаПоСсылке(СсылкаДокумента) Экспорт
	
	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода", "Функция");
	СтруктураВызова.Вставить("ИмяМетода", "ПолучитьТипДокументаПоСсылке");
	СтруктураВызова.Вставить("ПараметрыМетода", Новый Структура("СсылкаДокумента", СсылкаДокумента));
	
	Возврат Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова);	
	
КонецФункции

// Используется на форме настройки отбора документов, для предпросмотра выборки.
//
// Параметры:
//	НастройкиКомпоновщика - Неопределено, Строка, НастройкиКомпоновкиДанных - содержит настройки схемы компоновки данных, используемой
//																			  для отбора документов для выгрузки в базу Mobile Smarts
//	ТипДокумента1С - Строка - тип документа 1С	
//  НаименованиеБП - Строка - наименование бизнес-процесса
//
// Возвращаемое значение: 
//	- Массив из Структура - содержит значения реквизитов и служебные поля (например, количество строк в табличной части) документов, попавших в результат отбора
//  - ТаблицаЗначений - пустая таблица значений в случае, если отбор документов выполнить не удалось
&НаКлиенте
Функция ЛокЯдро_ПолучитьДокументыПоЗапросуСКД(НастройкиКомпоновщика, ТипДокумента1С, НаименованиеБП) Экспорт
	
	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода", "Функция");
	СтруктураВызова.Вставить("ИмяМетода", "ОтобратьДокументы1СЧерезСКД");

	ПараметрыМетода = Новый Структура;
	ПараметрыМетода.Вставить("НастройкиКомпоновки",НастройкиКомпоновщика);
	ПараметрыМетода.Вставить("ТипДокумента1С", ТипДокумента1С);
	ПараметрыМетода.Вставить("НазваниеБП", НаименованиеБП);
	ПараметрыМетода.Вставить("ПараметрыУзлов", ЛокЯдро_ПолучитьЗначенияГлобальныхПараметров());
	СтруктураВызова.Вставить("ПараметрыМетода", ПараметрыМетода);
	
	Возврат Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,,АдресаПеременных,3);
КонецФункции

// Используется на форме настройки отбора документов, для предпросмотра выборки по произвольному отбору.
//
// Параметры:
//	ID_ПроизвольногоОтбора - Строка - идентификатор произвольного отбора документов
//	НастройкиКомпоновщика - Неопределено, Строка, НастройкиКомпоновкиДанных - содержит настройки схемы компоновки данных, используемой
//																			  для отбора документов для выгрузки в базу Mobile Smarts
//
// Возвращаемое значение:
//	- Массив из Структура - содержит значения реквизитов и служебные поля (например, количество строк в табличной части) документов, попавших в результат отбора,
//							если ВернутьМассивСтруктур = Истина
//  - ТаблицаЗначений - содержит значения реквизитов и служебные поля (например, количество строк в табличной части) документов, попавших в результат отбора,
//    					если ВернутьМассивСтруктур = Ложь
//	- Неопределено - если отобрать документы не удалось
&НаКлиенте
Функция ЛокЯдро_ПолучитьДокументыПоПроизвольномуОтбору(ID_ПроизвольногоОтбора, НастройкиКомпоновщика = Неопределено) Экспорт
	
	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода", "Функция");
	СтруктураВызова.Вставить("ИмяМетода", "ОтобратьДокументы1СЧерезПроизвольныйОтбор");

	ПараметрыМетода = Новый Структура;
	ПараметрыМетода.Вставить("ID_ПроизвольногоОтбора", ID_ПроизвольногоОтбора);
	ПараметрыМетода.Вставить("ВернутьМассивСтруктур", Истина);
	ПараметрыМетода.Вставить("ДопОтбор", Истина);
	ПараметрыМетода.Вставить("ПараметрыУзлов", Неопределено);
	ПараметрыМетода.Вставить("НастройкиКомпоновкиСтр", НастройкиКомпоновщика);
	СтруктураВызова.Вставить("ПараметрыМетода", ПараметрыМетода);
	
	Возврат Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,,АдресаПеременных);
КонецФункции

// Возвращает флаг попадания ссылки в отбор документов
//
// Параметры:
//	НастройкаОтбора	- Структура - содержит настройку отбора, на попадание в который проверяется документ
//	СсылкаНаДокумент - ДокументСсылка - ссылка на документ, попадание в отбор которого необходимо проверить
//
// Возвращаемое значение:
//	Булево - признак попадания ссылки документа в отбор
&НаКлиенте
Функция ЛокЯдро_ПроверитьПопаданиеСсылкиВОтборДокументов(НастройкаОтбора, СсылкаНаДокумент) Экспорт
	
	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода", "Функция");
	СтруктураВызова.Вставить("ИмяМетода", "ПроверитьПопаданиеСсылкиВОтборДокументов");

	ПараметрыМетода = Новый Структура;
	ПараметрыМетода.Вставить("НастройкаОтбора",НастройкаОтбора);
	ПараметрыМетода.Вставить("СсылкаНаДокумент", СсылкаНаДокумент);
	ПараметрыМетода.Вставить("ПараметрыУзлов", ЛокЯдро_ПолучитьЗначенияГлобальныхПараметров());
	СтруктураВызова.Вставить("ПараметрыМетода", ПараметрыМетода);
	
	Возврат Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,,АдресаПеременных,1);
КонецФункции

&НаКлиенте
Процедура ЛокЯдро_ВыгрузитьНоменклатуруИзДокумента(Документ1С, НастройкаБП,ТипБазы)
			
	МетаданныеНСИ = ЛокЯдро_ПолучитьМетаданныеНСИ();
	НазваниеРеквизитаНоменклатуры = МетаданныеНСИ.Номенклатура.ИмяСправочника;
	
	//Найдем настройку выгрузки ТЧ с номенклатурой и название ТЧ с номенклатурой
	ИмяТЧДокумента = "";
	НастройкиВыгрузкиТЧ = НастройкаБП.НастройкаВыгрузкиТЧ;
	
	Если НастройкиВыгрузкиТЧ = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Для Каждого НастройкаВыгрузкиТЧ из НастройкиВыгрузкиТЧ Цикл
		Если НастройкаВыгрузкиТЧ.Свойство("ЭтоТаблицаЗначений") Тогда
			Продолжить;
		КонецЕсли;
		тчСопоставленияРеквизитов = НастройкаВыгрузкиТЧ.ТабличнаяЧастьДокумента1С;
		НайденныеСтрокиНастройки = ЛокЯдро_НайтиВМассивеСтруктурПоОтбору(тчСопоставленияРеквизитов,Новый Структура("ИмяПриемника","ИдТовара"));
		Если НайденныеСтрокиНастройки <> Неопределено И НайденныеСтрокиНастройки.Количество() > 0 Тогда
			ИмяТЧДокумента = НастройкаВыгрузкиТЧ.НастройкаТЧСтрокой;
			ИмяРеквизитаИсточника = НайденныеСтрокиНастройки[0].ИмяИсточника;
			СписокДополнительныхОбработчиков = ЛокЯдро_ПолучитьСписокДополнительныхОбработчиковПолученияТЧ(НастройкаБП.ТипИсходногоДокумента1С);
			Если ЛокЯдро_СтрНайти(ВРЕГ(ИмяТЧДокумента), "ЗАПРОС") = 0
				И НЕ (СписокДополнительныхОбработчиков <> Неопределено И СписокДополнительныхОбработчиков.Получить(ИмяТЧДокумента) <> Неопределено)
				И СтруктураМетаданных.Документы1С[НастройкаБП.ТипИсходногоДокумента1С].ТабличныеЧасти[ИмяТЧДокумента].Реквизиты.НайтиПоЗначению(НазваниеРеквизитаНоменклатуры) <> Неопределено Тогда
				Прервать;
			Иначе
				ИмяТЧДокумента = "";
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Если ИмяТЧДокумента <> "" Тогда

		МассивНоменклатуры = ЛокЯдро_ВыгрузитьКолонкуИзТЧДокумента(Документ1С,НастройкаВыгрузкиТЧ,НазваниеРеквизитаНоменклатуры,ИмяРеквизитаИсточника);
		
		Если НЕ МассивНоменклатуры.Количество() Тогда
			Возврат;
		КонецЕсли;
		
		НастройкиКомпоновщика = "";
		Отбор = Новый Структура("ИмяТаблицы", "Номенклатура");
		НастройкаКомпоновщикаСтрокой = ЛокЯдро_ПолучитьИзКэшаЗначениеТабличнойНастройкиSMARTS("НастройкиОбменаСправочников", Отбор, "НастройкаКомпоновщикаСтрокой");
		Если ЗначениеЗаполнено(НастройкаКомпоновщикаСтрокой) Тогда
			НастройкиКомпоновщика = ЛокЯдро_ЗначениеИзСтрокиXML(НастройкаКомпоновщикаСтрокой);
		КонецЕслИ;
		
		РаботаБезАлкоголя 					= ЛокЯдро_ПолучитьИзКэшаНастройкуSMARTS("РаботаБезАлкоголя");
		ПараметрыУзлов = ЛокЯдро_ПолучитьЗначенияГлобальныхПараметров();

		ПараметрыВыгрузки = ЛокЯдро_ПолучитьЗаполнитьСтруктуруПараметровВыгрузкиСправочника("Номенклатура");
		
		СтруктураВызова = Новый Структура;
		СтруктураВызова.Вставить("ТипМетода", "Функция");
		СтруктураВызова.Вставить("ИмяМетода", "ПолучитьПорциюДанныхДляВыгрузки");
		СтруктураВызова.Вставить("ПараметрыМетода", Новый Структура("ИмяТаблицы,НастройкиКомпоновщика,ПараметрыКомпоновщика, ТипБазы,ОтборПоНоменклатуре,РаботаБезАлкоголя, ПараметрыВыгрузки, ID_БазыSMARTS", "Номенклатура", НастройкиКомпоновщика,"", ТипБазы,МассивНоменклатуры,РаботаБезАлкоголя, ПараметрыВыгрузки, ""));
		ДанныеДляВыгрузки = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,ложь,АдресаПеременных);
		
		флОчищатьСправочникПередВыгрузкой = Ложь;
		
		ТипИнтерфейса = ЛокЯдро_ПолучитьТипИнтерфейса(ТипБазы); // ТипИнтерфейса = КомЯдро_ПолучитьЗначениеПеременной("ТипИнтерфейса");
		
		Если РасположениеКомпоненты = "НаСервере" Тогда
			СтруктураВызова = Новый Структура;
			СтруктураВызова.Вставить("ТипМетода", "Функция");
			СтруктураВызова.Вставить("ИмяМетода", "ВыгрузитьПодготовленныйМассивНаСерверSMARTS");
			СтруктураВызова.Вставить("ПараметрыМетода", Новый Структура("ИмяТаблицы,ДанныеДляВыгрузки,ТипБазы,ОчищатьСправочникПередВыгрузкой", "Номенклатура", ДанныеДляВыгрузки,ТипБазы,флОчищатьСправочникПередВыгрузкой));
			РезультатВыгрузки = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,ложь,АдресаПеременных);
		Иначе
			Если ТипИнтерфейса = "REST_API" Тогда
				РезультатВыгрузки = REST_API_ВыгрузитьТаблицуНаСерверSMARTS("Номенклатура", ДанныеДляВыгрузки, ТипБазы, флОчищатьСправочникПередВыгрузкой);
			Иначе
				РезультатВыгрузки = КомЯдро_ВыгрузитьТаблицуНаСерверSMARTS(ТипБазы, "Номенклатура", ДанныеДляВыгрузки, флОчищатьСправочникПередВыгрузкой);
			КонецЕсли;
		КонецЕсли;
		
		Если НЕ РезультатВыгрузки.Свойство("Статус") ИЛИ НЕ РезультатВыгрузки.Статус = Истина Тогда	
			Если ТипИнтерфейса = "REST_API" Тогда
				Сообщение = РезультатВыгрузки.Сообщение;
			Иначе	
				ОписаниеОшибки = КомЯдро_ПолучитьОшибку(ТипБазы);		
				Сообщение = "Ошибка выгрузки таблицы [Номеклатура]." + Символы.ВК + ОписаниеОшибки;
			КонецЕсли;			
			Сообщить(Сообщение);							
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры

// Вызывает из модуля обработки функцию СписокДополнительныхОбработчиковПолученияТЧ и возвращает результат ее выполнения
//
// Параметры:
//	ТипДокумента - Неопределено, Строка - имя типа документа 1С, для которого требуется получить список дополнительных обработчиков получения табличных частей
//
// Возвращаемое значение:
//	- Соответствие - содержит список дополнительных обработчиков получения табличных частей
//	- Неопределено - если список дополнительных обработчиков получить не удалось
&НаКлиенте
Функция ЛокЯдро_ПолучитьСписокДополнительныхОбработчиковПолученияТЧ(ТипДокумента = Неопределено) Экспорт
	
	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода", "Функция");
	СтруктураВызова.Вставить("ПараметрыМетода", Новый Структура("ТипДокумента",ТипДокумента));
	СтруктураВызова.Вставить("ИмяМетода", "ПолучитьСписокДополнительныхОбработчиковПолученияТЧ");
	
	Возврат Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,,АдресаПеременных);	
	
КонецФункции

// Выгружаем по одному документу для каждого на сервер Mobile Smarts для каждого бизнес-процесса
//
&НаКлиенте
Процедура ЛокЯдро_ВыгрузитьДокументы() Экспорт
	
	ИмяСобытия = "ЛокЯдро_ВыгрузитьДокументы";
	
	МассивБизнесПроцессовСДокументами = Новый Массив;
	РежимОбмена = "Интерактивный";
	
	НастройкиОтборовУзлов = ЛокЯдро_ПолучитьИзКэшаНастройкуSMARTS("НастройкиОтборовУзлов_" + РежимОбмена);
	СтруктураНастроекБизнесПроцессов_ПоУмолчанию = ЛокЯдро_ПолучитьИзКэшаСтруктуруНастроекПоУмолчаниюБизнесПроцессов();
	НастройкиБизнесПроцессов					 = СтруктураНастроекБизнесПроцессов_ПоУмолчанию.НастройкиБизнесПроцессов;
	
	Попытка
		СписокОтобранныхДокументов = ЛокЯдро_ПолучитьСписокДокументов1С(РежимОбмена);
	Исключение
		ТекстОшибки = "Ошибка получения списка документов: " + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", ТекстОшибки);		
	КонецПопытки;
	
	Если ЗначениеЗаполнено(СписокОтобранныхДокументов) Тогда 
		Для Каждого СтрокаДокумента Из СписокОтобранныхДокументов Цикл
			Если СтрокаДокумента.Свойство("ЭтоТаблицаЗначений") Тогда
				Продолжить;	
			КонецЕсли;
			
			Попытка
				
				Если ЗначениеЗаполнено(СтрокаДокумента.НастройкаБизнесПроцесса) Тогда
					ID_БизнесПроцесса = СтрокаДокумента.НастройкаБизнесПроцесса;					
				Иначе
					
					НайденныеСтроки = Новый Массив;
					Если НастройкиБизнесПроцессов <> Ложь Тогда
						Для Каждого НастройкаБизнесПроцесса Из НастройкиБизнесПроцессов Цикл
							Если НастройкаБизнесПроцесса.Свойство("ЭтоТаблицаЗначений") Тогда
								Продолжить;
							КонецЕсли;
							
							ИспользуемыеОтборыУзлов = ЛокЯдро_НайтиВМассивеСтруктурПоОтбору(НастройкиОтборовУзлов, Новый Структура("Используется, ID_БизнесПроцесса", Истина, НастройкаБизнесПроцесса.ID_БизнесПроцесса));
							Если НастройкаБизнесПроцесса.Свойство("Используется") И НастройкаБизнесПроцесса.Используется
								И НастройкаБизнесПроцесса.Свойство("ТипИсходногоДокумента1С")
								И НастройкаБизнесПроцесса.ТипИсходногоДокумента1С = СокрЛП(СтрокаДокумента.ТипДокумента1С) 
								И ИспользуемыеОтборыУзлов <> Неопределено 
								И ИспользуемыеОтборыУзлов.Количество() Тогда				
								НайденныеСтроки.Добавить(НастройкаБизнесПроцесса);
							КонецЕсли;
						КонецЦикла;
					КонецЕсли;
					
					Если НЕ НайденныеСтроки.Количество() Тогда
						//Запись в ЖР
						ТекстОшибки = "Для типа документа " + СтрокаДокумента.ТипДокумента1С + " нет настроенного или активного бизнес-процесса";
						ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", ТекстОшибки);
						Продолжить;
					ИначеЕсли НайденныеСтроки.Количество() >= 1 Тогда
						//Берем первый бизнес-процесс
						ID_БизнесПроцесса = НайденныеСтроки[0].ID_БизнесПроцесса;
					КонецЕсли;
					
				КонецЕсли;
				
			Исключение
				//Запись в ЖР
				ТекстОшибки = "Ошибка получения бизнес-процесса для документа " + СтрокаДокумента.ТипДокумента1С + " : " + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
				ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", ТекстОшибки);				
				Продолжить;
			КонецПопытки;
			
			БизнесПроцессНаименование = "";
			Если НастройкиОтборовУзлов <> Ложь Тогда
				НастройкиОтбораУзлаПоБП = ЛокЯдро_НайтиВМассивеСтруктурПоОтбору(НастройкиОтборовУзлов, Новый Структура("ID_БизнесПроцесса", ID_БизнесПроцесса));
				Если ТипЗнч(НастройкиОтбораУзлаПоБП) = Тип("Массив") 
					И НастройкиОтбораУзлаПоБП.Количество() <> 0 Тогда
					БизнесПроцессНаименование = НастройкиОтбораУзлаПоБП[0].Название;
				КонецЕсли;
			КонецЕсли;
			
			МассивБизнесПроцессовСДокументами.Добавить(ID_БизнесПроцесса);
			
			Попытка
				НачалоСобытия 	= ТекущаяУниверсальнаяДатаВМиллисекундах();

				ЛокЯдро_ВыгрузитьДокументВБазуSMARTS(СтрокаДокумента.Ссылка, ID_БизнесПроцесса, Неопределено, "Основная");
				ТекстИнформации = "Выгружен документ " + СтрокаДокумента.Ссылка + " по бизнес-процессу " + БизнесПроцессНаименование;
				ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", ТекстИнформации, НачалоСобытия);
			Исключение
				//Запись в ЖР
				ТекстОшибки = "Ошибка выгрузки документа " + СтрокаДокумента.ТипДокумента1С + " по бизнес-процессу " + БизнесПроцессНаименование + ": " + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
				ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", ТекстОшибки);				
				Продолжить;
			КонецПопытки;

		КонецЦикла;
	КонецЕсли;

	Если НастройкиОтборовУзлов <> Ложь Тогда
		Для каждого НастройкаОтборовУзла Из НастройкиОтборовУзлов Цикл
			
			Если НастройкаОтборовУзла.Свойство("ЭтоТаблицаЗначений") Тогда
				Продолжить;
			КонецЕсли;
			
			Если МассивБизнесПроцессовСДокументами.Найти(НастройкаОтборовУзла.ID_БизнесПроцесса) = Неопределено Тогда
				
				//Запись в ЖР, что по БП не найдено документов для выгрузки
				ТекстОшибки = "По бизнес-процессу " + НастройкаОтборовУзла.Название + " не была найдено ни одного документа";
				ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Предупреждение", ТекстОшибки);
				
			КонецЕсли;
			
		КонецЦикла;
	КонецЕсли;

КонецПроцедуры

// Выводит список подключенных расширений и патчей
//
&НаКлиенте
Процедура ЛокЯдро_ПроверитьПодключенныеРасширенияИПатчи() Экспорт
	
	ИмяСобытия = "ЛокЯдро_ПроверитьПодключенныеРасширенияИПатчи";

	#Область СовместимыйКодFresh
	//Попытка
	//	
	//	СтруктураПараметров = ПередаваемыеВОбработчикОжиданияПараметры;
	//			
	//	ЛокЯдро_ЗаписатьНачалоВыполненияАвтотеста(ИмяСобытия);
	#КонецОбласти //СовместимыйКодFresh
				
		СтруктураВызова = Новый Структура;
		СтруктураВызова.Вставить("ТипМетода", "Процедура");
		СтруктураВызова.Вставить("ИмяМетода", "ПроверитьПодключенныеРасширенияИПатчи");
		СтруктураДанныеБазы = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,, АдресаПеременных);	
		
	#Область СовместимыйКодFresh
	//	ЛокЯдро_ЗаписатьОкончаниеВыполненияАвтотеста(ИмяСобытия);
	//	
	//Исключение
	//	ИнфоОбОшибке = ИнформацияОбОшибке();
	//	ТекстОшибки = ПодробноеПредставлениеОшибки(ИнфоОбОшибке);
	//	ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Ошибка выполнения автотеста" + 
	//	" по причине: " + Символы.ПС + ТекстОшибки);
	//КонецПопытки;
	#КонецОбласти //СовместимыйКодFresh

КонецПроцедуры

// Проверяет доступность работы с документами 1с
//
&НаКлиенте
Процедура ЛокЯдро_ПроверитьДоступностьРаботыСДокументами1С() Экспорт
	
	ИмяСобытия = "ЛокЯдро_ПроверитьДоступностьРаботыСДокументами1С";
	
	#Область СовместимыйКодFresh
	//Попытка
	//	
	//	СтруктураПараметров = ПередаваемыеВОбработчикОжиданияПараметры;
	//			
	//	ЛокЯдро_ЗаписатьНачалоВыполненияАвтотеста(ИмяСобытия);
	#КонецОбласти //СовместимыйКодFresh
		
		МассивИменТиповДокументов1С 	= Новый Массив;
		
		// Получение типов используемых документов
		СтруктураНастроекБизнесПроцессов_ПоУмолчанию = ЛокЯдро_ПолучитьИзКэшаСтруктуруНастроекПоУмолчаниюБизнесПроцессов();
		НастройкиБизнесПроцессов					 = СтруктураНастроекБизнесПроцессов_ПоУмолчанию.НастройкиБизнесПроцессов;
		
		Если НастройкиБизнесПроцессов <> Ложь Тогда
			Для каждого НастройкаБизнесПроцесса Из НастройкиБизнесПроцессов Цикл
				
				Если НастройкаБизнесПроцесса.Свойство("ЭтоТаблицаЗначений") Тогда
					Продолжить;
				КонецЕсли;
				
				Если ЗначениеЗаполнено(НастройкаБизнесПроцесса.ТипИсходногоДокумента1С)
					И МассивИменТиповДокументов1С.Найти(НастройкаБизнесПроцесса.ТипИсходногоДокумента1С) = Неопределено Тогда
					МассивИменТиповДокументов1С.Добавить(НастройкаБизнесПроцесса.ТипИсходногоДокумента1С);
				КонецЕсли;
				
				Если МассивИменТиповДокументов1С.Найти(НастройкаБизнесПроцесса.ТипРезультирующегоДокумента1С) = Неопределено Тогда
					МассивИменТиповДокументов1С.Добавить(НастройкаБизнесПроцесса.ТипРезультирующегоДокумента1С);
				КонецЕсли;
				
			КонецЦикла;
		КонецЕсли;
		
		СтруктураВызова = Новый Структура;
		СтруктураВызова.Вставить("ТипМетода", "Процедура");
		СтруктураВызова.Вставить("ИмяМетода", "ПроверитьДоступностьРаботыСДокументами1С");
		СтруктураВызова.Вставить("ПараметрыМетода", Новый Структура("МассивИменТиповДокументов1С", МассивИменТиповДокументов1С));
		СтруктураДанныеБазы = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,,АдресаПеременных);	
		
	#Область СовместимыйКодFresh
	//	ЛокЯдро_ЗаписатьОкончаниеВыполненияАвтотеста(ИмяСобытия);
	//	
	//Исключение
	//	ИнфоОбОшибке = ИнформацияОбОшибке();
	//	ТекстОшибки = ПодробноеПредставлениеОшибки(ИнфоОбОшибке);
	//	ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Ошибка выполнения автотеста" + 
	//	" по причине: " + Символы.ПС + ТекстОшибки);
	//КонецПопытки;
	#КонецОбласти //СовместимыйКодFresh

КонецПроцедуры

// Получает список используемых бизнес-процессов и их отборов
//
&НаКлиенте
Процедура ЛокЯдро_ПолучитьСписокВсехБизнесПроцессов() Экспорт
	
	ИмяСобытия = "ЛокЯдро_ПолучитьСписокВсехБизнесПроцессов";
	
	#Область СовместимыйКодFresh
	//Попытка
	//	
	//	СтруктураПараметров = ПередаваемыеВОбработчикОжиданияПараметры;
	//			
	//	ЛокЯдро_ЗаписатьНачалоВыполненияАвтотеста(ИмяСобытия);
	#КонецОбласти //СовместимыйКодFresh
		
		// Получение списка БП и вывод в ЖР информации по используемым
		НастройкиБизнесПроцессов = ЛокЯдро_ПолучитьОбщуюСтруктуруБизнесПроцессов();
		
		Для Каждого НастройкаБизнесПроцесса Из НастройкиБизнесПроцессов Цикл
			
			Если НастройкаБизнесПроцесса.Свойство("ЭтоТаблицаЗначений") Тогда
				Продолжить;
			КонецЕсли;
			
			Если НастройкаБизнесПроцесса.Используется Тогда                                                                          				
				ТекстИспользования = "(Используется) ";
			Иначе
				ТекстИспользования = "(Не используется) ";
			КонецЕсли;
			
			ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", ТекстИспользования + НастройкаБизнесПроцесса.Название);				
			
			ЛокЯдро_ПолучитьСписокОтборовБизнесПроцесса(НастройкаБизнесПроцесса.ID_БизнесПроцесса);
			
		КонецЦикла;
		
	#Область СовместимыйКодFresh
	//	ЛокЯдро_ЗаписатьОкончаниеВыполненияАвтотеста(ИмяСобытия);
	//	
	//Исключение
	//	ИнфоОбОшибке = ИнформацияОбОшибке();
	//	ТекстОшибки = ПодробноеПредставлениеОшибки(ИнфоОбОшибке);
	//	ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Ошибка выполнения автотеста" + 
	//	" по причине: " + Символы.ПС + ТекстОшибки);
	//КонецПопытки;
	#КонецОбласти //СовместимыйКодFresh

КонецПроцедуры

// Проверяет бизнес-процессы на момент ошибок, когда включен отбор, но выключен или отсутсвует бизнес процесс, 
// и наоборот, когда выключен отбор, но есть включенный бизнес-процесс
//
&НаКлиенте
Процедура ЛокЯдро_ПроверкаСоответствияИспользованияБизнесПроцессовИОтборов() Экспорт
	
	ИмяСобытия = "ЛокЯдро_ПроверкаСоответствияИспользованияБизнесПроцессовИОтборов";
	
	#Область СовместимыйКодFresh
	//Попытка
	//	
	//	СтруктураПараметров = ПередаваемыеВОбработчикОжиданияПараметры;
	//			
	//	ЛокЯдро_ЗаписатьНачалоВыполненияАвтотеста(ИмяСобытия);
	#КонецОбласти //СовместимыйКодFresh
		
		// Получение списка БП и вывод в ЖР информации по используемым
		НастройкиБизнесПроцессов 		= ЛокЯдро_ПолучитьОбщуюСтруктуруБизнесПроцессов();
		ОтборыБизнесПроцессовРучные 	= ЛокЯдро_ПолучитьИзКэшаНастройкуSMARTS("НастройкиОтборовУзлов_Интерактивный");
		ОтборыБизнесПроцессовОнлайн 	= ЛокЯдро_ПолучитьИзКэшаНастройкуSMARTS("НастройкиОтборовУзлов_Онлайн");
		
		Для Каждого НастройкаБизнесПроцесса Из НастройкиБизнесПроцессов Цикл
			
			Если ОтборыБизнесПроцессовРучные = Ложь 
				Или ОтборыБизнесПроцессовОнлайн = Ложь Тогда
				Продолжить;
			КонецЕсли;
			
			ОтбораБП_Ручной = ЛокЯдро_НайтиВМассивеСтруктурПоОтбору(ОтборыБизнесПроцессовРучные, Новый Структура("ID_БизнесПроцесса", НастройкаБизнесПроцесса.ID_БизнесПроцесса));
			ОтбораБП_Онлайн = ЛокЯдро_НайтиВМассивеСтруктурПоОтбору(ОтборыБизнесПроцессовОнлайн, Новый Структура("ID_БизнесПроцесса", НастройкаБизнесПроцесса.ID_БизнесПроцесса));
			
			ОтборВключенРучной = Неопределено;
			ОтборВключенОнлайн = Неопределено;
			
			Если ТипЗнч(ОтбораБП_Ручной) = Тип("Массив") И ОтбораБП_Ручной.Количество() Тогда
				ОтборВключенРучной = ОтбораБП_Ручной[0].Используется;
			КонецЕсли;
			Если ТипЗнч(ОтбораБП_Онлайн) = Тип("Массив") И ОтбораБП_Онлайн.Количество() Тогда
				ОтборВключенОнлайн = ОтбораБП_Онлайн[0].Используется;
			КонецЕсли;
			
			Если НастройкаБизнесПроцесса.Используется И ОтборВключенРучной = Ложь И ОтборВключенОнлайн = Ложь Тогда                                                                          				
				ТекстКомментария = "Бизнес-процесс: " + НастройкаБизнесПроцесса.Название + " - используется, но выключены отборы по нему";
			ИначеЕсли Не НастройкаБизнесПроцесса.Используется И ОтборВключенРучной = Истина И ОтборВключенОнлайн = Истина Тогда
				ТекстКомментария = "Бизнес-процесс: " + НастройкаБизнесПроцесса.Название + " - не используется, но отборы по нему включены";
			Иначе
				Продолжить;
			КонецЕсли;                                                                                                                                  
			
			ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Предупреждение", ТекстКомментария);									
			
		КонецЦикла;                                                                                          			
		
	#Область СовместимыйКодFresh
	//	ЛокЯдро_ЗаписатьОкончаниеВыполненияАвтотеста(ИмяСобытия);
	//	
	//Исключение
	//	ИнфоОбОшибке = ИнформацияОбОшибке();
	//	ТекстОшибки = ПодробноеПредставлениеОшибки(ИнфоОбОшибке);
	//	ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Ошибка выполнения автотеста" + 
	//	" по причине: " + Символы.ПС + ТекстОшибки);
	//КонецПопытки;
	#КонецОбласти //СовместимыйКодFresh

КонецПроцедуры

// Получает список глобальных переменных и их значений
//
&НаКлиенте
Процедура ЛокЯдро_ПолучитьСписокГлобальныхПеременныхИЗначений() Экспорт
	
	ИмяСобытия = "ЛокЯдро_ПолучитьСписокГлобальныхПеременныхИЗначений";
	
	#Область СовместимыйКодFresh
	//Попытка
	//	
	//	СтруктураПараметров = ПередаваемыеВОбработчикОжиданияПараметры;
	//			
	//	ЛокЯдро_ЗаписатьНачалоВыполненияАвтотеста(ИмяСобытия);
	#КонецОбласти //СовместимыйКодFresh
		
		// Получение списка глобальных переменных
		ГлобальныеПараметры = ЛокЯдро_ПолучитьИзКэшаНастройкуSMARTS("ГлобальныеПараметры");
		
		Если ГлобальныеПараметры <> Ложь Тогда
			
			Для Каждого СтруктураГлобальногоПараметра Из ГлобальныеПараметры Цикл			
				
				Если СтруктураГлобальногоПараметра.Свойство("ЭтоТаблицаЗначений") Тогда
					Продолжить;
				КонецЕсли;
				
				Если СтруктураГлобальногоПараметра.Использование Тогда                                         
					ЗначениеГлПараметра = СтруктураГлобальногоПараметра.Значение;
					ТекстКомментария = СтруктураГлобальногоПараметра.Наименование + ": " + ?(ЗначениеЗаполнено(ЗначениеГлПараметра), ЗначениеГлПараметра, "<не заполнено>");
					ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", ТекстКомментария);				
				КонецЕсли;
				
			КонецЦикла;
			
		КонецЕсли;
		
	#Область СовместимыйКодFresh
	//	ЛокЯдро_ЗаписатьОкончаниеВыполненияАвтотеста(ИмяСобытия);
	//	
	//Исключение
	//	ИнфоОбОшибке = ИнформацияОбОшибке();
	//	ТекстОшибки = ПодробноеПредставлениеОшибки(ИнфоОбОшибке);
	//	ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Ошибка выполнения автотеста" + 
	//	" по причине: " + Символы.ПС + ТекстОшибки);
	//КонецПопытки;
	#КонецОбласти //СовместимыйКодFresh

КонецПроцедуры

// Получает список макетов СКД для выгрузки из 1С и соответствующих им справочников
//
&НаКлиенте
Процедура ЛокЯдро_ПолучитьСписокМакетовСКДДляВыгрузкиСправочников() Экспорт
	
	ИмяСобытия = "ЛокЯдро_ПолучитьСписокМакетовСКДДляВыгрузкиСправочников";
	
	#Область СовместимыйКодFresh
	//Попытка
	//	
	//	СтруктураПараметров = ПередаваемыеВОбработчикОжиданияПараметры;
	//			
	//	ЛокЯдро_ЗаписатьНачалоВыполненияАвтотеста(ИмяСобытия);
	#КонецОбласти //СовместимыйКодFresh
		
		СписокИспользуемыхСправочников = ЛокЯдро_ПолучитьСписокИспользуемыхСправочников();
		
		//Может вернуться неопределено в случае, если нет интеграционной обработки
		//Попробуем получить ИО снова
		Если СписокИспользуемыхСправочников = Неопределено Тогда
			
			Если РасположениеКомпоненты = Неопределено Тогда
				РасположениеКомпоненты = ЛокЯдро_ПолучитьДанныеИзХранилища1С("Cleverence_РасположениеКомпоненты");
			КонецЕсли;
			ЛокЯдро_ПодключитьИнтеграционнуюОбработку(РасположениеКомпоненты);
			
			СписокИспользуемыхСправочников = ЛокЯдро_ПолучитьСписокИспользуемыхСправочников();
			Если СписокИспользуемыхСправочников = Неопределено Тогда
				Возврат;
			КонецЕсли;
			
		КонецЕсли;
		
		МассивСтруктурИменСправочников = Новый Массив;	
		
		Для Каждого ЭлементСписка Из СписокИспользуемыхСправочников Цикл		
			МассивСтруктурИменСправочников.Добавить(Новый Структура("ИмяСправочника, ИмяМакета", ЭлементСписка.Значение, ""));		
		КонецЦикла;
		
		МассивСтруктурИменМакетов = ЛокЯдро_ПолучитьМассивСтруктурМакетовИОПоУмолчанию(МассивСтруктурИменСправочников);
		
		Для Каждого СтруктураИменМакетов Из МассивСтруктурИменМакетов Цикл
			
			Если ПустаяСтрока(СтруктураИменМакетов.ИмяМакета) Тогда
				ТекстКомментария = СтруктураИменМакетов.ИмяСправочника + " : макет СКД для выгрузки не найден";
			Иначе
				ТекстКомментария = СтруктураИменМакетов.ИмяСправочника + " : выгружается по макету СКД <" + СтруктураИменМакетов.ИмяМакета + ">";
			КонецЕсли;		
			
			ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", ТекстКомментария);
			
		КонецЦикла;
		
	#Область СовместимыйКодFresh
	//	ЛокЯдро_ЗаписатьОкончаниеВыполненияАвтотеста(ИмяСобытия);
	//	
	//Исключение
	//	ИнфоОбОшибке = ИнформацияОбОшибке();
	//	ТекстОшибки = ПодробноеПредставлениеОшибки(ИнфоОбОшибке);
	//	ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Ошибка выполнения автотеста" + 
	//	" по причине: " + Символы.ПС + ТекстОшибки);
	//КонецПопытки;
	#КонецОбласти //СовместимыйКодFresh

КонецПроцедуры

// Проверяет корректность работы бизнес-процессов (типы метаданных, обработчики, реквизиты)
&НаКлиенте
Процедура ЛокЯдро_ПроверитьКорректностьНастроекБизнесПроцессов() Экспорт
	
	ИмяСобытия = "ЛокЯдро_ПроверитьКорректностьНастроекБизнесПроцессов";
	
	#Область СовместимыйКодFresh
	//Попытка
	//	
	//	СтруктураПараметров = ПередаваемыеВОбработчикОжиданияПараметры;
	//			
	//	ЛокЯдро_ЗаписатьНачалоВыполненияАвтотеста(ИмяСобытия);
	#КонецОбласти //СовместимыйКодFresh
		
		// Получение типов используемых документов
		НастройкиБизнесПроцессов = ЛокЯдро_ПолучитьОбщуюСтруктуруБизнесПроцессов();	
		
		МассивИменТиповДокументов1С = Новый Массив;
		МассивИменТиповДокументовMS = Новый Массив;
		
		МассивПроверенныхОбработчиков 	= Новый Массив;
		МассивИтоговПроверки 			= Новый Массив;
		
		Для Каждого НастройкаБизнесПроцесса Из НастройкиБизнесПроцессов Цикл
			
			МассивОшибокБП 			= Новый Массив;
			
			СтрМетаданных = Новый Структура("МетаданныеДокMS,МетаданныеДок1СВыгрузка,МетаданныеДок1СЗагрузка", Неопределено, Неопределено, Неопределено);
			
			СтруктураПроверки = Новый Структура;
			СтруктураПроверки.Вставить("ID_БизнесПроцесса",	НастройкаБизнесПроцесса.ID_БизнесПроцесса);
			СтруктураПроверки.Вставить("Название", 			НастройкаБизнесПроцесса.Название);
			СтруктураПроверки.Вставить("ОшибкаБП", 			Ложь);
			СтруктураПроверки.Вставить("СтороннийБП", 		Ложь);
			
			// Проверяем корректность основных настроек метаданных
			ЛокЯдро_ПроверитьКорректностьТипаМетаданных(
			НастройкаБизнесПроцесса.ТипДокументаMS,
			"ДокументыMS", 
			МассивИменТиповДокументовMS, 
			СтрМетаданных.МетаданныеДокMS,
			СтруктураПроверки, 
			МассивОшибокБП);
			
			Если Не СтруктураПроверки.СтороннийБП Тогда
				
				ЛокЯдро_ПроверитьКорректностьТипаМетаданных(
				НастройкаБизнесПроцесса.ТипИсходногоДокумента1С,
				"Документы1С", 
				МассивИменТиповДокументов1С,
				СтрМетаданных.МетаданныеДок1СВыгрузка,
				СтруктураПроверки, 
				МассивОшибокБП);			
				ЛокЯдро_ПроверитьКорректностьТипаМетаданных(
				НастройкаБизнесПроцесса.ТипРезультирующегоДокумента1С, 	
				"Документы1С", 
				МассивИменТиповДокументов1С, 
				СтрМетаданных.МетаданныеДок1СЗагрузка,
				СтруктураПроверки, 
				МассивОшибокБП);					
				
				// Если проблема с метаданными в настройках, то нет смысла проверять дальше их составляющие
				Если Не СтруктураПроверки.ОшибкаБП Тогда
					
					// Проверка обработчиков
					ЛокЯдро_ПроверитьДоступностьОбработчиковЗагрузки(НастройкаБизнесПроцесса, МассивПроверенныхОбработчиков, СтруктураПроверки, МассивОшибокБП);
					
					// Проверка произвольных кодов и обработчиков
					ЛокЯдро_ПроверитьДоступностьИКорректностьПроизвольныхОбработчиков(НастройкаБизнесПроцесса, СтруктураПроверки, МассивОшибокБП);		                                                          	
					
					// Проверка настроек загрузки/выгрузки шапки и ТЧ документа
					ЛокЯдро_ПроверитьКорректностьНастроекОбработкиПолейИТабличныхЧастей(НастройкаБизнесПроцесса, СтрМетаданных, СтруктураПроверки, МассивОшибокБП);
					
				КонецЕсли;
				
				// Подставляем список найденных ошибок в строку проверки текущего бизнес-процесса
				СтруктураПроверки.Вставить("МассивОшибок", МассивОшибокБП);
				
			КонецЕсли;
			
			МассивИтоговПроверки.Добавить(СтруктураПроверки);
			
		КонецЦикла;
		
		МассивСтороннихБП = Новый Массив;
		
		// Выводим полученную информацию
		Для Каждого ЭлементПроверки Из МассивИтоговПроверки Цикл
			
			Если ЭлементПроверки.ОшибкаБП Тогда
				
				МассивОшибок = ЭлементПроверки.МассивОшибок;
				
				ТекстКомментария = "При проверке настроек бизнес-процесса <" + ЭлементПроверки.Название + "> выявлено " + МассивОшибок.Количество() + " ошибки(-ок):";
				ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", ТекстКомментария);		
				
				Для Каждого Ошибка Из МассивОшибок Цикл
					ТекстКомментария = " - " + Ошибка;
					ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", ТекстКомментария);		
				КонецЦикла;
				
			ИначеЕсли ЭлементПроверки.СтороннийБП Тогда
				
				МассивСтороннихБП.Добавить(ЭлементПроверки.ID_БизнесПроцесса);
				ТекстКомментария = "Проверка настроек бизнес-процесса <" + ЭлементПроверки.Название + "> не проводилась, т.к. он не входит в данный программный продукт.";
				ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Предупреждение", ТекстКомментария);		
				
			Иначе
				
				ТекстКомментария = "Проверка настроек бизнес-процесса <" + ЭлементПроверки.Название + "> прошла успешно";
				ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", ТекстКомментария);
				
			КонецЕсли;		
			
		КонецЦикла;
		
		// Запоминаем список бизнес-процессов, для последующей фильтрации выгрузки документов
		ЛокЯдро_ЗаписатьВКэшНастройкуSMARTS("СторонниеБизнесПроцессы", МассивСтороннихБП);
		
	#Область СовместимыйКодFresh
	//	ЛокЯдро_ЗаписатьОкончаниеВыполненияАвтотеста(ИмяСобытия);
	//	
	//Исключение
	//	ИнфоОбОшибке = ИнформацияОбОшибке();
	//	ТекстОшибки = ПодробноеПредставлениеОшибки(ИнфоОбОшибке);
	//	ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Ошибка выполнения автотеста" + 
	//	" по причине: " + Символы.ПС + ТекстОшибки);
	//КонецПопытки;
	#КонецОбласти //СовместимыйКодFresh

КонецПроцедуры

&НаКлиенте
Функция ЛокЯдро_ПолучениеУстройстваПоПинкодуДляВыгрузкиДокумента(ПинКод, ТипБазы) Экспорт
	
	Если Не ЛокЯдро_ПроверкаКонтрольнойЦифры(ПинКод) Тогда	
		Возврат Неопределено;                             		
	КонецЕсли;
	
	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода", "Функция");
	СтруктураВызова.Вставить("ИмяМетода", "ПолучениеУстройстваПоПинкодуДляВыгрузкиДокумента");

	ПараметрыМетода = Новый Структура;
	ПараметрыМетода.Вставить("ПинКод",	ПинКод);
	ПараметрыМетода.Вставить("ТипБазы", ТипБазы);
	СтруктураВызова.Вставить("ПараметрыМетода", ПараметрыМетода);
	
	Возврат Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,, АдресаПеременных);
	
 КонецФункции

// Проверяет корректность переданного пин-кода по алгоритму Луна
//
&НаКлиенте
Функция ЛокЯдро_ПроверкаКонтрольнойЦифры(ПинКод)
	
	Количество = СтрДлина(ПинКод) + 1;    
	Сумма = 0;
	
	Для Инд = 1 По (Количество - 1) Цикл
		
		ТекЧисло = Сред(ПинКод, (Количество - Инд), 1);
		
		Если (Инд / 2 = Цел(Инд / 2)) Тогда
			ТекЧисло = 2 * ТекЧисло;
			Если (ТекЧисло > 9) then 
				ТекЧисло = ТекЧисло - 9;
			КонецЕсли;
		КонецЕсли;
		
		Сумма = Сумма + ТекЧисло;   
		
	КонецЦикла;
	
	Итог = (Сумма / 10) - Цел(Сумма / 10);
	
	Возврат Итог = 0; 
	
 КонецФункции

// Получает массив документов SMARTS из бэкапов за период
//
&НаКлиенте
Функция ЛокЯдро_ПолучениеАрхивныхДокументовSMARTS(ПараметрыЗапроса, ФильтрыЗапроса, ТипБазы) Экспорт

	Если РасположениеКомпоненты = "НаСервере" Тогда
		СтруктураВызова = Новый Структура;
		СтруктураВызова.Вставить("ТипМетода", "Функция");
		СтруктураВызова.Вставить("ИмяМетода", "ПолучениеАрхивныхДокументовSMARTS");

		ПараметрыМетода = Новый Структура;
		ПараметрыМетода.Вставить("ПараметрыЗапроса",	ПараметрыЗапроса);		
		ПараметрыМетода.Вставить("ФильтрыЗапроса",		ФильтрыЗапроса);		
		ПараметрыМетода.Вставить("ТипБазы", 			ТипБазы);
		
		СтруктураВызова.Вставить("ПараметрыМетода", ПараметрыМетода);
		
		Возврат Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,, АдресаПеременных);
	Иначе
		Возврат ЛокЯдро_ПолучитьАрхивныеДокументыSMARTS(ПараметрыЗапроса, ФильтрыЗапроса, ТипБазы);	
	КонецЕсли;
	
 КонецФункции
 
// Загружает массив архивных документов SMARTS на сервер
//
&НаКлиенте
Функция ЛокЯдро_ВосстановитьДокументыSMARTS(МассивДокументов, ТипБазы) Экспорт

	Если РасположениеКомпоненты = "НаСервере" Тогда
		СтруктураВызова = Новый Структура;
		СтруктураВызова.Вставить("ТипМетода", "Функция");
		СтруктураВызова.Вставить("ИмяМетода", "ВосстановитьДокументыSMARTS");

		ПараметрыМетода = Новый Структура;
		ПараметрыМетода.Вставить("МассивДокументов",	МассивДокументов);	
		ПараметрыМетода.Вставить("ТипБазы", 			ТипБазы);
		
		СтруктураВызова.Вставить("ПараметрыМетода", 	ПараметрыМетода);
		
		Возврат Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,, АдресаПеременных);
	Иначе
		Возврат ЛокЯдро_ВосстановитьАрхивныеДокументыSMARTS(МассивДокументов, ТипБазы);	
	КонецЕсли;
	
КонецФункции

&НаКлиенте
Функция ЛокЯдро_ПолучитьАрхивныеДокументыSMARTS(ПараметрыЗапроса, ФильтрыЗапроса, ТипБазы)
	
	ИмяСобытия = "ЛокЯдро_ПолучитьАрхивныеДокументыSMARTS";
	
	МассивДокументов = Новый Массив;
	
	// Получаем настройки подключения
	Если ТипБазы = "Частная" Тогда
		КлючПеременной = "REST_API_СтруктураПодключенияЧастнойБазыMS";
	ИначеЕсли ТипБазы = "Временная" Тогда
		КлючПеременной = "REST_API_СтруктураПодключенияВременнойБазыMS";
	Иначе
		КлючПеременной = "REST_API_СтруктураПодключенияБазыMS";
	КонецЕсли;
	
	СтруктураПодключения = КомЯдро_ПолучитьЗначениеПеременной(КлючПеременной); 
	
	Если СтруктураПодключения = Неопределено Тогда
		Возврат МассивДокументов;
	КонецЕсли;
	
	ОтправляемыеДанные = Новый Соответствие;	
	Для Каждого СтрПараметра Из ПараметрыЗапроса Цикл
		ОтправляемыеДанные.Вставить(СтрПараметра.Ключ, СтрПараметра.Значение);				
	КонецЦикла;                                                               	
	
	ТекстМетода = "Operations('ПолучитьАрхДокументы')";
	
	Если ЗначениеЗаполнено(ФильтрыЗапроса) Тогда
		ТекстМетода = ТекстМетода + "?$filter=";
		Для Каждого СтрФильтра Из ФильтрыЗапроса Цикл
			Если (СтрФильтра.Ключ = "id")Тогда                                   
				ТекстФильтра = СтрФильтра.Ключ + " eq '" + СтрФильтра.Значение + "' and ";				
			Иначе
				ТекстФильтра = "contains(" + СтрФильтра.Ключ + ",'" + СтрФильтра.Значение + "') and ";
			КонецЕсли;
			ТекстМетода = ТекстМетода + ТекстФильтра;
		КонецЦикла;
		ТекстМетода = Лев(ТекстМетода, СтрДлина(ТекстМетода) - 5);
	КонецЕсли;                                              
	
	СтруктураОтвета = REST_API_ВыполнитьМетод(
		СтруктураПодключения, 
		Новый Структура("HTTPМетод, Метод, ТипЗапроса", "POST", ТекстМетода, "ПолучениеСпискаДокументов"), 
		ОтправляемыеДанные, 
		АдресаПеременных);
		
	Если СтруктураОтвета.КодСостояния <> 200 Тогда
		
		ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(
			ИмяСобытия, 
			"Ошибка", 
			"Запрос: POST, Operations('ПолучитьАрхДокументы'). Получен некорректный ответ от сервера, Код состояния: " + Строка(СтруктураОтвета.КодСостояния)+ ". Содержание ошибки: " + Строка(СтруктураОтвета.ТекстОшибки));	
			
		Возврат МассивДокументов;
		
	Иначе
		
		Documets = СтруктураОтвета.ОтветСервера.Получить("documentList");	
		Если Documets = Неопределено Тогда
			Возврат МассивДокументов;
		КонецЕсли;
		
	КонецЕсли;		
			
	// Обходим выборку, заполняем массив данных для возврата на форму
	Для Каждого Document Из Documets Цикл
		
		СтруктураДокумента = Новый Структура("Синоним, УИД, ИДУстройства, ИмяФайла, Тип, ВремяБэкапа", "", "", "", "", "", "");
		
		СтруктураДокумента.Синоним 			= Document["name"];
		СтруктураДокумента.УИД 				= Document["id"];
		СтруктураДокумента.ИДУстройства 	= Document["deviceId"];
		
		СтруктураДокумента.ИмяФайла 		= Document["fileName"];		
		СтруктураДокумента.Тип 				= Document["documentTypeName"];
		СтруктураДокумента.ВремяБэкапа		= REST_API_ПреобразоватьКДате(Document["backupTime"]);
		
		МассивДокументов.Добавить(СтруктураДокумента);
		
	КонецЦикла;    	
	
	Возврат МассивДокументов;
	
КонецФункции

&НаКлиенте
Функция ЛокЯдро_ВосстановитьАрхивныеДокументыSMARTS(МассивДокументов, ТипБазы)
	
	ИмяСобытия = "ГлЯдро_ВосстановитьДокументыSMARTS";
	
	// Получаем настройки подключения
	Если ТипБазы = "Частная" Тогда
		КлючПеременной = "REST_API_СтруктураПодключенияЧастнойБазыMS";
	ИначеЕсли ТипБазы = "Временная" Тогда
		КлючПеременной = "REST_API_СтруктураПодключенияВременнойБазыMS";
	Иначе
		КлючПеременной = "REST_API_СтруктураПодключенияБазыMS";
	КонецЕсли;
	
	СтруктураПодключения = КомЯдро_ПолучитьЗначениеПеременной(КлючПеременной); 
	
	Если СтруктураПодключения = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;
	
	МассивДокументовНаВосстановление = Новый Массив;
	
	Для Каждого СтруктураДокумента Из МассивДокументов Цикл
		МассивДокументовНаВосстановление.Добавить(СтруктураДокумента.УИД);		
	КонецЦикла;
	
	ОтправляемыеДанные = Новый Соответствие;
	ОтправляемыеДанные.Вставить("FilesInfo@odata.type", "#Collection(Guid)");
	ОтправляемыеДанные.Вставить("FilesInfo", 			МассивДокументовНаВосстановление);
	
	// Посылаем запрос на сервер
	СтруктураОтвета = REST_API_ВыполнитьМетод(
		СтруктураПодключения, 
		Новый Структура("HTTPМетод, Метод, ТипЗапроса", "POST", "Operations('ВосстановитьДокументы')", "ПолучениеМетаданных"),
		ОтправляемыеДанные,
		АдресаПеременных);	
	
	// Обрабатываем ответ сервера
	Если СтруктураОтвета.КодСостояния < 200 или СтруктураОтвета.КодСостояния >= 300 Тогда
		Результат =  Ложь;
	Иначе
		Результат = СтруктураОтвета.ОтветСервера.Получить("result");			
	КонецЕсли;

	Возврат Результат;
	
КонецФункции 
 
// Вызывает из модуля обработки процедуру обработки документа 1С после отправки данных и записи документа в базу Mobile Smarts
//
// Параметры:
//	Документ1С 				- ДокументСсылка					- ссылка на выгружаемый документ
//	ДанныеДокумента 		- Структура 						- содержит в себе структурированные данные документа для выгрузки в Mobile Smarts. Обязательные поля в структуре:
//		* ШапкаДокумента 		- Структура 		- содержит данные шапки выгружаемого документа
//		* ТабличныеЧасти 		- Структура 		- содержит данные табличных частей выгружаемого документа
//	СтрокаНастройки 		- СтрокаТаблицыЗначений, Структура 	- содержит настройку бизнес-процесса
//  ID_БизнесПроцесса 		- Строка 							- идентификатор бизнес-процесса
//	АдресаПеременных 		- Структура 						- содержит адреса переменных, содержащих текущие настройки подключения Mobile Smarts
//
&НаКлиенте
Процедура ЛокЯдро_ОбработатьДокумент1СПослеВыгрузкиНаСерверSMARTS(Документ1С, ДанныеДокумента, ДанныеНастроекИзКэша = Неопределено, ID_БизнесПроцесса = "", АдресаПеременных) Экспорт
	
	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода", "Процедура");
	СтруктураВызова.Вставить("ИмяМетода", "ОбработатьДокумент1СПослеВыгрузкиНаСерверSMARTS");
	
	СтруктураПараметров = Новый Структура;
	СтруктураПараметров.Вставить("Документ1С", 				Документ1С);
	СтруктураПараметров.Вставить("ДанныеДокумента", 		ДанныеДокумента);
	СтруктураПараметров.Вставить("ДанныеНастроекИзКэша", 	ДанныеНастроекИзКэша);	
	СтруктураПараметров.Вставить("ID_БизнесПроцесса", 		ID_БизнесПроцесса);	
	
	СтруктураВызова.Вставить("ПараметрыМетода", СтруктураПараметров);
	
	Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,, АдресаПеременных);	
	
КонецПроцедуры

// Проверяет, входит ли версия конфигурации 1с в интервал поддерживаемых конфигураций ИО
//
&НаКлиенте
Процедура ЛокЯдро_ПроверитьПоддерживаемыеВерсииКонфигурации() Экспорт

	ИмяСобытия = "ЛокЯдро_ПроверитьПоддерживаемыеВерсииКонфигурации";
	
	#Область СовместимыйКодFresh
	//Попытка
	//	
	//	СтруктураПараметров = ПередаваемыеВОбработчикОжиданияПараметры;
	//			
	//	ЛокЯдро_ЗаписатьНачалоВыполненияАвтотеста(ИмяСобытия);
	#КонецОбласти //СовместимыйКодFresh
		
		ИнформацияСовместимости = ЛокЯдро_ПолучитьИнформациюСовместимости();
		
		Если ТипЗнч(ИнформацияСовместимости) = Тип("Структура") Тогда
			ИнфоОКонфигурации = ЛокЯдро_ПодключеннаяКонфигурация();
			Если ИнформацияСовместимости.флСоответствуетКонфигурации Тогда			
				Если ИнформацияСовместимости.флСоответствуетВерсии Тогда				
					ТекстКомментария = "Проверка поддерживаемых версий конфигурации прошла успешно. Текущая версия конфигурации " + ИнфоОКонфигурации + " входит в интервал " + ИнформацияСовместимости.ПоддерживаемыеВерсииКонфигурации;
					ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", ТекстКомментария);
				Иначе
					ТекстКомментария = "При проверке поддерживаемых версий конфигурации обнаружена ошибка. Текущая версия конфигурации " + ИнфоОКонфигурации + " не поддерживается. Поддерживаемые версии: " + ИнформацияСовместимости.ПоддерживаемыеВерсииКонфигурации;
					ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", ТекстКомментария);
				КонецЕсли;
			Иначе		
				ТекстКомментария = "При проверке поддерживаемых версий конфигурации обнаружена ошибка. Текущая конфигурации " + ИнфоОКонфигурации + " не поддерживается в ИО.";
				ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", ТекстКомментария);
			КонецЕсли;
		Иначе
			ТекстКомментария = "При проверке поддерживаемых версий конфигурации обнаружена ошибка. Не удалось получить информация совместимости.";
			ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", ТекстКомментария);
		КонецЕсли;
		
	#Область СовместимыйКодFresh
	//	ЛокЯдро_ЗаписатьОкончаниеВыполненияАвтотеста(ИмяСобытия);
	//	
	//Исключение
	//	ИнфоОбОшибке = ИнформацияОбОшибке();
	//	ТекстОшибки = ПодробноеПредставлениеОшибки(ИнфоОбОшибке);
	//	ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Ошибка выполнения автотеста" + 
	//	" по причине: " + Символы.ПС + ТекстОшибки);
	//КонецПопытки;
	#КонецОбласти //СовместимыйКодFresh

КонецПроцедуры

// Получает список бизнес-процессов для переданных документов 1С, согласно отборам документов по полученным настройкам
//
// Параметры:
//  РежимОбмена 		- Неопределено, Строка 	- режим обмена - "Интерактивный", "Онлайн", "Автообмен"
//	ОбъектыНазначения 	- Массив из Структура 	- список ссылок на выгружаемые документы 1С
//	ТипДокумента1С 		- Строка 				- тип исходящего документа 1С
//
// Возвращаемое значение:
//	- Массив из Структура 	- содержит:	
//      	* ID_БизнесПроцесса - Строка - идентификатор бизнес-процесса
//			* Название 			- Строка - название бизнес-процесса
//  - Неопределено 			- если не удалось получить список бизнес-процессов
//
&НаКлиенте
Функция ЛокЯдро_ПолучитьБизнесПроцессДляТекущихДокументов(РежимОбмена, ОбъектыНазначения, ТипДокумента1С) Экспорт
	
	// На случай пропажи значений переменных на сервере
	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода", "Функция");
	СтруктураВызова.Вставить("ИмяМетода", "ПолучитьИзКэшаНастройкуSMARTS");
	СтруктураВызова.Вставить("ПараметрыМетода", Новый Структура("КлючНастройки", "Ид"));
	ИдБазыДляПроверкиКэша = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,,АдресаПеременных,1);
			
	Если ИдБазыДляПроверкиКэша = Неопределено Тогда
		ЛокЯдро_Инициализация();
	КонецЕсли;
		
	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода", "Функция");
	СтруктураВызова.Вставить("ИмяМетода", "ПолучитьБизнесПроцессДляТекущихДокументов");
	
	ПараметрыМетода = Новый Структура;
	ПараметрыМетода.Вставить("СписокДокументов", ОбъектыНазначения);
	ПараметрыМетода.Вставить("БизнесПроцессы", ЛокЯдро_ПолучитьИзКэшаНастройкуSMARTS("НастройкиБизнесПроцессов", Истина));
	
	НастройкиОтборов = ЛокЯдро_ПолучитьИзКэшаНастройкуSMARTS("НастройкиОтборовУзлов_" + РежимОбмена);
	Если ТипЗнч(НастройкиОтборов) <> Тип("Массив") Тогда
		НастройкиОтборов = ЛокЯдро_ПолучитьНастройкуНаСервереSMARTS("НастройкиОтборовУзлов_" + РежимОбмена, ДанныеТекущегоУзла.ID_Узла);
	КонецЕсли;
	
	ПараметрыМетода.Вставить("НастройкиОтборов", НастройкиОтборов);
	ПараметрыМетода.Вставить("ПараметрыУзлов", ЛокЯдро_ПолучитьЗначенияГлобальныхПараметров());
	ПараметрыМетода.Вставить("РежимОбмена", РежимОбмена);
	ПараметрыМетода.Вставить("ТипДокумента1С", ТипДокумента1С);
	
	СтруктураВызова.Вставить("ПараметрыМетода", Новый Структура("НастройкиДляМетода", ПараметрыМетода));
	
	Возврат Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,, АдресаПеременных, 1);	
	
КонецФункции

&НаКлиенте
Функция ЛокЯдро_ПроверитьНаличиеСовмещенныхСтрокВНастройкеБП(НастройкаБП)

	ЗапрашиватьCombinedItems = Истина; // По умолчанию запрашиваем CombinedItems
	
	Если ТипЗнч(НастройкаБП) <> Тип("Структура") Тогда
		Возврат ЗапрашиватьCombinedItems;	
	КонецЕсли;		
		
	СовмещенныеСтрокиЗагрузка = Ложь;
	СовмещенныеСтрокаВыгрузка = Ложь;
	
	НастройкаЗагрузкиТЧ = Неопределено;
	НастройкаВыгрузкиТЧ = Неопределено;
	Если НастройкаБП.Свойство("НастройкаЗагрузкиТЧ", НастройкаЗагрузкиТЧ)
		И ТипЗнч(НастройкаЗагрузкиТЧ) = Тип("Массив") Тогда
		СовмещенныеСтрокиЗагрузка = ЛокЯдро_НайтиВМассивеСтруктурПоОтбору(НастройкаЗагрузкиТЧ, Новый Структура("ТабличнаяЧастьДокументаMS", "СовмещенныеСтроки"));
	КонецЕсли;
	Если НастройкаБП.Свойство("НастройкаВыгрузкиТЧ", НастройкаВыгрузкиТЧ)
		И ТипЗнч(НастройкаВыгрузкиТЧ) = Тип("Массив") Тогда
		СовмещенныеСтрокиВыгрузка = ЛокЯдро_НайтиВМассивеСтруктурПоОтбору(НастройкаВыгрузкиТЧ, Новый Структура("ТабличнаяЧастьДокументаMS", "СовмещенныеСтроки"));
	КонецЕсли;
		
	Если СовмещенныеСтрокиЗагрузка = Неопределено
		И СовмещенныеСтрокиВыгрузка = Неопределено Тогда
		ЗапрашиватьCombinedItems = Ложь;				
	КонецЕсли;		
	
    Возврат ЗапрашиватьCombinedItems;
	
КонецФункции

#КонецОбласти

#Область УниверсальныеМеханизмы

// Выводит информационное сообщение при отсутствии соединения с базой Mobile Smarts
//
// Параметры:
//	ЕстьСоединение - Булево - флаг наличия соединения с базой Mobile Smarts	
//	ДопПараметры - Структура - дополнительные параметры
&НаКлиенте
Процедура ЛокЯдро_ИнициализацияПодключениеЧастнойБазыЗавершение(ЕстьСоединение,ДопПараметры) Экспорт
		
	Если НЕ ЕстьСоединение = Истина Тогда
		
		Сообщить("Не удалось подключиться к частной базе ");		
	
	КонецЕсли;
	
КонецПроцедуры

// Удаляет неподходящие для операции группы пользователей из дерева пользователей Mobile SMARTS и помещает во временное хранилище для передачи значения на клиент
// 
// Параметры:
//	Дерево - ДеревоЗначений - дерево пользователей Mobile SMARTS
//
// Возвращаемое значение:
//	Строка - адрес хранилища значений с подготовленным деревом пользователей 
&НаСервере
Функция ЛокЯдро_ПодготовитьДеревоПользователейНаСервере(Знач Дерево) Экспорт
	вПользователиMS = Неопределено;
	
	Если ЭтоАдресВременногоХранилища(Дерево) Тогда
		Дерево = ПолучитьИзВременногоХранилища(Дерево);
	КонецЕсли;
	
	Если Дерево <> Неопределено Тогда
		вПользователиMS = Дерево.Скопировать();
	Иначе
		
	КонецЕсли;
	
	Если Дерево <> Неопределено Тогда
		НайденнаяСтрокаДЗ = вПользователиMS.Строки.Найти("Спрашивать при выгрузке", "ИдГруппыПользователя", Ложь);
	Иначе 
		НайденнаяСтрокаДЗ = Неопределено;
	КонецЕсли;

	Если НайденнаяСтрокаДЗ <> Неопределено Тогда
		вПользователиMS.Строки.Удалить(НайденнаяСтрокаДЗ);
	КонецЕсли;
	
	Возврат ПоместитьВоВременноеХранилище(вПользователиMS,Новый УникальныйИдентификатор());
КонецФункции

// Удаляет неподходящие для операции группы устройств из дерева устройств Mobile SMARTS и помещает во временное хранилище для передачи значения на клиент
// 
// Параметры:
//	Дерево - ДеревоЗначений - дерево устройств Mobile SMARTS
//
// Возвращаемое значение:
//	Строка - адрес хранилища значений с подготовленным деревом устройств
&НаСервере
Функция ЛокЯдро_ПодготовитьДеревоУстройствНаСервере(Знач Дерево) Экспорт
	вУстройстваMS = Неопределено;
	
	Если ЭтоАдресВременногоХранилища(Дерево) Тогда
		Дерево = ПолучитьИзВременногоХранилища(Дерево);
	КонецЕсли;
	
	Если Дерево <> Неопределено Тогда
		вУстройстваMS = Дерево.Скопировать();
		НайденнаяСтрокаДЗ = вУстройстваMS.Строки.Найти("Выгружать всем", "ИдГруппыПользователя", Ложь);
	Иначе 
		НайденнаяСтрокаДЗ = Неопределено;
	КонецЕсли;
	
	// Удалим ненужные для данной формы элементы дерева пользователей
	Если НайденнаяСтрокаДЗ <> Неопределено Тогда
		вУстройстваMS.Строки.Удалить(НайденнаяСтрокаДЗ);
	КонецЕсли;	
	
	Если Дерево <> Неопределено Тогда
		НайденнаяСтрокаДЗ = вУстройстваMS.Строки.Найти("Спрашивать при выгрузке", "ИдГруппыПользователя", Ложь);
	Иначе 
		НайденнаяСтрокаДЗ = Неопределено;
	КонецЕсли;

	Если НайденнаяСтрокаДЗ <> Неопределено Тогда
		вУстройстваMS.Строки.Удалить(НайденнаяСтрокаДЗ);
	КонецЕсли;
	
	Возврат ПоместитьВоВременноеХранилище(вУстройстваMS,Новый УникальныйИдентификатор());
КонецФункции

// Возвращает список подключенных устройств ТСД
// 
// Параметры:
//	Дерево - ДеревоЗначений - дерево устройств Mobile SMARTS
//
// Возвращаемое значение:
//	Массив - список ИД устройств
&НаСервере
Функция ЛокЯдро_ПолучитьМассивПодключенныхУстройствБезВинКлиентовНаСервере(Знач Дерево) Экспорт
	
	вУстройстваMS = Неопределено;
	МассивУстройствMS = Новый Массив;	
	
	Если ЭтоАдресВременногоХранилища(Дерево) Тогда
		Дерево = ПолучитьИзВременногоХранилища(Дерево);
	КонецЕсли;
	
	Если Дерево <> Неопределено Тогда
		вУстройстваMS = Дерево.Скопировать();
		НайденнаяСтрокаДЗ = вУстройстваMS.Строки.Найти("Выгружать всем", "ИдГруппыПользователя", Ложь);
	Иначе 
		Возврат МассивУстройствMS;
	КонецЕсли;
	
	// Удалим ненужные для данной формы элементы дерева пользователей
	Если НайденнаяСтрокаДЗ <> Неопределено Тогда
		вУстройстваMS.Строки.Удалить(НайденнаяСтрокаДЗ);
	КонецЕсли;	
	
	НайденнаяСтрокаДЗ = вУстройстваMS.Строки.Найти("Спрашивать при выгрузке", "ИдГруппыПользователя", Ложь);
	Если НайденнаяСтрокаДЗ <> Неопределено Тогда
		вУстройстваMS.Строки.Удалить(НайденнаяСтрокаДЗ);
	КонецЕсли;
		
	Для Каждого СтрокаУстройства Из вУстройстваMS.Строки Цикл		
		Если ЛокЯдро_СтрНайтиНаСервере(СокрЛП(СтрокаУстройства.ИдГруппыПользователя), "WIN-") = 1 Тогда
			Продолжить;
		КонецЕсли;		
		
		СтруктураУстройства = Новый Структура; 
		СтруктураУстройства.Вставить("Ид",  СтрокаУстройства.ИдГруппыПользователя);
		СтруктураУстройства.Вставить("Имя", СтрокаУстройства.ГруппаПользователь);			
		
		МассивУстройствMS.Добавить(СтруктураУстройства);		
	КонецЦикла;
	
	Возврат МассивУстройствMS;
	
КонецФункции

// Создает массив копированием исходного по заданному отбору
//
// Параметры:
//	МассивИсточник - Массив из Произвольный - исходный массив
//	Отбор - Неопределено, Структура - отбор, применяемый в случае, когда элементами исходного массива являются структуры
//
// Возвращаемое значение:
//	- Массив из Произвольный - полученный массив
//  - Неопределено - если в параметр МассивИсточник передан не массив
&НаКлиенте
Функция ЛокЯдро_СкопироватьМассив(МассивИсточник,Отбор = Неопределено) Экспорт
	Если ТипЗнч(МассивИсточник)<>Тип("Массив") Тогда
		Возврат Неопределено;	
	КонецЕсли;
	
	МассивПриемник = Новый Массив;
	Для Каждого ЭлементМассива Из МассивИсточник Цикл
		Если ТипЗнч(ЭлементМассива) = Тип("Структура") Тогда
			Если Отбор <> Неопределено 
				И НЕ ЭлементМассива.Свойство("ЭтоТаблицаЗначений")
				И НЕ ЛокЯдро_СтруктураПодходитПодОтбор(ЭлементМассива,Отбор) Тогда
				Продолжить;
			КонецЕсли;
			МассивПриемник.Добавить(ЛокЯдро_СкопироватьСтруктуру(ЭлементМассива));
		ИначеЕсли ТипЗнч(ЭлементМассива) = Тип("Массив") Тогда
			МассивПриемник.Добавить(ЛокЯдро_СкопироватьМассив(ЭлементМассива));
		Иначе
			МассивПриемник.Добавить(ЭлементМассива);
		КонецЕсли;
	КонецЦикла;	
	Возврат МассивПриемник;
КонецФункции

// Создает структуру копированием исходной
//
// Параметры:
//	СтруктураИсточник - Структура - исходная структура.
//	СписокКолонок - Неопределено, Строка - список ключей структуры, разделенных запятыми, которые необходимо скопировать.
//										   Если параметр не передан, копируются все ключи.
//
// Возвращаемое значение:
//	Структура - полученная структура.
&НаКлиенте
Функция ЛокЯдро_СкопироватьСтруктуру(СтруктураИсточник,СписокКолонок = Неопределено) Экспорт
	СтруктураПриемник = Новый Структура;
	
	Если СписокКолонок <> Неопределено Тогда
		Колонки = ЛокЯдро_РазложитьСтрокуВМассивПодстрок(СписокКолонок, ",");
	КонецЕсли;
	
	Для Каждого ЭлементСтруктуры Из СтруктураИсточник Цикл
		
		Если СписокКолонок <> Неопределено 
			И Колонки.Найти(ЭлементСтруктуры.Ключ) = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		Если ТипЗнч(ЭлементСтруктуры.Значение) = Тип("Структура") Тогда
			СтруктураПриемник.Вставить(ЭлементСтруктуры.Ключ, ЛокЯдро_СкопироватьСтруктуру(ЭлементСтруктуры.Значение));
		ИначеЕсли ТипЗнч(ЭлементСтруктуры.Значение) = Тип("Массив") Тогда
			СтруктураПриемник.Вставить(ЭлементСтруктуры.Ключ, ЛокЯдро_СкопироватьМассив(ЭлементСтруктуры.Значение));
		Иначе
			СтруктураПриемник.Вставить(ЭлементСтруктуры.Ключ, ЭлементСтруктуры.Значение);
		КонецЕсли;
	КонецЦикла;
	Возврат СтруктураПриемник;
КонецФункции

// Проверяет соответствие произвольной структуры переданному отбору
// Соответствие подразумевает, что в структуре есть все ключи, содержащиеся в отборе,
// и значения структуры и отбора по одинаковым ключам совпадают.
//
// Параметры:
//	Структура - Структура - структура, которую требуется проверить на соответствие отбору.
//	Отбор - Структура - отбор, по которому требуется проверить соответствие.
//
// Возвращаемое значение:
//	Булево - признак соответствия структуры переданному отбору.
&НаКлиенте
Функция ЛокЯдро_СтруктураПодходитПодОтбор(Структура,Отбор) Экспорт
	Для Каждого ЭлементОтбора Из Отбор Цикл
		Если НЕ Структура.Свойство(ЭлементОтбора.Ключ)
			ИЛИ Структура[ЭлементОтбора.Ключ] <> ЭлементОтбора.Значение Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	Возврат Истина;
КонецФункции

&НаСервере
Функция ЛокЯдро_ДеревоПользователейВоВременноеХранилище(СписокПользователейMS)
	Если ТипЗнч(СписокПользователейMS)  <> Тип("СписокЗначений") Тогда
		Возврат Неопределено;
	КонецЕсли; 

	ПользователиMS = Новый ДеревоЗначений;
	ПользователиMS.Колонки.Добавить("Выгружать", 			Новый ОписаниеТипов("Булево"), "Выгружать");
	ПользователиMS.Колонки.Добавить("ГруппаПользователь", 	Новый ОписаниеТипов("Строка"), "Группа/пользователь");
	ПользователиMS.Колонки.Добавить("ИдГруппыПользователя", Новый ОписаниеТипов("Строка"), "Ид группы/пользователя");	
	
	Для Каждого Пользователь из СписокПользователейMS Цикл
		
		ИдИИмяПользователя 	= ЛокЯдро_РазложитьСтрокуВМассивПодстрок(Пользователь.Значение, 		";");
		ИдИИмяГруппы 		= ЛокЯдро_РазложитьСтрокуВМассивПодстрок(Пользователь.Представление, ";");
		
		Если ИдИИмяГруппы.Количество() >= 2 Тогда
			ИдГруппы  	= ИдИИмяГруппы[0];
			ИмяГруппы 	= ИдИИмяГруппы[1];			
		Иначе
			ИдГруппы 	= Неопределено;
			ИмяГруппы 	= Неопределено;			
		КонецЕсли;	
		
		ИдПользователя  = ИдИИмяПользователя[0];
		ИмяПользователя = ИдИИмяПользователя[1];		
		
		// Если у элемента нет группы, значит, элемент сам является группой, добавляем его в корень дерева пользователей MS
		Если ИдГруппы = Неопределено Тогда
			
			СтрокаДерева 						= ПользователиMS.Строки.Добавить();
			СтрокаДерева.ИдГруппыПользователя 	= ИдПользователя;
			СтрокаДерева.ГруппаПользователь 	= ИмяПользователя;					
			
		Иначе	
			
			// иначе - ищем группу в корне дерева
			СтрокаПоискаГруппы = ПользователиMS.Строки.Найти(ИдГруппы, "ИдГруппыПользователя");			
			
			// если не нашли, добавляем группу в корень дерева, а в группу - пользователя
			Если СтрокаПоискаГруппы = Неопределено Тогда
				
				СтрокаГруппы 						= ПользователиMS.Строки.Добавить();
				СтрокаГруппы.ИдГруппыПользователя 	= ИдГруппы;
				СтрокаГруппы.ГруппаПользователь 	= ИмяГруппы;
				
				СтрокаПользователя 						= СтрокаГруппы.Строки.Добавить();
				СтрокаПользователя.ИдГруппыПользователя = ИдПользователя;
				СтрокаПользователя.ГруппаПользователь 	= ИмяПользователя;			
				
			Иначе
				
				// иначе - добавляем в найденную группу пользователя
				СтрокаДерева 						= СтрокаПоискаГруппы.Строки.Добавить();
				СтрокаДерева.ИдГруппыПользователя 	= ИдПользователя;
				СтрокаДерева.ГруппаПользователь 	= ИмяПользователя;			
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла; 
	
	Возврат ПоместитьВоВременноеХранилище(ПользователиMS,Новый УникальныйИдентификатор());
	
КонецФункции

&НаСервере
Функция ЛокЯдро_ДеревоУстройствВоВременноеХранилище(СписокУстройствMS, флЛегкоеОблако = Ложь)
	
	Если ТипЗнч(СписокУстройствMS) <> Тип("СписокЗначений") Тогда
		Возврат Неопределено;
	КонецЕсли; 

	УстройстваMS = Новый ДеревоЗначений;
	УстройстваMS.Колонки.Добавить("Выгружать", 			  Новый ОписаниеТипов("Булево"), "Выгружать");
	Если флЛегкоеОблако Тогда
		УстройстваMS.Колонки.Добавить("ПинКод",   		  Новый ОписаниеТипов("Строка"), "Пин-код");
	КонецЕсли;
	УстройстваMS.Колонки.Добавить("ГруппаПользователь",   Новый ОписаниеТипов("Строка"), "Группа/пользователь");
	УстройстваMS.Колонки.Добавить("ИдГруппыПользователя", Новый ОписаниеТипов("Строка"), "Ид группы/пользователя");	
	
	Для Каждого Устройство из СписокУстройствMS Цикл
		
		ИдИИмяУстройства = ЛокЯдро_РазложитьСтрокуВМассивПодстрок(Устройство.Значение, ";");
		
		Если флЛегкоеОблако Тогда
			ПинУстройства  	= ИдИИмяУстройства[0];
			ИдУстройства  	= ИдИИмяУстройства[1];
			ИмяУстройства 	= ИдИИмяУстройства[2];		
		Иначе
			ИдУстройства  	= ИдИИмяУстройства[0];
			ИмяУстройства 	= ИдИИмяУстройства[1];		
		КонецЕсли;
		
		СтрокаДерева 						= УстройстваMS.Строки.Добавить();
		СтрокаДерева.ИдГруппыПользователя 	= ИдУстройства;
		СтрокаДерева.ГруппаПользователь 	= ИмяУстройства;					
		Если флЛегкоеОблако Тогда
			СтрокаДерева.ПинКод				= ПинУстройства;					
		КонецЕсли;
		
	КонецЦикла; 
	
	Возврат ПоместитьВоВременноеХранилище(УстройстваMS, Новый УникальныйИдентификатор());
	
КонецФункции

&НаСервере
Функция ЛокЯдро_ЗначениеИзСтрокиXML(Знач ЗначениеНастройки, КонвертироватьТаблицуЗначенийВМассивСтруктур = Ложь) Экспорт
	
	Если Не ЗначениеЗаполнено(ЗначениеНастройки) Или ТипЗнч(ЗначениеНастройки) <> Тип("Строка") Тогда
		Возврат ЗначениеНастройки;
	КонецЕсли;
	
	ЧтениеXML = Новый ЧтениеXML;
	ЧтениеXML.УстановитьСтроку(ЗначениеНастройки);
	
	Попытка		
		ПолученноеЗначение = СериализаторXDTO.ПрочитатьXML(ЧтениеXML);		
	Исключение                                                        		
		Если Найти(ЗначениеНастройки, "http://v8.1c.ru/8.1/data/core") = 0 Тогда
			// Это не xml, пытаемся использовать ЗначениеИзСтрокиВнутр
			ПолученноеЗначение = ЗначениеИзСтрокиВнутр(ЗначениеНастройки);
		Иначе                                                            			
			ПолученноеЗначение = ЛокЯдро_ПреобразованиеЗначенияXMLЧерезXSL(ЗначениеНастройки);				
		КонецЕсли;                                                    		
	КонецПопытки;
		
	Если ТипЗнч(ПолученноеЗначение) = Тип ("ТаблицаЗначений") И КонвертироватьТаблицуЗначенийВМассивСтруктур Тогда
		ПолученноеЗначение = ЛокЯдро_ТаблицуЗначенийВМассивСтруктур(ПолученноеЗначение);
	КонецЕсли; 
	
	Возврат ПолученноеЗначение;
	
КонецФункции

&НаСервере
Функция ЛокЯдро_ЗначениеВСтрокуXML(Знач ЗначениеНастройки, КонвертироватьМассивСтруктурВТаблицуЗначений = Ложь) Экспорт
	
	ВозвращаемоеЗначение = ЗначениеНастройки;
	
	Если ТипЗнч(ЗначениеНастройки) = Тип("Массив") И КонвертироватьМассивСтруктурВТаблицуЗначений Тогда
		ВозвращаемоеЗначение = ЛокЯдро_МассивСтруктурВТаблицуЗначений(ЗначениеНастройки);	
	КонецЕсли;
	
	ПолученнаяСтрока = Новый ЗаписьXML;
	ПолученнаяСтрока.УстановитьСтроку();
	СериализаторXDTO.ЗаписатьXML(ПолученнаяСтрока, ВозвращаемоеЗначение, НазначениеТипаXML.Явное);
	
	СтрокаXML = ПолученнаяСтрока.Закрыть();
	
	Возврат СтрокаXML;
	
КонецФункции

&НаСервере
Функция ЛокЯдро_ПреобразованиеЗначенияXMLЧерезXSL(Знач ЗначениеНастройки)
	
	ПараметрыМетода = Новый Структура;
	ПараметрыМетода.Вставить("ЗначениеНастройки", ЗначениеНастройки);
	
	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода", "Функция");
	СтруктураВызова.Вставить("ИмяМетода", "ПреобразованиеЗначенияXMLЧерезXSL");
	СтруктураВызова.Вставить("ПараметрыМетода", ПараметрыМетода);

	ПередаваемыеПараметры = Транзит_ПоместитьЗначениеВХранилищеНаСервере(СтруктураВызова);
	
	АдресРезультата = Транзит_ВызватьГлобальныйМетодНаСервере(ПередаваемыеПараметры, Неопределено);
	
	Если ЭтоАдресВременногоХранилища(АдресРезультата) Тогда
		ПолученноеЗначение = ПолучитьИзВременногоХранилища(АдресРезультата);
	Иначе
		ПолученноеЗначение = Неопределено;
	КонецЕсли;
	
	Возврат ПолученноеЗначение;
	
КонецФункции

// Выполняет обновление структуры настроек бизнес-процессов
//
// Параметры:
//	НастройкиБизнесПроцессов - Массив из Структура - содержит настройки бизнес-процессов
//							 - Строка - адрес временного хранилища, по которому хранятся настройки бизнес-процессов
//  НастройкиОбновились - Булево - флаг того, что настройки обновились
//  ВернутьАдресХранилища - Булево - флаг того, что необходимо вернуть адрес хранилища
//
// Возвращаемое значение:
//	- Массив из Структура - содержит обновленные настройки бизнес-процессов, если ВернутьАдресХранилища = Ложь
//	- Строка - адрес временного хранилища, по которому хранятся обновленные настройки бизнес-процессов, если ВернутьАдресХранилища = Истина
&НаКлиенте
Функция ЛокЯдро_ОбновитьСтруктуруНастроекБизнесПроцессов(Знач НастройкиБизнесПроцессов,НастройкиОбновились,ВернутьАдресХранилища=Ложь) Экспорт

	Если НЕ ЗначениеЗаполнено(НастройкиБизнесПроцессов) ИЛИ НастройкиБизнесПроцессов = Ложь Тогда			
		Возврат НастройкиБизнесПроцессов;
	КонецЕсли;	
	
	Если ЭтоАдресВременногоХранилища(НастройкиБизнесПроцессов) Тогда
		НастройкиБизнесПроцессов = ПолучитьИзВременногоХранилища(НастройкиБизнесПроцессов);		
	КонецЕсли;
	
	Если НастройкиБизнесПроцессов.Количество() = 0 ИЛИ НЕ НастройкиБизнесПроцессов[0].Свойство("КолонкиТаблицыЗначений") Тогда
		Возврат Ложь;	
	КонецЕсли;
	
	//Временная Заплатка (
	ЕстьИзменение = Ложь;
	Для Каждого СтрокаНастройки из НастройкиБизнесПроцессов Цикл
		Если СтрокаНастройки.Свойство("IDБизнесПроцесса") Тогда
			СтрокаНастройки.Вставить("ID_БизнесПроцесса",СтрокаНастройки.IDБизнесПроцесса);
			СтрокаНастройки.Удалить("IDБизнесПроцесса");
			ЕстьИзменение = Истина;
		КонецЕсли;
	КонецЦикла;
	
	 // Проверка на то, что бизнес-процессы уже сконвертированы
	Если НЕ ЕстьИзменение Тогда
		Возврат НастройкиБизнесПроцессов;
	КонецЕсли; 
	
	Если ЕстьИзменение Тогда
		НастройкиБизнесПроцессов[0].КолонкиТаблицыЗначений = СтрЗаменить(НастройкиБизнесПроцессов[0].КолонкиТаблицыЗначений,"IDБизнесПроцесса","ID_БизнесПроцесса");
	КонецЕсли;
	//Временная Заплатка )
	
	НастройкиОбновились = Ложь;	
	Колонки = ЛокЯдро_РазложитьСтрокуВМассивПодстрок(НастройкиБизнесПроцессов[0].КолонкиТаблицыЗначений, ",");
	
	СписокКолонокДляПреобразования = Новый Соответствие;
	Если Колонки.Найти("ИсходныйДокумент1С") <> Неопределено Тогда
		СписокКолонокДляПреобразования.Вставить("ИсходныйДокумент1С","ТипИсходногоДокумента1С");
		//Исправим значение синонимов на типы
		Для Каждого СтрокаНастройки Из НастройкиБизнесПроцессов Цикл
			Если СтрокаНастройки.Свойство("ЭтоТаблицаЗначений") ИЛИ НЕ ЗначениеЗаполнено(СтрокаНастройки.ИсходныйДокумент1С) Тогда
				Продолжить;
			КонецЕсли;
			
			Документ1С = Неопределено;
			Попытка
				Документ1С = СтруктураМетаданных.Документы1С[СтрокаНастройки.ИсходныйДокумент1С];
			Исключение
				Попытка 
					Документ1С = СтруктураМетаданных.Документы1С[СтрокаНастройки.ИсходныйДокумент1ССиноним];
				Исключение
				КонецПопытки;
			КонецПопытки;
			Если Документ1С = Неопределено Тогда
				СтрокаНастройки.Используется = Ложь;
			    СтрокаНастройки.ИсходныйДокумент1С = "";
			Иначе
				СтрокаНастройки.ИсходныйДокумент1С = Документ1С.Имя;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	Если Колонки.Найти("ДокументПриемник") <> Неопределено Тогда
		СписокКолонокДляПреобразования.Вставить("ДокументПриемник","ТипРезультирующегоДокумента1С");
		//Исправим значение синонимов на типы
		Для Каждого СтрокаНастройки Из НастройкиБизнесПроцессов Цикл
			Если СтрокаНастройки.Свойство("ЭтоТаблицаЗначений") ИЛИ НЕ ЗначениеЗаполнено(СтрокаНастройки.ДокументПриемник) Тогда
				Продолжить;
			КонецЕсли;
			Документ1С = Неопределено;
			Попытка
				Документ1С = СтруктураМетаданных.Документы1С[СтрокаНастройки.ДокументПриемник];
			Исключение
				Попытка 
					Документ1С = СтруктураМетаданных.Документы1С[СтрокаНастройки.Приемник1ССиноним];
				Исключение
				КонецПопытки;
			КонецПопытки;
			Если Документ1С = Неопределено Тогда
				СтрокаНастройки.Используется = Ложь;
			    СтрокаНастройки.ДокументПриемник = "";
			Иначе
				СтрокаНастройки.ДокументПриемник = Документ1С.Имя;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	Если Колонки.Найти("НастройкиЗагрузкиТЧ") <> Неопределено Тогда
		СписокКолонокДляПреобразования.Вставить("НастройкиЗагрузкиТЧ","НастройкаЗагрузкиТЧ");
	КонецЕсли;
	
	Если Колонки.Найти("ИсходныйДокумент1ССиноним") <> Неопределено Тогда
		СписокКолонокДляПреобразования.Вставить("ИсходныйДокумент1ССиноним","$Удалить");
	КонецЕсли;
	Если Колонки.Найти("Приемник1ССиноним") <> Неопределено Тогда
		СписокКолонокДляПреобразования.Вставить("Приемник1ССиноним","$Удалить");
	КонецЕсли;
	Если Колонки.Найти("ДокументMSСиноним") <> Неопределено Тогда
		СписокКолонокДляПреобразования.Вставить("ДокументMSСиноним","$Удалить");
	КонецЕсли;
	Если Колонки.Найти("БазаMobileSMARTS") <> Неопределено Тогда
		СписокКолонокДляПреобразования.Вставить("БазаMobileSMARTS","$Удалить");
	КонецЕсли;
	Если Колонки.Найти("НастроитьПравилаВыгрузкиТЧ") <> Неопределено Тогда
		СписокКолонокДляПреобразования.Вставить("НастроитьПравилаВыгрузкиТЧ","$Удалить");
	КонецЕсли;
	Если Колонки.Найти("НастроитьПравилаВыгрузкиШапки") <> Неопределено Тогда
		СписокКолонокДляПреобразования.Вставить("НастроитьПравилаВыгрузкиШапки","$Удалить");
	КонецЕсли;
	Если Колонки.Найти("НастроитьПравилаЗагрузкиШапки") <> Неопределено Тогда
		СписокКолонокДляПреобразования.Вставить("НастроитьПравилаЗагрузкиШапки","$Удалить");
	КонецЕсли;
	Если Колонки.Найти("НастроитьСоставЗагрузкиТЧ") <> Неопределено Тогда
		СписокКолонокДляПреобразования.Вставить("НастроитьСоставЗагрузкиТЧ","$Удалить");
	КонецЕсли;
	Если Колонки.Найти("ТекстЗапросаЗагрузкаСТДС") <> Неопределено Тогда
		СписокКолонокДляПреобразования.Вставить("ТекстЗапросаЗагрузкаСТДС","$Удалить");
	КонецЕсли;
	
	Если Колонки.Найти("НастройкаПредставленийРеквизитовДокумента") = Неопределено Тогда
		СписокКолонокДляПреобразования.Вставить("НастройкаПредставленийРеквизитовДокумента", "$Добавить");
	КонецЕсли;
	Если Колонки.Найти("ЗаменитьПредставлениеДокументаПриВыгрузке") = Неопределено Тогда
		СписокКолонокДляПреобразования.Вставить("ЗаменитьПредставлениеДокументаПриВыгрузке", "$Добавить");
	КонецЕсли;
	Если Колонки.Найти("ЭтоТиповойБизнесПроцесс") = Неопределено Тогда
		СписокКолонокДляПреобразования.Вставить("ЭтоТиповойБизнесПроцесс", "$Добавить");
	КонецЕсли;
	Если Колонки.Найти("Комментарий") = Неопределено Тогда
		СписокКолонокДляПреобразования.Вставить("Комментарий", "$Добавить");
	КонецЕсли;
	Если Колонки.Найти("КоллективнаяРабота") = Неопределено Тогда
		СписокКолонокДляПреобразования.Вставить("КоллективнаяРабота", "$Добавить");
	КонецЕсли;
	Если Колонки.Найти("СоздаватьНовыйДокументПриЗагрузке") = Неопределено Тогда
		СписокКолонокДляПреобразования.Вставить("СоздаватьНовыйДокументПриЗагрузке", "$Добавить");//Новый ОписаниеТипов("Булево"));
	КонецЕсли;
	Если Колонки.Найти("НазначитьПользователю") = Неопределено Тогда
		СписокКолонокДляПреобразования.Вставить("НазначитьПользователю", "$Добавить");// Новый ОписаниеТипов("Строка"));
	КонецЕсли;
	Если Колонки.Найти("СпособНазначения") = Неопределено Тогда
		СписокКолонокДляПреобразования.Вставить("СпособНазначения", "$Добавить");// Новый ОписаниеТипов("Строка"));
	КонецЕсли;
	Если Колонки.Найти("КопияДокументаДляКаждогоПользователя") = Неопределено Тогда
		СписокКолонокДляПреобразования.Вставить("КопияДокументаДляКаждогоПользователя", "$Добавить");// Новый ОписаниеТипов("Булево"));
	КонецЕсли;
	Если Колонки.Найти("ЗаписыватьДокументПослеЗагрузки") = Неопределено Тогда
		СписокКолонокДляПреобразования.Вставить("ЗаписыватьДокументПослеЗагрузки", "$Добавить");//Новый ОписаниеТипов("Булево"));
	КонецЕсли;
	Если Колонки.Найти("СвязиТабличныхЧастей") = Неопределено Тогда
		СписокКолонокДляПреобразования.Вставить("СвязиТабличныхЧастей", "$Добавить");// Новый ОписаниеТипов("ТаблицаЗначений"));
	КонецЕсли;
	Если Колонки.Найти("ВыполнитьТолькоПроизвольныйКод") = Неопределено Тогда
		СписокКолонокДляПреобразования.Вставить("ВыполнитьТолькоПроизвольныйКод", "$Добавить");// Новый ОписаниеТипов("Булево"));
	КонецЕсли;
	
	// ****** +++    - реализовать выгрузку из 1С из нескольких ТЧ, поэтому меняем состав столбцов ************
	
	// выполняем измененения структуры таблицы настроек только если структура осталась в старом формате (когда нельзя было выгружать несколько ТЧ 1С)
	
	Если Колонки.Найти("НастройкаВыгрузкиТЧ") <> Неопределено 
		И НастройкиБизнесПроцессов.Количество() > 1 Тогда
		КолонкиНастройкаВыгрузкиТЧ = ЛокЯдро_РазложитьСтрокуВМассивПодстрок(НастройкиБизнесПроцессов[1].НастройкаВыгрузкиТЧ[0].КолонкиТаблицыЗначений, ",");	
		
		Если КолонкиНастройкаВыгрузкиТЧ.Найти("ТабличнаяЧастьДокумента1С") = Неопределено Тогда
			Соответствие = Новый Соответствие;
			Для Каждого СтрокаНастройки Из НастройкиБизнесПроцессов Цикл 
				Если СтрокаНастройки.Свойство("ЭтоТаблицаЗначений") Тогда
					Продолжить;
				КонецЕсли;
				Соответствие.Вставить(СтрокаНастройки.ID_БизнесПроцесса, СтрокаНастройки.НастройкаВыгрузкиТЧ);						
			КонецЦикла;
			
			СтруктураНовойТЗ  = Новый Структура("ЭтоТаблицаЗначений,КолонкиТаблицыЗначений",Истина,"ТабличнаяЧастьДокументаMS,НастройкаТЧСтрокой,Настроить,ТабличнаяЧастьДокумента1С,ТекстЗапросаВыгрузкиНаТСД,ТекстКодаПолучениеПараметров");
			
			// копируем существующие настройки выгрузки ТЧ, чтобы не пропали			
			Если Колонки.Найти("ТекстЗапросаВыгрузкиНаТСД") <> Неопределено Тогда
				СписокКолонокДляПреобразования.Вставить("ТекстЗапросаВыгрузкиНаТСД","$Удалить");
			КонецЕсли;
			Для Каждого Строка Из НастройкиБизнесПроцессов Цикл 
				Если Строка.Свойство("ЭтоТаблицаЗначений") Тогда
					Продолжить;
				КонецЕсли;
				КопияТЗ = Новый Массив;
				КопияТЗ.Добавить(СтруктураНовойТЗ);
				
				СтрокаНастройки = Новый Структура(); 		
				
				СтрокаНастройки.Вставить("ТабличнаяЧастьДокументаMS","СтрокиПлан");
				СтрокаНастройки.Вставить("НастройкаТЧСтрокой",Строка.ИмяТЧ1СИсходного);
				СтрокаНастройки.Вставить("ТабличнаяЧастьДокумента1С",Соответствие[Строка.ID_БизнесПроцесса]);				
				СтрокаНастройки.Вставить("Настроить",?(СтрокаНастройки.ТабличнаяЧастьДокумента1С.Количество(), "Настроено", "Настроить"));
				
				Если Колонки.Найти("ТекстЗапросаВыгрузкиНаТСД") <> Неопределено Тогда
					СтрокаНастройки.Вставить("ТекстЗапросаВыгрузкиНаТСД",Строка.ТекстЗапросаВыгрузкиНаТСД);								
				КонецЕсли;	
				КопияТЗ.Добавить(СтрокаНастройки);
				Строка.НастройкаВыгрузкиТЧ = КопияТЗ;
			КонецЦикла;
			
		КонецЕсли;
	КонецЕсли;
	
	Если СписокКолонокДляПреобразования.Количество() > 0 Тогда
		Для Каждого Строка Из НастройкиБизнесПроцессов Цикл
			Если Строка.Свойство("ЭтоТаблицаЗначений") Тогда
				Продолжить;
			КонецЕсли;
			//Исправим структуру
			Для Каждого КолонкаДляПреобразования Из СписокКолонокДляПреобразования Цикл
				Если КолонкаДляПреобразования.Значение = "$Удалить" Тогда
					Строка.Удалить(КолонкаДляПреобразования.Ключ);
				ИначеЕсли КолонкаДляПреобразования.Значение =  "$Добавить" Тогда
					Строка.Вставить(КолонкаДляПреобразования.Ключ);
				Иначе 
					Строка.Вставить(КолонкаДляПреобразования.Значение,Строка[КолонкаДляПреобразования.Ключ]);								
					Строка.Удалить(КолонкаДляПреобразования.Ключ);
				КонецЕсли;
				
			КонецЦикла;	
		КонецЦикла;
		Для Каждого КолонкаДляПреобразования Из СписокКолонокДляПреобразования Цикл
			Если КолонкаДляПреобразования.Значение = "$Удалить" Тогда
				Колонки.Удалить(Колонки.Найти(КолонкаДляПреобразования.Ключ)); 
			ИначеЕсли КолонкаДляПреобразования.Значение =  "$Добавить" Тогда
				Колонки.Добавить(КолонкаДляПреобразования.Ключ);
			Иначе
				Индекс = Колонки.Найти(КолонкаДляПреобразования.Ключ);
				Колонки[Индекс] = КолонкаДляПреобразования.Значение;
			КонецЕсли;
		КонецЦикла;
		СтрокаКолонок = "";
		Для Каждого Колонка из Колонки Цикл
			СтрокаКолонок = СтрокаКолонок + Колонка +",";	
		КонецЦикла;
		СтрокаКолонок = Лев(СтрокаКолонок,СтрДлина(СтрокаКолонок)-1);
		НастройкиБизнесПроцессов[0].КолонкиТаблицыЗначений = СтрокаКолонок;
		НастройкиОбновились = Истина;
	КонецЕсли;
	
	//Конвертируем Настройки Выгрузки/Загрузки Полей  (
	СписокРеквизитовMSДляСовместимостиШапки = ЛокЯдро_ПолучитьСписокАнглийскихНазванияПолейШапкиMS();
	СписокРеквизитовMSДляСовместимостиТЧ = ЛокЯдро_ПолучитьСписокАнглийскихНазванияПолейТЧMS();
	Для Каждого СтрокаБП Из НастройкиБизнесПроцессов Цикл
		Если СтрокаБП.Свойство("ЭтоТаблицаЗначений") Тогда
			Продолжить;
		КонецЕсли;
		
		Если СтрокаБП.ЗагружатьВТотЖе = Истина И НЕ ЗначениеЗаполнено(СтрокаБП.ТипРезультирующегоДокумента1С) Тогда
			СтрокаБП.ТипРезультирующегоДокумента1С = СтрокаБП.ТипИсходногоДокумента1С;	
		КонецЕсли;
		
		ТипДокумента1С = СтрокаБП.ТипИсходногоДокумента1С;	
		ТипДокументаMS = ЛокЯдро_ПреобразованиеНаименованияДокументаБезПробелов(СтрокаБП.ТипДокументаMS);		
		СписокРеквизитовMS = Новый СписокЗначений;
		СписокРеквизитов1С = Новый СписокЗначений;
		Если ЗначениеЗаполнено(ТипДокументаMS) И СтруктураМетаданных.ДокументыMS.Свойство(ТипДокументаMS) Тогда
			СписокРеквизитовMS = СтруктураМетаданных.ДокументыMS[ТипДокументаMS].Реквизиты;
		КонецЕсли;
		Если ЗначениеЗаполнено(ТипДокумента1С) И СтруктураМетаданных.Документы1С.Свойство(ТипДокумента1С) Тогда
			СписокРеквизитов1С = СтруктураМетаданных.Документы1С[ТипДокумента1С].Реквизиты;
		КонецЕсли;
		
		ТаблицаРеквизитовШапки = СтрокаБП.НастройкаВыгрузкиПолей;
		Если ТаблицаРеквизитовШапки <> Неопределено Тогда
			СтрокаБП.НастройкаВыгрузкиПолей = ЛокЯдро_КонвертироватьВыгрузкуПолей(ТаблицаРеквизитовШапки,СписокРеквизитовMS,СписокРеквизитов1С);	
		КонецЕсли;
		Если СтрокаБП.НастройкаВыгрузкиТЧ = Неопределено Тогда
			СтрокаБП.НастройкаВыгрузкиТЧ = Новый Массив;
		КонецЕсли;
		Для Каждого СтрокаТЧ Из СтрокаБП.НастройкаВыгрузкиТЧ Цикл
			Если СтрокаТЧ.Свойство("ЭтоТаблицаЗначений") Тогда
				Продолжить;
			КонецЕсли;
			ИмяТабличнойЧасти1С = СтрокаТЧ.НастройкаТЧСтрокой;
			ТекстЗапросаВыгрузкиНаТСД = СтрокаТЧ.ТекстЗапросаВыгрузкиНаТСД;
			ИмяТабличнойЧастиMS = СтрокаТЧ.ТабличнаяЧастьДокументаMS;
			
			Если Найти(ИмяТабличнойЧасти1С, "Запрос") Тогда
				Если ЗначениеЗаполнено(ТекстЗапросаВыгрузкиНаТСД) Тогда
					СписокРеквизитов1С = ЗаполнитьСписокПолейЗапроса(ТипДокумента1С, ТекстЗапросаВыгрузкиНаТСД);			
				КонецЕсли;	
			ИначеЕсли ЗначениеЗаполнено(ТипДокумента1С) И ЗначениеЗаполнено(ИмяТабличнойЧасти1С)
				И СтруктураМетаданных.Документы1С.Свойство(ТипДокумента1С) 
				И СтруктураМетаданных.Документы1С[ТипДокумента1С].ТабличныеЧасти.Свойство(ИмяТабличнойЧасти1С) Тогда
				СписокРеквизитов1С = СтруктураМетаданных.Документы1С[ТипДокумента1С].ТабличныеЧасти[ИмяТабличнойЧасти1С].Реквизиты;
			КонецЕсли;
			
			Если (ИмяТабличнойЧастиMS = "СтрокиПлан" 
				ИЛИ ИмяТабличнойЧастиMS = "СтрокиФакт"
				ИЛИ ИмяТабличнойЧастиMS = "СовмещенныеСтроки")
				И СтруктураМетаданных.ДокументыMS.Свойство(ТипДокументаMS) Тогда
				СписокРеквизитовMS = СтруктураМетаданных.ДокументыMS[ТипДокументаMS].РеквизитыТЧ;							
				
			ИначеЕсли (ИмяТабличнойЧастиMS = "СерииПлан" 
				ИЛИ   ИмяТабличнойЧастиMS = "СерииФакт")
				И СтруктураМетаданных.ДокументыMS.Свойство(ТипДокументаMS) Тогда
				СписокРеквизитовMS = СтруктураМетаданных.ДокументыMS[ТипДокументаMS].РеквизитыСерии;							
				
			ИначеЕсли (ИмяТабличнойЧастиMS = "СерийныеНомераПлан" 
				ИЛИ   ИмяТабличнойЧастиMS = "СерийныеНомераФакт")
				И СтруктураМетаданных.ДокументыMS.Свойство(ТипДокументаMS) Тогда
				СписокРеквизитовMS = СтруктураМетаданных.ДокументыMS[ТипДокументаMS].РеквизитыСерийныеНомера;							
				
			ИначеЕсли СтруктураМетаданных.ДокументыMS.Свойство(ТипДокументаMS) Тогда
				СписокДопТаблиц = СтруктураМетаданных.ДокументыMS[ТипДокументаMS].ДополнительныеТаблицы;
				Для Каждого ДопТаблица Из СписокДопТаблиц Цикл
					Если ДопТаблица.Представление = ИмяТабличнойЧастиMS Тогда
						СписокРеквизитовMS = ДопТаблица.Значение;
						Прервать;
					КонецЕсли;
				КонецЦикла;			
			КонецЕсли;
			СтрокаТЧ.ТабличнаяЧастьДокумента1С = ЛокЯдро_КонвертироватьВыгрузкуПолей(СтрокаТЧ.ТабличнаяЧастьДокумента1С,СписокРеквизитовMS,СписокРеквизитов1С);
		КонецЦикла;
		
		ТипДокумента1С = СтрокаБП.ТипРезультирующегоДокумента1С;	
		СписокРеквизитов1С = Новый СписокЗначений;
		СписокРеквизитовMS = Новый СписокЗначений;
		Если ЗначениеЗаполнено(ТипДокумента1С) И СтруктураМетаданных.Документы1С.Свойство(ТипДокумента1С) Тогда
			СписокРеквизитов1С = СтруктураМетаданных.Документы1С[ТипДокумента1С].Реквизиты;
		КонецЕсли;
		Если ЗначениеЗаполнено(ТипДокументаMS) И СтруктураМетаданных.ДокументыMS.Свойство(ТипДокументаMS) Тогда
			СписокРеквизитовMS = СтруктураМетаданных.ДокументыMS[ТипДокументаMS].Реквизиты;
		КонецЕсли;
		
		ТаблицаРеквизитовШапки = СтрокаБП.НастройкаЗагрузкиПолей;
		Если ТаблицаРеквизитовШапки <> Неопределено Тогда
			СтрокаБП.НастройкаЗагрузкиПолей = ЛокЯдро_КонвертироватьЗагрузкуПолей(ТаблицаРеквизитовШапки,СписокРеквизитовMS,СписокРеквизитов1С,СписокРеквизитовMSДляСовместимостиШапки);	
		КонецЕсли;
		
		Если СтрокаБП.НастройкаЗагрузкиТЧ = Неопределено Тогда
			СтрокаБП.НастройкаЗагрузкиТЧ = Новый Массив;
		КонецЕсли;
		
		Для Каждого СтрокаТЧ Из СтрокаБП.НастройкаЗагрузкиТЧ Цикл
			Если СтрокаТЧ.Свойство("ЭтоТаблицаЗначений") Тогда
				Продолжить;
			КонецЕсли;
			
			ИмяТабличнойЧасти1С = СтрокаТЧ.НастройкаТЧСтрокой;
			Если (НЕ СтрокаТЧ.Свойство("ТабличнаяЧастьДокумента1С") ИЛИ НЕ ЗначениеЗаполнено(СтрокаТЧ.ТабличнаяЧастьДокумента1С))
				И СтрокаТЧ.Свойство("ТабличнаяЧастьДокумента1ССтрокой") И ЗначениеЗаполнено(СтрокаТЧ.ТабличнаяЧастьДокумента1ССтрокой) Тогда
				СтрокаТЧ.Вставить("ТабличнаяЧастьДокумента1С",ЛокЯдро_ЗначениеИзСтрокиXML(СтрокаТЧ.ТабличнаяЧастьДокумента1ССтрокой,Истина));
			КонецЕсли;
			Если СтруктураМетаданных.ДокументыMS.Свойство(ТипДокументаMS) Тогда
				СписокДопТаблиц = СтруктураМетаданных.ДокументыMS[ТипДокументаMS].ДополнительныеТаблицы;
			Иначе
				СписокДопТаблиц = Новый СписокЗначений;
			КонецЕсли;
			ДополнительнаяТаблица = Неопределено;
			Если ЗначениеЗаполнено(ТипДокумента1С) И СтруктураМетаданных.Документы1С.Свойство(ТипДокумента1С)
				И ЗначениеЗаполнено(ИмяТабличнойЧасти1С) И СтруктураМетаданных.Документы1С.Свойство(ИмяТабличнойЧасти1С) Тогда
				СписокРеквизитов1С = СтруктураМетаданных.Документы1С[ТипДокумента1С].ТабличныеЧасти[ИмяТабличнойЧасти1С].Реквизиты;
			КОнецЕсли;
			Для Каждого ДопТаблица Из СписокДопТаблиц Цикл
				Если ДопТаблица.Представление = ИмяТабличнойЧастиMS Тогда
					ДополнительнаяТаблица = ДопТаблица; 
					Прервать;
				КонецЕсли;
			КонецЦикла;
			
			Если ДополнительнаяТаблица = Неопределено Тогда
				Если СтруктураМетаданных.ДокументыMS.Свойство(ТипДокументаMS) Тогда
					СписокРеквизитовMS = СтруктураМетаданных.ДокументыMS[ТипДокументаMS].РеквизитыТЧ.Скопировать();
					СписокРеквизитовMS.Добавить("КлючСвязиСерий", "КлючСвязиСерий");
					СписокРеквизитовMS.Добавить("КлючСвязиСерийныхНомеров", "КлючСвязиСерийныхНомеров");
				КонецЕсли;
			Иначе	
				СписокРеквизитовMS = ДополнительнаяТаблица.Значение;	
			КонецЕсли;
			
			СписокПравилПоиска = Новый СписокЗначений;
			СписокПравилПоиска.Добавить("Равно", "Равно или оба пустые");
			СписокПравилПоиска.Добавить("РавноПусто1С", "Равно или в 1С пусто");
			СписокПравилПоиска.Добавить("РавноПустоТСД", "Равно или на ТСД пусто");
			
			СтрокаТЧ.ТабличнаяЧастьДокумента1С = ЛокЯдро_КонвертироватьЗагрузкуПолей(СтрокаТЧ.ТабличнаяЧастьДокумента1С,СписокРеквизитовMS,СписокРеквизитов1С,СписокРеквизитовMSДляСовместимостиТЧ);
		КонецЦикла;
	КонецЦикла;
	// )
	НастройкиОбновились = Истина;
	Если ВернутьАдресХранилища Тогда
		
		Возврат ПоместитьВоВременноеХранилище(НастройкиБизнесПроцессов,Новый УникальныйИдентификатор());	
		
	Иначе
		
		Возврат НастройкиБизнесПроцессов;	
		
	КонецЕсли;
КонецФункции	

// Конвертирует старые настройки выгрузки полей в новые 
//
// Параметры:
//	ТаблицаРеквизитовИсходная - Массив из Структура - старые настройки выгрузки полей
//	СписокРеквизитовMS - СписокЗначений - список реквизитов Mobile Smarts
//	СписокРеквизитов1С - СписокЗначений - список реквизитов 1С
//
// Возвращаемое значение:
//	Массив из Структура - новые настройки выгрузки полей
&НаКлиенте
Функция ЛокЯдро_КонвертироватьВыгрузкуПолей(ТаблицаРеквизитовИсходная,СписокРеквизитовMS,СписокРеквизитов1С) Экспорт
	
	ТаблицаРеквизитов = Новый Массив;
	ТаблицаРеквизитов.Добавить(Новый Структура("ЭтоТаблицаЗначений,КолонкиТаблицыЗначений",Истина,"ТипПриемникаСиноним,ИмяЗначениеПриемника,СинонимПриемника,ИмяПриемника,ТипИсточникаСиноним,ИмяЗначениеИсточника,СинонимИсточника,ЗначениеИсточника,СпособСопоставленияСиноним,Комментарий,ТипПриемника,ТипИсточника,ИмяИсточника,СпособСопоставления,Выгружать,ПрЗначение,ИсЗначение"));
	
	Для Каждого СтрокаИсходнойТаблицы Из ТаблицаРеквизитовИсходная Цикл
		Если СтрокаИсходнойТаблицы.Свойство("ЭтоТаблицаЗначений") Тогда
			Продолжить;
		КонецЕсли;
		НоваяСтрока = Новый Структура("ТипПриемникаСиноним,ИмяЗначениеПриемника,СинонимПриемника,ИмяПриемника,ТипИсточникаСиноним,ИмяЗначениеИсточника,СинонимИсточника,ЗначениеИсточника,СпособСопоставленияСиноним,Комментарий,ТипПриемника,ТипИсточника,ИмяИсточника,СпособСопоставления,Выгружать,ПрЗначение,ИсЗначение");
		ЗаполнитьЗначенияСвойств(НоваяСтрока, СтрокаИсходнойТаблицы);
		
		// Временное решение. Загрузка старых настроек
		Если СтрокаИсходнойТаблицы.Свойство("ИмяMS") Тогда
			НоваяСтрока.ИмяПриемника = СтрокаИсходнойТаблицы.ИмяMS;
			НайденныйЭлементИмениПриемника = СписокРеквизитовMS.НайтиПоЗначению(НоваяСтрока.ИмяПриемника);
			Если НайденныйЭлементИмениПриемника <> Неопределено Тогда
				НоваяСтрока.СинонимПриемника = НайденныйЭлементИмениПриемника.Представление;
			Иначе
				НоваяСтрока.СинонимПриемника = СтрокаИсходнойТаблицы.ИмяMS;
			КонецЕсли;
			НоваяСтрока.ТипПриемника = "РеквизитMS";
			НоваяСтрока.ТипПриемникаСиноним = "Фиксированный реквизит Mobile SMARTS";
		КонецЕсли;
		
		Если СтрокаИсходнойТаблицы.Свойство("Имя1С") <> Неопределено Тогда
			
			Если СтрокаИсходнойТаблицы.Свойство("Тип") И СтрокаИсходнойТаблицы.Тип = "Реквизит 1С" Тогда
				// ищем в реквизитах
				НайденныйЭлементИмениИсточника = СписокРеквизитов1С.НайтиПоЗначению(СтрокаИсходнойТаблицы.Имя1С);
				Если НайденныйЭлементИмениИсточника <> Неопределено Тогда
					НоваяСтрока.ИмяИсточника = НайденныйЭлементИмениИсточника.Значение;
					НоваяСтрока.СинонимИсточника = НайденныйЭлементИмениИсточника.Представление;
					НоваяСтрока.ТипИсточника = "Реквизит1С";
					НоваяСтрока.ТипИсточникаСиноним = "Реквизит 1С";
				КонецЕсли;
				
				Если ЗначениеЗаполнено(НоваяСтрока.ИмяИсточника) Тогда
					Если СтрокаИсходнойТаблицы.Свойство("ВыгружатьКакUID") Тогда
						Если СтрокаИсходнойТаблицы.ВыгружатьКакUID = "Ссылка (GUID)" ИЛИ СтрокаИсходнойТаблицы.ВыгружатьКакUID = "Ссылка(GUID)" Тогда
							НоваяСтрока.СпособСопоставления = "СтрокаGUID";
							НоваяСтрока.СпособСопоставленияСиноним = "Ссылка (строка GUID)";
						ИначеЕсли СтрокаИсходнойТаблицы.ВыгружатьКакUID = "По наименованию" Тогда
							НоваяСтрока.СпособСопоставления = "Наименование";
							НоваяСтрока.СпособСопоставленияСиноним = "Наименование (для справочников)";
						ИначеЕсли СтрокаИсходнойТаблицы.ВыгружатьКакUID = "Код" Тогда
							НоваяСтрока.СпособСопоставления = "Код";
							НоваяСтрока.СпособСопоставленияСиноним = "Код (для справочников)";
						Иначе
							НоваяСтрока.СпособСопоставления = "КакЕсть";
							НоваяСтрока.СпособСопоставленияСиноним = "Как есть (простой тип)";
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
				
			ИначеЕсли СтрокаИсходнойТаблицы.Свойство("Тип") И (СтрокаИсходнойТаблицы.Тип = "Дата" ИЛИ СтрокаИсходнойТаблицы.Тип = "Число" ИЛИ СтрокаИсходнойТаблицы.Тип = "Строка" ИЛИ СтрокаИсходнойТаблицы.Тип = "Булево") Тогда
				НоваяСтрока.ТипИсточника = "ПроизвольноеЗначение";
				НоваяСтрока.ТипИсточникаСиноним = "Произвольное значение";
				НоваяСтрока.СпособСопоставления = "КакЕсть";
				НоваяСтрока.СпособСопоставленияСиноним = "Как есть (простой тип)";
				НоваяСтрока.ЗначениеИсточника = СтрокаИсходнойТаблицы.Имя1С;
				
			ИначеЕсли  СтрокаИсходнойТаблицы.Свойство("Тип")  И СтрокаИсходнойТаблицы.Тип = "Произвольный код" Тогда
				НоваяСтрока.ТипИсточника = "ПроизвольныйКод";
				НоваяСтрока.ТипИсточникаСиноним = "Произвольный код";
				Если СтрокаИсходнойТаблицы.Свойство("ВыгружатьКакUID") Тогда
					Если СтрокаИсходнойТаблицы.ВыгружатьКакUID = "Ссылка (поиск по GUID)" Тогда
						НоваяСтрока.СпособСопоставления = "СтрокаGUID";
						НоваяСтрока.СпособСопоставленияСиноним = "Поиск по GUID";
					ИначеЕсли СтрокаИсходнойТаблицы.ВыгружатьКакUID = "По наименованию" Тогда
						НоваяСтрока.СпособСопоставления = "Наименование";
						НоваяСтрока.СпособСопоставленияСиноним = "Поиск по Наименованию (для справочников)";
					ИначеЕсли СтрокаИсходнойТаблицы.ВыгружатьКакUID = "Код" Тогда
						НоваяСтрока.СпособСопоставления = "Код";
						НоваяСтрока.СпособСопоставленияСиноним = "Поиск по Коду (для справочников)";
					Иначе
						НоваяСтрока.СпособСопоставления = "КакЕсть";
						НоваяСтрока.СпособСопоставленияСиноним = "Как есть (любой тип)";
					КонецЕсли;
				КонецЕсли;
				НоваяСтрока.ЗначениеИсточника = СтрокаИсходнойТаблицы.ID_Кода;
				НоваяСтрока.СинонимИсточника = СтрокаИсходнойТаблицы.Имя1С;	
			КонецЕсли;
		КонецЕсли;			
		ТаблицаРеквизитов.Добавить(НоваяСтрока);
	КонецЦикла;
	Возврат ТаблицаРеквизитов;
КонецФункции

// Конвертирует старые настройки загрузки полей в новые 
//
// Параметры:
//	ТаблицаРеквизитовИсходная - Массив из Структура - старые настройки загрузки полей
//	СписокРеквизитовMS - СписокЗначений - список реквизитов Mobile Smarts
//	СписокРеквизитов1С - СписокЗначений - список реквизитов 1С
//	СписокРеквизитовMSДляСовместимости - СписокЗначений - список реквизитов Mobile Smarts для совместимости
//
// Возвращаемое значение:
//	Массив из Структура - новые настройки загрузки полей
&НаКлиенте
Функция ЛокЯдро_КонвертироватьЗагрузкуПолей(ТаблицаРеквизитовИсходная,СписокРеквизитовMS,СписокРеквизитов1С,СписокРеквизитовMSДляСовместимости) Экспорт
	
	ТаблицаРеквизитов = Новый Массив;
	ТаблицаРеквизитов.Добавить(Новый Структура("ЭтоТаблицаЗначений,КолонкиТаблицыЗначений",Истина,"Загружать,ТипПриемникаСиноним,ИмяЗначениеПриемника,СинонимПриемника,ИмяПриемника,ТипИсточникаСиноним,ИмяЗначениеИсточника,СинонимИсточника,ЗначениеИсточника,СпособСопоставленияСиноним,ПравилоПоискаСиноним,Группировать,ОчищатьПередЗагрузкой,ОбработчикПодбораКоличества,Комментарий,ТипПриемника,ТипИсточника,ИмяИсточника,СпособСопоставления,ПравилоПоиска"));
	
	Если ТипЗнч(ТаблицаРеквизитовИсходная) = Тип("Массив") Тогда
		Для Каждого СтрокаИсходнойТаблицы Из ТаблицаРеквизитовИсходная Цикл
			Если СтрокаИсходнойТаблицы.Свойство("ЭтоТаблицаЗначений") Тогда
				Продолжить;
			КонецЕсли;
			
			НоваяСтрока = Новый Структура("Загружать,ТипПриемникаСиноним,ИмяЗначениеПриемника,СинонимПриемника,ИмяПриемника,ТипИсточникаСиноним,ИмяЗначениеИсточника,СинонимИсточника,ЗначениеИсточника,СпособСопоставленияСиноним,ПравилоПоискаСиноним,Группировать,ОчищатьПередЗагрузкой,ОбработчикПодбораКоличества,Комментарий,ТипПриемника,ТипИсточника,ИмяИсточника,СпособСопоставления,ПравилоПоиска");
			ЗаполнитьЗначенияСвойств(НоваяСтрока, СтрокаИсходнойТаблицы);
			
			// Временное решение. Загрузка старых настроек
			Если СтрокаИсходнойТаблицы.Свойство("Имя1С") Тогда
				НоваяСтрока.ИмяПриемника = СтрокаИсходнойТаблицы.Имя1С;
				НайденныйЭлементИмениПриемника = СписокРеквизитов1С.НайтиПоЗначению(НоваяСтрока.ИмяПриемника);
				Если НайденныйЭлементИмениПриемника <> Неопределено Тогда
					НоваяСтрока.СинонимПриемника = НайденныйЭлементИмениПриемника.Представление;
				Иначе
					НоваяСтрока.СинонимПриемника = СтрокаИсходнойТаблицы.Имя1С;
				КонецЕсли;
				НоваяСтрока.ТипПриемника = "Реквизит1С";
				НоваяСтрока.ТипПриемникаСиноним = "Фиксированный реквизит 1С";
			КонецЕсли;
			
			Если СтрокаИсходнойТаблицы.Свойство("ИмяMS") Тогда
				
				Если СтрокаИсходнойТаблицы.Тип = "Реквизит Mobile SMARTS" Тогда
					
					// ищем в реквизитах
					НайденныйЭлементИмениСовместимости = СписокРеквизитовMSДляСовместимости.НайтиПоЗначению(СтрокаИсходнойТаблицы.ИмяMS);
					Если НайденныйЭлементИмениСовместимости <> Неопределено Тогда
						НайденныйЭлементИмениИсточника = СписокРеквизитовMS.НайтиПоЗначению(НайденныйЭлементИмениСовместимости.Представление);
					Иначе
						НайденныйЭлементИмениИсточника = СписокРеквизитовMS.НайтиПоЗначению(СтрокаИсходнойТаблицы.ИмяMS);
					КонецЕсли;
					Если НайденныйЭлементИмениИсточника <> Неопределено Тогда
						НоваяСтрока.ИмяИсточника = НайденныйЭлементИмениИсточника.Значение;
						НоваяСтрока.СинонимИсточника = НайденныйЭлементИмениИсточника.Представление;
						НоваяСтрока.ТипИсточника = "РеквизитMS";
						НоваяСтрока.ТипИсточникаСиноним = "Реквизит Mobile SMARTS";
					КонецЕсли;
					
					Если ЗначениеЗаполнено(НоваяСтрока.ИмяИсточника) Тогда
						Если СтрокаИсходнойТаблицы.Свойство("ВыгружатьКакUID") Тогда
							Если СтрокаИсходнойТаблицы.ВыгружатьКакUID = "Ссылка (поиск по GUID)" Тогда
								НоваяСтрока.СпособСопоставления = "СтрокаGUID";
								НоваяСтрока.СпособСопоставленияСиноним = "Поиск по GUID";
							ИначеЕсли СтрокаИсходнойТаблицы.ВыгружатьКакUID = "По наименованию" Тогда
								НоваяСтрока.СпособСопоставления = "Наименование";
								НоваяСтрока.СпособСопоставленияСиноним = "Поиск по Наименованию (для справочников)";
							ИначеЕсли СтрокаИсходнойТаблицы.ВыгружатьКакUID = "Код" Тогда
								НоваяСтрока.СпособСопоставления = "Код";
								НоваяСтрока.СпособСопоставленияСиноним = "Поиск по Коду (для справочников)";
							Иначе
								НоваяСтрока.СпособСопоставления = "КакЕсть";
								НоваяСтрока.СпособСопоставленияСиноним = "Как есть (любой тип)";
							КонецЕсли;
						КонецЕсли;
					КонецЕсли;
				ИначеЕсли СтрокаИсходнойТаблицы.Тип = "Произвольный код" Тогда
				    НоваяСтрока.ТипИсточника = "ПроизвольныйКод";
					НоваяСтрока.ТипИсточникаСиноним = "Произвольный код";
					Если СтрокаИсходнойТаблицы.Свойство("ВыгружатьКакUID") Тогда
						Если СтрокаИсходнойТаблицы.ВыгружатьКакUID = "Ссылка (поиск по GUID)" Тогда
							НоваяСтрока.СпособСопоставления = "СтрокаGUID";
							НоваяСтрока.СпособСопоставленияСиноним = "Поиск по GUID";
						ИначеЕсли СтрокаИсходнойТаблицы.ВыгружатьКакUID = "По наименованию" Тогда
							НоваяСтрока.СпособСопоставления = "Наименование";
							НоваяСтрока.СпособСопоставленияСиноним = "Поиск по Наименованию (для справочников)";
						ИначеЕсли СтрокаИсходнойТаблицы.ВыгружатьКакUID = "Код" Тогда
							НоваяСтрока.СпособСопоставления = "Код";
							НоваяСтрока.СпособСопоставленияСиноним = "Поиск по Коду (для справочников)";
						Иначе
							НоваяСтрока.СпособСопоставления = "КакЕсть";
							НоваяСтрока.СпособСопоставленияСиноним = "Как есть (любой тип)";
						КонецЕсли;
					КонецЕсли;
					НоваяСтрока.ИмяИсточника = СтрокаИсходнойТаблицы.ID_Кода;
					НоваяСтрока.ЗначениеИсточника = СтрокаИсходнойТаблицы.ID_Кода;
					НоваяСтрока.СинонимИсточника = СтрокаИсходнойТаблицы.ИмяMS;
				ИначеЕсли СтрокаИсходнойТаблицы.Тип = "Дата" ИЛИ СтрокаИсходнойТаблицы.Тип = "Число" ИЛИ СтрокаИсходнойТаблицы.Тип = "Строка" ИЛИ СтрокаИсходнойТаблицы.Тип = "Булево" Тогда
					НоваяСтрока.ТипИсточника = "ПроизвольноеЗначение";
					НоваяСтрока.ТипИсточникаСиноним = "Произвольное значение";
					НоваяСтрока.СпособСопоставления = "КакЕсть";
					НоваяСтрока.СпособСопоставленияСиноним = "Как есть (любой тип)";
					НоваяСтрока.ЗначениеИсточника = СтрокаИсходнойТаблицы.ИмяMS;
				КонецЕсли;
				
			КонецЕсли;
			
			// Временное решение Окончание
			
			Если НоваяСтрока.Группировать = Неопределено 
				И СтрокаИсходнойТаблицы.Свойство("ПолеПоиска")  Тогда 
				НоваяСтрока.Группировать =  СтрокаИсходнойТаблицы.ПолеПоиска;
			КонецЕсли;
			
			Если НоваяСтрока.ПравилоПоиска = Неопределено 
				И НоваяСтрока.Группировать = Истина Тогда				
				НоваяСтрока.ПравилоПоиска = "РавноПустоТСД";
				НоваяСтрока.ПравилоПоискаСиноним = "Равно или на ТСД пусто";				
			КонецЕсли;

			ТаблицаРеквизитов.Добавить(НоваяСтрока);
		КонецЦикла;
	КонецЕсли;
	Возврат ТаблицаРеквизитов;
КонецФункции

&НаКлиенте
Функция ЛокЯдро_ПолучитьСписокАнглийскихНазванияПолейШапкиMS()
	
	Список = Новый СписокЗначений;
	Список.Добавить("Id", "Ид");
	Список.Добавить("Name", "Имя");
	Список.Добавить("DocumentTypeName", "ИмяТипаДокумента");
	Список.Добавить("WarehouseId", "ИдСклада");
	Список.Добавить("Appointment", "Назначение");
	Список.Добавить("AutoAppointed", "ВыдаватьАвтоматически");
	Список.Добавить("Barcode", "Штрихкод");
	Список.Добавить("ServerHosted", "ИсполняемыйНаСервере");
	Список.Добавить("CreateDate", "ДатаСоздания");
	Список.Добавить("Priority", "Приоритет");
	Список.Добавить("Description", "Описание");
	
	Возврат Список;
КонецФункции

&НаКлиенте
Функция ЛокЯдро_ПолучитьСписокАнглийскихНазванияПолейТЧMS()
	
	Список = Новый СписокЗначений;
	Список.Добавить("ProductId", "ИдТовара");
	Список.Добавить("PackingId", "ИдУпаковки");
	Список.Добавить("DeclaredQuantity", "КоличествоПлан");
	Список.Добавить("CurrentQuantity", "КоличествоФакт");
	Список.Добавить("FirstStorageBarcode", "ШтрихкодПервогоМеста");
	Список.Добавить("SecondStorageBarcode", "ШтрихкодВторогоМеста");	
	Список.Добавить("ExpiredDate", "СрокГодности");
	Список.Добавить("RegistrationDate", "ДатаРегистрации");
	Список.Добавить("BindedLine", "СвязаннаяСтрока");
	Список.Добавить("Overload", "Переполнение");
	Список.Добавить("Underload", "Недобор");
	Список.Добавить("UnderloadedOrOverloaded", "ЕстьНедоборИлиПереполнение");
	Список.Добавить("SSCC", "SSCC");
	
	Возврат Список;
КонецФункции

// Возвращает список полей запроса по переданному типу документа 1С и тексту запроса
//
// Параметры:
//	ТипДокумента1С - Строка - тип документа 1С	
//  ТекстЗапроса - Строка - текст запроса
//
// Возвращаемое значение:
//	СписокЗначений
&НаСервере
Функция ЗаполнитьСписокПолейЗапроса(ТипДокумента1С, ТекстЗапроса) Экспорт
	
	СписокПолей = Новый СписокЗначений;
	
	Запрос = Новый Запрос(ТекстЗапроса);
	Запрос.УстановитьПараметр("Ссылка", Документы[ТипДокумента1С].ПустаяСсылка());
	Попытка
		Результат = Запрос.Выполнить().Выгрузить();
		Для Каждого Колонка из Результат.Колонки Цикл
			СписокПолей.Добавить(Колонка.Имя, Колонка.Имя);
		КонецЦикла;
	Исключение
		Сообщить("Не удалось получить список полей по причине ошибки выполнения запроса.");
	КонецПопытки;
	
	Возврат СписокПолей;

КонецФункции

// Преобразует таблицу значений в массив структур.
// Может использоваться для передачи на клиент данных в том случае, если таблица
// значений содержит только такие значения, которые могут
// быть переданы с сервера на клиент.
//
// Полученный массив содержит структуры, каждая из которых повторяет
// структуру колонок таблицы значений.
//
// Не рекомендуется использовать для преобразования таблиц значений
// с большим количеством строк.
//
// Параметры:
//	ТаблицаЗначений - ТаблицаЗначений - исходная таблица значений.
//
// Возвращаемое значение:
//	Массив из Структура - коллекция строк таблицы в виде структур.
&НаСервере 
Функция ЛокЯдро_ТаблицуЗначенийВМассивСтруктур(Знач ТаблицаЗначений) Экспорт
	
	Если ЭтоАдресВременногоХранилища(ТаблицаЗначений) Тогда
		ТаблицаЗначений = ПолучитьИзВременногоХранилища(ТаблицаЗначений);
	КонецЕсли;
	
	//Возможно пришел массив структур
	Если ТипЗнч(ТаблицаЗначений) = Тип("Массив") И ТаблицаЗначений.Количество() > 0 
		И ТипЗнч(ТаблицаЗначений[0]) = Тип("Структура") 
		И (НЕ ТаблицаЗначений[0].Свойство("ЭтоТаблицаЗначений") ИЛИ ТаблицаЗначений[0].ЭтоТаблицаЗначений) Тогда
		Возврат ТаблицаЗначений;
	КонецЕсли;
	
	Если ТипЗнч(ТаблицаЗначений) <> Тип("ТаблицаЗначений") И ТипЗнч(ТаблицаЗначений) <> Тип("ДеревоЗначений") Тогда
	    Возврат Неопределено;
	КонецЕсли; 
	
	Массив = Новый Массив();
	
	СтруктураСтрокой = "";
	НужнаЗапятая = Ложь;
	Для Каждого Колонка Из ТаблицаЗначений.Колонки Цикл
		Если НужнаЗапятая Тогда
			СтруктураСтрокой = СтруктураСтрокой + ",";
		КонецЕсли;
		СтруктураСтрокой = СтруктураСтрокой + Колонка.Имя;
		НужнаЗапятая = Истина;
	КонецЦикла;
	
	ОписаниеТаблицыЗначений = Новый Структура("ЭтоТаблицаЗначений, КолонкиТаблицыЗначений", Истина, СтруктураСтрокой); 
	Массив.Добавить(ОписаниеТаблицыЗначений);
	
	Для Каждого Строка Из ТаблицаЗначений Цикл
		НоваяСтрока = Новый Структура(СтруктураСтрокой);
		ЗаполнитьЗначенияСвойств(НоваяСтрока, Строка);
		Для каждого ЭлементСтруктуры Из НоваяСтрока Цикл
		
			Если ТипЗнч(ЭлементСтруктуры.Значение) = Тип("ТаблицаЗначений") Тогда
				НоваяСтрока.Вставить(ЭлементСтруктуры.Ключ, ЛокЯдро_ТаблицуЗначенийВМассивСтруктур(ЭлементСтруктуры.Значение));
			КонецЕсли; 
		
		КонецЦикла; 
		Массив.Добавить(НоваяСтрока);
	КонецЦикла;
	
	Возврат Массив;

КонецФункции

// Преобразует массив структур в таблицу значений.
//
// Параметры:
//  МассивСтруктур - Массив из Структура - исходный массив структур.
//
// Возвращаемое значение:
//	ТаблицаЗначений - полученная таблица значений.
&НаСервере 
Функция ЛокЯдро_МассивСтруктурВТаблицуЗначений(Знач МассивСтруктур) Экспорт
	
	ТекстОшибки = "";
	
	Если ТипЗнч(МассивСтруктур) <> Тип("Массив") Тогда
	    ТекстОшибки = "Ошибка преобразования массива структур в таблицу значений: Параметр не является массивом!";
		Сообщение = Новый СообщениеПользователю;
		Сообщение.Текст = ТекстОшибки;
		Сообщение.Сообщить(); 
		Возврат Неопределено;
	КонецЕсли; 
	
	Если МассивСтруктур.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ОписаниеТЗ = МассивСтруктур[0];
	Если ТипЗнч(ОписаниеТЗ) <> Тип("Структура") Тогда
		ТекстОшибки = "Ошибка преобразования массива структур в таблицу значений: Не обнаружено описание таблицы значений!";
		Сообщение = Новый СообщениеПользователю;
		Сообщение.Текст = ТекстОшибки;
		Сообщение.Сообщить(); 
		Возврат Неопределено;
	КонецЕсли;
	
	КолонкиТЗ = "";
	Если НЕ ОписаниеТЗ.Свойство("ЭтоТаблицаЗначений") ИЛИ НЕ ОписаниеТЗ.Свойство("КолонкиТаблицыЗначений") Тогда
		МассивКолонок = Новый Массив;
		Для Каждого Колонка Из ОписаниеТЗ Цикл
			МассивКолонок.Добавить(Колонка.Ключ);	
		КонецЦикла;
		ИндексНачала = 0;
	Иначе 
		КолонкиТЗ = ОписаниеТЗ.КолонкиТаблицыЗначений;
		МассивКолонок = ЛокЯдро_РазложитьСтрокуВМассивПодстрок(КолонкиТЗ, ",");
		ИндексНачала = 1;
	КонецЕсли;

	ТаблицаЗначений = Новый ТаблицаЗначений;
	
	Для каждого НаименованиеКолонки Из МассивКолонок Цикл
		ТаблицаЗначений.Колонки.Добавить(НаименованиеКолонки);
	КонецЦикла; 
	
	Для Сч = ИндексНачала По МассивСтруктур.Количество() - 1 Цикл

		Если ТипЗнч(МассивСтруктур[Сч]) = Тип("Структура") Тогда
			НоваяСтрока = ТаблицаЗначений.Добавить();
			Результат = Новый Структура();
			Для каждого Элемент Из МассивСтруктур[Сч] Цикл
			
				Если ТипЗнч(Элемент.Значение) = Тип("Массив")Тогда
				
					Результат.Вставить(Элемент.Ключ, ЛокЯдро_МассивСтруктурВТаблицуЗначений(Элемент.Значение));
					
				Иначе
					
					Результат.Вставить(Элемент.Ключ, Элемент.Значение);
					
				КонецЕсли; 
			
			КонецЦикла; 
		    ЗаполнитьЗначенияСвойств(НоваяСтрока, Результат);
		КонецЕсли;
		
	КонецЦикла; 
	
	Возврат ТаблицаЗначений;

КонецФункции

// Возвращает структуру описания базы на сервере Mobile Smarts
//
// Параметры:
//	РасположениеКомпоненты - Строка - расположение компоненты Mobile Smarts
//	ТипБазы - Строка - "Частная", "Временная", "Основная"
//	ТипИнтерфейса - Строка - "REST_API", "COM"
//
// Возвращаемое значение:
//	Неопределено, Структура - см. КомЯдро_СоздатьСтруктуруОписанияБазыSMARTS или REST_API_ПолучитьОписаниеБазы (в зависимости от типа интерфейса)
&НаКлиенте 
Функция ЛокЯдро_ПолучитьОписаниеБазыSMARTS(РасположениеКомпоненты,ТипБазы = "Основная",ТипИнтерфейса=Неопределено) Экспорт
	
	Если ТипИнтерфейса = Неопределено Тогда
		ТипИнтерфейса = ЛокЯдро_ПолучитьТипИнтерфейса(ТипБазы); // ТипИнтерфейса = КомЯдро_ПолучитьЗначениеПеременной("ТипИнтерфейса");
	КонецЕсли;
	
	СтруктураДанныеБазы = Неопределено;
	Если РасположениеКомпоненты = "НаСервере" Тогда
		СтруктураВызова = Новый Структура;
		СтруктураВызова.Вставить("ТипМетода", "Функция");
		СтруктураВызова.Вставить("ИмяМетода", "НайтиБазуНаСервереСМАРТС");
		СтруктураВызова.Вставить("ПараметрыМетода", Новый Структура("ТипБазы,ТипИнтерфейса",ТипБазы,ТипИнтерфейса));
		СтруктураДанныеБазы = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,,АдресаПеременных);	
	Иначе
		Если ТипИнтерфейса = "REST_API" Тогда
			Если ТипБазы = "Частная" Тогда
				СтруктураПодключенияБазыMS = КомЯдро_ПолучитьЗначениеПеременной("REST_API_СтруктураПодключенияЧастнойБазыMS");	
			ИначеЕсли ТипБазы = "Временная" Тогда
				СтруктураПодключенияБазыMS = КомЯдро_ПолучитьЗначениеПеременной("REST_API_СтруктураПодключенияВременнойБазыMS");
			Иначе
				СтруктураПодключенияБазыMS = КомЯдро_ПолучитьЗначениеПеременной("REST_API_СтруктураПодключенияБазыMS");
			КонецЕсли;
			
			Если ТипЗнч(СтруктураПодключенияБазыMS) = Тип("Структура")
				И СтруктураПодключенияБазыMS.Свойство("ОписаниеБазы") Тогда
				СтруктураДанныеБазы = СтруктураПодключенияБазыMS.ОписаниеБазы;
				Если НЕ (ТипЗнч(СтруктураДанныеБазы) = Тип("Структура") 
						И СтруктураДанныеБазы.Свойство("АвторизацияВключена")
						И СтруктураДанныеБазы.АвторизацияВключена) Тогда
					СтруктураДанныеБазы = REST_API_ПолучитьОписаниеБазы(ТипБазы,АдресаПеременных);	
				КонецЕсли;
			Иначе
				СтруктураДанныеБазы = REST_API_ПолучитьОписаниеБазы(ТипБазы,АдресаПеременных);
			КонецЕсли;
		Иначе
			Если ТипБазы = "Частная" Тогда
				СтруктураПодключенияБазыMS = КомЯдро_ПолучитьЗначениеПеременной("СтруктураПодключенияЧастнойБазыMS");	
			ИначеЕсли ТипБазы = "Временная" Тогда
				СтруктураПодключенияБазыMS = КомЯдро_ПолучитьЗначениеПеременной("СтруктураПодключенияВременнойБазыMS");
			Иначе
				СтруктураПодключенияБазыMS = КомЯдро_ПолучитьЗначениеПеременной("СтруктураПодключенияБазыMS");
			КонецЕсли;
			
			Если ТипЗнч(СтруктураПодключенияБазыMS) = Тип("Структура")
				И СтруктураПодключенияБазыMS.Свойство("ОписаниеБазы") Тогда
				СтруктураДанныеБазы = СтруктураПодключенияБазыMS.ОписаниеБазы;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	Если СтруктураДанныеБазы <> Неопределено Тогда
		#Область НесовместимыйКодFresh
		ФормироватьСтрокуСоединения = Ложь;
		#КонецОбласти //НесовместимыйКодFresh
		#Область СовместимыйКодFresh
		//ФормироватьСтрокуСоединения = Истина;
		#КонецОбласти //СовместимыйКодFresh
		
		Если ФормироватьСтрокуСоединения Тогда
			База1ССтрокаСоединенияКлиент = СокрЛП(СтрокаСоединенияИнформационнойБазы());
			Если ЛокЯдро_СтрНайти(База1ССтрокаСоединенияКлиент,"ws=""http") > 0 Тогда // Если подключение через веб-клиент, то оставим только строку подключения
				База1ССтрокаСоединенияКлиент = Прав(База1ССтрокаСоединенияКлиент,СтрДлина(База1ССтрокаСоединенияКлиент)-4); //обрезаем ws=" в начале
				База1ССтрокаСоединенияКлиент = Лев(База1ССтрокаСоединенияКлиент,СтрДлина(База1ССтрокаСоединенияКлиент)-2);  //обрезаем "; в конце
				База1ССтрокаСоединенияКлиент = База1ССтрокаСоединенияКлиент+"/hs/clevhs"; // Допишем строку к http-сервисам для 1СFresh
			КонецЕсли;
			СтруктураДанныеБазы.Вставить("База1ССтрокаСоединенияКлиент", База1ССтрокаСоединенияКлиент);
		Иначе
			СтруктураДанныеБазы.Вставить("База1ССтрокаСоединенияКлиент", "");
		КонецЕсли;
	КонецЕсли;
	
	Возврат СтруктураДанныеБазы;
	
КонецФункции

// Получает базу на сервере Mobile Smarts по идентификатору и возвращает ее описание
//
// Параметры:
//	РежимПоиска - Строка - расположение компоненты Mobile Smarts
//	ИДБазы - Строка - идентификатор базы на сервере Mobile Smarts		
//	ТипБазы - Строка - "Частная", "Временная", "Основная"
//
//Возвращаемое значение:
//	Неопределено, Структура - см. КомЯдро_СоздатьСтруктуруОписанияБазыSMARTS
&НаКлиенте
Функция ЛокЯдро_ПолучитьБазуНаСервереSMARTS(РежимПоиска,ИДБазы,ТипБазы = "Временная") Экспорт
	
	Если РежимПоиска = "НаСервере" Тогда
		СтруктураВызова = Новый Структура;
		СтруктураВызова.Вставить("ТипМетода", "Функция");
		СтруктураВызова.Вставить("ИмяМетода", "ПолучитьБазуНаСервереSMARTS");
		СтруктураВызова.Вставить("ПараметрыМетода", Новый Структура("ИДБазы,ТипБазы", ИДБазы,ТипБазы));
		СтруктураДанныеБазы = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,,АдресаПеременных);	
	Иначе
		Если НЕ КомЯдро_ПодключитьсяКСерверуSMARTS(,ТипБазы) Тогда
			Возврат Неопределено;
		КонецЕсли;
		ОписаниеБазы = КомЯдро_ПолучитьБазуНаСервереSMARTS(ИДБазы,ТипБазы);
		Если ОписаниеБазы = Неопределено Тогда
			Возврат Неопределено;
	    КонецЕсли;
		СтруктураДанныеБазы = КомЯдро_СоздатьСтруктуруОписанияБазыSMARTS(ОписаниеБазы);
	КонецЕсли;
	
	Возврат СтруктураДанныеБазы; 
КонецФункции

// Выполняет поиск в массиве структур по заданным ключу и значению ключа
//
// Параметры:
//	МассивСтруктур - Массив из Структура - массив структур, в котором выполняетчся поиск
//	КлючПоиска - Строка - ключ структуры, по которому выполняется поиск
//	ЗначениеПоиска - Произвольный - значение ключа структуры, по которому выполняется поиск
//	ВернутьИндекс - Булево - флаг необходимости вернуть индекс элемента массива, а не сам элемент
//
// Возвращаемое значение:
//	- Число - индекс найденного элемента массива, если ВернутьИндекс = Истина
//	- Структура - значение найденного элемента массива, если ВернутьИндекс = Ложь
//	- Неопределено - если элемент массива найти не удалось
&НаКлиенте
Функция НайтиСтруктуруВМассивеПоЭлементу(МассивСтруктур, КлючПоиска, ЗначениеПоиска,ВернутьИндекс=Ложь) Экспорт
	
	Если ТипЗнч(МассивСтруктур) <> Тип("Массив") 
		ИЛИ КлючПоиска = "" 
		ИЛИ ЗначениеПоиска = Неопределено Тогда
		// переданные параметры некорректны 
		Возврат Неопределено;
	КонецЕсли;
	
	НайденноеЗначениеЭлемента = Неопределено;
	Индекс = -1;
	Для каждого ЭлементМассива Из МассивСтруктур Цикл
		Индекс = Индекс + 1;
		Если ТипЗнч(ЭлементМассива) <> Тип("Структура") Тогда
			Продолжить;
		КонецЕсли;  
		
		Если ЭлементМассива.Свойство(КлючПоиска, НайденноеЗначениеЭлемента) Тогда
			Если НайденноеЗначениеЭлемента = ЗначениеПоиска Тогда
				Возврат ?(ВернутьИндекс,Индекс,ЭлементМассива);
			КонецЕсли; 
		КонецЕсли; 
	
	КонецЦикла; 
	
	Возврат Неопределено;

КонецФункции // НайтиСтруктуруВМассивеПоЭлементу()
 
// Возвращает новый уникальный идентификатор с префиксом
//
// Параметры:
//  Префикс - Строка
//
// Возвращаемое значение:
//	Строка
&НаСервере
Функция ЛокЯдро_ПолучитьНовыйID(Префикс) Экспорт
	
	Возврат Префикс + СтрЗаменить(Строка(Новый УникальныйИдентификатор()), "-", "");
	
КонецФункции

// Вызывает из модуля обработки функцию получения метаданных НСИ из интеграционной обработки
//
// Возвращаемое значение:
//	Структура - ключами являются наименования метаданных НСИ, значениями - структуры, содержащие описание
//				этих метаданных в конфигурациях, для которых предназначена интеграционная обработка
&НаКлиенте
Функция ЛокЯдро_ПолучитьМетаданныеНСИ() Экспорт
	
	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода", "Функция");
	СтруктураВызова.Вставить("ИмяМетода", "ПолучитьМетаданныеНСИ");
	
	МетаданныеНСИ = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,,АдресаПеременных);	
	
	Возврат МетаданныеНСИ;
	
КонецФункции

// Получает макет обработки
//
// Параметры:
//	ИмяМакета - Строка
//
// Возвращаемое значение:
//	- ТабличныйДокумент
//  - ТекстовыйДокумент
//	- другой объект, который может быть макетом.
&НаКлиенте
Функция ЛокЯдро_ПолучитьМакетОбработки(ИмяМакета) Экспорт
	
	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода", "Функция");
	СтруктураВызова.Вставить("ИмяМетода", "ПолучитьМакетОбработки");
	СтруктураВызова.Вставить("ПараметрыМетода", Новый Структура("ИмяМакета", ИмяМакета));
	
	Возврат Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова);
	
КонецФункции

// Определяет наличие штрихкода в базе 1С путем выполнения запроса
// к объекту метаданных, в котором хранятся штрихкоды номенклатуры
//
// Параметры:
//	Штрихкод - Строка	
//  СтруктураХраненияШК - Структура - содержит:
//		* ШК_ОбъектМетаданных - Строка - имя объекта метаданных, в котором хранятся штрихкоды номенклатуры
//      * ШК_ИзмерениеШтрихкода - Строка - имя реквзита объекта метаданных, в котором хранятся значения штрихкодов
//
// Возвращаемое значение:
//	Булево - флаг наличия штрихкода в базе 1С
&НаКлиенте
Функция ЛокЯдро_ШтрихКодЕстьВБазе1С(Штрихкод, СтруктураХраненияШК) Экспорт
	
	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода", "Функция");
	СтруктураВызова.Вставить("ИмяМетода", "ШтрихКодЕстьВБазе1С");
	
	ПараметрыМетода = Новый Структура;
	ПараметрыМетода.Вставить("Штрихкод", Штрихкод);
	ПараметрыМетода.Вставить("СтруктураХраненияШК", СтруктураХраненияШК);
	
	СтруктураВызова.Вставить("ПараметрыМетода", ПараметрыМетода);
	
	РезультатФункции = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова);	
	
	Возврат РезультатФункции;
	
КонецФункции

// Вызывает из модуля обработки функцию получения данных штрихкода из интеграционной обработки
//
// Параметры:
//	Штрихкод - Строка - штрихкод, данные которого требуется получить	
//
// Возвращаемое значение:
//	Структура - содержит данные штрихкода, полученные путем выполнения запроса
//				к объекту метаданных, содержащему штрихкоды номенклатуры
&НаКлиенте
Функция ЛокЯдро_ПолучитьДанныеШтрихКода(Штрихкод) Экспорт
	
	ПараметрыМетода = Новый Структура;
	ПараметрыМетода.Вставить("Штрихкод", Штрихкод);
	
	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода", "Функция");
	СтруктураВызова.Вставить("ИмяМетода", "ПолучитьДанныеШтрихКода");
	СтруктураВызова.Вставить("ПараметрыМетода", ПараметрыМетода);

	Возврат Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,,АдресаПеременных);
	
КонецФункции

// Возвращает универсальное имя обработчика в виде [ПрефиксКонфигурации]_[ТипДокумента (при наличии)]_[ТипОбработчика]
//
// Параметры:
//	ТипОбработчика - Строка - тип обработчика	
//  ТипДокумента - Строка - тип документа
//
// Возвращаемое значение:
//	Строка
&НаКлиенте
Функция ЛокЯдро_ПолучитьУниверсальноеИмяОбработчика(ТипОбработчика, ТипДокумента = "") Экспорт
	
	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода", "Функция");
	СтруктураВызова.Вставить("ИмяМетода", "ПолучитьУниверсальноеИмяОбработчика");
	ПараметрыМетода = Новый Структура;
	ПараметрыМетода.Вставить("ТипОбработчика", ТипОбработчика);
	ПараметрыМетода.Вставить("ТипДокумента", ТипДокумента);
	СтруктураВызова.Вставить("ПараметрыМетода", ПараметрыМетода);
	
	УниверсальноеИмяОбработчика = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,,АдресаПеременных);	
	
	Возврат УниверсальноеИмяОбработчика;
	
КонецФункции

// Вызывает из модуля обработки функцию проверки доступности обработчика в интеграционной обработке
//
// Параметры:
//	ИмяОбработчика - Строка - имя обработчика
//  СтруктураПараметров - Структура - содержит параметры обработчика
//
// Возвращаемое значение: 
//	Структура - содержит:
//		* Статус - Булево - флаг успешности результата проверки
//		* Сообщение - Строка - информационное сообщение о результатах проверки
&НаКлиенте
Функция ЛокЯдро_ПроверитьДоступностьОбработчика(ИмяОбработчика, СтруктураПараметров) Экспорт
	
	РезультатПроверки = Новый Структура("Статус,Сообщение", Истина, "");
	
	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода", "Функция");
	СтруктураВызова.Вставить("ИмяМетода", "ПроверитьДоступностьОбработчика");
	ПараметрыМетода = Новый Структура;
	ПараметрыМетода.Вставить("ИмяОбработчика", ИмяОбработчика);
	ПараметрыМетода.Вставить("СтруктураПараметров", СтруктураПараметров);
	СтруктураВызова.Вставить("ПараметрыМетода", ПараметрыМетода);
	
	РезультатВызова = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,,АдресаПеременных);	
	
	РезультатПроверки.Вставить("Статус", РезультатВызова.Статус);
	
	Если РезультатВызова.Статус Тогда
		РезультатПроверки.Вставить("Сообщение", "В качестве колонки ограничения будет использована колонка с именем [" + РезультатВызова.Сообщение + "]");
	Иначе
		РезультатПроверки.Вставить("Сообщение", "Для данного документа не создан обработчик с именем [" + ИмяОбработчика + "()]");
	КонецЕсли;
	
	Возврат РезультатПроверки;
	
КонецФункции

// Вызывает функцию проверки доступности обработчика на форме интеграционной обработки
//
// Параметры:
//	ИмяОбработчика - Строка - имя обработчика
//
// Возвращаемое значение: 
//	Структура - содержит:
//		* Статус - Булево - флаг успешности результата проверки
//		* Сообщение - Строка - информационное сообщение о результатах проверки
&НаКлиенте
Функция ЛокЯдро_ПроверитьДоступностьОбработчикаФормы(ИмяОбработчика) Экспорт
	
	РезультатПроверки = Новый Структура("Статус, Сообщение", Ложь, "");
	
	// Если метод есть в интеграционной обработке, то возвращается ошибка о недостаточности фактических параметров, без имени метода; 
	// а если метода нет, то ошибка возвращает текст, что такой-то метод не обнаружен. Вот наличие имени обработчика в сообщении и проверяем
	Попытка
		#Область НесовместимыйКодFresh
		Выполнить("ФормаИнтеграционнойОбработки." + ИмяОбработчика + "()");
		#КонецОбласти //НесовместимыйКодFresh
		#Область СовместимыйКодFresh
		//СтруктураВыполнения = ФормаИнтеграционнойОбработки.ВыполнитьОбработчик_ПослеОткрытияФормыДокумента(ИмяОбработчика, Неопределено);
		//Инфо = СтруктураВыполнения.ИнфоОбОшибке;
		//Если Инфо <> Неопределено Тогда
		//	Описание = Инфо.Описание;
		//КонецЕсли;
		#КонецОбласти //СовместимыйКодFresh
	Исключение
		Инфо 		= ИнформацияОбОшибке();
		Описание 	= Инфо.Описание;
	КонецПопытки;
	
	#Область НесовместимыйКодFresh
	РезультатПроверки.Статус 	= ЛокЯдро_СтрНайти(ВРег(Описание), "(" + ВРег(ИмяОбработчика) + ")") = 0;
	#КонецОбласти //НесовместимыйКодFresh
	#Область СовместимыйКодFresh
	//РезультатПроверки.Статус 	= Описание <> "Ошибка при вызове метода контекста (ПодключитьОбработчикОжидания)";
	#КонецОбласти //СовместимыйКодFresh
	РезультатПроверки.Сообщение = Описание;
	
	Возврат РезультатПроверки;	
	
КонецФункции

// Вызывает из модуля обработки функцию получения единицы измерения по умолчанию из интеграционной обработки
//
// Параметры:
//	ТоварСсылка - СправочникСсылка.Номенклатура - ссылка на элемент номенклатуры, единицу измерения которого требуется получить	
//
// Возвращаемое значение:
//	- СправочникСсылка.[ИмяОбъектаМетаданныхСодержащегоЕдиницыИзмерения] - единица измерения переданной номенклатуры
//	- Неопределено - если единицу измерения получить не удалось
&НаКлиенте
Функция ЛокЯдро_ПолучитьЕдиницуИзмеренияПоУмолчанию(ТоварСсылка) Экспорт
	
	ПараметрыМетода = Новый Структура;
	ПараметрыМетода.Вставить("ТоварСсылка", ТоварСсылка);
	
	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода", "Функция");
	СтруктураВызова.Вставить("ИмяМетода", "ПолучитьЕдиницуИзмеренияПоУмолчанию");
	СтруктураВызова.Вставить("ПараметрыМетода", ПараметрыМетода);

	Возврат Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,,АдресаПеременных);
	
КонецФункции

// Разбивает строку на несколько строк по указанному разделителю. Разделитель может иметь любую длину.
//
// Параметры:
//  Значение    - Строка - текст с разделителями
//  Разделитель - Строка - разделитель строк текста, минимум 1 символ
//
// Возвращаемое значение:
//  Массив из Строка
&НаСервереБезКонтекста
Функция ЛокЯдро_РазложитьСтрокуВМассивПодстрок(Знач Стр, Разделитель = ",") Экспорт
	
	МассивСтрок = Новый Массив();
	Если Разделитель = " " Тогда
		Стр = СокрЛП(Стр);
		Пока 1 = 1 Цикл
			Поз = Найти(Стр, Разделитель);
			Если Поз = 0 Тогда
				МассивСтрок.Добавить(Стр);
				Возврат МассивСтрок;
			КонецЕсли;
			МассивСтрок.Добавить(Лев(Стр, Поз - 1));
			Стр = СокрЛ(Сред(Стр, Поз));
		КонецЦикла;
	Иначе
		ДлинаРазделителя = СтрДлина(Разделитель);
		Пока 1 = 1 Цикл
			Поз = Найти(Стр, Разделитель);
			Если Поз = 0 Тогда
				Если (СокрЛП(Стр) <> "") Тогда
					МассивСтрок.Добавить(Стр);
				КонецЕсли;
				Возврат МассивСтрок;
			КонецЕсли;
			МассивСтрок.Добавить(Лев(Стр,Поз - 1));
			Стр = Сред(Стр, Поз + ДлинаРазделителя);
		КонецЦикла;
	КонецЕсли;
	
КонецФункции

// Возвращает текстовое представление интервала времени, заданного в секундах.
//
// Параметры:
//	Время - Число - интервал времени в секундах.
//
// Возвращаемое значение:
//	Строка - представление интервала времени.
&НаКлиенте
Функция ЛокЯдро_ПредставлениеВремени(Время) Экспорт

	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода", "Функция");
	СтруктураВызова.Вставить("ИмяМетода", "ПредставлениеВремени");	
	СтруктураВызова.Вставить("ПараметрыМетода", Новый Структура("Время", Время));
	
	Возврат Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова);

КонецФункции

// Формирует подробное сообщение о выгрузке таблицы на сервер Mobile Smarts
//
// Параметры:
//	Сообщение - Строка - результат выгрузки таблицы
//  ПредставлениеВремениОбщее - Строка - текстовое представление общего времени выгрузки
//  ПредставлениеВремени1С - Строка - текстовое представление времени получения данных из 1С
//  ПредставлениеВремениMS - Строка - текстовое представление времени выгрузки данных на сервер Mobile Smarts
//
// Возвращаемое значение:
//	Строка
&НаКлиенте
Функция ЛокЯдро_СформироватьПодробноеСообщениеОВыгрузкеТаблицы(Знач Сообщение, ПредставлениеВремениОбщее, ПредставлениеВремени1С, ПредставлениеВремениMS) Экспорт

	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода"		, "Функция");
	СтруктураВызова.Вставить("ИмяМетода"		, "СформироватьПодробноеСообщениеОВыгрузкеТаблицы");	
	СтруктураВызова.Вставить("ПараметрыМетода"	, Новый Структура);
	
	СтруктураВызова.ПараметрыМетода.Вставить("Сообщение"				, Сообщение);
	СтруктураВызова.ПараметрыМетода.Вставить("ПредставлениеВремениОбщее", ПредставлениеВремениОбщее);
	СтруктураВызова.ПараметрыМетода.Вставить("ПредставлениеВремени1С"	, ПредставлениеВремени1С);
	СтруктураВызова.ПараметрыМетода.Вставить("ПредставлениеВремениMS"	, ПредставлениеВремениMS);
	
	Возврат Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова);

КонецФункции

// Получает тип установленного продукта по описанию подключенной базы Mobile Smarts
//
// Параметры:
//	ИдПриложения - Строка -	идентификатор приложения в описании базы
//	ИдОсновногоПриложения - Строка - идентификатор основного приложения в описании базы
//
// Возвращаемое значение:
//	Строка
&НаКлиенте
Функция ЛокЯдро_ПолучитьТипУстановленногоПродукта(ИдПриложения, ИдОсновногоПриложения = Неопределено) Экспорт

	НаборИДСклад	= ЛокЯдро_ПолучитьИдСклада();
	НаборИДМагазин	= ЛокЯдро_ПолучитьИдМагазина();
	
	Если НаборИДМагазин.Получить(ВРег(СокрЛП(ИдПриложения))) <> Неопределено
		ИЛИ НаборИДМагазин.Получить(ВРег(СокрЛП(ИдОсновногоПриложения))) <> Неопределено Тогда
		
		ТипУстановленногоПродукта = "Магазин";
		
	ИначеЕсли НаборИДСклад.Получить(ВРег(СокрЛП(ИдПриложения))) <> Неопределено
		ИЛИ НаборИДСклад.Получить(ВРег(СокрЛП(ИдОсновногоПриложения))) <> Неопределено Тогда
		
		ТипУстановленногоПродукта = "Склад";
		
	ИначеЕсли ВРег(СокрЛП(ИдПриложения)) = ВРег(СокрЛП("8022B928-C509-4F7A-B119-2F77942FDF63"))
		ИЛИ ВРег(СокрЛП(ИдОсновногоПриложения)) = ВРег(СокрЛП("8022B928-C509-4F7A-B119-2F77942FDF63")) Тогда
		
		ТипУстановленногоПродукта = "Курьер";	
		
	ИначеЕсли ВРег(СокрЛП(ИдПриложения)) = ВРег(СокрЛП("A3AAE75F-9961-4733-AC61-F09EAB9BE328")) 
		ИЛИ ВРег(СокрЛП(ИдОсновногоПриложения)) = ВРег(СокрЛП("A3AAE75F-9961-4733-AC61-F09EAB9BE328")) 
		Или ВРег(СокрЛП(ИдПриложения)) = ВРег(СокрЛП("D30D2520-A6BE-4CBF-B06C-B063095BFBBC")) 
		ИЛИ ВРег(СокрЛП(ИдОсновногоПриложения)) = ВРег(СокрЛП("D30D2520-A6BE-4CBF-B06C-B063095BFBBC")) Тогда		
		
		ТипУстановленногоПродукта = "Прайсчекер";
		
	ИначеЕсли ВРег(СокрЛП(ИдПриложения)) = ВРег(СокрЛП("1DC2DC26-0BEE-4959-98A4-8D70D59C0189"))
		ИЛИ ВРег(СокрЛП(ИдОсновногоПриложения)) = ВРег(СокрЛП("1DC2DC26-0BEE-4959-98A4-8D70D59C0189")) Тогда
		
		ТипУстановленногоПродукта = "МДЛП";
		
	Иначе
		
		ТипУстановленногоПродукта = "Не удалось определить...";
		
	КонецЕсли;		
	
	Возврат ТипУстановленногоПродукта;
	
КонецФункции

Функция ЛокЯдро_ПолучитьИдСклада()

	НаборИДСклад = Новый Соответствие();
	
	НаборИДСклад.Вставить("FD6465C0-C44A-455E-869D-02DFF3143373", "Базовый"); 		// Склад 15, Базовый с ЕГАИС: 				Артикул: WH15AE-1C83
	НаборИДСклад.Вставить("9B3E6ADA-9AD3-4928-8F96-10455B03EC94", "Расширенный"); 	// Склад 15, Расширенный с ЕГАИС: 			Артикул: WH15BE-1C83
	НаборИДСклад.Вставить("225366C9-7149-4F43-9D31-2B205CB808E8", "Полный"); 		// Склад 15, Полный с ЕГАИС: 				Артикул: WH15CE-1C83
	НаборИДСклад.Вставить("79C0F5DF-A166-490F-8270-10D082503F1B", "Базовый"); 		// Склад 15, Базовый с МОТП: 				Артикул: WH15AT-1C83
	НаборИДСклад.Вставить("1C0290DA-ACF4-4E1D-AC75-034AD01AC8AF", "Расширенный"); 	// Склад 15, Расширенный с МОТП: 			Артикул: WH15BT-1C83
	НаборИДСклад.Вставить("B6ED486C-B5BA-4E0D-A5F2-065E7C590E6F", "Полный"); 		// Склад 15, Полный с МОТП: 				Артикул: WH15CT-1C83
	НаборИДСклад.Вставить("A3646B4B-421C-465B-BAC9-DE6265CA478D", "Базовый"); 		// Склад 15, Базовый с ЕГАИС и МОТП:		Артикул: WH15AET-1C83
	НаборИДСклад.Вставить("27833CA4-72E4-4D88-B171-F0CD1A929575", "Расширенный"); 	// Склад 15, Расширенный с ЕГАИС и МОТП: 	Артикул: WH15BET-1C83
	НаборИДСклад.Вставить("B648F175-3F6A-462F-AD05-473B00D6DF6A", "Полный"); 		// Склад 15, Полный с ЕГАИС и МОТП: 		Артикул: WH15CET-1C83
	НаборИДСклад.Вставить("6A80DE7A-0DD7-4226-8ADC-4EA01BD40586", "Базовый"); 		// Склад 15, Базовый с Кировкой: 			Артикул: WH15AK-1C83
	НаборИДСклад.Вставить("15266969-9980-4AA4-A34C-08D241B67305", "Расширенный"); 	// Склад 15, Расширенный с Кировкой: 		Артикул: WH15BK-1C83
	НаборИДСклад.Вставить("212E5362-5969-40DC-9781-CB7B8AB811DB", "Полный"); 		// Склад 15, Полный с Кировкой: 			Артикул: WH15CK-1C83
	
	Возврат НаборИДСклад;

КонецФункции

Функция ЛокЯдро_ПолучитьИдМагазина()

	НаборИДМагазин = Новый Соответствие();
	
	НаборИДМагазин.Вставить("6D0E08AE-4A95-4D1F-974E-A39BD727D446", "Минимум"); 	// Магазин 15, Минимум
	НаборИДМагазин.Вставить("F42C7B5F-405C-4076-AE07-9348F189EE71", "Базовый"); 	// Магазин 15, Базовый / Базовый с ЕГАИС / Общепит
	НаборИДМагазин.Вставить("BEB9F819-15DA-490A-B3C1-657313366191", "Расширенный"); // Магазин 15, Расширенный / Расширенный с ЕГАИС
	НаборИДМагазин.Вставить("44005805-2DCA-45A7-9C34-0A07FDB3FE12", "Полный"); 		// Магазин 15, Полный / Демо / Мегамаркет с ЕГАИС / Мегамаркет
	НаборИДМагазин.Вставить("1F274C52-AB81-4683-B32B-670377B06C49", "Базовый"); 	// Магазин 15, Базовый с ЕГАИС и МОТП
	НаборИДМагазин.Вставить("5E91F650-A426-4A91-84DB-95F7AD21A74B", "Базовый"); 	// Магазин 15, Базовый с МДЛП
	НаборИДМагазин.Вставить("8C71B6D0-E7F3-4E55-85E9-B672D25FFF93", "Базовый"); 	// Магазин 15, Базовый с МОТП
	НаборИДМагазин.Вставить("84599890-B97D-46F2-BE26-3FCA10168211", "Полный"); 		// Магазин 15, Мегамаркет с ЕГАИС и МОТП
	НаборИДМагазин.Вставить("6737FE34-D882-44E3-9266-67BC0FC2F876", "Полный"); 		// Магазин 15, Мегамаркет с МДЛП
	НаборИДМагазин.Вставить("2992E28B-B3C8-4056-91CA-F1D62B3F7BA5", "Полный"); 		// Магазин 15, Мегамаркет с МОТП
	НаборИДМагазин.Вставить("7390E2F7-4EE1-4354-824A-F8A90BF18A22",	"Базовый"); 	// Магазин 15, Продуктовый Базовый без ЕГАИС
	НаборИДМагазин.Вставить("FD7A47C1-C067-497A-BD99-5447D0446B74", "Базовый"); 	// Магазин 15, Продуктовый Базовый
	НаборИДМагазин.Вставить("4783EE23-6789-4DF0-A143-D63F93DFAD73", "Полный"); 		// Магазин 15, Продуктовый Мегамаркет без ЕГАИС
	НаборИДМагазин.Вставить("46A30E5E-67C3-44E9-9974-21AF99A952ED", "Полный"); 		// Магазин 15, Продуктовый Мегамаркет
	НаборИДМагазин.Вставить("F66F38A5-3826-46EE-82E5-5B63F93658A1", "Расширенный"); // Магазин 15, Продуктовый Расширенный без ЕГАИС
	НаборИДМагазин.Вставить("68C8847C-96B5-482C-979A-5152FCBDC4E9", "Расширенный"); // Магазин 15, Продуктовый Расширенный
	НаборИДМагазин.Вставить("9879D274-E98D-4B1A-B05F-86F3D546D138", "Расширенный"); // Магазин 15, Расширенный с ЕГАИС и МОТП
	НаборИДМагазин.Вставить("F56852C7-EF97-4EFE-BDE3-7F01132BC2FF",	"Расширенный"); // Магазин 15, Расширенный с МДЛП
	НаборИДМагазин.Вставить("54281FF1-A6FB-47BC-A8DF-C6EE289592A1", "Расширенный"); // Магазин 15, Расширенный с МОТП
	НаборИДМагазин.Вставить("77318905-FB62-4C3C-8DD6-374F0BEA1450",	"Базовый"); 	// Магазин 15, Шмотки Базовый
	НаборИДМагазин.Вставить("D843170E-A956-4CDA-B3EF-47E244482C86", "Полный"); 		// Магазин 15, Шмотки Мегамаркет
	НаборИДМагазин.Вставить("A0043528-C6CC-48F9-8BB3-8C5BEF2FCA79", "Расширенный"); // Магазин 15, Шмотки Расширенный
	
	Возврат НаборИДМагазин;
	
КонецФункции

// Получает уровень приложения строкой по описанию подключенной базы Mobile Smarts
//
// Параметры:
//	УровеньЧислом - Число - уровень приложения в описании базы	
//	
// Возвращаемое значение:
//	Строка
&НаКлиенте
Функция ЛокЯдро_ПолучитьУровеньПриложения(УровеньЧислом) Экспорт

	Если УровеньЧислом = 0 Тогда
		
		УровеньПриложения = "Минимум";
		
	ИначеЕсли УровеньЧислом = 1 Тогда
		
		УровеньПриложения = "Базовый";	
		
	ИначеЕсли УровеньЧислом = 2 Тогда
		
		УровеньПриложения = "Расширенный";		
		
	ИначеЕсли УровеньЧислом = 100 Тогда
		
		УровеньПриложения = "Полный";	
		
	Иначе	
		
		УровеньПриложения = "Не удалось определить...";	
		
	КонецЕсли;	
	
	Возврат УровеньПриложения;
	
КонецФункции

// Получает информацию об установленном продукте Mobile Smarts по описанию подключенной базы
//
// Параметры:
//	ИдПриложения - Строка -	идентификатор приложения в описании базы
//	ИдОсновногоПриложения - Строка - идентификатор основного приложения в описании базы
//
// Возвращаемое значение 
//	Структура - содержит:
//		* ТипУстановленногоПродукта - Строка
//		* УровеньПриложения - Строка
&НаКлиенте
Функция ЛокЯдро_ПолучитьИнформациюОПродукте(ИдПриложения, ИдОсновногоПриложения = Неопределено) Экспорт
	
	СоответствиеПродуктов = Новый Соответствие;
	
	НаборИдМагазин = ЛокЯдро_ПолучитьИдМагазина();
	Для каждого ИдМагазина ИЗ НаборИдМагазин Цикл
		СоответствиеПродуктов.Вставить(ИдМагазина.Ключ, Новый Структура("ТипУстановленногоПродукта, УровеньПриложения", "Магазин", ИдМагазина.Значение));
	КонецЦикла;
		
	НаборИдСклад = ЛокЯдро_ПолучитьИдСклада();
	Для каждого ИдСклад ИЗ НаборИдСклад Цикл
		СоответствиеПродуктов.Вставить(ИдСклад.Ключ, Новый Структура("ТипУстановленногоПродукта, УровеньПриложения", "Склад", ИдСклад.Значение));
	КонецЦикла;
	
	СоответствиеПродуктов.Вставить("8022B928-C509-4F7A-B119-2F77942FDF63", Новый Структура("ТипУстановленногоПродукта, УровеньПриложения", "Курьер", "")); 	 		   // Курьер
	СоответствиеПродуктов.Вставить("A3AAE75F-9961-4733-AC61-F09EAB9BE328", Новый Структура("ТипУстановленногоПродукта, УровеньПриложения", "Прайсчекер", "")); 	 	   // Прайсчекер
	СоответствиеПродуктов.Вставить("D30D2520-A6BE-4CBF-B06C-B063095BFBBC", Новый Структура("ТипУстановленногоПродукта, УровеньПриложения", "Прайсчекер", "")); 	 	   // Прайсчекер
	СоответствиеПродуктов.Вставить("1DC2DC26-0BEE-4959-98A4-8D70D59C0189", Новый Структура("ТипУстановленногоПродукта, УровеньПриложения", "МДЛП", "")); 	 		   // МДЛП
	
	ИнформацияОПродукте = СоответствиеПродуктов.Получить(ВРег(СокрЛП(ИдПриложения)));
	
	Если ИнформацияОПродукте = Неопределено Тогда
		ИнформацияОПродукте = СоответствиеПродуктов.Получить(ВРег(СокрЛП(ИдОсновногоПриложения)));	
	КонецЕсли;	
	
	Если ИнформацияОПродукте = Неопределено Тогда
		ИнформацияОПродукте = Новый Структура("ТипУстановленногоПродукта, УровеньПриложения", "Не удалось определить...", "");			
	КонецЕсли;
	
	Возврат ИнформацияОПродукте;
	
КонецФункции

// Получает из кэша тип интерфейса для переданного типа базы
//
// Параметры:
//	ТипБазы - Строка - "Частная", "Временная", "Основная"
//
// Возвращаемое значение:
//	Строка - "COM", "REST_API"
&НаКлиенте
Функция ЛокЯдро_ПолучитьТипИнтерфейса(ТипБазы = "Основная") Экспорт

	ТипИнтерфейса = Неопределено;
	
	Если ТипБазы = "Частная" И ТипЗнч(ДанныеТекущегоУзла) = Тип("Структура") Тогда
		ДанныеУзла = Неопределено;
		ВсеУзлы = ЛокЯдро_ПолучитьИзКэшаНастройкуSMARTS("Узлы");
		Если ТипЗнч(ВсеУзлы) = Тип("Массив") Тогда
			ДанныеУзла = НайтиСтруктуруВМассивеПоЭлементу(ВсеУзлы, "ID_Узла", ДанныеТекущегоУзла.ID_Узла);
		КонецЕсли;
			
		Если ДанныеУзла <> Неопределено И ДанныеУзла.Свойство("ТипИнтерфейсаЧБ") Тогда
			ТипИнтерфейса = ДанныеУзла.ТипИнтерфейсаЧБ;
		КонецЕсли;
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(ТипИнтерфейса) Тогда
		ТипИнтерфейса = КомЯдро_ПолучитьЗначениеПеременной("ТипИнтерфейса");
	КонецЕсли;
	
	Возврат ТипИнтерфейса;
	
КонецФункции

// Проверяет, содержит ли строка только цифры.
//
// Параметры:
//  Значение         - Строка - проверяемая строка.
//  Устаревший       - Булево - устаревший параметр, не используется.
//  ПробелыЗапрещены - Булево - если Ложь, то в строке допустимо наличие пробелов.
//
// Возвращаемое значение:
//   Булево - Истина - строка содержит только цифры или пустая, Ложь - строка содержит иные символы.
//
// Пример:
//  Результат = ЛокЯдро_ТолькоЦифрыВСтроке("0123"); // Истина
//  Результат = ЛокЯдро_ТолькоЦифрыВСтроке("0123abc"); // Ложь
//  Результат = ЛокЯдро_ТолькоЦифрыВСтроке("01 2 3",, Ложь); // Истина
&НаКлиенте
Функция ЛокЯдро_ТолькоЦифрыВСтроке(Знач Значение, Знач Устаревший = Истина, Знач ПробелыЗапрещены = Истина) Экспорт
	
	Если ТипЗнч(Значение) <> Тип("Строка") Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если Не ПробелыЗапрещены Тогда
		Значение = СтрЗаменить(Значение, " ", "");
	КонецЕсли;
		
	Если СтрДлина(Значение) = 0 Тогда
		Возврат Истина;
	КонецЕсли;
	
	// Если содержит только цифры, то в результате замен должна быть получена пустая строка.
	// Проверять при помощи ПустаяСтрока нельзя, так как в исходной строке могут быть пробельные символы.
	Возврат СтрДлина(
		СтрЗаменить( СтрЗаменить( СтрЗаменить( СтрЗаменить( СтрЗаменить(
		СтрЗаменить( СтрЗаменить( СтрЗаменить( СтрЗаменить( СтрЗаменить( 
			Значение, "0", ""), "1", ""), "2", ""), "3", ""), "4", ""), "5", ""), "6", ""), "7", ""), "8", ""), "9", "")) = 0;
	
КонецФункции

// Сравнить две строки версий.
//
// Параметры:
//  ЧастиВерсии1  - Строка - номер версии в формате РР.{П|ПП}.ЗЗ.СС.
//				  - Массив - массив, содержащий части версии
//  ЧастиВерсии2  - Строка - второй сравниваемый номер версии.
//                - Массив - массив, содержащий части версии
//
// Возвращаемое значение:
//   Число   - больше 0, если СтрокаВерсии1 > СтрокаВерсии2; 0, если версии равны.
//
&НаКлиенте
Функция ЛокЯдро_СравнитьВерсии(Знач ЧастиВерсии1, Знач ЧастиВерсии2) Экспорт
	
	Результат = 0;
	
	Если ТипЗнч(ЧастиВерсии1) = Тип("Строка") И ТипЗнч(ЧастиВерсии2) = Тип("Строка") Тогда
		Строка1 = ?(ПустаяСтрока(ЧастиВерсии1), "0.0.0.0", ЧастиВерсии1);
		Версия1 = ЛокЯдро_РазложитьСтрокуВМассивПодстрок(Строка1, ".");	
		Строка2 = ?(ПустаяСтрока(ЧастиВерсии2), "0.0.0.0", ЧастиВерсии2);
		Версия2 = ЛокЯдро_РазложитьСтрокуВМассивПодстрок(Строка2, ".");
	ИначеЕсли ТипЗнч(ЧастиВерсии1) = Тип("Массив") И ТипЗнч(ЧастиВерсии2) = Тип("Массив") Тогда
		Версия1 = ЧастиВерсии1;
		Версия2 = ЧастиВерсии2;
	Иначе
		Возврат Результат;
	КонецЕсли;
	
	Если Версия1.Количество() < 4 Тогда
		Возврат Результат;
	КонецЕсли;
	Если Версия2.Количество() < 4 Тогда
		Возврат Результат;
	КонецЕсли;
	
	Для Разряд = 0 По 3 Цикл
		Результат = Число(ЛокЯдро_ОставитьЦифрыВСтроке(Версия1[Разряд], Истина)) - Число(ЛокЯдро_ОставитьЦифрыВСтроке(Версия2[Разряд], Истина));
		Если Результат <> 0 Тогда
			Возврат Результат;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Оставляет в строке только цифры
//
// Параметры:
//  ИсходнаяСтрока  			- Строка - строка, в которой необходимо оставить только цифры
//	ОставитьТолькоПервыеЦифры 	- Булево - если установлено "Истина", то будет возвращена строка до первого найдененного символа, отличного от цифры
//
// Возвращаемое значение:
//   Строка   - строка, содержащая только цифры
//
&НаКлиентеНаСервереБезКонтекста
Функция ЛокЯдро_ОставитьЦифрыВСтроке(ИсходнаяСтрока, ОставитьТолькоПервыеЦифры = Ложь)
	
	ПолученнаяСтрока = "";
	
	Для Индекс = 1 По СтрДлина(ИсходнаяСтрока) Цикл
		Символ = Сред(ИсходнаяСтрока, Индекс, 1);
		Если КодСимвола(Символ) >= 48 И КодСимвола(Символ) <= 57 Тогда // Код нуля - 48, код 9-ки - 57
			ПолученнаяСтрока = ПолученнаяСтрока + Символ;
		ИначеЕсли ОставитьТолькоПервыеЦифры Тогда
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Возврат ПолученнаяСтрока;
	
КонецФункции

// Удаляет все вхождения переданного значения из массива.
//
// Параметры:
//  Массив 		- Массив - массив, из которого необходимо удалить значение;
//  Значение 	- Произвольный - удаляемое значение из массива.
//
&НаКлиентеНаСервереБезКонтекста
Процедура ЛокЯдро_УдалитьВсеВхожденияЗначенияИзМассива(Массив, Значение) Экспорт
	
	КоличествоЭлементовКоллекции = Массив.Количество();
	
	Для ОбратныйИндекс = 1 По КоличествоЭлементовКоллекции Цикл
		
		Индекс = КоличествоЭлементовКоллекции - ОбратныйИндекс;
		
		Если Массив[Индекс] = Значение Тогда
			
			Массив.Удалить(Индекс);
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Дополняет массив МассивПриемник значениями из массива МассивИсточник.
//
// Параметры:
//  МассивПриемник 				- Массив - массив, в который необходимо добавить значения.
//  МассивИсточник 				- Массив - массив значений для заполнения.
//  ТолькоУникальныеЗначения 	- Булево - если истина, то в массив будут включены только уникальные значения.
//
&НаКлиентеНаСервереБезКонтекста
Процедура ЛокЯдро_ДополнитьМассив(МассивПриемник, МассивИсточник, ТолькоУникальныеЗначения = Ложь) Экспорт
	
	Если ТолькоУникальныеЗначения Тогда
		
		УникальныеЗначения = Новый Соответствие;
		
		Для Каждого Значение Из МассивПриемник Цикл
			УникальныеЗначения.Вставить(Значение, Истина);
		КонецЦикла;
		
		Для Каждого Значение Из МассивИсточник Цикл
			Если УникальныеЗначения[Значение] = Неопределено Тогда
				МассивПриемник.Добавить(Значение);
				УникальныеЗначения.Вставить(Значение, Истина);
			КонецЕсли;
		КонецЦикла;
		
	Иначе
		
		Для Каждого Значение Из МассивИсточник Цикл
			МассивПриемник.Добавить(Значение);
		КонецЦикла;
		
	КонецЕсли;
	
КонецПроцедуры

// Проверяет наличие искомого реквизита в переданной таблице реквизитов
//
// Параметры:
//  ИмяРеквизита		- Строка	- Имя искомого реквизита
//  МассивРеквизитов	- Массив	- Список реквизитов, принадлежащих переданной таблице метаданных
//  СтруктураПроверки	- Структура - Структура проверки текущего бизнес-процесса
//  МассивОшибок		- Массив 	- Массив строковых значений, содержащих описание возникших ошибок
//  ТекстОбластиОшибки	- Строка	- Текстовый элемент сообщения об ошибке, описывающий область настроек, в которой обнаружена ошибка
//  РеквизитИсточника	- Строка	- "Документ1С" или "ДокументMS"
//
&НаКлиенте
Процедура ЛокЯдро_ПроверитьНаличиеРеквизита(ИмяРеквизита, МассивРеквизитов, СтруктураПроверки, МассивОшибок, ТекстОбластиОшибки = "", РеквизитИсточника)
	
	Если ПустаяСтрока(ИмяРеквизита) Тогда
		СтруктураПроверки.ОшибкаБП = Истина;
		ТекстОшибки = "Не заполнен реквизит документа " + Прав(РеквизитИсточника, 2) + " <" + ?(ПустаяСтрока(ИмяРеквизита), "...", ИмяРеквизита)
			+ "> " + ТекстОбластиОшибки;		
		МассивОшибок.Добавить(ТекстОшибки);
		Возврат;
	КонецЕсли;
	
	НеНайден = Ложь;
	
	Если ТипЗнч(МассивРеквизитов) = Тип("Массив") Тогда
		МассивНайденныхРеквизитов = ЛокЯдро_НайтиВМассивеСтруктурПоОтбору(МассивРеквизитов, Новый Структура("Значение", ИмяРеквизита));
		Если МассивНайденныхРеквизитов = Неопределено
			Или (ТипЗнч(МассивНайденныхРеквизитов) = Тип("Массив") И Не МассивНайденныхРеквизитов.Количество()) Тогда			
			НеНайден = Истина;
		КонецЕсли;
		// Если не найдено по имени, проверим на всякий случай по колонке Uni (т.к. имя может быть типа "barcode")
		Если НеНайден Тогда
			МассивНайденныхРеквизитов = ЛокЯдро_НайтиВМассивеСтруктурПоОтбору(МассивРеквизитов, Новый Структура("Uni", НРег(ИмяРеквизита)));
			Если МассивНайденныхРеквизитов <> Неопределено Тогда
				НеНайден = Ложь;
			КонецЕсли;
			// В КОМ-режиме колонка Uni пуста для данного свойства, поэтому пока так...
			Если НеНайден И НРег(ИмяРеквизита) = "barcode" Тогда
				МассивНайденныхРеквизитов = ЛокЯдро_НайтиВМассивеСтруктурПоОтбору(МассивРеквизитов, Новый Структура("Значение", "Штрихкод"));	
				Если МассивНайденныхРеквизитов <> Неопределено Тогда
					НеНайден = Ложь;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	ИначеЕсли ТипЗнч(МассивРеквизитов) = Тип("СписокЗначений") Тогда
		Если МассивРеквизитов.НайтиПоЗначению(ИмяРеквизита) = Неопределено Тогда
			НеНайден = Истина;
		КонецЕсли;		
	КонецЕсли;
	
	Если НеНайден Тогда
		
		СтруктураПроверки.ОшибкаБП = Истина;
		ТекстОшибки = "Не найден реквизит документа " + Прав(РеквизитИсточника, 2) + " <" + ИмяРеквизита + "> " + ТекстОбластиОшибки;		
		МассивОшибок.Добавить(ТекстОшибки);
		
	КонецЕсли;

КонецПроцедуры

// Проверяет корректность текста произвольного кода с точки зрения синтаксиса 1С
//
// Параметры:
//  ТекстКода					 - Строка 	- Текст обработчика произвольного кода
//  ИмяПроизвольногоКода		 - Строка 	- Наименование проверяемого произвольного кода
//  ТекстНаправленияОбработчика	 - Строка	- Вспомогательная переменная, необходимая для обозначения в тексте направления работы передачи данных
// 
// Возвращаемое значение:
//   - СтруктураВозврата		- Структура	- Структура возвращаемого результата (успешно ли прошла проверка, текст ошибки)
//
&НаСервере
Функция ЛокЯдро_ПроверитьСинтакическоеВыполнениеКода(ТекстКода, ИмяПроизвольногоКода, ТекстНаправленияОбработчика) Экспорт
	
	СтруктураВозврата = Новый Структура("ЕстьОшибки, ТекстОшибки", Ложь, ""); 
	
	Попытка			
		//Выполнить(ТекстКода);
		СтрокаВызова = ТекстКода;
		ПараметрыАлгоритма = Новый Структура;
		ЛокЯдро_ВыполнитьВБезопасномРежиме(СтрокаВызова, ПараметрыАлгоритма);
	Исключение      
		ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());		
		Если Найти(ВРег(ТекстОшибки), ВРег("Переменная не определена")) = 0 Тогда
			СтруктураВозврата.ЕстьОшибки 	= Истина;        				
			СтруктураВозврата.ТекстОшибки 	= "Обнаружены синтаксические ошибки в тексте произвольного кода " + ТекстНаправленияОбработчика + " <" 
				+ ИмяПроизвольногоКода + ">:" + Символы.ПС + " - " + ТекстОшибки;
		КонецЕсли;              		
	КонецПопытки;
	
	Возврат СтруктураВозврата;
	
КонецФункции

// Проверяет доступность и заполненность обработчика
//
// Параметры:
//  ОбработчикДокумента	- Строка 	- Имя произвольного обработчика
//  СтруктураПроверки	- Структура - Структура проверки текущего бизнес-процесса
//  МассивОшибок		- Массив 	- Массив строковых значений, содержащих описание возникших ошибок
//  Загрузка			- Булево 	- Признак направления обработчика
//
&НаКлиенте
Процедура ЛокЯдро_ПроверкаПроизвольногоОбработчикаДокумента(ОбработчикДокумента, СтруктураПроверки, МассивОшибок, Загрузка = Ложь)
	
	Если Не ЗначениеЗаполнено(ОбработчикДокумента) Тогда		
		СтруктураПроверки.ОшибкаБП = Истина;
		ТекстОшибки = "Не заполнен обработчик " + ?(Загрузка, "загрузки", "выгрузки") + " документа";					
		МассивОшибок.Добавить(ТекстОшибки);						
	Иначе                                               		
		МассивОбработчиков = Новый Массив;
		МассивОбработчиков.Добавить(ОбработчикДокумента);
		
		ЛокЯдро_ПроверкаДоступностиОбработчиковИнтеграционнойОбработки(МассивОбработчиков,, СтруктураПроверки, МассивОшибок);		
	КонецЕсли;
			
КонецПроцедуры

// Проверяет доступность обработчиков интеграционной обработки
//
// Параметры:
//  МассивОбработчиков				- Массив 		- Массив строковых значений, отражающих имена проверяемых методов интеграционной обработки
//  МассивПроверенныхОбработчиков	- Массив 		- Массив уже проверенных методов интеграционной обработки (вне зависимости от бизнес-процесса)
//  СтруктураПроверки				- Структура 	- Структура проверки текущего бизнес-процесса
//  МассивОшибок					- Массив 		- Массив строковых значений, содержащих описание возникших ошибок
//
&НаКлиенте
Процедура ЛокЯдро_ПроверкаДоступностиОбработчиковИнтеграционнойОбработки(МассивОбработчиков, МассивПроверенныхОбработчиков = Неопределено, СтруктураПроверки, МассивОшибок)
	
	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода", 		"Функция");
	СтруктураВызова.Вставить("ИмяМетода", 		"ПроверитьНаличиеМетодовИнтеграционнойОбработки");
	СтруктураВызова.Вставить("ПараметрыМетода", Новый Структура("МассивМетодов, МассивПроверенныхМетодов", МассивОбработчиков, МассивПроверенныхОбработчиков));
	СтруктураПроверкиМетодов 		= Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,, АдресаПеременных);
	МассивРезультатовПроверок 		= СтруктураПроверкиМетодов.МассивРезультатовПроверок;
	МассивПроверенныхОбработчиков 	= СтруктураПроверкиМетодов.МассивПроверенныхМетодов;	
	
	МассивОтсутствующихМетодов = ЛокЯдро_НайтиВМассивеСтруктурПоОтбору(МассивРезультатовПроверок, Новый Структура("МетодДоступен", Ложь));
	Если МассивОтсутствующихМетодов <> Неопределено Тогда				
		
		СтруктураПроверки.ОшибкаБП = Истина;
		
		Для Каждого ОтсутствующийМетод Из МассивОтсутствующихМетодов Цикл
			ТекстОшибки = "Обработчик " + ОтсутствующийМетод.ИмяМетода + " не найден в интеграционной обработке";
			МассивОшибок.Добавить(ТекстОшибки);				
		КонецЦикла;				
		
	КонецЕсли;
	
КонецПроцедуры

#Область ПечатьЦенников

// Вызывает процедуру печати ценников из модуля формы интеграционной обработки
//
// Параметры:
//	ДанныеДляПечати - ДанныеФормы - данные для печати ценников
&НаКлиенте
Процедура ЛокЯдро_ПечатьЦенников(ДанныеДляПечати) Экспорт
	
	Если ФормаИнтеграционнойОбработки <> Неопределено Тогда
		Попытка
			ФормаИнтеграционнойОбработки.ПечатьЦенников(ДанныеДляПечати);
		Исключение			
			Сообщить("Не удалось напечатать ценники");	
		КонецПопытки; 	
	КонецЕсли;
	
КонецПроцедуры

// Выполняет метод данного модуля по имени. Используется для вызова из других форм
//
// Параметры:
//	ИмяМетода - Строка - имя вызываемого метода
//	СтруктураПараметров - Структура, Неопределено - содержит параметры вызываемого метода
//
// Возвращаемое значение:
//	Структура - результат выполнения процедуры:
//		* ИнфоОбОшибке - ИнформацияОбОшибке - информация об ошибке
//		* ТекстОшибки - Строка - подробное представление об ошибке
//
&НаКлиенте
Функция ЛокЯдро_ВыполнитьМетодПоИмени(ИмяМетода, СтруктураПараметров = Неопределено) Экспорт

	ИнфоОбОшибке 		= Неопределено;
	ТекстОшибки 		= "";
	
	ПередаваемыеВОбработчикОжиданияПараметры = СтруктураПараметров;
		
	Попытка
		ПодключитьОбработчикОжидания(ИмяМетода, 0.1, Истина);
	Исключение
		ИнфоОбОшибке 	= ИнформацияОбОшибке();
		ТекстОшибки 	= ПодробноеПредставлениеОшибки(ИнфоОбОшибке);
	КонецПопытки;
	
	СтруктураВыполнения = Новый Структура;
	СтруктураВыполнения.Вставить("ИнфоОбОшибке", 	ИнфоОбОшибке);
	СтруктураВыполнения.Вставить("ТекстОшибки", 	ТекстОшибки);
	
	Возврат СтруктураВыполнения;

КонецФункции

&НаКлиенте
Процедура ЛокЯдро_ЗаписатьНачалоВыполненияАвтотеста(ИмяМетодаАвтотеста) Экспорт
	
	СтруктураПараметров = ПередаваемыеВОбработчикОжиданияПараметры;
	
	ПолноеИмяАвтотеста = "";
	
	СтруктураВыполненияАвтотестов = СтруктураПараметров.СтруктураВыполненияАвтотестов;
	Для Каждого ЭлементВыполненияАвтотестов Из СтруктураВыполненияАвтотестов Цикл
		Если ЭлементВыполненияАвтотестов.Значение = ИмяМетодаАвтотеста Тогда
			ПолноеИмяАвтотеста = ЭлементВыполненияАвтотестов.Ключ;
		КонецЕсли;
	КонецЦикла;
	
	ИмяАвтотеста 				= ?(ЗначениеЗаполнено(ПолноеИмяАвтотеста), СтрЗаменить(ПолноеИмяАвтотеста, "КлеверенсАвтотесты.", ""), ИмяМетодаАвтотеста);
	СтрокаВыделенияАвтотестов 	= СтруктураПараметров.СтрокаВыделенияАвтотестов;
	
	ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяАвтотеста, "Информация", СтрокаВыделенияАвтотестов + "Начало");
	НачалоВыполненияОперации = ТекущаяУниверсальнаяДатаВМиллисекундах();

	ПередаваемыеВОбработчикОжиданияПараметры.Вставить("НачалоВыполненияОперации", НачалоВыполненияОперации);
	
КонецПроцедуры

&НаКлиенте
Процедура ЛокЯдро_ЗаписатьОкончаниеВыполненияАвтотеста(ИмяМетодаАвтотеста) Экспорт
	
	СтруктураПараметров = ПередаваемыеВОбработчикОжиданияПараметры;
	
	ПолноеИмяАвтотеста = "";
	
	СтруктураВыполненияАвтотестов = СтруктураПараметров.СтруктураВыполненияАвтотестов;
	Для Каждого ЭлементВыполненияАвтотестов Из СтруктураВыполненияАвтотестов Цикл
		Если ЭлементВыполненияАвтотестов.Значение = ИмяМетодаАвтотеста Тогда
			ПолноеИмяАвтотеста = ЭлементВыполненияАвтотестов.Ключ;
		КонецЕсли;
	КонецЦикла;
	
	ИмяАвтотеста 				= ?(ЗначениеЗаполнено(ПолноеИмяАвтотеста), СтрЗаменить(ПолноеИмяАвтотеста, "КлеверенсАвтотесты.", ""), ИмяМетодаАвтотеста);
	СтрокаВыделенияАвтотестов 	= СтруктураПараметров.СтрокаВыделенияАвтотестов;
	НачалоВыполненияОперации 	= СтруктураПараметров.НачалоВыполненияОперации;
	
	ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяАвтотеста, "Информация", СтрокаВыделенияАвтотестов + "Конец", НачалоВыполненияОперации);	
	
КонецПроцедуры

#КонецОбласти

#Область КомпонентаMobileSMARTS

#Область КомпонентаMobileSMARTS_Подключение

// Проверяет наличие подключения к серверу Mobile Smarts. Если подключения нет, пытается переподключиться и поднять COM.
//
// Параметры:
//	Переподключиться - Булево - определяет необходимость явного переподключения к базе Mobile Smarts
//  ТипБазы - Строка - "Частная", "Временная", "Основная"
//
// Возвращаемое значение:
//	Булево - флаг наличия подключения к серверу Mobile Smarts
&НаКлиенте
Функция КомЯдро_ПодключитьсяКСерверуSMARTS(Переподключиться, ТипБазы) Экспорт
	
	НачалоСобытия = ТекущаяУниверсальнаяДатаВМиллисекундах();
	ИмяСобытия = "КомЯдро_ПодключитьсяКСерверуSMARTS";
	
	Если ТипБазы = "Частная" Тогда
		СтруктураБазMSCOM = COMЧастнойБазыMS;
		КлючПеременной = "СтруктураПодключенияЧастнойБазыMS";
	ИначеЕсли ТипБазы = "Временная" Тогда
		СтруктураБазMSCOM = COMВременнойБазыMS;
		КлючПеременной = "СтруктураПодключенияВременнойБазыMS";
	Иначе
		СтруктураБазMSCOM = COMБазыMS;
		КлючПеременной = "СтруктураПодключенияБазыMS";
	КонецЕсли;
	
	СтруктураБазMS = КомЯдро_ПолучитьЗначениеПеременной(КлючПеременной);
	
	НужноПересоздатьКом = Переподключиться = Истина
		 ИЛИ СтруктураБазMSCOM = Неопределено 
		 ИЛИ Строка(СтруктураБазMSCOM.TerminalConnector) <> "COMОбъект";
		 
	Если НЕ НужноПересоздатьКом Тогда
		Попытка
			НужноПересоздатьКом = (ЗначениеЗаполнено(СтруктураБазMSCOM.StorageConnector.ИдПодключеннойБазы) И СтруктураБазMSCOM.StorageConnector.ПроверитьСоединение()) <> Истина;
			ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Проверка соединения с базой Mobile SMARTS", НачалоСобытия);	
		Исключение
			ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
			ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Тест cоединения с базой Mobile SMARTS не пройден, запуск переподключения, Описание ошибки: " + ТекстОшибки, НачалоСобытия);			
			НужноПересоздатьКом = Истина;
		КонецПопытки;
	КонецЕсли;
		 
	Если НужноПересоздатьКом Тогда
		СтруктураБазMSCOM = КомЯдро_ПолучитьСтруктуруПодключенияБазыСМАРТС();
	КонецЕсли;
	
	Если ТипБазы = "Частная" Тогда
		COMЧастнойБазыMS = СтруктураБазMSCOM; 
	ИначеЕсли ТипБазы = "Временная" Тогда
		COMВременнойБазыMS = СтруктураБазMSCOM;
	Иначе
		COMБазыMS = СтруктураБазMSCOM;
	КонецЕсли;
	
	ЕстьПодключение = СтруктураБазMSCOM <> Неопределено И Строка(СтруктураБазMSCOM.TerminalConnector) = "COMОбъект";
	
	Если НужноПересоздатьКом И ЕстьПодключение 
		И СтруктураБазMS <> Неопределено
		И ТипЗнч(СтруктураБазMS) = Тип("Структура") Тогда
		
		Если СтруктураБазMS.Свойство("СтрокаПодключенияСМАРТС") И ЗначениеЗаполнено(СтруктураБазMS.СтрокаПодключенияСМАРТС) Тогда
			СтрокаПодключения = СтруктураБазMS.СтрокаПодключенияСМАРТС;
		ИначеЕсли СтруктураБазMS.Свойство("IdBaseSMARTS") И ЗначениеЗаполнено(СтруктураБазMS.IdBaseSMARTS) Тогда
			СтрокаПодключения = СтруктураБазMS.IdBaseSMARTS;
		ИначеЕсли СтруктураБазMS.Свойство("ОписаниеБазы")
			И СтруктураБазMS.ОписаниеБазы.Свойство("IdBaseSMARTS") Тогда
			СтрокаПодключения = СтруктураБазMS.ОписаниеБазы.Ид;
		Иначе
			СтрокаПодключения = Неопределено;
		КонецЕсли;
		
		Если СтрокаПодключения <> Неопределено Тогда
			Попытка
				Результат = СтруктураБазMSCOM.TerminalConnector.УстановитьТекущуюБазуСМАРТСБезАвт(СтрокаПодключения) = Истина;
				ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Проверка соединения с базой Mobile SMARTS", НачалоСобытия);
			Исключение
				Результат = СтруктураБазMSCOM.TerminalConnector.УстановитьТекущуюБазуСМАРТС(СтрокаПодключения) = Истина;
			КонецПопытки;
			
			Если Результат И СтруктураБазMS.Свойство("ОписаниеБазы")
				И ТипЗнч(СтруктураБазMS.ОписаниеБазы) = Тип("Структура")
				И СтруктураБазMS.ОписаниеБазы.Свойство("АвторизацияВключена")
				И СтруктураБазMS.ОписаниеБазы.АвторизацияВключена
				И СтруктураБазMS.ОписаниеБазы.Свойство("АвторизацияЛогин")
				И ЗначениеЗаполнено(СтруктураБазMS.ОписаниеБазы.АвторизацияЛогин)
				И СтруктураБазMS.ОписаниеБазы.Свойство("АвторизацияТокен")
				И ЗначениеЗаполнено(СтруктураБазMS.ОписаниеБазы.АвторизацияТокен) Тогда
				//Если авторизация сохранена
				
				РезультатАвторизации= Неопределено;
				Попытка
					РезультатАвторизации = СтруктураБазMSCOM.TerminalConnector.АвторизоватьсяПоТокену(СтруктураБазMS.ОписаниеБазы.АвторизацияЛогин,СтруктураБазMS.ОписаниеБазы.АвторизацияТокен);
					ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Проверка соединения с базой Mobile SMARTS", НачалоСобытия);
				Исключение	
				КонецПопытки;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Есть подключение: " + Строка(ЕстьПодключение), НачалоСобытия);
	
	Возврат ЕстьПодключение;
	
КонецФункции

// Выполняет проверку подключения к базе Mobile Smarts по идентификатору подключенной базы.
//
// Параметры:
//	ЕстьПодключение - Булево - флаг установления соединения с сервером Mobile Smarts	
//  ДопПараметры - Структура - содержит:
//		* СтрокаПодключения - Строка
//      * ТипБазы - Строка - "Частная", "Временная", "Основная"
//      * СтруктураПодключения - Структура - структура подключения к базе Mobile Smarts
//      * СохранятьАвторизацию - Булево
//      * ИмяБазы - Строка
//
// Возвращаемое значение:
//	Булево
&НаКлиенте
Процедура КомЯдро_ПроверитьСоединениеССерверомSMARTSЗавершение(ЕстьПодключение, ДопПараметры) Экспорт
	
	Если ДопПараметры.ТипБазы = "Частная" Тогда
		СтруктураПодключенияMS = COMЧастнойБазыMS;
	ИначеЕсли ДопПараметры.ТипБазы = "Временная" Тогда
		СтруктураПодключенияMS = COMВременнойБазыMS;
	Иначе
		СтруктураПодключенияMS = COMБазыMS;
	КонецЕсли;
	
	Если ЕстьПодключение <> Ложь Тогда
		Если ЗначениеЗаполнено(СтруктураПодключенияMS.StorageConnector.ИдПодключеннойБазы) тогда
			ЕстьПодключение = СтруктураПодключенияMS.StorageConnector.ПроверитьСоединение();
		Иначе
			ЕстьПодключение = Ложь;
		КонецЕсли;
	КонецЕсли;	
	
	НастройкиИнициализированы = КомЯдро_ПолучитьЗначениеПеременной("НастройкиИнициализированы"); 
	
	Если ЕстьПодключение Тогда
		Если НЕ НастройкиИнициализированы = Истина 
			И ДопПараметры.ИнициализироватьНастройки Тогда
			ЛокЯдро_Инициализация();
		КонецЕсли;
	Иначе
		СтруктураСменыСтатуса = Новый Структура("Статус, Параметр, Операция, ТипБазы", 
			"РаботаССерверомБазаНедоступна", 
			ДопПараметры.СтруктураПодключения, 
			"ПодключениеКБазеSMARTS",
			?(ДопПараметры.Свойство("ТипБазы"),ДопПараметры.ТипБазы,Неопределено));
		Оповестить("СменаСтатуса", СтруктураСменыСтатуса);

		Если НЕ ДопПараметры.Свойство("ТипБазы")
			ИЛИ НЕ ДопПараметры.ТипБазы = "Частная" Тогда
		НастройкиИнициализированы = Ложь;
		КонецЕсли;
	КонецЕсли;	
	
	Если ДопПараметры.Свойство("ОписаниеОповещения")
		И ДопПараметры.ОписаниеОповещения <> Неопределено Тогда
		ВыполнитьОбработкуОповещения(ДопПараметры.ОписаниеОповещения,ЕстьПодключение);	
	КонецЕсли;
	
КонецПроцедуры

// Выполняет проверку подключения к базе Mobile Smarts по идентификатору подключенной базы.
// Если проверка пройдена, сохраняет описание подключенной базы в структуре баз Mobile Smarts.
//
// Параметры:
//	РезультатЗакрытияФормы - Неопределено, Структура - содержит:
//		* АвторизацияЗапомнить - Булево - флаг необходимость сохранить авторизацию
//      * АвторизацияЛогин - Строка - логин авторизации
//		* АвторизацияТокен - Строка - токен авторизации
//
//  ДопПараметры - Структура - содержит:
//		* СтрокаПодключения - Строка
//      * ТипБазы - Строка - "Частная", "Временная", "Основная"
//      * СтруктураПодключения - Структура - структура подключения к базе Mobile Smarts
//      * СохранятьАвторизацию - Булево
//      * ИмяБазы - Строка
&НаКлиенте
Процедура КомЯдро_ПодключитьсяКБазеSMARTSЗавершение(РезультатЗакрытияФормы, ДопПараметры) Экспорт
	
	СтруктураПодключения = ДопПараметры.СтруктураПодключения;	
	
	Если ДопПараметры.Свойство("СтруктураПодключения")
		И ТипЗнч(ДопПараметры.СтруктураПодключения) = Тип("Структура")
		И ДопПараметры.СтруктураПодключения.Свойство("РасположениеКомпоненты") Тогда
		РасположениеКомпоненты = ДопПараметры.СтруктураПодключения.РасположениеКомпоненты;
	ИначеЕсли ДопПараметры.Свойство("РасположениеКомпоненты") Тогда
		РасположениеКомпоненты = ДопПараметры.РасположениеКомпоненты;
	Иначе
		РасположениеКомпоненты = КомЯдро_ПолучитьЗначениеПеременной("РасположениеКомпоненты");
	КонецЕсли;
	
	СтруктураОписанияБазы = ЛокЯдро_ПолучитьБазуНаСервереSMARTS(РасположениеКомпоненты, ДопПараметры.СтрокаПодключения, ДопПараметры.ТипБазы);
	
	Если ДопПараметры.ТипБазы = "Частная" Тогда
		СтруктураБазMS = COMЧастнойБазыMS;
		КлючПеременной = "СтруктураПодключенияЧастнойБазыMS";
	ИначеЕсли ДопПараметры.ТипБазы = "Временная" Тогда
		СтруктураБазMS = COMВременнойБазыMS;
		КлючПеременной = "СтруктураПодключенияВременнойБазыMS";
	Иначе
		СтруктураБазMS = COMБазыMS; 
		КлючПеременной = "СтруктураПодключенияБазыMS";
	КонецЕсли;
	
	РезультатАвторизации = Ложь;
	
	Если ТипЗнч(РезультатЗакрытияФормы) = Тип("Структура") Тогда
		СтруктураПодключения.Вставить("АвторизацияВключена", Истина);
		СтруктураПодключения.Вставить("АвторизацияЛогин", РезультатЗакрытияФормы.АвторизацияЛогин);
		Если РезультатЗакрытияФормы.АвторизацияЗапомнить Тогда
			СтруктураПодключения.Вставить("АвторизацияТокен",РезультатЗакрытияФормы.АвторизацияТокен);
			СтруктураОписанияБазы.Вставить("АвторизацияВключена",Истина);
			СтруктураОписанияБазы.Вставить("АвторизацияЛогин",СтруктураПодключения.АвторизацияЛогин);
			СтруктураОписанияБазы.Вставить("АвторизацияТокен",СтруктураПодключения.АвторизацияТокен);
			Если ДопПараметры.СохранятьАвторизацию Тогда
				Если ДопПараметры.ТипБазы = "Частная" Тогда
					ID_Узла = ДанныеТекущегоУзла.ID_Узла;
					ТаблицаУзлов = ЛокЯдро_ПолучитьИзКэшаНастройкуSMARTS("Узлы");
					Если ТипЗнч(ТаблицаУзлов) = Тип("Массив") Тогда
						Для каждого НастройкаУзла Из ТаблицаУзлов Цикл
							Если НастройкаУзла.Свойство("ID_Узла")
								И НастройкаУзла.ID_Узла = ДанныеТекущегоУзла.ID_Узла  Тогда
								НастройкаУзла.Вставить("ЧастнаяБазаMS",СтруктураОписанияБазы);
							КонецЕсли;
						КонецЦикла;
					КонецЕсли;
					ЛокЯдро_СохранитьНастройкуВБазеSMARTS("Узлы", ТаблицаУзлов);
					ЛокЯдро_ЗаписатьВКэшНастройкуSMARTS("Узлы", ТаблицаУзлов); 		
				ИначеЕсли ДопПараметры.ТипБазы = "Основная" Тогда
					ЛокЯдро_СохранитьДанныеВХранилище1С("Cleverence_ПараметрыПодключенияMS", СтруктураОписанияБазы);
					ПараметрыПодключенияMS = СтруктураОписанияБазы;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(СтруктураБазMS.StorageConnector.ИдПодключеннойБазы) тогда
		ПроверкаСоединения = СтруктураБазMS.StorageConnector.ПроверитьСоединение() = Истина;
	Иначе
		ПроверкаСоединения = Ложь;
	КонецЕсли;
	
	Если ПроверкаСоединения Тогда
		ID_ПодключаемойБазы = ?(СтруктураПодключения.Свойство("IdBaseSMARTS") И ЗначениеЗаполнено(СтруктураПодключения.IdBaseSMARTS),СтруктураПодключения.IdBaseSMARTS,СтруктураБазMS.StorageConnector.НастройкиТекущейБазы.СерверныйИдентификаторПриложения);
		СтрокаПодключенияСМАРТС = ?(СтруктураПодключения.Свойство("СтрокаПодключенияСМАРТС") И ЗначениеЗаполнено(СтруктураПодключения.СтрокаПодключенияСМАРТС),СтруктураПодключения.СтрокаПодключенияСМАРТС,СтруктураОписанияБазы.СтрокаПодключения);
	КонецЕсли;
	
	Если СтруктураПодключения.Свойство("АвторизацияВключена")
		И СтруктураПодключения.АвторизацияВключена = Истина Тогда
		СтруктураОписанияБазы.Вставить("АвторизацияВключена",Истина);
	КонецЕсли;
	
	пСтруктураБазMS = Новый Структура;
	пСтруктураБазMS.Вставить("IdBaseSMARTS", ID_ПодключаемойБазы);
	пСтруктураБазMS.Вставить("СтрокаПодключенияСМАРТС",СтрокаПодключенияСМАРТС);
	пСтруктураБазMS.Вставить("ОписаниеБазы",СтруктураОписанияБазы);
	
	КомЯдро_СохранитьЗначениеПеременной(КлючПеременной,пСтруктураБазMS);
	
	Если ДопПараметры.ОписаниеОповещения <> Неопределено Тогда
		ВыполнитьОбработкуОповещения(ДопПараметры.ОписаниеОповещения,ПроверкаСоединения);	
	КонецЕсли;	
	
КонецПроцедуры

// Вызывает функцию проверки подключения к базе Mobile Smarts
//
// Параметры:
//	РезультатЗакрытияФормы - Неопределено, Структура - содержит:
//		* АвторизацияТокен - Строка - токен авторизации
//      * АвторизацияЛогин - Строка - логин авторизации
//		* АвторизацияЗапомнить - Булево - флаг необходимость сохранить авторизацию
//  ДопПараметры - Структура - содержит:
//		* СтрокаПодключения - Строка
//      * ТипБазы - Строка - "Частная", "Временная", "Основная"
//      * СтруктураПодключения - Структура - структура подключения к базе Mobile Smarts
//      * СохранятьАвторизацию - Булево
//      * ИмяБазы - Строка
//
// Возвращаемое значение:
//	Булево - результат проверки соединения с базой Mobile Smarts
&НаКлиенте
Функция КомЯдро_ПодключитьсяКБазеSMARTSНаСервереЗавершение(РезультатЗакрытияФормы, ДопПараметры) Экспорт
	
	ИмяСобытия = "КомЯдро_ПодключитьсяКБазеSMARTSНаСервереЗавершение";
	НачалоСобытия = ТекущаяУниверсальнаяДатаВМиллисекундах();
	
	СтруктураПодключения = ДопПараметры.СтруктураПодключения;	

	Если ДопПараметры.Свойство("СтруктураПодключения")
		И ТипЗнч(ДопПараметры.СтруктураПодключения) = Тип("Структура")
		И ДопПараметры.СтруктураПодключения.Свойство("РасположениеКомпоненты") Тогда
		РасположениеКомпоненты = ДопПараметры.СтруктураПодключения.РасположениеКомпоненты;
	ИначеЕсли ДопПараметры.Свойство("РасположениеКомпоненты") Тогда
		РасположениеКомпоненты = ДопПараметры.РасположениеКомпоненты;
	Иначе
		РасположениеКомпоненты = КомЯдро_ПолучитьЗначениеПеременной("РасположениеКомпоненты");
	КонецЕсли;
	
	Если ТипЗнч(СтруктураПодключения) = Тип("Структура")
		И СтруктураПодключения.Свойство("ТипИнтерфейса")
		И ЗначениеЗаполнено(СтруктураПодключения.ТипИнтерфейса) Тогда
		ТипИнтерфейса = СтруктураПодключения.ТипИнтерфейса;
	Иначе
		ТипИнтерфейса = ЛокЯдро_ПолучитьТипИнтерфейса(?(ТипЗнч(ДопПараметры) = Тип("Структура") И ДопПараметры.Свойство("ТипБазы"), ДопПараметры.ТипБазы, "Временная")); // ТипИнтерфейса = КомЯдро_ПолучитьЗначениеПеременной("ТипИнтерфейса");
	КонецЕсли;

	СтруктураОписанияБазы = ЛокЯдро_ПолучитьОписаниеБазыSMARTS(РасположениеКомпоненты,?(ТипЗнч(ДопПараметры) = Тип("Структура") И ДопПараметры.Свойство("ТипБазы"),ДопПараметры.ТипБазы,"Временная"),ТипИнтерфейса);
	Если СтруктураОписанияБазы = Неопределено И ТипИнтерфейса = "COM" Тогда
		СтруктураОписанияБазы = ЛокЯдро_ПолучитьБазуНаСервереSMARTS(РасположениеКомпоненты,ДопПараметры.СтрокаПодключения,ДопПараметры.ТипБазы);
	КонецЕсли;
	
	РезультатАвторизации = Ложь;
	
	Если СтруктураОписанияБазы <> Неопределено
		И ТипЗнч(РезультатЗакрытияФормы) = Тип("Структура") Тогда
		СтруктураПодключения.Вставить("АвторизацияВключена", Истина);
		СтруктураПодключения.Вставить("АвторизацияЛогин", РезультатЗакрытияФормы.АвторизацияЛогин);
		Если РезультатЗакрытияФормы.АвторизацияЗапомнить Тогда
			СтруктураПодключения.Вставить("АвторизацияТокен",РезультатЗакрытияФормы.АвторизацияТокен);
			СтруктураОписанияБазы.Вставить("АвторизацияВключена",Истина);
			СтруктураОписанияБазы.Вставить("АвторизацияЛогин",СтруктураПодключения.АвторизацияЛогин);
			СтруктураОписанияБазы.Вставить("АвторизацияТокен",СтруктураПодключения.АвторизацияТокен);
			Если ДопПараметры.СохранятьАвторизацию Тогда
				Если ДопПараметры.ТипБазы = "Частная" Тогда
					ID_Узла = ДанныеТекущегоУзла.ID_Узла;
					ТаблицаУзлов = ЛокЯдро_ПолучитьИзКэшаНастройкуSMARTS("Узлы");
					Если ТипЗнч(ТаблицаУзлов) = Тип("Массив") Тогда
						Для каждого НастройкаУзла Из ТаблицаУзлов Цикл
							Если НастройкаУзла.Свойство("ID_Узла")
								И НастройкаУзла.ID_Узла = ДанныеТекущегоУзла.ID_Узла  Тогда
								НастройкаУзла.Вставить("ЧастнаяБазаMS",СтруктураОписанияБазы);
							КонецЕсли;
						КонецЦикла;
					КонецЕсли;
					ЛокЯдро_СохранитьНастройкуВБазеSMARTS("Узлы", ТаблицаУзлов);
					ЛокЯдро_ЗаписатьВКэшНастройкуSMARTS("Узлы", ТаблицаУзлов); 		
				ИначеЕсли ДопПараметры.ТипБазы = "Основная" Тогда
					ЛокЯдро_СохранитьДанныеВХранилище1С("Cleverence_ПараметрыПодключенияMS", СтруктураОписанияБазы);
					ПараметрыПодключенияMS = СтруктураОписанияБазы;
				КонецЕсли;
			КонецЕсли;
			ЛокЯдро_СохранитьДанныеВХранилище1С("СохраненнаяАвторизацияЛогин", РезультатЗакрытияФормы.АвторизацияЛогин);	
			ЛокЯдро_СохранитьДанныеВХранилище1С("СохраненнаяАвторизацияПароль", РезультатЗакрытияФормы.АвторизацияПароль);
			ДопПараметры.Вставить("СтруктураОписанияБазы", СтруктураОписанияБазы);
			ДопПараметры.Вставить("СтруктураПодключения", СтруктураПодключения);
		Иначе
			ЛокЯдро_СохранитьДанныеВХранилище1С("СохраненнаяАвторизацияЛогин", "");
			ЛокЯдро_СохранитьДанныеВХранилище1С("СохраненнаяАвторизацияПароль", "");
		КонецЕсли;
	КонецЕсли;
	
	Если СтруктураОписанияБазы = Неопределено Тогда
		Возврат Ложь;		
	КонецЕсли;
	
	Если РасположениеКомпоненты = "НаСервере" Тогда
		СтруктураВызова = Новый Структура;
		СтруктураВызова.Вставить("ТипМетода", "Функция");
		СтруктураВызова.Вставить("ИмяМетода", "ПодключитьсяКБазеSMARTSНаСервереЗавершение");
		СтруктураВызова.Вставить("ПараметрыМетода", Новый Структура("РезультатЗакрытияФормы, ДопПараметры",РезультатЗакрытияФормы, ДопПараметры));
		Возврат Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,,АдресаПеременных);
	Иначе
		
		Если ТипИнтерфейса = "REST_API" Тогда
			Если ДопПараметры.ТипБазы = "Частная" Тогда
				КлючПеременной = "REST_API_СтруктураПодключенияЧастнойБазыMS";
			ИначеЕсли ДопПараметры.ТипБазы = "Временная" Тогда
				КлючПеременной = "REST_API_СтруктураПодключенияВременнойБазыMS";
			Иначе
				КлючПеременной = "REST_API_СтруктураПодключенияБазыMS";
			КонецЕсли;
			
			пСтруктураБазMS = Новый Структура;
			пСтруктураБазMS.Вставить("СтрокаПодключенияСМАРТС", СтруктураОписанияБазы.СтрокаПодключения);
			пСтруктураБазMS.Вставить("ОписаниеБазы", СтруктураОписанияБазы);
			
			КомЯдро_СохранитьЗначениеПеременной(КлючПеременной,пСтруктураБазMS);
			
			Возврат REST_API_ПодключитьсяКБазеSMARTS(ДопПараметры.СтруктураПодключения,ложь);
		Иначе
			Если ДопПараметры.ТипБазы = "Частная" Тогда
				СтруктураБазMSCOM = COMЧастнойБазыMS;
				КлючПеременной = "СтруктураПодключенияЧастнойБазыMS";
			ИначеЕсли ДопПараметры.ТипБазы = "Временная" Тогда
				СтруктураБазMSCOM = COMВременнойБазыMS;
				КлючПеременной = "СтруктураПодключенияВременнойБазыMS";
			Иначе
				СтруктураБазMSCOM = COMБазыMS;
				КлючПеременной = "СтруктураПодключенияБазыMS";
			КонецЕсли;
			
			Если ЗначениеЗаполнено(СтруктураБазMSCOM.StorageConnector.ИдПодключеннойБазы) тогда
				ПроверкаСоединения = СтруктураБазMSCOM.StorageConnector.ПроверитьСоединение() = Истина;
				ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Проверка соединения StorageConnector, результат: " + Строка(ПроверкаСоединения), НачалоСобытия);
			Иначе
				ПроверкаСоединения = Ложь;
			КонецЕсли;
			
			Если ПроверкаСоединения Тогда
				ID_ПодключаемойБазы = ?(СтруктураПодключения.Свойство("IdBaseSMARTS") И ЗначениеЗаполнено(СтруктураПодключения.IdBaseSMARTS),СтруктураПодключения.IdBaseSMARTS,СтруктураБазMSCOM.StorageConnector.НастройкиТекущейБазы.СерверныйИдентификаторПриложения);
				СтрокаПодключенияСМАРТС = ?(СтруктураПодключения.Свойство("СтрокаПодключенияСМАРТС") И ЗначениеЗаполнено(СтруктураПодключения.СтрокаПодключенияСМАРТС),СтруктураПодключения.СтрокаПодключенияСМАРТС,СтруктураОписанияБазы.СтрокаПодключения);
				ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Проверка соединения StorageConnector. ИдБазы: " + Строка(ID_ПодключаемойБазы) + ", Строка подключения: " + Строка(СтрокаПодключенияСМАРТС), НачалоСобытия);
			КонецЕсли;
			
			Если СтруктураПодключения.Свойство("АвторизацияВключена")
				И СтруктураПодключения.АвторизацияВключена = Истина Тогда
				СтруктураОписанияБазы.Вставить("АвторизацияВключена",Истина);
			КонецЕсли;
			
			//В описании базы может быть некорректная строка подключения. Заменим на строку подключения на введенную пользователем
			Если ЗначениеЗаполнено(СтрокаПодключенияСМАРТС)
				И ТипЗнч(СтруктураОписанияБазы) = Тип("Структура") Тогда
				СтруктураОписанияБазы.Вставить("СтрокаПодключения",СтрокаПодключенияСМАРТС);
				СтруктураОписанияБазы.Вставить("СтрокаПодключенияСМАРТС",СтрокаПодключенияСМАРТС);
			КонецЕсли;				
			
			пСтруктураБазMS = Новый Структура;
			пСтруктураБазMS.Вставить("IdBaseSMARTS", ID_ПодключаемойБазы);
			пСтруктураБазMS.Вставить("СтрокаПодключенияСМАРТС",СтрокаПодключенияСМАРТС);
			пСтруктураБазMS.Вставить("ОписаниеБазы",СтруктураОписанияБазы);
			
			КомЯдро_СохранитьЗначениеПеременной(КлючПеременной,пСтруктураБазMS);
			
			ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Структура инициализации. ИдБазы: " + Строка(ID_ПодключаемойБазы) + ", Строка подключения: " + Строка(СтрокаПодключенияСМАРТС), НачалоСобытия);
			
			Возврат ПроверкаСоединения;
		КонецЕсли
	КонецЕсли;		
КонецФункции

&НаКлиенте	
Функция КомЯдро_ПолучитьСтруктуруПодключенияБазыСМАРТС(ВтораяПопытка = Ложь)	
	
	НачалоСобытия = ТекущаяУниверсальнаяДатаВМиллисекундах();
	ИмяСобытия="КомЯдро_ПолучитьСтруктуруПодключенияБазыСМАРТС";
	
	TerminalConnector = Неопределено;
	НужноПочиститьКеш = Ложь;
	
	ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Начало, перед созданием ком объектов", НачалоСобытия);
	Попытка
		#Область НесовместимыйКодFresh
		TerminalConnector = Новый COMОбъект("AddIn.Cl.TerminalConnector");
		#КонецОбласти //НесовместимыйКодFresh
		КОМсоздан = Истина;
	Исключение
		СтруктураСменыСтатуса = Новый Структура("Статус, Параметр, Операция", 
			"ПроверкаБезопасностиПройденаПроверямЗапускКомMS", 
			"", 
			"ПодключениеЧерезCOM");
		Оповестить("СменаСтатуса", СтруктураСменыСтатуса);		
		
		КОМсоздан = Ложь;
		ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
	КонецПопытки;
	ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Комсоздан = " + Строка(КОМсоздан), НачалоСобытия);
	Если TerminalConnector = Неопределено Тогда
		КОМсоздан = Ложь;
	Иначе
		Попытка
			ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Перед: УстановитьВерсию1С", НачалоСобытия);
			TerminalConnector.УстановитьВерсию1С("v8");
			ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "После: УстановитьВерсию1С", НачалоСобытия);
		Исключение
			КОМсоздан = Ложь;
			ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
			НужноПочиститьКеш = Истина;
		КонецПопытки;
	КонецЕсли;
	
	Если КОМсоздан = Ложь Тогда
		ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Ком НЕ Создался! ВтораяПопытка = " + Строка(ВтораяПопытка) + ", ОписаниеОшибки: " + ТекстОшибки, НачалоСобытия);
		TerminalConnector = Неопределено;
		Если НЕ ВтораяПопытка И НужноПочиститьКеш Тогда
			КомЯдро_УдалитьПеременныеCOM();
			ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Очистка комов и кеша выполнена");
			Возврат КомЯдро_ПолучитьСтруктуруПодключенияБазыСМАРТС(Истина);			
		КонецЕсли;
		Возврат Неопределено;
	КонецЕсли;
	
	StorageConnector  = TerminalConnector.ПолучитьОбъектСоединенияСБазой();
			
	СтруктураПодключенияMSСМАРТС = Новый Структура;
	СтруктураПодключенияMSСМАРТС.Вставить("TerminalConnector", TerminalConnector);
	СтруктураПодключенияMSСМАРТС.Вставить("StorageConnector", StorageConnector);
	
	ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Конец создания комов и помещения их в структуру, структура: " + Строка(СтруктураПодключенияMSСМАРТС), НачалоСобытия);
		
	Возврат СтруктураПодключенияMSСМАРТС;
	
КонецФункции

&НаКлиенте
Процедура КомЯдро_УдалитьПеременныеCOM()
	
	КомЯдро_УдалитьCOMИзСтруктуры(COMЧастнойБазыMS);
	КомЯдро_УдалитьCOMИзСтруктуры(COMВременнойБазыMS);
	КомЯдро_УдалитьCOMИзСтруктуры(COMБазыMS);	
		
КонецПроцедуры

&НаКлиенте
Процедура КомЯдро_УдалитьCOMИзСтруктуры(СтруктураCOM)
	
	Если ТипЗнч(СтруктураCOM) = Тип("Структура") Тогда
		Для каждого КлючЗначение ИЗ СтруктураCOM Цикл
			Если ТипЗнч(КлючЗначение.Значение) = Тип("COMОбъект") Тогда
				СтруктураCOM[КлючЗначение.Ключ] = Неопределено;		
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	СтруктураCOM = Неопределено;
	
КонецПроцедуры

&НаКлиенте
Функция КомЯдро_ПолучитьОшибку(ТипБазы)
	
	Если ТипБазы = "Частная" Тогда
		СтруктураПодключенияMS = COMЧастнойБазыMS;
	ИначеЕсли ТипБазы = "Временная" Тогда
		СтруктураПодключенияMS = COMВременнойБазыMS;
	Иначе
		СтруктураПодключенияMS = COMБазыMS;
	КонецЕсли;
	
	ОписаниеОшибки = "";
	Ошибка = СтруктураПодключенияMS.TerminalConnector.ПолучитьОшибку(ОписаниеОшибки);
	Возврат ОписаниеОшибки;
	
КонецФункции

// Получает из кэша значение переменной по ключу
//
// Параметры:
//	КлючПеременной - Строка - ключ переменной в кэше 
//
// Возвращаемое значение:
//	Произвольный - значение переменной
&НаКлиенте
Функция КомЯдро_ПолучитьЗначениеПеременной(КлючПеременной) Экспорт
	Если НЕ ЗначениеЗаполнено(КлючПеременной)
		ИЛИ НЕ ТипЗнч(АдресаПеременных) = Тип("Структура")
		ИЛИ НЕ АдресаПеременных.Свойство(КлючПеременной) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если ТипЗнч(КлючПеременной) = Тип("Строка") Тогда
		Если НЕ ЭтоАдресВременногоХранилища(АдресаПеременных[КлючПеременной]) Тогда 
			Возврат Неопределено;
		КонецЕсли;
		Возврат ПолучитьИзВременногоХранилища(АдресаПеременных[КлючПеременной]);
	ИначеЕсли ТипЗнч(КлючПеременной) = Тип("Структура") Тогда
		Для Каждого КлючЗначение ИЗ КлючПеременной Цикл
			Если НЕ ЭтоАдресВременногоХранилища(АдресаПеременных[КлючЗначение.Ключ]) Тогда 
				ПолученноеЗначение = Неопределено;
			Иначе
				ПолученноеЗначение = ПолучитьИзВременногоХранилища(АдресаПеременных[КлючЗначение.Ключ]);
			КонецЕсли;	
			КлючПеременной.Вставить(КлючЗначение.Ключ,ПолученноеЗначение); 
		КонецЦикла;		
		Возврат КлючПеременной;
	КонецЕсли;
КонецФункции

// Сохраняет значения во временном хранилище и добавляет адрес в переменную для хранения 
//
// Параметры:
//	КлючПеременной - Строка, Структура - ключ для хранения переменной в структуре адресов или структура сохраняемых значений.
//	СохраняемоеЗначение	- Произвольный, Структура - Сохраняемое значение переменной или, если КлючПеременной содержит структуру,
//													то Структура с адресами переменных.
//
// Возвращаемое значение:
//   Булево - Возвращает признак успешности сохранения.
&НаКлиенте
Функция КомЯдро_СохранитьЗначениеПеременной(КлючПеременной,СохраняемоеЗначение) Экспорт
	
	Если НЕ ЗначениеЗаполнено(КлючПеременной)
		ИЛИ НЕ ТипЗнч(АдресаПеременных) = Тип("Структура")
		ИЛИ НЕ АдресаПеременных.Свойство("ИдентификаторФормы") Тогда
		Возврат Ложь;
	КонецЕсли;

	Если ТипЗнч(КлючПеременной) = Тип("Строка") Тогда
		АдресаПеременных.Вставить(КлючПеременной,ПоместитьВоВременноеХранилище(СохраняемоеЗначение,АдресаПеременных.ИдентификаторФормы));
	ИначеЕсли ТипЗнч(КлючПеременной) = Тип("Структура") Тогда
		АдресаПеременных = СохраняемоеЗначение;
		Для Каждого КлючЗначение ИЗ КлючПеременной Цикл
			АдресаПеременных.Вставить(КлючЗначение.Ключ,ПоместитьВоВременноеХранилище(КлючЗначение.Значение,АдресаПеременных.ИдентификаторФормы));
		КонецЦикла;		
		Возврат КлючПеременной;
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

// Проверяет соединение с базой Mobile Smarts, если не требуется явного переподключения. Если тест соединения не пройден или требуется явное переподключение,
// проверяет соединение с сервером Mobile Smarts и получает описание подключаемой базы. Если авторизация не требуется или сохранена, выполняет попытку подключиться
// к базе без авторизации или по сохраненным данным авторизации соответственно.
//
// Параметры:
//	СтруктураПодключения - Структура - структура подключения к базе Mobile Smarts
//  Переподключиться - Булево - определяет необходимость явного переподключения к базе Mobile Smarts
//  ТипБазы - Строка - "Частная", "Временная", "Основная"
//	РасположениеКомпоненты - Строка - расположение компоненты Mobile Smarts
//	СохранятьАвторизацию - Булево - флаг необходимости сохранять авторизацию
//  Интерактивно - Булево - флаг работы в интерактивном режиме
//
// Возвращаемое значение:
//	- Структура - если требуется авторизация в интерактивном режиме - содержит:
//  	* Статус - Строка	
//      * СтрокаПодключения - Строка
//      * ИмяБазы - Строка
//      * Логин - Строка
//      * ТипБазы - Строка
//      * ДопПараметры - Структура - содержит:
//			** СтрокаПодключения - Строка
//          ** ТипБазы - Строка
//          ** СтруктураПодключения - Структура - структура подключения к базе Mobile Smarts
//          ** СохранятьАвторизацию - Булево
//          ** ИмяБазы - Строка
//			** Логин - Строка
//	- Булево - результат проверки соединения с подключенной базой Mobile Smarts
&НаКлиенте
Функция КомЯдро_ПодключитьсяКБазеSMARTS(СтруктураПодключения,Переподключиться = Ложь,ТипБазы = "Основная", РасположениеКомпоненты = Неопределено,СохранятьАвторизацию=Ложь,Интерактивно=Ложь) Экспорт
	
	Перем ID_ПодключаемойБазы,СтрокаПодключенияСМАРТС,ОписаниеБазы,СтруктураОписанияБазы;
	
	НачалоСобытия = ТекущаяУниверсальнаяДатаВМиллисекундах();
	ИмяСобытия = "КомЯдро_ПодключитьсяКБазеSMARTS";
			
	Если ТипБазы = "Частная" Тогда
		СтруктураБазMSCOM = COMЧастнойБазыMS;
		КлючПеременной = "СтруктураПодключенияЧастнойБазыMS";
	ИначеЕсли ТипБазы = "Временная" Тогда
		СтруктураБазMSCOM = COMВременнойБазыMS;
		КлючПеременной = "СтруктураПодключенияВременнойБазыMS";
	Иначе
		СтруктураБазMSCOM = COMБазыMS;
		КлючПеременной = "СтруктураПодключенияБазыMS";
	КонецЕсли;
	
	СтруктураБазMS = КомЯдро_ПолучитьЗначениеПеременной(КлючПеременной);
	
	Если НЕ Переподключиться  
		И НЕ СтруктураБазMS = Неопределено
		И СтруктураБазMS.Свойство("ОписаниеБазы") И ТипЗнч(СтруктураБазMS.ОписаниеБазы) = Тип("Структура") Тогда
		
		Попытка
			ТестСоединения = СтруктураБазMSCOM.StorageConnector.ПроверитьСоединение() = Истина;
			ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "После теста cоединения с базой Mobile SMARTS " + Строка(ТестСоединения), НачалоСобытия);
		Исключение
			ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
			ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Тест cоединения с базой Mobile SMARTS не пройден, запуск переподключения, Описание ошибки: " + ТекстОшибки, НачалоСобытия);			
			ТестСоединения = Ложь;
		КонецПопытки;
		
		Если ТестСоединения Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЕсли;
	
	Если НЕ КомЯдро_ПодключитьсяКСерверуSMARTS(Переподключиться,ТипБазы) Тогда
		Возврат Ложь;		
	КонецЕсли;
	
	СтрокаПодключения = Неопределено;
	
	Если СтруктураПодключения = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если СтруктураПодключения.Свойство("СтрокаПодключенияСМАРТС") И ЗначениеЗаполнено(СтруктураПодключения.СтрокаПодключенияСМАРТС) Тогда
		СтрокаПодключения = СтруктураПодключения.СтрокаПодключенияСМАРТС;
	ИначеЕсли СтруктураПодключения.Свойство("IdBaseSMARTS") И ЗначениеЗаполнено(СтруктураПодключения.IdBaseSMARTS) Тогда
		СтрокаПодключения = СтруктураПодключения.IdBaseSMARTS;
	ИначеЕсли СтруктураПодключения.Свойство("Ид") Тогда
		СтрокаПодключения = СтруктураПодключения.Ид;
	КонецЕсли;
	
	Если ТипБазы = "Частная" Тогда
		СтруктураБазMSCOM = COMЧастнойБазыMS;
	ИначеЕсли ТипБазы = "Временная" Тогда
		СтруктураБазMSCOM = COMВременнойБазыMS;
	Иначе
		СтруктураБазMSCOM = COMБазыMS;
	КонецЕсли;
	
	ОписаниеБазы = СтруктураБазMSCOM.TerminalConnector.ПолучитьБазуСМАРТСПоИД(СтрокаПодключения);
	Если ТипЗнч(ОписаниеБазы) = Тип("COMОбъект") Тогда
		СтруктураОписанияБазы = КомЯдро_СоздатьСтруктуруОписанияБазыSMARTS(ОписаниеБазы);
		Если НЕ СтруктураПодключения.Свойство("АвторизацияВключена")
			ИЛИ НЕ СтруктураПодключения.АвторизацияВключена = Истина Тогда
			СтруктураПодключения.Вставить("АвторизацияВключена",СтруктураОписанияБазы.АвторизацияВключена);
		Иначе
			СтруктураОписанияБазы.Вставить("АвторизацияВключена",Истина);
		КонецЕсли;
	Иначе
		Возврат Ложь;
	КонецЕсли;
	
	Токен = Неопределено;
	Если СтруктураОписанияБазы.АвторизацияВключена Тогда
		Если СтруктураПодключения.Свойство("АвторизацияТокен")
			И ЗначениеЗаполнено(СтруктураПодключения.АвторизацияТокен) Тогда
			Токен = СтруктураПодключения.АвторизацияТокен;
		Иначе		
        	АвторизацияЛогин  = ЛокЯдро_ПолучитьДанныеИзХранилища1С("СохраненнаяАвторизацияЛогин");
			Если ЗначениеЗаполнено(АвторизацияЛогин) Тогда
				АвторизацияПароль = ЛокЯдро_ПолучитьДанныеИзХранилища1С("СохраненнаяАвторизацияПароль");
				АвторизацияПароль = ЛокЯдро_РасшифроватьСтроку(АвторизацияПароль, ЛокЯдро_ПолучитьКлючШифрования(АвторизацияЛогин, СтрДлина(АвторизацияПароль)));
				
				Токен = КомЯдро_ПолучитьТокенSMARTS(СтрокаПодключения, АвторизацияЛогин, АвторизацияПароль, ТипБазы);
				Если Токен <> Ложь И Токен <> Неопределено Тогда	
					СтруктураПодключения.Вставить("АвторизацияЛогин", АвторизацияЛогин);
					СтруктураПодключения.Вставить("АвторизацияТокен", Токен);
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	ДопПараметры = Новый Структура("СтрокаПодключения,РасположениеКомпоненты,ТипБазы,СтруктураПодключения,СохранятьАвторизацию,ИмяБазы",СтрокаПодключения,РасположениеКомпоненты,ТипБазы,СтруктураПодключения,СохранятьАвторизацию,СтруктураОписанияБазы.Имя);
	Если СтруктураОписанияБазы.АвторизацияВключена
		И (Токен = Ложь ИЛИ Токен = Неопределено) Тогда
		
		//Если авторизация не сохранена
		Если Интерактивно Тогда
			Возврат Новый Структура("Статус,СтрокаПодключения,ИмяБазы,Логин,ТипБазы,ДопПараметры,ТекстОшибки","ТребуетсяАвторизация",СтрокаПодключения,СтруктураОписанияБазы.Имя,?(СтруктураПодключения.Свойство("АвторизацияЛогин"),СтруктураПодключения.АвторизацияЛогин,""),ТипБазы,ДопПараметры,"");
		Иначе
			Возврат КомЯдро_ПодключитьсяКБазеSMARTSНаСервереЗавершение(,ДопПараметры);
		КонецЕсли;				
		
	Иначе
		
		Попытка
			Результат = СтруктураБазMSCOM.TerminalConnector.УстановитьТекущуюБазуСМАРТСБезАвт(СтрокаПодключения) = Истина;
			ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Попытка подключиться к базе Mobile SMARTS: Строка подключения: " + Строка(СтрокаПодключения), НачалоСобытия);
		Исключение
			Результат = СтруктураБазMSCOM.TerminalConnector.УстановитьТекущуюБазуСМАРТС(СтрокаПодключения) = Истина;
			ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Исключение подключиться к базе Mobile SMARTS: Строка подключения: " + Строка(СтрокаПодключения), НачалоСобытия);
		КонецПопытки;
		
		Если Результат Тогда
			Если ТипЗнч(СтруктураПодключения) = Тип("Структура")
				И СтруктураПодключения.Свойство("АвторизацияВключена")
				И СтруктураПодключения.АвторизацияВключена
				И СтруктураПодключения.Свойство("АвторизацияЛогин")
				И ЗначениеЗаполнено(СтруктураПодключения.АвторизацияЛогин)
				И СтруктураПодключения.Свойство("АвторизацияТокен")
				И ЗначениеЗаполнено(СтруктураПодключения.АвторизацияТокен) Тогда
				//Если авторизация сохранена
				
				РезультатАвторизации= Неопределено;
				Попытка
					РезультатАвторизации = СтруктураБазMSCOM.TerminalConnector.АвторизоватьсяПоТокену(СтруктураПодключения.АвторизацияЛогин,СтруктураПодключения.АвторизацияТокен);
					ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Авторизация по токену, результат: " + Строка(РезультатАвторизации), НачалоСобытия);
				Исключение
					ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Не удалось авторизоваться по токену", НачалоСобытия);
				КонецПопытки;
				
				Если НЕ СтруктураБазMSCOM.StorageConnector.ПроверитьСоединение() = Истина Тогда
					//Если не удалось авторизоваться
					Если Интерактивно Тогда
						Возврат Новый Структура("Статус,СтрокаПодключения,ИмяБазы,Логин,ТипБазы,ДопПараметры,ТекстОшибки","ОшибкаАвторизации",СтрокаПодключения,СтруктураОписанияБазы.Имя,?(СтруктураПодключения.Свойство("АвторизацияЛогин"),СтруктураПодключения.АвторизацияЛогин,""),ТипБазы,ДопПараметры,"");
					Иначе
						Возврат КомЯдро_ПодключитьсяКБазеSMARTSНаСервереЗавершение(,ДопПараметры);
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		Возврат КомЯдро_ПодключитьсяКБазеSMARTSНаСервереЗавершение(,ДопПараметры);
	КонецЕсли;
			
КонецФункции

// Вызывает функцию проверки соединения с сервером Mobile Smarts, при успешном выполнении проверки - с подключенной базой Mobile Smarts
//
// Параметры:
//	СтруктураПодключения - Структура - структура подключения к базе Mobile Smarts
//	РасположениеКомпоненты - Строка - расположение компоненты Mobile Smarts
//  Переподключиться - Булево - определяет необходимость явного переподключения к базе Mobile Smarts
//  ТипБазы - Строка - "Частная", "Временная", "Основная"
//	СохранятьАвторизацию - Булево - флаг необходимости сохранять данные авторизации
//  Интерактивно - Булево - флаг работы в интерактивном режиме
//
// Возвращаемое значение:
//	- Структура - если требуется авторизация в интерактивном режиме - содержит:
//  	* Статус - Строка	
//      * СтрокаПодключения - Строка
//      * ИмяБазы - Строка
//      * Логин - Строка
//      * ТипБазы - Строка
//      * ДопПараметры - Структура - содержит:
//			** СтрокаПодключения - Строка
//          ** ТипБазы - Строка
//          ** СтруктураПодключения - Структура - структура подключения к базе Mobile Smarts
//          ** СохранятьАвторизацию - Булево
//          ** ИмяБазы - Строка
//			** Логин - Строка
//	- Булево - результат проверки соединения с сервером Mobile Smarts
&НаКлиенте
Функция КомЯдро_ПроверитьСоединениеССерверомSMARTS(СтруктураПодключения = Неопределено, РасположениеКомпоненты = Неопределено,Переподключиться = ложь,ТипБазы = "Основная",СохранятьАвторизацию = Ложь,Интерактивно = Ложь) Экспорт
	
	Если НЕ КомЯдро_ПодключитьсяКСерверуSMARTS(Переподключиться,ТипБазы) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если ТипБазы = "Частная" Тогда
		СтруктураПодключенияMS = COMЧастнойБазыMS;
		пСтруктура = ДанныеТекущегоУзла.ЧастнаяБазаMS;
	ИначеЕсли ТипБазы = "Временная" Тогда
		СтруктураПодключенияMS = COMВременнойБазыMS;
		пСтруктура = Неопределено;
	Иначе
		СтруктураПодключенияMS = COMБазыMS;
		пСтруктура =ПараметрыПодключенияMS;
	КонецЕсли;

	Если СтруктураПодключенияMS = Неопределено Тогда
		Возврат Ложь;
	Иначе
		
		Если СтруктураПодключения = Неопределено Тогда
			нСтруктура = пСтруктура;
		Иначе
			нСтруктура = СтруктураПодключения;
		КонецЕсли;
		
		Возврат КомЯдро_ПодключитьсяКБазеSMARTS(нСтруктура,Переподключиться,ТипБазы,РасположениеКомпоненты,СохранятьАвторизацию,Интерактивно);								
	КонецЕсли;
	
КонецФункции

#КонецОбласти

#Область КомпонентаMobileSMARTS_БазыSMARTS

// Выполняет авторизацию в базе Mobile Smarts и возвращает токен авторизации
//
// Параметры:
//	СтрокаПодключения - Строка - строка подключения к базе Mobile Smarts
//	Логин - Строка - логин авторизации
//	Пароль - Строка - пароль авторизации
//	ТипБазы - Строка - "Частная", "Временная", "Основная"
//
// Возвращаемое значение:
//	Строка - токен авторизации
&НаКлиенте
Функция КомЯдро_ПолучитьТокенSMARTS(СтрокаПодключения,Логин,Пароль,ТипБазы = "Основная") Экспорт
	
	Если НЕ КомЯдро_ПодключитьсяКСерверуSMARTS(Истина,ТипБазы) Тогда
		Возврат Ложь;		
	КонецЕсли;
	
	Токен = "";
	
	Если ТипБазы = "Частная" Тогда
		СтруктураПодключенияMS = COMЧастнойБазыMS;
	ИначеЕсли ТипБазы = "Временная" Тогда
		СтруктураПодключенияMS = COMВременнойБазыMS;
	Иначе
		СтруктураПодключенияMS = COMБазыMS;
	КонецЕсли;
	
	Если СтруктураПодключенияMS.TerminalConnector.УстановитьТекущуюБазуСМАРТСБезАвт(СтрокаПодключения) = Истина Тогда
	
		Токен = СтруктураПодключенияMS.TerminalConnector.АвторизоватьсяПоЛогину(Логин,Пароль);
	
	КонецЕсли;
	
	Возврат Токен;
	
КонецФункции

&НаКлиенте
Функция КомЯдро_ПолучитьСписокБазНаСервереSMARTS(Полное = Истина)
	
	Если НЕ КомЯдро_ПодключитьсяКСерверуSMARTS(Ложь,"Основная") Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	РезультатМассив = Новый Массив;
	СтруктураПодключенияБазыMS = COMБазыMS;
	
	СписокБазНаСервере = СтруктураПодключенияБазыMS.TerminalConnector.ПолучитьСписокБазСМАРТС("");
	Для Индекс = 0 По СписокБазНаСервере.Количество - 1 Цикл
		ВыбраннаяБазаSMARTS = СписокБазНаСервере.Элемент(Индекс);
		СтруктураДанныеБазы = КомЯдро_СоздатьСтруктуруОписанияБазыSMARTS(ВыбраннаяБазаSMARTS,Полное);
		РезультатМассив.Добавить(СтруктураДанныеБазы);
	КонецЦикла;
	
	Если РезультатМассив.Количество() > 0 Тогда
		СтруктураСтрокой = "";
		НужнаЗапятая = Ложь;
		Для Каждого ЭлементСтруктуры Из РезультатМассив[0] Цикл
			Если НужнаЗапятая Тогда
				СтруктураСтрокой = СтруктураСтрокой + ",";
			КонецЕсли;
			СтруктураСтрокой = СтруктураСтрокой + ЭлементСтруктуры.Ключ;
			НужнаЗапятая = Истина;
		КонецЦикла;
	КонецЕсли; 
		
	ОписаниеТаблицыЗначений = Новый Структура("ЭтоТаблицаЗначений, КолонкиТаблицыЗначений", Истина, СтруктураСтрокой); 
	РезультатМассив.Вставить(0, ОписаниеТаблицыЗначений);
	
	Возврат РезультатМассив;
	
КонецФункции

&НаКлиенте 
Функция КомЯдро_ПолучитьБазуНаСервереSMARTS(ИдентификаторБазы,ТипБазы)
		
	Если ТипБазы = "Частная" Тогда
		СтруктураПодключенияMSCOM = COMЧастнойБазыMS;
		КлючПеременной = "СтруктураПодключенияЧастнойБазыMS";
	ИначеЕсли ТипБазы = "Временная" Тогда
		СтруктураПодключенияMSCOM = COMВременнойБазыMS;
		КлючПеременной = "СтруктураПодключенияВременнойБазыMS";
	Иначе
		СтруктураПодключенияMSCOM = COMБазыMS;
		КлючПеременной = "СтруктураПодключенияБазыMS";
	КонецЕсли;

	СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной(КлючПеременной);
	
	Если НЕ ЗначениеЗаполнено(ИдентификаторБазы) Тогда
		Если СтруктураПодключенияMS.Свойство("СтрокаПодключенияСМАРТС") И ЗначениеЗаполнено(СтруктураПодключенияMS.СтрокаПодключенияСМАРТС) Тогда
			СтрокаПодключения = СтруктураПодключенияMS.СтрокаПодключенияСМАРТС;
		ИначеЕсли СтруктураПодключенияMS.Свойство("IdBaseSMARTS") И ЗначениеЗаполнено(СтруктураПодключенияMS.IdBaseSMARTS) Тогда
			СтрокаПодключения = СтруктураПодключенияMS.IdBaseSMARTS;
		Иначе
			СтрокаПодключения = СтруктураПодключенияMS.Ид;
		КонецЕсли;
		
		БазаSMARTS = СтруктураПодключенияMSCOM.TerminalConnector.ПолучитьБазуСМАРТСПоИД(СтрокаПодключения);
	Иначе
	    БазаSMARTS = СтруктураПодключенияMSCOM.TerminalConnector.ПолучитьБазуСМАРТСПоИД(ИдентификаторБазы);
	КонецЕсли;
	
	Возврат БазаSMARTS;
	
КонецФункции

&НаКлиенте
Функция КомЯдро_СоздатьСтруктуруОписанияБазыSMARTS(ОписаниеБазы,Полное=Истина)
	
	СтруктураДанныеБазы = Новый Структура;
		
	СтруктураДанныеБазы.Вставить("Ид", ОписаниеБазы.Ид);
	СтруктураДанныеБазы.Вставить("Имя", ОписаниеБазы.Имя);
	
	Попытка
		НастройкиБазыСМАРТС = ОписаниеБазы.ПолучитьНастройки();
	Исключение
		// при невозможности открыть базу
		СтруктураДанныеБазы.Имя = "(Повреждена!) " + СтруктураДанныеБазы.Имя;
		Возврат СтруктураДанныеБазы;
	КонецПопытки;	
	
	Если НЕ Полное Тогда
		Возврат СтруктураДанныеБазы;
	КонецЕсли;
	
	Попытка
		ПолноеНаименованиеПродукта = ОписаниеБазы.ПолучитьОписаниеПриложения().ToString;
	Исключение
		ПолноеНаименованиеПродукта = "Не удалось получить имя продукта";
	КонецПопытки;
	
	ПозицияV = ЛокЯдро_СтрНайти(ПолноеНаименованиеПродукта, "v.");
	ВерсияПриложения = ?(ПозицияV > 0, СокрЛП(Сред(ПолноеНаименованиеПродукта, ПозицияV + 2)), "");
	
	СтруктураДанныеБазы.Вставить("Комментарий", 				ОписаниеБазы.Комментарий);
	СтруктураДанныеБазы.Вставить("СтрокаПодключения", 			ОписаниеБазы.СтрокаПодключения);
	СтруктураДанныеБазы.Вставить("РабочийКаталог", 				ОписаниеБазы.РабочийКаталог);
	СтруктураДанныеБазы.Вставить("ИдПриложения", 				ОписаниеБазы.Приложение.Id);		
	СтруктураДанныеБазы.Вставить("ИмяПриложения", 				ОписаниеБазы.Приложение.Name);
	СтруктураДанныеБазы.Вставить("УровеньПриложения", 			ОписаниеБазы.Приложение.Level);
	СтруктураДанныеБазы.Вставить("ИдОсновногоПриложения", 		ОписаниеБазы.Приложение.ParentId);
	СтруктураДанныеБазы.Вставить("РаботаСУстройствомНапрямую", 	НастройкиБазыСМАРТС.РаботаСУстройствомНапрямую);
	СтруктураДанныеБазы.Вставить("РаботаСКаталогом", 			НастройкиБазыСМАРТС.РаботаСКаталогом);
	СтруктураДанныеБазы.Вставить("РаботаССервером", 			НастройкиБазыСМАРТС.РаботаССервером);
	СтруктураДанныеБазы.Вставить("РаботаСЛокальнымСервером", 	НастройкиБазыСМАРТС.РаботаСЛокальнымСервером);
	СтруктураДанныеБазы.Вставить("РаботаСУдаленнымСервером", 	НастройкиБазыСМАРТС.РаботаСУдаленнымСервером);
	СтруктураДанныеБазы.Вставить("ПапкаОбмена", 				НастройкиБазыСМАРТС.ПолучитьТекущуюПапкуОбмена());
	ИнформацияОПродукте = ЛокЯдро_ПолучитьИнформациюОПродукте(ОписаниеБазы.Приложение.Id,ОписаниеБазы.Приложение.ParentId);
	СтруктураДанныеБазы.Вставить("УровеньПриложенияСтрокой",	?(ЗначениеЗаполнено(ИнформацияОПродукте.УровеньПриложения), ИнформацияОПродукте.УровеньПриложения, ЛокЯдро_ПолучитьУровеньПриложения(ОписаниеБазы.Приложение.Level)));
	СтруктураДанныеБазы.Вставить("ТипУстановленногоПродукта",	ИнформацияОПродукте.ТипУстановленногоПродукта);
	СтруктураДанныеБазы.Вставить("АвторизацияВключена", 		Ложь);
	СтруктураДанныеБазы.Вставить("АвторизацияЛогин", 			"");
	СтруктураДанныеБазы.Вставить("АвторизацияТокен", 			"");
	СтруктураДанныеБазы.Вставить("АвторизацияРефрешТокен",		"");
	СтруктураДанныеБазы.Вставить("СтрокаПодключенияСМАРТС",		ОписаниеБазы.СтрокаПодключения);
	СтруктураДанныеБазы.Вставить("IdBaseSMARTS", 				ОписаниеБазы.Ид);
	СтруктураДанныеБазы.Вставить("QR", 							"");
	СтруктураДанныеБазы.Вставить("ВерсияПриложения", 			ВерсияПриложения);
	СтруктураДанныеБазы.Вставить("ВерсияКонфигурацииSMARTS",	"");
	
	//В старых версиях платформы MS нет поля АвторизацияВключена
	Попытка 
		СтруктураДанныеБазы.АвторизацияВключена = НастройкиБазыСМАРТС.АвторизацияВключена;
	Исключение
	КонецПопытки;
		
	Попытка // Если нет связи с удаленной базой смартс, то платформа выдает ошибку
		ИмяИнтеграционнойОбработки 	= НастройкиБазыСМАРТС.Получить("ИмяИнтеграционнойОбработкиКонфигурации1С");
		ПутьИнтеграционнойОбработки = НастройкиБазыСМАРТС.Получить("ПутьИнтеграционнойОбработкиКонфигурации1С");
		ТипОбработки = НастройкиБазыСМАРТС.Получить("ТипОбработки");
	Исключение
		ИмяИнтеграционнойОбработки 	= Неопределено;
		ПутьИнтеграционнойОбработки = Неопределено;
		ТипОбработки = Неопределено;
	КонецПопытки;
	
	Если ТипОбработки = "СправочникСсылка" Тогда
		Попытка
			Путь = ЛокЯдро_ЗначениеИзСтрокиXML(ПутьИнтеграционнойОбработки);
		Исключение
			Путь = Неопределено;
		КонецПопытки;
	Иначе
		Путь = ПутьИнтеграционнойОбработки;
	КонецЕсли;
	
	//Заплатка
	Если ТипЗнч(Путь) = Тип("COMОбъект") Тогда
		Путь = Неопределено;
	КонецЕсли;
	
	СтруктураДанныеБазы.Вставить("ТипОбработки",ТипОбработки);
	СтруктураДанныеБазы.Вставить("ИмяИнтеграционнойОбработки", ?(НЕ ЗначениеЗаполнено(ИмяИнтеграционнойОбработки),"",ИмяИнтеграционнойОбработки));
	СтруктураДанныеБазы.Вставить("ПутьИнтеграционнойОбработки", ?(НЕ ЗначениеЗаполнено(ИмяИнтеграционнойОбработки),"\Обработки 1С\Обработки интеграции\", Путь));		
	
	Попытка // Если нет связи с удаленной базой смартс, то платформа выдает ошибку
		ПутьОсновнойОбработки 	= НастройкиБазыСМАРТС.Получить("ПутьОсновнойОбработки");
		ТипОсновнойОбработки 	= НастройкиБазыСМАРТС.Получить("ТипОсновнойОбработки");
	Исключение
		ПутьОсновнойОбработки 	= Неопределено;
		ТипОсновнойОбработки 	= Неопределено;
	КонецПопытки;

	Если ТипОсновнойОбработки = "СправочникСсылка" Тогда
		Попытка
			Путь = ЛокЯдро_ЗначениеИзСтрокиXML(ПутьОсновнойОбработки);
		Исключение
			Путь = Неопределено;
		КонецПопытки;
	Иначе
		Путь = ПутьОсновнойОбработки;
	КонецЕсли;
	
	//Заплатка
	Если ТипЗнч(Путь) = Тип("COMОбъект") Тогда
		Путь = Неопределено;
	КонецЕсли;
	
	СтруктураДанныеБазы.Вставить("ТипОсновнойОбработки", ТипОсновнойОбработки);
	СтруктураДанныеБазы.Вставить("ПутьОсновнойОбработки", Путь);
	
	Возврат СтруктураДанныеБазы;
	
КонецФункции

#КонецОбласти

#Область КомпонентаMobileSMARTS_НастройкиSMARTS

&НаКлиенте
Функция КомЯдро_ПолучитьНастройкиНаСервереSMARTS(ИдентификаторБазы = Неопределено,ТипБазы)
	
	НастройкиБазыSMARTS = Неопределено;
	Если НЕ ЗначениеЗаполнено(ИдентификаторБазы) Тогда 
		БазаSMARTS = КомЯдро_ПолучитьБазуНаСервереSMARTS(,ТипБазы);
	Иначе
		БазаSMARTS = КомЯдро_ПолучитьБазуНаСервереSMARTS(ИдентификаторБазы,ТипБазы);
	КонецЕсли;
	Если БазаSMARTS <> Неопределено Тогда
		НастройкиБазыSMARTS = БазаSMARTS.ПолучитьНастройки();
	КонецЕсли;
	
	Возврат НастройкиБазыSMARTS;
	
КонецФункции

&НаКлиенте
Функция КомЯдро_ЗаполнитьНастройкиSMARTS(СтруктураНастроек, УзловыеНастройки, ID_Узла = "",ТипБазы = "Основная")
	
	Если НЕ КомЯдро_ПодключитьсяКСерверуSMARTS(Ложь,ТипБазы) Тогда
		Возврат СтруктураНастроек;
	КонецЕсли;
	
	НастройкиБазыSMARTS = КомЯдро_ПолучитьНастройкиНаСервереSMARTS(,ТипБазы);
	Если НастройкиБазыSMARTS = Неопределено Тогда
		Возврат СтруктураНастроек;
	КонецЕсли;
	
	Для Каждого Настройка Из СтруктураНастроек Цикл
		ИтоговыйКлючНастройки = Настройка.Ключ;
		Если УзловыеНастройки.Найти(Настройка.Ключ) <> Неопределено Тогда
			ИтоговыйКлючНастройки = ИтоговыйКлючНастройки + ?(ID_Узла = "", "", "_"+ ID_Узла);
		КонецЕсли;
		ЗначениеНастройки = НастройкиБазыSMARTS.Получить(ИтоговыйКлючНастройки);
		// Для совместимости со старыми настройками
		Если ЗначениеНастройки = Неопределено 
			И Найти(ИтоговыйКлючНастройки,"ПроизвольныеКоды_")  > 0  Тогда
			ЗначениеНастройки = НастройкиБазыSMARTS.Получить(СтрЗаменить(ИтоговыйКлючНастройки,"ПроизвольныеКоды_","ПроизвольныйКод_"));
		КонецЕсли;			
		// Для совместимости со старыми настройками
		Если ЗначениеНастройки = "Да" Тогда
			ЗначениеНастройки = Истина;
		ИначеЕсли ЗначениеНастройки = "Нет" Тогда
			ЗначениеНастройки = Ложь;	
		КонецЕсли;	
		СтруктураНастроек.Вставить(Настройка.Ключ, ?(ЗначениеНастройки = Неопределено, Ложь, ЗначениеНастройки));
	КонецЦикла;
	
	Возврат СтруктураНастроек;
	
КонецФункции

&НаКлиенте
Процедура КомЯдро_ЗаписатьНастройкиSMARTS(СтруктураНастроек, УзловыеНастройки, ID_Узла = "")
	
	ИмяСобытия = "КомЯдро_ЗаписатьНастройкиSMARTS (ЛокЯдро)";
	
	Если НЕ КомЯдро_ПодключитьсяКСерверуSMARTS(Ложь,"Основная") Тогда
		Возврат;
	КонецЕсли;
	
	НеЛогировать = Ложь;
	Если СтруктураНастроек.Свойство("НеЛогировать", НеЛогировать) Тогда
		СтруктураНастроек.Удалить("НеЛогировать");	
	КонецЕсли;
	
	//Обновляем дату актуальности настроек, чтобы при последующем онлайн-вызове были получены сохраненные настройки.
	ИзменилисьКлючевыеНастройки = Ложь;
	МассивИсключений = Новый Массив;
	МассивИсключений.Добавить("НастройкиОтборовУзлов_Онлайн");
	МассивИсключений.Добавить("НастройкиБизнесПроцессов_Пользовательские");
	МассивИсключений.Добавить("НастройкиОбменаСправочников");
	МассивИсключений.Добавить("ИспользоватьШаблоныВесовогоТовара");
	МассивИсключений.Добавить("ПрефиксКодаВесовогоТовара");
	МассивИсключений.Добавить("ЧислоЗнаковПослеЗапятойВесТовара");
	МассивИсключений.Добавить("ДлинаКодаВесовогоТовара");
	МассивИсключений.Добавить("ПрефиксВключенВКодВесовогоТовара");
	МассивИсключений.Добавить("ВыгружатьНоменклатуруДокументаПередВыгрузкойДокумента");
	МассивИсключений.Добавить("ЗначенияПараметровУзлов");
	МассивИсключений.Добавить("ГлобальныеПараметры_Значения");
	МассивИсключений.Добавить("ГлобальныеПараметры");
	МассивИсключений.Добавить("ГлобальныеПараметры_Пользовательские");
	МассивИсключений.Добавить("НастройкиБизнесПроцессов_ПользовательскиеНастройки");	
	МассивИсключений.Добавить("ФормаОбменаВыбранныеКолонки");
	МассивИсключений.Добавить("ФормаОбменаВыбранныеКолонкиSMARTS");
	
	ИзменилисьКэшируемыеНастройки = Ложь;
	МассивИсключенийКэшируемыеНастройки = Новый Массив; // Ключевые настройки для оффлайна в дополнение к МассивИсключений
	МассивИсключенийКэшируемыеНастройки.Добавить("НастройкиОтборовУзлов_Интерактивный");
	
	СтруктураПодключенияБазыMS = КомЯдро_ПолучитьЗначениеПеременной("СтруктураПодключенияБазыMS");
	
	БазаSMARTS = КомЯдро_ПолучитьБазуНаСервереSMARTS(СтруктураПодключенияБазыMS.IdBaseSMARTS,"Основная"); 
	Если БазаSMARTS = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	НастройкиБазыSMARTS = БазаSMARTS.ПолучитьНастройки();
	Если НастройкиБазыSMARTS = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Для Каждого Настройка Из СтруктураНастроек Цикл
		Если НЕ ИзменилисьКлючевыеНастройки
			И МассивИсключений.Найти(Настройка.Ключ) <> Неопределено Тогда
			ИзменилисьКлючевыеНастройки = Истина;
			ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Изменение ключевых настроек, изменена настройка: " + Настройка.Ключ);
		КонецЕсли;
		
		Если НЕ ИзменилисьКэшируемыеНастройки
			И (ИзменилисьКлючевыеНастройки ИЛИ МассивИсключенийКэшируемыеНастройки.Найти(Настройка.Ключ) <> Неопределено) Тогда
			ИзменилисьКэшируемыеНастройки = Истина;
			ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Изменение кэшируемых настроек, изменена настройка: " + Настройка.Ключ);
		КонецЕсли;

		ИтоговыйКлючНастройки = Настройка.Ключ;
		Если УзловыеНастройки.Найти(Настройка.Ключ) <> Неопределено Тогда
			ИтоговыйКлючНастройки = ИтоговыйКлючНастройки + ?(ID_Узла = "", "", "_"+ ID_Узла);
		КонецЕсли;
		
		НастройкиБазыSMARTS.Настройка(ИтоговыйКлючНастройки).Значение = Настройка.Значение;
	КонецЦикла;
	
	Если НеЛогировать <> Истина Тогда
		ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Запись настроек в CustomSettings");
	КонецЕсли;
	
	БазаSMARTS.СохранитьНастройки(НастройкиБазыSMARTS);
	
	StorageConnector 	= COMБазыMS.StorageConnector;
	ConnectorID 		= "OneC_Connector";
	
	Если ИзменилисьКлючевыеНастройки ИЛИ ИзменилисьКэшируемыеНастройки Тогда
		ПостфиксБазы	 = СтрЗаменить(БазаSMARTS.Ид, "-", "_");	
		ДатаАктуальности = ЛокЯдро_ПолучитьТекущуюДатуНаСервере();
		
		Если ИзменилисьКлючевыеНастройки Тогда
			ЛокЯдро_СохранитьДанныеВХранилище1С("Cleverence_ДатаАктуальностиНастроек_" + ПостфиксБазы, ДатаАктуальности);
			ЛокЯдро_СохранитьДанныеВХранилище1С("Cleverence_REST_API_ДатаАктуальностиСоединения", Неопределено);
			ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Сброшена дата актуальности настроек, постфикс базы: " + ПостфиксБазы);
		КонецЕсли;
		
		Если ИзменилисьКэшируемыеНастройки Тогда
			ЛокЯдро_СохранитьНастройкуВБазеSMARTS("ДатаАктуальностиКэшируемыхНастроек", ДатаАктуальности);
			ЛокЯдро_СохранитьДанныеВХранилище1С("Cleverence_ДатаАктуальностиКэшируемыхНастроек_" + ПостфиксБазы, ДатаАктуальности);
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

&НаКлиенте
Процедура КомЯдро_УдалитьНастройкиSMARTS(СтруктураНастроек, УзловыеНастройки, ID_Узла = "")
	
	Если НЕ КомЯдро_ПодключитьсяКСерверуSMARTS(Ложь,"Основная") Тогда
		Возврат;
	КонецЕсли;
	
	СтруктураПодключенияБазыMS = КомЯдро_ПолучитьЗначениеПеременной("СтруктураПодключенияБазыMS");
	
	БазаSMARTS = КомЯдро_ПолучитьБазуНаСервереSMARTS(СтруктураПодключенияБазыMS.IdBaseSMARTS,"Основная"); 
	Если БазаSMARTS = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	НастройкиБазыSMARTS = БазаSMARTS.ПолучитьНастройки();
	Если НастройкиБазыSMARTS = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Для Каждого Настройка Из СтруктураНастроек Цикл
		ИтоговыйКлючНастройки = Настройка.Ключ;
		Если УзловыеНастройки.Найти(Настройка.Ключ) <> Неопределено Тогда
			ИтоговыйКлючНастройки = ИтоговыйКлючНастройки + ?(ID_Узла = "", "", "_"+ ID_Узла);
		КонецЕсли;
		НастройкиБазыSMARTS.Удалить(ИтоговыйКлючНастройки);
	КонецЦикла;
	
	БазаSMARTS.СохранитьНастройки(НастройкиБазыSMARTS);
	
КонецПроцедуры

// Получает структуру подключения базы Mobile Smarts и выполняет тест соединения
//
// Параметры:
//	ТипБазы - Строка - "Частная", "Временная", "Основная"
//
// Возвращаемое значение:
//	- Структура	- структура подключения базы Mobile Smarts
//  - Булево - если тест соединения не пройден
&НаКлиенте
Функция КомЯдро_ПолучитьСтруктуруПодключенияMS(ТипБазы) Экспорт
	
	ИмяСобытия = "КомЯдро_ПолучитьСтруктуруПодключенияMS";
	
	Если ТипБазы = "Частная" Тогда
		СтруктураБазMS = COMЧастнойБазыMS;
	ИначеЕсли ТипБазы = "Временная" Тогда
		СтруктураБазMS = COMВременнойБазыMS;
	Иначе
		СтруктураБазMS = COMБазыMS;
	КонецЕсли;
	
	Попытка
		ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "1. Перед тестом cоединения с базой Mobile SMARTS");
		ТестСоединения = СтруктураБазMS.StorageConnector.ПроверитьСоединение() = Истина;
		ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "2. После теста cоединения с базой Mobile SMARTS" + Строка(ТестСоединения));
	Исключение
		ТестСоединения = Ложь;
	КонецПопытки;
	
	Если ТестСоединения Тогда
		Возврат СтруктураБазMS;
	Иначе
		Возврат неопределено;
	КонецЕсли;
КонецФункции

#КонецОбласти

#Область КомпонентаMobileSMARTS_EnironmentSMARTS

&НаКлиенте
Функция КомЯдро_ПолучитьМетаданныеДокументовMS(ТипБазы, ИмяПеременнойНастройки)
	
	Если НЕ КомЯдро_ПодключитьсяКСерверуSMARTS(Ложь,ТипБазы) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если ТипБазы = "Частная" Тогда
		СтруктураПодключенияMS = COMЧастнойБазыMS;
	ИначеЕсли ТипБазы = "Временная" Тогда
		СтруктураПодключенияMS = COMВременнойБазыMS;
	Иначе
		СтруктураПодключенияMS = COMБазыMS;
	КонецЕсли;
		
	Если НЕ СтруктураПодключенияMS.Свойство("Окружение") ИЛИ СтруктураПодключенияMS.Окружение = Неопределено Тогда
		СтруктураПодключенияMS.Вставить("Окружение", СтруктураПодключенияMS.TerminalConnector.ПолучитьСреду());
	КонецЕсли;
	
	Если СтруктураПодключенияMS.Окружение = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	МетаданныеДокументовMS = Новый Структура;
	
	СписокОбязательныхПолей = Новый Массив;
	СписокОбязательныхПолей.Добавить(Новый Структура("Значение,Ключ","Ид", "Идентификатор"));
	СписокОбязательныхПолей.Добавить(Новый Структура("Значение,Ключ","СозданНаТСД", "Создан на ТСД"));
	СписокОбязательныхПолей.Добавить(Новый Структура("Значение,Ключ","Имя", "Имя"));
	СписокОбязательныхПолей.Добавить(Новый Структура("Значение,Ключ","Назначение", "Назначение"));
	СписокОбязательныхПолей.Добавить(Новый Структура("Значение,Ключ","ДатаСоздания", "Дата создания"));
	СписокОбязательныхПолей.Добавить(Новый Структура("Значение,Ключ","ИмяТипаДокумента", "Имя типа документа"));
	СписокОбязательныхПолей.Добавить(Новый Структура("Значение,Ключ","ИдСклада", "Идентификатор склада"));
	СписокОбязательныхПолей.Добавить(Новый Структура("Значение,Ключ","Штрихкод", "Штрихкод"));
	СписокОбязательныхПолей.Добавить(Новый Структура("Значение,Ключ","Приоритет", "Приоритет"));
	СписокОбязательныхПолей.Добавить(Новый Структура("Значение,Ключ","Описание", "Описание"));
	СписокОбязательныхПолей.Добавить(Новый Структура("Значение,Ключ","ВыдаватьПоШтрихкоду", "Выдавать по штрихкоду"));
	СписокОбязательныхПолей.Добавить(Новый Структура("Значение,Ключ","ИсполняемыйНаСервере", "Исполняемый на сервере"));
	СписокОбязательныхПолей.Добавить(Новый Структура("Значение,Ключ","Завершен", "Завершен"));
	СписокОбязательныхПолей.Добавить(Новый Структура("Значение,Ключ","ВОбработке", "В обработке"));
	СписокОбязательныхПолей.Добавить(Новый Структура("Значение,Ключ","Изменен", "Изменен"));
	СписокОбязательныхПолей.Добавить(Новый Структура("Значение,Ключ","ИдПользователя", "Идентификатор пользователя"));
	СписокОбязательныхПолей.Добавить(Новый Структура("Значение,Ключ","DeviceId", "ИдУстройства"));
	СписокОбязательныхПолей.Добавить(Новый Структура("Значение,Ключ","UserName", "ИмяПользователя"));
	СписокОбязательныхПолей.Добавить(Новый Структура("Значение,Ключ","Underloaded", "Underloaded"));
	СписокОбязательныхПолей.Добавить(Новый Структура("Значение,Ключ","Overloaded", "Overloaded"));
	СписокОбязательныхПолей.Добавить(Новый Структура("Значение,Ключ","UnderloadedOrOverloaded"));
	
	СписокОбязательныхПолейТЧ = Новый Массив;
	СписокОбязательныхПолейТЧ.Добавить(Новый Структура("Значение,Ключ","ИдТовара", "ИдТовара"));
	СписокОбязательныхПолейТЧ.Добавить(Новый Структура("Значение,Ключ","ИдУпаковки", "ИдУпаковки"));
	СписокОбязательныхПолейТЧ.Добавить(Новый Структура("Значение,Ключ","КоличествоПлан", "Количество (План)"));
	СписокОбязательныхПолейТЧ.Добавить(Новый Структура("Значение,Ключ","КоличествоФакт", "Количество (Факт)"));
	СписокОбязательныхПолейТЧ.Добавить(Новый Структура("Значение,Ключ","ИдПервогоМеста", "Ид первого места"));
	СписокОбязательныхПолейТЧ.Добавить(Новый Структура("Значение,Ключ","ИдВторогоМеста", "Ид второго места"));
	СписокОбязательныхПолейТЧ.Добавить(Новый Структура("Значение,Ключ","ДатаРегистрации", "Дата регистрации"));
	СписокОбязательныхПолейТЧ.Добавить(Новый Структура("Значение,Ключ","СрокГодности", "Срок годности"));
	СписокОбязательныхПолейТЧ.Добавить(Новый Структура("Значение,Ключ","Переполнение", "Переполнение"));
	СписокОбязательныхПолейТЧ.Добавить(Новый Структура("Значение,Ключ","Недобор", "Недобор"));
	СписокОбязательныхПолейТЧ.Добавить(Новый Структура("Значение,Ключ","ЕстьНедоборИлиПереполнение", "Есть недобор или переполнение"));
	СписокОбязательныхПолейТЧ.Добавить(Новый Структура("Значение,Ключ","Остаток", "Остаток"));
	СписокОбязательныхПолейТЧ.Добавить(Новый Структура("Значение,Ключ","СвязаннаяСтрока", "Связанная строка"));
	СписокОбязательныхПолейТЧ.Добавить(Новый Структура("Значение,Ключ","SSCC", "SSCC"));
		
	РеквизитыСерии = Новый Массив;
	РеквизитыСерии.Добавить(Новый Структура("Значение,Ключ","ИдСерии", "Идентификатор Серии"));
	РеквизитыСерии.Добавить(Новый Структура("Значение,Ключ","ИмяСерии", "Имя серии"));
	РеквизитыСерии.Добавить(Новый Структура("Значение,Ключ","ИдТовара", "ИдТовара"));
	РеквизитыСерии.Добавить(Новый Структура("Значение,Ключ","КоличествоФакт", "Количество (Факт)"));
	РеквизитыСерии.Добавить(Новый Структура("Значение,Ключ","Характеристика", "Характеристика"));
	РеквизитыСерии.Добавить(Новый Структура("Значение,Ключ","АлкоКод", "АлкоКод"));
	РеквизитыСерии.Добавить(Новый Структура("Значение,Ключ","ФормаА", "ФормаА"));
	РеквизитыСерии.Добавить(Новый Структура("Значение,Ключ","КлючСерии", "КлючСерии"));
	РеквизитыСерии.Добавить(Новый Структура("Значение,Ключ","АлкоНаим", "АлкоНаим"));
	РеквизитыСерии.Добавить(Новый Структура("Значение,Ключ","ДатаРозлива", "ДатаРозлива"));
	РеквизитыСерии.Добавить(Новый Структура("Значение,Ключ","НаименованиеДляПоиска", "НаименованиеДляПоиска"));
	РеквизитыСерии.Добавить(Новый Структура("Значение,Ключ","ДатаСерии", "ДатаСерии"));
	РеквизитыСерии.Добавить(Новый Структура("Значение,Ключ","ИндексСорт", "ИндексСорт"));
	РеквизитыСерии.Добавить(Новый Структура("Значение,Ключ","Код", "Код"));
	РеквизитыСерии.Добавить(Новый Структура("Значение,Ключ","Штрихкод", "Штрихкод"));
	РеквизитыСерии.Добавить(Новый Структура("Значение,Ключ","Номер", "Номер"));
	РеквизитыСерии.Добавить(Новый Структура("Значение,Ключ","Ид", "Ид"));
	РеквизитыСерии.Добавить(Новый Структура("Значение,Ключ","Дополнительно", "Дополнительно"));
	
	РеквизитыСерийныеНомера = Новый Массив;
	РеквизитыСерийныеНомера.Добавить(Новый Структура("Значение,Ключ","СН", "Серийный номер"));
	РеквизитыСерийныеНомера.Добавить(Новый Структура("Значение,Ключ","ИдСерии", "Идентификатор Серии"));
	РеквизитыСерийныеНомера.Добавить(Новый Структура("Значение,Ключ","ИдТовара", "ИдТовара"));
	РеквизитыСерийныеНомера.Добавить(Новый Структура("Значение,Ключ","КоличествоФакт", "Количество (факт)"));
	РеквизитыСерийныеНомера.Добавить(Новый Структура("Значение,Ключ","Характеристика", "Характеристика"));
	
	Для Каждого ТипДокумента из СтруктураПодключенияMS.Окружение.DocumentTypes Цикл
		
		Если ТипДокумента.Virtual Тогда    //  Виртуальный
			Продолжить;
		КонецЕсли;
		
		СтруктураДокумента = Новый Структура();
		СтруктураДокумента.Вставить("Имя", ТипДокумента.Name);
		СтруктураДокумента.Вставить("Синоним", ТипДокумента.Alias);
		// реквизиты документа
		СписокРеквизитов = КомЯдро_ПолучитьСписокРеквизитовСущностиMS(ТипДокумента.Fields, СписокОбязательныхПолей);
		СтруктураДокумента.Вставить("Реквизиты", СписокРеквизитов);
		// реквизиты табличной части
		СписокРеквизитов = КомЯдро_ПолучитьСписокРеквизитовСущностиMS(ТипДокумента.Columns, СписокОбязательныхПолейТЧ);
		СтруктураДокумента.Вставить("РеквизитыТЧ", СписокРеквизитов);
		// серии и серийные номера
		СтруктураДокумента.Вставить("РеквизитыСерии", РеквизитыСерии);
		СтруктураДокумента.Вставить("РеквизитыСерийныеНомера", РеквизитыСерийныеНомера);
		
		// Дополнительные таблицы
		СписокДополнительныхТаблиц = Новый СписокЗначений();
			
		Для ИндексТаблицы = 0 По ТипДокумента.Tables.Count-1 Цикл 
			ДопТаблица = ТипДокумента.Tables.Item(ИндексТаблицы); 	
			СписокПолейДопТаблицы = КомЯдро_ПолучитьСписокРеквизитовСущностиMS(ДопТаблица.Fields);
			СписокДополнительныхТаблиц.Добавить(СписокПолейДопТаблицы, ДопТаблица.Name);
		КонецЦикла;
									
		СтруктураДокумента.Вставить("ДополнительныеТаблицы", СписокДополнительныхТаблиц);									
		
		ИмяТипаДокумента = ЛокЯдро_ПреобразованиеНаименованияДокументаБезПробелов(ТипДокумента.Name);		
		МетаданныеДокументовMS.Вставить(ИмяТипаДокумента, СтруктураДокумента);
		
	КонецЦикла; 
	
	Таблицы = Новый СписокЗначений;	
	
	Для ИндексТаблицы = 0 По СтруктураПодключенияMS.Окружение.Tables.Count-1 Цикл 
		ДопТаблица = COMБазыMS.Окружение.Tables.Item(ИндексТаблицы); 	
		СписокПолейДопТаблицы = КомЯдро_ПолучитьСписокРеквизитовСущностиMS(ДопТаблица.Fields);
		Таблицы.Добавить(СписокПолейДопТаблицы, ДопТаблица.Name);
	КонецЦикла;
		
	СписокПользователейMS = Новый СписокЗначений;
	
	СписокПользователейMS.Добавить("Выгружать всем;Выгружать всем"); 	
	СписокПользователейMS.Добавить("Спрашивать при выгрузке;Спрашивать при выгрузке");	
	
	Для Инд = 0 По СтруктураПодключенияMS.Окружение.Users.count - 1 Цикл
		ТекущийПользователь = COMБазыMS.Окружение.Users.Item(Инд);
		СписокПользователейMS.Добавить(ТекущийПользователь.Id + ";" + ТекущийПользователь.Name, ТекущийПользователь.GroupId + ";" + ТекущийПользователь.GroupName);
	КонецЦикла;	
	
	флЛегкоеОблако = Ложь;
	//
	//InternetGateOption = КомЯдро_ПолучитьИзКэшаНастройкуSMARTS("InternetGateOption");
	//Если InternetGateOption <> Ложь И ВРег(InternetGateOption) = "AVAILABLE" Тогда
	//	флЛегкоеОблако = Истина;
	//Иначе
	//	флЛегкоеОблако = Ложь;
	//КонецЕсли;
	//
	СписокУстройствMS = Новый СписокЗначений;
	СписокУстройствMS.Добавить("Выгружать всем;Выгружать всем"); 	
	СписокУстройствMS.Добавить("Спрашивать при выгрузке;Спрашивать при выгрузке");	
	
	УстройстваMS = СтруктураПодключенияMS.StorageConnector.ПолучитьДанныеОТерминалах();
	Для Счетчик = 0 По УстройстваMS.Количество - 1 Цикл
		//Pincode    = СокрЛП(УстройстваMS.Item(Счетчик).pincode);
		DeviceId   = СокрЛП(УстройстваMS.Item(Счетчик).DeviceId);
		DeviceName = СокрЛП(УстройстваMS.Item(Счетчик).DeviceName);
		//СписокУстройствMS.Добавить(Pincode + ";" + DeviceId + ";" + ?(НЕ ЗначениеЗаполнено(DeviceName), DeviceId, DeviceName + ", (" + DeviceId + ")") + ";");
		СписокУстройствMS.Добавить(DeviceId + ";" + ?(НЕ ЗначениеЗаполнено(DeviceName), DeviceId, DeviceName + ", (" + DeviceId + ")") + ";");
	КонецЦикла;	
	
	МассивВыгружаемыхПолейНоменклатурыMS = ЛокЯдро_ПолучитьМассивВыгружаемыхПолейНоменклатурыMS();
	
	СтрРезультат = Новый Структура;
	СтрРезультат.Вставить("ДокументыMS",					МетаданныеДокументовMS);
	СтрРезультат.Вставить("Tables",							Таблицы);
	СтрРезультат.Вставить("ПользователиMS",					СписокПользователейMS);
	СтрРезультат.Вставить("УстройстваMS",					СписокУстройствMS);
	СтрРезультат.Вставить("UniПолейНоменклатуры",			Неопределено);
	СтрРезультат.Вставить("ВыгружаемыеПоляНоменклатурыMS", 	МассивВыгружаемыхПолейНоменклатурыMS);
	
	ЛокЯдро_СохранитьДанныеВХранилище1С(ИмяПеременнойНастройки, СтрРезультат);
	
	ПользователиMSАдрес = ЛокЯдро_ДеревоПользователейВоВременноеХранилище(СписокПользователейMS);
	УстройстваMSАдрес 	= ЛокЯдро_ДеревоУстройствВоВременноеХранилище(СписокУстройствMS, флЛегкоеОблако);
	
	СтрРезультат.Вставить("ПользователиMS", ПользователиMSАдрес);
	СтрРезультат.Вставить("УстройстваMS",	УстройстваMSАдрес);
	
	Возврат СтрРезультат;
	
КонецФункции

&НаКлиенте
Функция КомЯдро_ПолучитьМетаданныеMSИзХранилища1С(ТипБазы, ИмяПеременнойНастройки)
	
	ИмяСобытия = "КомЯдро_ПолучитьМетаданныеMSИзХранилища1С";
	
	пСтруктураМетаданных = ЛокЯдро_ПолучитьДанныеИзХранилища1С(ИмяПеременнойНастройки);
	Если ТипЗнч(пСтруктураМетаданных) <> Тип("Структура") Тогда
		Возврат Неопределено;		
	КонецЕсли;
	
	//InternetGateOption = ГлЯдро_ПолучитьИзКэшаНастройкуSMARTS("InternetGateOption",, АдресаПеременных);
	//Если InternetGateOption <> Ложь И ВРег(InternetGateOption) = "AVAILABLE" Тогда
	//	флЛегкоеОблако = Истина;
	//Иначе
	//	флЛегкоеОблако = Ложь;
	//КонецЕсли;
	флЛегкоеОблако = Ложь;
	
	СписокПользователейMS = пСтруктураМетаданных.ПользователиMS;
	СписокУстройствMS 	  = пСтруктураМетаданных.УстройстваMS;
	
	ОбновитьСписокПользователей = ТипЗнч(СписокПользователейMS) <> Тип("СписокЗначений");
	ОбновитьСписокУстройств		= флЛегкоеОблако ИЛИ ТипЗнч(СписокУстройствMS) <> Тип("СписокЗначений");
	
	Если ОбновитьСписокПользователей ИЛИ ОбновитьСписокУстройств Тогда
		Если НЕ КомЯдро_ПодключитьсяКСерверуSMARTS(Ложь,ТипБазы) Тогда
			Возврат Неопределено;
		КонецЕсли;
		
		Если ТипБазы = "Частная" Тогда
			СтруктураПодключенияMS = COMЧастнойБазыMS;
		ИначеЕсли ТипБазы = "Временная" Тогда
			СтруктураПодключенияMS = COMВременнойБазыMS;
		Иначе
			СтруктураПодключенияMS = COMБазыMS;
		КонецЕсли;
			
		Если НЕ СтруктураПодключенияMS.Свойство("Окружение") ИЛИ СтруктураПодключенияMS.Окружение = Неопределено Тогда
			СтруктураПодключенияMS.Вставить("Окружение", СтруктураПодключенияMS.TerminalConnector.ПолучитьСреду());
		КонецЕсли;
		
		Если СтруктураПодключенияMS.Окружение = Неопределено Тогда
			Возврат Неопределено;
		КонецЕсли;
	КонецЕсли;		
		
	// ***

	Если ОбновитьСписокПользователей Тогда
		СписокПользователейMS = Новый СписокЗначений;
	    СписокПользователейMS.Добавить("Выгружать всем;Выгружать всем"); 	
		СписокПользователейMS.Добавить("Спрашивать при выгрузке;Спрашивать при выгрузке");	
		
		Для Инд = 0 По СтруктураПодключенияMS.Окружение.Users.count - 1 Цикл
			ТекущийПользователь = СтруктураПодключенияMS.Окружение.Users.Item(Инд);
			СписокПользователейMS.Добавить(Строка(ТекущийПользователь.Id) + ";" + Строка(ТекущийПользователь.Name), Строка(ТекущийПользователь.GroupId) + ";" + Строка(ТекущийПользователь.GroupName));
		КонецЦикла;
		
		пСтруктураМетаданных.Вставить("ПользователиMS", СписокПользователейMS);
	КонецЕсли;
	
	// ***
	
	Если ОбновитьСписокУстройств Тогда
		СписокУстройствMS = Новый СписокЗначений;
		Если Не флЛегкоеОблако Тогда
			СписокУстройствMS.Добавить("Выгружать всем;Выгружать всем"); 	
			СписокУстройствMS.Добавить("Спрашивать при выгрузке;Спрашивать при выгрузке");	
		КонецЕсли;
		
		УстройстваMS = СтруктураПодключенияMS.StorageConnector.ПолучитьДанныеОТерминалах();
		Для Счетчик = 0 По УстройстваMS.Количество - 1 Цикл
			Если флЛегкоеОблако Тогда
				Pincode = СокрЛП(УстройстваMS.Item(Счетчик).pincode);
			КонецЕсли;
			DeviceId   = СокрЛП(УстройстваMS.Item(Счетчик).DeviceId);
			DeviceName = СокрЛП(УстройстваMS.Item(Счетчик).DeviceName);
			Если флЛегкоеОблако Тогда
				СписокУстройствMS.Добавить(Pincode + ";" + DeviceId + ";" + ?(НЕ ЗначениеЗаполнено(DeviceName), DeviceId, DeviceName + ", (" + DeviceId + ")") + ";");
			Иначе
				СписокУстройствMS.Добавить(DeviceId + ";" + ?(НЕ ЗначениеЗаполнено(DeviceName), DeviceId, DeviceName + ", (" + DeviceId + ")") + ";");
			КонецЕсли;
		КонецЦикла;
			
		пСтруктураМетаданных.Вставить("УстройстваMS", СписокУстройствMS);
	КонецЕсли;	

	Если ОбновитьСписокПользователей ИЛИ ОбновитьСписокУстройств Тогда
		ЛокЯдро_СохранитьДанныеВХранилище1С(ИмяПеременнойНастройки, пСтруктураМетаданных);
	КонецЕсли;
	
	ПользователиMSАдрес = ЛокЯдро_ДеревоПользователейВоВременноеХранилище(СписокПользователейMS);
	УстройстваMSАдрес 	= ЛокЯдро_ДеревоУстройствВоВременноеХранилище(СписокУстройствMS, флЛегкоеОблако);
	
	пСтруктураМетаданных.Вставить("ПользователиMS", ПользователиMSАдрес);
	пСтруктураМетаданных.Вставить("УстройстваMS",	УстройстваMSАдрес);
	
	Возврат пСтруктураМетаданных;
	
КонецФункции

&НаКлиенте
Функция КомЯдро_ОбновитьМетаданныеТаблицMS(ТипБазы)
	
	Если НЕ КомЯдро_ПодключитьсяКСерверуSMARTS(Ложь, ТипБазы) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если ТипБазы = "Частная" Тогда
		СтруктураПодключенияMS = COMЧастнойБазыMS;
	ИначеЕсли ТипБазы = "Временная" Тогда
		СтруктураПодключенияMS = COMВременнойБазыMS;
	Иначе
		СтруктураПодключенияMS = COMБазыMS;
	КонецЕсли;
		
	Если НЕ СтруктураПодключенияMS.Свойство("Окружение") ИЛИ СтруктураПодключенияMS.Окружение = Неопределено Тогда
		СтруктураПодключенияMS.Вставить("Окружение", СтруктураПодключенияMS.TerminalConnector.ПолучитьСреду());
	КонецЕсли;
	
	Если СтруктураПодключенияMS.Окружение = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Таблицы = Новый СписокЗначений;	
	
	Для ИндексТаблицы = 0 По СтруктураПодключенияMS.Окружение.Tables.Count-1 Цикл 
		ДопТаблица = COMБазыMS.Окружение.Tables.Item(ИндексТаблицы); 	
		СписокПолейДопТаблицы = КомЯдро_ПолучитьСписокРеквизитовСущностиMS(ДопТаблица.Fields);
		Таблицы.Добавить(СписокПолейДопТаблицы, ДопТаблица.Name);
	КонецЦикла;
		
	Возврат Таблицы;
	
КонецФункции

&НаКлиенте
Функция КомЯдро_ПолучитьСписокСлужебныхДокументовMS(ТипБазы)
	
	Если НЕ КомЯдро_ПодключитьсяКСерверуSMARTS(Ложь,ТипБазы) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если ТипБазы = "Частная" Тогда
		СтруктураПодключенияMS = COMЧастнойБазыMS;
	ИначеЕсли ТипБазы = "Временная" Тогда
		СтруктураПодключенияMS = COMВременнойБазыMS;
	Иначе
		СтруктураПодключенияMS = COMБазыMS;
	КонецЕсли;
		
	Если НЕ СтруктураПодключенияMS.Свойство("Окружение") ИЛИ СтруктураПодключенияMS.Окружение = Неопределено Тогда
		СтруктураПодключенияMS.Вставить("Окружение", СтруктураПодключенияMS.TerminalConnector.ПолучитьСреду());
	КонецЕсли;
	
	Если СтруктураПодключенияMS.Окружение = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	СлужебныеДокументыMS = Новый СписокЗначений;
	
	Для Каждого ТипДокумента из СтруктураПодключенияMS.Окружение.DocumentTypes Цикл
		
		Если Не ТипДокумента.Virtual Тогда
			Продолжить;
		КонецЕсли;
		
		СлужебныеДокументыMS.Добавить(ТипДокумента.Name, ТипДокумента.ToString);
		
	КонецЦикла; 
	
	Возврат СлужебныеДокументыMS;
	
КонецФункции

&НаКлиенте
Функция КомЯдро_ОбновитьМетаданныеПользователейMS(ТипБазы)
	
	Если НЕ КомЯдро_ПодключитьсяКСерверуSMARTS(Ложь,ТипБазы) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если ТипБазы = "Частная" Тогда
		СтруктураПодключенияMS = COMЧастнойБазыMS;
	ИначеЕсли ТипБазы = "Временная" Тогда
		СтруктураПодключенияMS = COMВременнойБазыMS;
	Иначе
		СтруктураПодключенияMS = COMБазыMS;
	КонецЕсли;
		
	Если НЕ СтруктураПодключенияMS.Свойство("Окружение") ИЛИ СтруктураПодключенияMS.Окружение = Неопределено Тогда
		СтруктураПодключенияMS.Вставить("Окружение", СтруктураПодключенияMS.TerminalConnector.ПолучитьСреду());
	КонецЕсли;
	
	Если СтруктураПодключенияMS.Окружение = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	СписокПользователейMS = Новый СписокЗначений;
	
	СписокПользователейMS.Добавить("Выгружать всем;Выгружать всем"); 	
	СписокПользователейMS.Добавить("Спрашивать при выгрузке;Спрашивать при выгрузке");	
	
	Для Инд = 0 По СтруктураПодключенияMS.Окружение.Users.count - 1 Цикл
		ТекущийПользователь = COMБазыMS.Окружение.Users.Item(Инд);
		СписокПользователейMS.Добавить(ТекущийПользователь.Id + ";" + ТекущийПользователь.Name, ТекущийПользователь.GroupId + ";" + ТекущийПользователь.GroupName);
	КонецЦикла;	
	
	ПользователиMSАдрес = ЛокЯдро_ДеревоПользователейВоВременноеХранилище(СписокПользователейMS);
	
	// СтруктураМетаданных.Вставить("ПользователиMS", ?(ПользователиMSАдрес = Неопределено, "", ПользователиMSАдрес));
	
	ЛокЯдро_ОбновитьМетаданныеПользователейMSВХранилище1С(СписокПользователейMS, ПользователиMSАдрес);
	
КонецФункции

&НаКлиенте
Функция КомЯдро_ПолучитьСписокРеквизитовСущностиMS(СущностьMS, ДополнительныйСписок = Неопределено)
	
	СписокРеквизитов = Новый Массив;
	Для Индекс = 0 По СущностьMS.Количество - 1 Цикл
		ДанныеРеквизита = СущностьMS.Элемент(Индекс);
		Если НЕ ДанныеРеквизита.ReadOnly Тогда
			СписокРеквизитов.Добавить(Новый Структура("Значение,Ключ,Uni",ДанныеРеквизита.ИмяПоля, ДанныеРеквизита.ИмяПоля, ЛокЯдро_ПреобразоватьПервыйСимволВНижнийРегистр(ДанныеРеквизита.uni)));
		КонецЕсли;
	КонецЦикла;
	
	Если ДополнительныйСписок <> Неопределено Тогда
		Для Каждого ДополнительныйЭлемент Из ДополнительныйСписок Цикл
			СписокРеквизитов.Добавить(ДополнительныйЭлемент);
		КонецЦикла;
	КонецЕсли;
	
	Возврат СписокРеквизитов;
		
КонецФункции

&НаКлиенте
Процедура КомЯдро_ОбновитьШаблоныВесовогоТовараMS(ТаблицаШаблонов)
	
	Если НЕ КомЯдро_ПодключитьсяКСерверуSMARTS(Ложь,"Основная") Тогда
		Возврат;
	КонецЕсли;
	
	СтруктураПодключенияБазыMS = COMБазыMS;
	
	Если НЕ СтруктураПодключенияБазыMS.Свойство("Окружение") ИЛИ СтруктураПодключенияБазыMS.Окружение = Неопределено Тогда
		СтруктураПодключенияБазыMS.Вставить("Окружение", СтруктураПодключенияБазыMS.TerminalConnector.ПолучитьСреду());
	КонецЕсли;
	
	КоллекцияШаблонов = СтруктураПодключенияБазыMS.Окружение.ProductSchema.CommonTemplates;
	
	// Удаление существующих шаблонов
	КоличествоШаблоновКУдалению = КоллекцияШаблонов.Количество;
	Для Счетчик = -(КоличествоШаблоновКУдалению-1) По 0 Цикл
		ТекущийШаблон = КоллекцияШаблонов.Элемент(-Счетчик);
		Если Найти(ТекущийШаблон, "OneC:1") > 0 Тогда
			КоллекцияШаблонов.Удалить(ТекущийШаблон);
		КонецЕсли;
	КонецЦикла;
	
	// Добавление новых шаблонов
	Для Каждого Шаблон из ТаблицаШаблонов Цикл
		ЦелаяЧасть = Шаблон.ЦелаяЧасть - СтрДлина(Шаблон.Префикс);
		Если Шаблон.ПрефиксВключенВКод Тогда			
			КоллекцияШаблонов.Добавить("{Barcode:@" + Шаблон.Префикс + "[0-9]{" + Шаблон.ДлинаКодаВесовогоТовара + "}}{Quantity:" + ЦелаяЧасть + "." + Шаблон.ДробнаяЧасть + "}{OneC:1}");
		Иначе
			КоллекцияШаблонов.Добавить(Шаблон.Префикс + "{Barcode:" + Шаблон.ДлинаКодаВесовогоТовара + "}{Quantity:" + ЦелаяЧасть + "." + Шаблон.ДробнаяЧасть + "}{OneC:1}");
		КонецЕсли;
	КонецЦикла;
	
	СтруктураПодключенияБазыMS.TerminalConnector.УстановитьСреду(СтруктураПодключенияБазыMS.Окружение);
	
КонецПроцедуры 

&НаКлиенте
Процедура КомЯдро_УстановитьПоискПоНаименованиюИАртикулу(УстановитьПоискПоНаименованиюИАртикулу)
	COMБазыMS.TerminalConnector.УстановитьПоискПоНаименованиюИАртикулу(УстановитьПоискПоНаименованиюИАртикулу);		
КонецПроцедуры

&НаКлиенте
Функция КомЯдро_ПолучитьСписокСправочниковВКонфигурацииSMARTS()
	МассивСправочников = Новый Массив;
		
	Для инд = 0 По СтруктураМетаданных.Tables.Количество() - 1 Цикл
		МассивСправочников.Добавить(СтруктураМетаданных.Tables.Получить(инд).Представление);		
	КонецЦикла;
	
	Возврат МассивСправочников;	
КонецФункции

&НаКлиенте
Функция КомЯдро_ПолучитьПользователейSMARTS(ТипБазы)
	
	Если НЕ КомЯдро_ПодключитьсяКСерверуSMARTS(Ложь,ТипБазы) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если ТипБазы = "Частная" Тогда
		СтруктураПодключенияMS = COMЧастнойБазыMS;
	ИначеЕсли ТипБазы = "Временная" Тогда
		СтруктураПодключенияMS = COMВременнойБазыMS;
	Иначе
		СтруктураПодключенияMS = COMБазыMS;
	КонецЕсли;	
	
	Если НЕ СтруктураПодключенияMS.Свойство("Окружение") ИЛИ СтруктураПодключенияMS.Окружение = Неопределено Тогда
		СтруктураПодключенияMS.Вставить("Окружение", СтруктураПодключенияMS.TerminalConnector.ПолучитьСреду());
		
		Если ТипБазы = "Частная" Тогда
			пCOMЧастнойБазыMS = СтруктураПодключенияMS;
			КомЯдро_СохранитьЗначениеПеременной("COMЧастнойБазыMS",пCOMЧастнойБазыMS);
		ИначеЕсли ТипБазы = "Временная" Тогда
			пCOMВременнойБазыMS = СтруктураПодключенияMS;
			КомЯдро_СохранитьЗначениеПеременной("COMВременнойБазыMS",пCOMВременнойБазыMS);
		Иначе
			пCOMБазыMS = СтруктураПодключенияMS;
			КомЯдро_СохранитьЗначениеПеременной("COMБазыMS",пCOMБазыMS);
		КонецЕсли; 
	КонецЕсли;
	
	Если СтруктураПодключенияMS.Окружение = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	МассивПользователейMS = Новый Массив;      
	
	Для Инд = 0 По СтруктураПодключенияMS.Окружение.Users.count - 1 Цикл
		
		ТекущийПользователь = СтруктураПодключенияMS.Окружение.Users.Item(Инд);
		
		стрПользователиMS = Новый Структура("Ид,Имя,ИдГруппы,ИмяГруппы,Пароль,Описание,Штрихкод,ИдСкладов");
		стрПользователиMS.Ид 		= ТекущийПользователь.Id;
		стрПользователиMS.Имя 		= ТекущийПользователь.Name;
		стрПользователиMS.ИдГруппы 	= ТекущийПользователь.GroupId;
		стрПользователиMS.ИмяГруппы = ТекущийПользователь.GroupName;
		стрПользователиMS.Описание 	= ТекущийПользователь.Description;			
		стрПользователиMS.Пароль 	= ТекущийПользователь.Password;			
		стрПользователиMS.Штрихкод 	= ТекущийПользователь.Barcode;    			
		
		СписокСкладов = Новый СписокЗначений;		
		Warehouses = ТекущийПользователь.WarehouseIds;                     
		Если Warehouses <> Неопределено Тогда                           
			Для ИндСклада = 0 По (Warehouses.count - 1) Цикл			
				СписокСкладов.Добавить(Warehouses.Item(ИндСклада));
			КонецЦикла;
		КонецЕсли;
		
		стрПользователиMS.ИдСкладов = СписокСкладов; 		
		
		МассивПользователейMS.Добавить(стрПользователиMS);
		
	КонецЦикла;	
	
	Возврат ПоместитьВоВременноеХранилище(МассивПользователейMS, Новый УникальныйИдентификатор());
	
КонецФункции

&НаКлиенте
Функция КомЯдро_ПолучитьСкладыSMARTS(ТипБазы)
	
	Если НЕ КомЯдро_ПодключитьсяКСерверуSMARTS(Ложь,ТипБазы) Тогда
		Возврат Неопределено;
	КонецЕсли;
		
	Если ТипБазы = "Частная" Тогда
		СтруктураПодключенияMS = COMЧастнойБазыMS;
	ИначеЕсли ТипБазы = "Временная" Тогда
		СтруктураПодключенияMS = COMВременнойБазыMS;
	Иначе
		СтруктураПодключенияMS = COMБазыMS;
	КонецЕсли;	
	
	Если НЕ СтруктураПодключенияMS.Свойство("Окружение") ИЛИ СтруктураПодключенияMS.Окружение = Неопределено Тогда
		СтруктураПодключенияMS.Вставить("Окружение", СтруктураПодключенияMS.TerminalConnector.ПолучитьСреду());
		
		Если ТипБазы = "Частная" Тогда
			пCOMЧастнойБазыMS = СтруктураПодключенияMS;
			КомЯдро_СохранитьЗначениеПеременной("COMЧастнойБазыMS",пCOMЧастнойБазыMS);
		ИначеЕсли ТипБазы = "Временная" Тогда
			пCOMВременнойБазыMS = СтруктураПодключенияMS;
			КомЯдро_СохранитьЗначениеПеременной("COMВременнойБазыMS",пCOMВременнойБазыMS);
		Иначе
			пCOMБазыMS = СтруктураПодключенияMS;
			КомЯдро_СохранитьЗначениеПеременной("COMБазыMS",пCOMБазыMS);
		КонецЕсли; 
	КонецЕсли;
	
	Если СтруктураПодключенияMS.Окружение = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	МассивСкладовMS = Новый Массив;
	
	Для Инд = 0 По СтруктураПодключенияMS.Окружение.Warehouses.count - 1 Цикл
		
		ТекущийСклад = СтруктураПодключенияMS.Окружение.Warehouses.Item(Инд);
		
		стрСкладыMS = Новый Структура("Ид,Имя");
		стрСкладыMS.Ид	= ТекущийСклад.Id;
		стрСкладыMS.Имя = ТекущийСклад.Name;		
		
		МассивСкладовMS.Добавить(стрСкладыMS);
		
	КонецЦикла;	
	
	Возврат ПоместитьВоВременноеХранилище(МассивСкладовMS, Новый УникальныйИдентификатор());
	
КонецФункции

&НаКлиенте
Функция КомЯдро_ПолучитьГруппыПользователейSMARTS(ТипБазы)
	
	Если НЕ КомЯдро_ПодключитьсяКСерверуSMARTS(Ложь,ТипБазы) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если ТипБазы = "Частная" Тогда
		СтруктураПодключенияMS = COMЧастнойБазыMS;
	ИначеЕсли ТипБазы = "Временная" Тогда
		СтруктураПодключенияMS = COMВременнойБазыMS;
	Иначе
		СтруктураПодключенияMS = COMБазыMS;
	КонецЕсли;	
	
	Если НЕ СтруктураПодключенияMS.Свойство("Окружение") ИЛИ СтруктураПодключенияMS.Окружение = Неопределено Тогда
		СтруктураПодключенияMS.Вставить("Окружение", СтруктураПодключенияMS.TerminalConnector.ПолучитьСреду());
		
		Если ТипБазы = "Частная" Тогда
			пCOMЧастнойБазыMS = СтруктураПодключенияMS;
			КомЯдро_СохранитьЗначениеПеременной("COMЧастнойБазыMS",пCOMЧастнойБазыMS);
		ИначеЕсли ТипБазы = "Временная" Тогда
			пCOMВременнойБазыMS = СтруктураПодключенияMS;
			КомЯдро_СохранитьЗначениеПеременной("COMВременнойБазыMS",пCOMВременнойБазыMS);
		Иначе
			пCOMБазыMS = СтруктураПодключенияMS;
			КомЯдро_СохранитьЗначениеПеременной("COMБазыMS",пCOMБазыMS);
		КонецЕсли; 
	КонецЕсли;
	
	Если СтруктураПодключенияMS.Окружение = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	МассивГруппПользователейMS = Новый Массив;
		
	Для Инд = 0 По СтруктураПодключенияMS.Окружение.Groups.count - 1 Цикл
		
		ТекущаяГруппа = СтруктураПодключенияMS.Окружение.Groups.Item(Инд);
		
		стрГруппыПользователейMS = Новый Структура("Ид,Имя,Роль,ТипыДокументов");
		стрГруппыПользователейMS.Ид 	= ТекущаяГруппа.Id;
		стрГруппыПользователейMS.Имя 	= ТекущаяГруппа.Name;
		Если ТипЗнч(ТекущаяГруппа.Role) = Тип("Число") Тогда
			Если ТекущаяГруппа.Role = 3 Тогда 
				РольСтрока = "User";				
			ИначеЕсли ТекущаяГруппа.Role = 2 Тогда 
				РольСтрока = "Administrator";
			Иначе
				РольСтрока = "MobileDeviceUser";
			КонецЕсли;
		Иначе     
			РольСтрока = ТекущаяГруппа.Role;
		КонецЕсли;
		стрГруппыПользователейMS.Роль 	= РольСтрока;
		
		ТипыДокументов = Новый Массив; 
		documentTypeNames = ТекущаяГруппа.DocumentTypeNames;
		Если documentTypeNames <> Неопределено Тогда
			Для ИндТипа = 0 По (documentTypeNames.count - 1) Цикл			
				ТипыДокументов.Добавить(documentTypeNames.Item(ИндТипа));
			КонецЦикла;					
		КонецЕсли;	
		стрГруппыПользователейMS.ТипыДокументов = ТипыДокументов;
		
		МассивГруппПользователейMS.Добавить(стрГруппыПользователейMS);	
		
	КонецЦикла;	
	
	Возврат ПоместитьВоВременноеХранилище(МассивГруппПользователейMS, Новый УникальныйИдентификатор());
	
КонецФункции

&НаКлиенте
Функция КомЯдро_ЗагрузитьПользователейВSMARTS(ПараметрыПользователя, ТипБазы)
	
	Если НЕ КомЯдро_ПодключитьсяКСерверуSMARTS(Ложь,ТипБазы) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если ТипБазы = "Частная" Тогда
		СтруктураПодключенияMS = COMЧастнойБазыMS;
	ИначеЕсли ТипБазы = "Временная" Тогда
		СтруктураПодключенияMS = COMВременнойБазыMS;
	Иначе
		СтруктураПодключенияMS = COMБазыMS;
	КонецЕсли;	
		
	Ответ = Новый Структура("Результат,ТекстОшибки", Истина, "");
		
	Попытка  	
		Users 		= СтруктураПодключенияMS.Окружение.Users;
		// Находим объект UserGroup по идентификатору
		CurrentUser = Users.FindById(ПараметрыПользователя["id"]);	
		
		// Если такого элемента нет, создаем новый
		НовыйЭлемент = Ложь;
		Если CurrentUser = Неопределено Или CurrentUser = Null Тогда			
			CurrentUser 	= Новый COMОбъект("Cleverence.Warehouse.User");
			CurrentUser.Id 	= ПараметрыПользователя["id"];          
			НовыйЭлемент = Истина;
		КонецЕсли;
		
		// Заполняем переданные поля
		CurrentUser.Name 	= Строка(ПараметрыПользователя["name"]);
		Если Не ПустаяСтрока(ПараметрыПользователя["password"]) Тогда
			CurrentUser.Password = ПараметрыПользователя["password"];
		ИначеЕсли НовыйЭлемент Тогда
			CurrentUser.Password = " ";
		КонецЕсли;
		Если Не ПустаяСтрока(ПараметрыПользователя["barcode"]) Тогда		
			CurrentUser.Barcode = ПараметрыПользователя["barcode"];
		ИначеЕсли НовыйЭлемент Тогда
			CurrentUser.Barcode = " ";
		КонецЕсли;
		
		CurrentUser.GroupName 	= ПараметрыПользователя["groupName"];
		CurrentUser.GroupId		= ПараметрыПользователя["groupId"];
	
		Warehouses = СтруктураПодключенияMS.Окружение.Warehouses;
		
		Для Каждого Склад Из ПараметрыПользователя["allWarehouses"] Цикл
			ИдСклада 		= Склад.Значение;
			Использование 	= Склад.Пометка;
			
			Warehouse = Warehouses.FindById(ИдСклада);                    
			Если (Warehouses <> Неопределено И Warehouses <> Null) Тогда 
				Если (CurrentUser.Warehouses.FindById(ИдСклада) = Неопределено Или CurrentUser.Warehouses.FindById(ИдСклада) = Null) 
					И Использование Тогда
					CurrentUser.Warehouses.Add(Warehouse);
				ИначеЕсли (CurrentUser.Warehouses.FindById(ИдСклада) <> Неопределено И CurrentUser.Warehouses.FindById(ИдСклада) <> Null) 
					И Не Использование Тогда       
					CurrentUser.Warehouses.Remove(Warehouse);
				КонецЕсли;
			КонецЕсли;						
		КонецЦикла;
		
		// Зашифровываем штрихкод и пароль
		CurrentUser.Encrypt();
		
		// Проверяем штрихкод пользователя на уникальность
		Если НовыйЭлемент Тогда 
			Если Users.FindByBarcode(CurrentUser.Barcode) = Неопределено Или  Users.FindByBarcode(CurrentUser.Barcode) = Null Тогда
				// Если элемент новый, добавляем его в UserCollection
				Users.Add(CurrentUser);								
			Иначе 
				Сообщить("Пользователь """ + Строка(CurrentUser.Name) + """ не выгружен в базу SMARTS. Пользователь с таким паролем уже существует.");
		    	Ответ.Результат =  Ложь;						
			КонецЕсли;	
		КонецЕсли;
		
		// Выгружаем обновленную UserCollection
		Если Ответ.Результат Тогда
			СтруктураПодключенияMS.StorageConnector.SetUsers(Users); 	
			
			Если НовыйЭлемент Тогда 
				Сообщить("Создан новый пользователь """ + Строка(CurrentUser.Name) + """.");			
			КонецЕсли;
		КонецЕсли;		   
		
	Исключение
		
		Ответ.Результат 	=  Ложь;
		Ответ.ТекстОшибки 	= ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		
	КонецПопытки;    
	
	Возврат Ответ;
	
КонецФункции

&НаКлиенте
Функция КомЯдро_ЗагрузитьГруппыПользователейВSMARTS(ПараметрыГруппы, ТипБазы)
	
	Если НЕ КомЯдро_ПодключитьсяКСерверуSMARTS(Ложь, ТипБазы) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если ТипБазы = "Частная" Тогда
		СтруктураПодключенияMS = COMЧастнойБазыMS;
	ИначеЕсли ТипБазы = "Временная" Тогда
		СтруктураПодключенияMS = COMВременнойБазыMS;
	Иначе
		СтруктураПодключенияMS = COMБазыMS;
	КонецЕсли;	
		
	Ответ = Новый Структура("Результат,ТекстОшибки", Истина, "");
		
	Попытка  			
		Groups 		= СтруктураПодключенияMS.Окружение.Groups;
		// Находим объект UserGroup по идентификатору
		CurrentGroup = Groups.FindById(ПараметрыГруппы["id"]);	
		
		// Если такого элемента нет, создаем новый
		НовыйЭлемент = Ложь;
		Если CurrentGroup = Неопределено Или CurrentGroup = Null Тогда			
			CurrentGroup 	= Новый COMОбъект("Cleverence.Warehouse.UserGroup");
			CurrentGroup.Id = ПараметрыГруппы["id"];          
			НовыйЭлемент = Истина;
		КонецЕсли;
		
		// Заполняем переданные поля
		CurrentGroup.Name 					= ПараметрыГруппы["name"];
		CurrentGroup.BatchMode 				= ПараметрыГруппы["batchMode"];
		CurrentGroup.ServerSideInventory 	= ПараметрыГруппы["serverSideInventory"];
		
		// Проставляем числовой эквивалент роли
		РольСтрока = ПараметрыГруппы["role"];		
		Если РольСтрока = "User" Тогда 
			ТекРоль = 3;							
		ИначеЕсли РольСтрока = "Administrator" Тогда
			ТекРоль = 2;
		Иначе
			ТекРоль = 0;
		КонецЕсли;                                   	
		CurrentGroup.Role 					= ТекРоль;
		
		// Заполняем таблицу доступных типов документов
		DocumentTypes = СтруктураПодключенияMS.Окружение.DocumentTypes;
		
		Для Каждого ТипДокумента Из ПараметрыГруппы["AlldocumentTypeNames"] Цикл
			ИмяТипа 		= ТипДокумента.Значение;
			Использование 	= ТипДокумента.Пометка;
			
			DocumentType = DocumentTypes.FindByName(ИмяТипа);                    
			Если (DocumentType <> Неопределено И DocumentType <> Null) Тогда 
				Если (CurrentGroup.DocumentTypes.FindByName(ИмяТипа) = Неопределено Или CurrentGroup.DocumentTypes.FindByName(ИмяТипа) = Null) 
					И Использование Тогда
					CurrentGroup.DocumentTypes.Add(DocumentType);
				ИначеЕсли (CurrentGroup.DocumentTypes.FindByName(ИмяТипа) <> Неопределено И CurrentGroup.DocumentTypes.FindByName(ИмяТипа) <> Null) 
					И Не Использование Тогда       
					CurrentGroup.DocumentTypes.Remove(DocumentType);
				КонецЕсли;
			КонецЕсли;						
		КонецЦикла;
		
		// Если элемент новый, добавляем его в UserGroupCollection, и выгружаем обновленную коллекцию
		Если НовыйЭлемент Тогда 
			Groups.Add(CurrentGroup);
		КонецЕсли;		  		
		СтруктураПодключенияMS.StorageConnector.SetUserGroups(Groups); 	
		
		Если НовыйЭлемент Тогда 
			Сообщить("Создана новая группа """ + Строка(CurrentGroup.Name) + """.");
		КонецЕсли;
		
	Исключение
		
		Ответ.Результат 	=  Ложь;
		Ответ.ТекстОшибки 	= ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		
	КонецПопытки;    
	
	Возврат Ответ;
	
КонецФункции

&НаКлиенте
Функция КомЯдро_УдалитьПользователейВSMARTS(ПараметрыПользователя, ТипБазы)
	
	Если НЕ КомЯдро_ПодключитьсяКСерверуSMARTS(Ложь,ТипБазы) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если ТипБазы = "Частная" Тогда
		СтруктураПодключенияMS = COMЧастнойБазыMS;
	ИначеЕсли ТипБазы = "Временная" Тогда
		СтруктураПодключенияMS = COMВременнойБазыMS;
	Иначе
		СтруктураПодключенияMS = COMБазыMS;
	КонецЕсли;	
		
	Ответ = Новый Структура("Результат,ТекстОшибки", Истина, "");
		
	Попытка  	
		Users 		= СтруктураПодключенияMS.Окружение.Users;
		// Находим объект User по идентификатору
		CurrentUser = Users.FindById(ПараметрыПользователя["Ид"]);	
		
		// Если такой объект найден удаляем его из UserCollection, и выгружаем обновленную коллекцию
		Если CurrentUser <> Неопределено И CurrentUser <> Null Тогда			
			Users.Remove(CurrentUser);			
			СтруктураПодключенияMS.StorageConnector.SetUsers(Users); 	
			Сообщить("Пользователь """ + Строка(CurrentUser.Name) + """ удален из базы SMARTS.");				
		КонецЕсли;		
		
	Исключение
		
		Ответ.Результат 	=  Ложь;
		Ответ.ТекстОшибки 	= ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		
	КонецПопытки;    
	
	Возврат Ответ;
	
КонецФункции

&НаКлиенте
Функция КомЯдро_УдалитьГруппыПользователейВSMARTS(ПараметрыГруппы, ТипБазы)
			
	Если НЕ КомЯдро_ПодключитьсяКСерверуSMARTS(Ложь,ТипБазы) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если ТипБазы = "Частная" Тогда
		СтруктураПодключенияMS = COMЧастнойБазыMS;
	ИначеЕсли ТипБазы = "Временная" Тогда
		СтруктураПодключенияMS = COMВременнойБазыMS;
	Иначе
		СтруктураПодключенияMS = COMБазыMS;
	КонецЕсли;	
		
	Ответ = Новый Структура("Результат,ТекстОшибки", Истина, "");
		
	Попытка  	
		
		Groups 		= СтруктураПодключенияMS.Окружение.Groups;
		// Находим объект UserGroup по идентификатору
		CurrentGroup = Groups.FindById(ПараметрыГруппы["Ид"]);	
		
		// Если такой объект найден удаляем его из UserGroupCollection, и выгружаем обновленную коллекцию
		Если CurrentGroup <> Неопределено И CurrentGroup <> Null Тогда			
			Groups.Remove(CurrentGroup);			
			СтруктураПодключенияMS.StorageConnector.SetUserGroups(Groups); 	
			Сообщить("Группа """ + Строка(CurrentGroup.Name) + """ удалена из базы Mobile SMARTS.");
		КонецЕсли;		
		
	Исключение
		
		Ответ.Результат 	=  Ложь;
		Ответ.ТекстОшибки 	= ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		
	КонецПопытки;    
	
	Возврат Ответ;
	
КонецФункции

#КонецОбласти

#Область КомпонентаMobileSMARTS_ДокументыSMARTS

&НаКлиенте
Функция КомЯдро_СформироватьНовыйДокументSMARTS(ДанныеДокумента, НазначенныйПользователь = "", СпособНазначения = "")

	#Область НесовместимыйКодFresh
	ДокументSMARTS = Новый COMОбъект("Cleverence.Warehouse.Document");
	
	Для Каждого РеквизитДокумента Из ДанныеДокумента.ШапкаДокумента Цикл
		Попытка
			ДокументSMARTS.SetField(РеквизитДокумента.Ключ, РеквизитДокумента.Значение);
		Исключение
		КонецПопытки;
	КонецЦикла;
	
	Если НазначенныйПользователь <> "" Тогда 
		Если СпособНазначения = "Устройству" Тогда
			ДокументSMARTS.SetField("Назначение", НазначенныйПользователь);
		Иначе
			ДокументSMARTS.SetField("Назначение", НазначенныйПользователь);
			ДокументSMARTS.SetField("Ид",ДокументSMARTS.Id+"#"+СтрЗаменить(НазначенныйПользователь,"|",""))
		КонецЕсли;
	КонецЕсли;

	Если ДанныеДокумента.Свойство("ТабличныеЧасти") И ДанныеДокумента.ТабличныеЧасти.Количество() > 0 Тогда
		Для Каждого ТабличнаяЧасть Из ДанныеДокумента.ТабличныеЧасти Цикл
			Если КомЯдро_ЭтоОсновнаяТаблица(ТабличнаяЧасть.Ключ) Тогда
				Для каждого СтрокаТЧ Из ТабличнаяЧасть.Значение Цикл												
					СтрокаДокументаSMARTS = Новый COMОбъект("Cleverence.Warehouse.DocumentItem");
					Для Каждого РеквизитСтроки Из СтрокаТЧ Цикл
						Попытка
							СтрокаДокументаSMARTS.SetField(РеквизитСтроки.Ключ, РеквизитСтроки.Значение);
						Исключение
						КонецПопытки;
					КонецЦикла;
					
					ДокументSMARTS[ТабличнаяЧасть.Ключ].Добавить(СтрокаДокументаSMARTS);					
				КонецЦикла; 
			Иначе
				ДопТаблицаSMARTS = Новый COMОбъект("Cleverence.Warehouse.Table");		
				ДопТаблицаSMARTS.Name = ТабличнаяЧасть.Ключ;
				
				Для каждого СтрокаТЧ Из ТабличнаяЧасть.Значение Цикл
					Row = Новый COMОбъект("Cleverence.Warehouse.Row");
					Для Каждого РеквизитСтроки Из СтрокаТЧ Цикл
						Попытка
							Row.SetField(РеквизитСтроки.Ключ, РеквизитСтроки.Значение);
						Исключение
						КонецПопытки;
					КонецЦикла;
					ДопТаблицаSMARTS.Rows.Add(Row);
				КонецЦикла;
				ДокументSMARTS.Tables.Add(ДопТаблицаSMARTS);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Возврат ДокументSMARTS;
	#КонецОбласти //НесовместимыйКодFresh
	
КонецФункции

&НаКлиенте
Функция КомЯдро_ЭтоОсновнаяТаблица(ИмяТаблицы) 
	
	ОсновныеТЧ = Новый Массив;
	ОсновныеТЧ.Добавить("СтрокиПлан");
	ОсновныеТЧ.Добавить("СтрокиФакт");
	ОсновныеТЧ.Добавить("СовмещенныеСтроки");
	ОсновныеТЧ.Добавить("СерииПлан");
	ОсновныеТЧ.Добавить("СерииФакт");
	ОсновныеТЧ.Добавить("СерийныеНомераПлан");
	ОсновныеТЧ.Добавить("СерийныеНомераФакт");
	
	Если ОсновныеТЧ.Найти(ИмяТаблицы) <> Неопределено Тогда
		Возврат Истина;
	Иначе
		Возврат Ложь;
	КонецЕсли;
	
КонецФункции

&НаКлиенте
Процедура КомЯдро_ЗаписатьДокументВБазуSMARTS(ДокументSMARTS, ТипБазы)
	
	Если НЕ КомЯдро_ПодключитьсяКСерверуSMARTS(Ложь,ТипБазы) Тогда
		Возврат;
	КонецЕсли;
	
	Если ТипБазы = "Частная" Тогда
		СтруктураБазMS = COMЧастнойБазыMS;
	ИначеЕсли ТипБазы = "Временная" Тогда
		СтруктураБазMS = COMВременнойБазыMS;
	Иначе
		СтруктураБазMS = COMБазыMS;
	КонецЕсли;
	
	СтруктураБазMS.StorageConnector.ВыгрузитьДокумент(ДокументSMARTS);
	
КонецПроцедуры

&НаКлиенте
Функция КомЯдро_ПолучитьСписокДокументовНаСервереSMARTS(ТаблицаДокументов, ТипБазы, РазмерВыборки = 0, ОтборПоПериоду = Неопределено, ОтборПоУзлу = Неопределено)
	
	Если НЕ КомЯдро_ПодключитьсяКСерверуSMARTS(Ложь,ТипБазы) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	СтруктураБазMS = КомЯдро_ПолучитьСтруктуруПодключенияMS(ТипБазы);
	Если СтруктураБазMS = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;

	// заполняем таблицу
	СписокДокументовSMARTS = СтруктураБазMS.TerminalConnector.ПолучитьДокументы(Неопределено);
	
	КоличествоДокументов = СписокДокументовSMARTS.Количество;
	
	Если НЕ СписокДокументовSMARTS = Неопределено Тогда
		Для ИндексДокумента = 0 По КоличествоДокументов - 1 Цикл			
			ТекущаяСтрокаТаблицы = Новый Структура("ДатаСоздания,
			|Имя,
			|Ид,
			|ИмяТипаДокумента,
			|СтрокиПланКоличество,
			|СтрокиФактКоличество,
			|ИмяПользователя,
			|ВОбработке,
			|Завершен,
			|НастройкаБизнесПроцесса,
			|СозданНаТСД,
			|ЕстьПереполнениеИлиНедобор,
			|ЕстьПереполнение,
			|ЕстьНедобор,
			|ДатаЗавершения,
			|КонтрольКоличества,
			|ИдИсходныхДокументов,
			|ИмяБП,
			|ИдУзла");
			
			ДокументSMARTS = СписокДокументовSMARTS.Элемент(ИндексДокумента);
			
			ИмяТипаДокумента = ЛокЯдро_ПреобразованиеНаименованияДокументаБезПробелов(ДокументSMARTS.documentTypeName);
			
			// Новые типы документов, добавленные, например, вручную, и еще не инициализированные в текущих
			// настройках ядра, просто пропускаем
			Если Не СтруктураМетаданных.ДокументыMS.Свойство(ИмяТипаДокумента) Тогда
				Продолжить;
			КонецЕсли;
		
			ЗаполнитьЗначенияСвойств(ТекущаяСтрокаТаблицы, ДокументSMARTS);
			
			// Отбор по периоду
			Если ОтборПоПериоду <> Неопределено Тогда
				Если ТипЗнч(ТекущаяСтрокаТаблицы.ДатаСоздания) = Тип("Дата") Тогда
					
					ДатаСоздания = ТекущаяСтрокаТаблицы.ДатаСоздания;
					
					Если ДатаСоздания < ОтборПоПериоду.ДатаНачала Тогда
						Продолжить;
					КонецЕсли;
										
					Если ЗначениеЗаполнено(ОтборПоПериоду.ДатаОкончания) Тогда
						Если ДатаСоздания > ОтборПоПериоду.ДатаОкончания Тогда
							Продолжить;
						КонецЕсли;
					КонецЕсли;
					
				КонецЕсли;
			КонецЕсли;
			
			ТекущаяСтрокаТаблицы.ИдУзла = ДокументSMARTS.ПолучитьПоле("ИдУзла");
			
			// Отбор по узлу
			Если ОтборПоУзлу <> Неопределено Тогда
				Если ЗначениеЗаполнено(ТекущаяСтрокаТаблицы.ИдУзла)
					И ТекущаяСтрокаТаблицы.ИдУзла <> ОтборПоУзлу.ID_Узла Тогда
					Продолжить;
				КонецЕсли;
			КонецЕсли;
					
			ТекущаяСтрокаТаблицы.СтрокиПланКоличество = ДокументSMARTS.СтрокиПлан.Количество;
			ТекущаяСтрокаТаблицы.СтрокиФактКоличество = ДокументSMARTS.СтрокиФакт.Количество;
			ТекущаяСтрокаТаблицы.ИдИсходныхДокументов = ДокументSMARTS.ПолучитьПоле("ИдИсходныхДокументов");
			// убрать, когда все поля из платформы можно будет получать по ключу - []
			ТекущаяСтрокаТаблицы.НастройкаБизнесПроцесса = ДокументSMARTS.ПолучитьПоле("НастройкаБизнесПроцесса");
			ТекущаяСтрокаТаблицы.КонтрольКоличества 	 = ДокументSMARTS.ПолучитьПоле("КонтрольКолва");
			ТекущаяСтрокаТаблицы.ИмяБП 					 = ДокументSMARTS.ПолучитьПоле("ИмяБП");
			ТекущаяСтрокаТаблицы.ИмяТипаДокумента 		 = ИмяТипаДокумента;
			
			// Дополняем существующую таблицу реквизитами шапки документа
			СтруктураРеквизитов = КомЯдро_ПолучитьДанныеДокументаНаСервереSMARTS(
				ДокументSMARTS.id, 
				СтруктураМетаданных.ДокументыMS[ИмяТипаДокумента], 
				?(ЕстьЧастнаяБаза,"Частная","Основная"), 
				Неопределено,
				Истина);
			СтруктураШапки = СтруктураРеквизитов.ШапкаДокумента;
			
			Для Каждого ЭлементСтруктуры Из СтруктураШапки Цикл
				Если ТекущаяСтрокаТаблицы.Свойство(ЭлементСтруктуры.Ключ) Тогда
					Продолжить;
				КонецЕсли;                                                                   			
				ТекущаяСтрокаТаблицы.Вставить(ЭлементСтруктуры.Ключ, ЭлементСтруктуры.Значение);			
			КонецЦикла;		

			ТаблицаДокументов.Добавить(ТекущаяСтрокаТаблицы);
			
			Если ЗначениеЗаполнено(РазмерВыборки) Тогда
				Если ТаблицаДокументов.Количество() > РазмерВыборки Тогда
					Прервать;
				КонецЕсли;
			КонецЕсли;
			
		КонецЦикла;
	КонецЕсли;

	Возврат ТаблицаДокументов;
	
КонецФункции

&НаКлиенте
Функция КомЯдро_ПолучитьДанныеДокументаНаСервереSMARTS(ID_Документа, СтруктураДокументаMS, ТипБазы, ФильтрТЧПоИдДокумента = Неопределено, ТолькоШапка = Ложь)
		
	Если НЕ КомЯдро_ПодключитьсяКСерверуSMARTS(Ложь,ТипБазы) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если ТипБазы = "Частная" Тогда
		СтруктураПодключенияMS = COMЧастнойБазыMS;
	ИначеЕсли ТипБазы = "Временная" Тогда
		СтруктураПодключенияMS = COMВременнойБазыMS;
	Иначе
		СтруктураПодключенияMS = COMБазыMS;
	КонецЕсли;
	
	ДокументSMARTS = СтруктураПодключенияMS.StorageConnector.ПолучитьДокумент(ID_Документа);
	
	ДанныеДокументаMS = Новый Структура;
	
	// Шапка
	РеквизитыШапки = Новый Структура;
	Для Каждого РеквизитДокумента Из СтруктураДокументаMS.Реквизиты Цикл
		Попытка
			РеквизитыШапки.Вставить(РеквизитДокумента.Значение, ДокументSMARTS.ПолучитьПоле(РеквизитДокумента.Значение));
		Исключение
			Сообщить("Реквизит с именем [" + РеквизитДокумента.Значение + "] отсутствует в шапке документа");
		КонецПопытки; 		
	КонецЦикла;
	
	Попытка
		СтатусДокументаMS = ДокументSMARTS.Статусы.Элемент(0);
		РеквизитыШапки.Вставить("ВремяНачалаОбработки",	СтатусДокументаMS.ВремяНачалаОбработки);
		РеквизитыШапки.Вставить("ВремяИзменения",		СтатусДокументаMS.ВремяИзменения);	
		РеквизитыШапки.Вставить("ВремяЗавершения",		СтатусДокументаMS.ВремяЗавершения);	
	Исключение	
	КонецПопытки;	
	
	ДанныеДокументаMS.Вставить("ШапкаДокумента", РеквизитыШапки);
	
	Если ТолькоШапка Тогда
		Возврат ДанныеДокументаMS;
	КонецЕсли;
	
	// Подготовка табличных частей
	ТабличнаяЧастьФакт = Новый Массив;
	ТабличнаяЧастьПлан = Новый Массив;
	ТабличнаяЧастьСовмещенные = Новый Массив;
	
	СписокПолей = "";
	МассивКолонок = Новый Массив;
	Для Каждого РеквизитТЧ Из СтруктураДокументаMS.РеквизитыТЧ Цикл
		СписокПолей = СписокПолей + РеквизитТЧ.Значение + ",";
		МассивКолонок.Добавить(РеквизитТЧ.Значение);
	КонецЦикла;	
	
	Для Каждого РеквизитСерии Из СтруктураДокументаMS.РеквизитыСерии Цикл
		// данное поле будет добавлено при заполнении вычислимых полей
		Если Найти(ВРег(СокрЛП("Характеристика")), ВРег(СокрЛП(РеквизитСерии.Значение))) Тогда
			Продолжить;
		КонецЕсли;	
		Если МассивКолонок.Найти(РеквизитСерии.Значение) = Неопределено Тогда
			МассивКолонок.Добавить(РеквизитСерии.Значение);
			СписокПолей = СписокПолей + РеквизитТЧ.Значение + ",";
		КонецЕсли;	
	КонецЦикла;
	
	Для Каждого РеквизитСерийныеНомера Из СтруктураДокументаMS.РеквизитыСерийныеНомера Цикл
		// данное поле будет добавлено при заполнении вычислимых полей
		Если Найти(ВРег(СокрЛП("Характеристика")), ВРег(СокрЛП(РеквизитСерийныеНомера.Значение))) Тогда
			Продолжить;
		КонецЕсли;	
		Если МассивКолонок.Найти(РеквизитСерийныеНомера.Значение) = Неопределено Тогда
			МассивКолонок.Добавить(РеквизитСерийныеНомера.Значение);
			СписокПолей = СписокПолей + РеквизитТЧ.Значение + ",";
		КонецЕсли;
	КонецЦикла;	
	СписокПолей = Лев(СписокПолей,СтрДлина(СписокПолей)-1);	
		
	СтрокиПланДокументаSMARTS = ДокументSMARTS.СтрокиПлан;
	СтрокиФактДокументаSMARTS = ДокументSMARTS.СтрокиФакт;
	СтрокиСовмДокументаSMARTS = ДокументSMARTS.CombinedItems;
	
	// План
	ТабличнаяЧастьПлан.Добавить(Новый Структура("ЭтоТаблицаЗначений,КолонкиТаблицыЗначений",Истина,СписокПолей));
	Для Индекс = 0 По СтрокиПланДокументаSMARTS.Количество - 1 Цикл
		СтрокаПланДокументаSMARTS = СтрокиПланДокументаSMARTS.Элемент(Индекс);
		
		// фильтр ТЧ если она была объединена из нескольких документов
		Если ЗначениеЗаполнено(ФильтрТЧПоИдДокумента) Тогда
			ИдДокументаВладелецСтроки = СтрокаПланДокументаSMARTS.ПолучитьПоле("ИдДокумента");
			Если ИдДокументаВладелецСтроки <> ФильтрТЧПоИдДокумента Тогда
				Продолжить;
			КонецЕсли;
		КонецЕсли;
		
		НоваяСтрока = Новый Структура();
		Для Каждого РеквизитТЧ Из МассивКолонок Цикл
			Попытка
				НоваяСтрока.Вставить(РеквизитТЧ, СтрокаПланДокументаSMARTS.ПолучитьПоле(РеквизитТЧ));
			Исключение
			    Сообщить("Реквизит с именем [" + РеквизитТЧ + "] отсутствует в табличной части [СтрокиПлан]");
			КонецПопытки; 			
		КонецЦикла;
		ТабличнаяЧастьПлан.Добавить(НоваяСтрока);
	КонецЦикла;
	ДанныеДокументаMS.Вставить("СтрокиПлан", ТабличнаяЧастьПлан);
	
	// Факт
	ТабличнаяЧастьФакт.Добавить(Новый Структура("ЭтоТаблицаЗначений,КолонкиТаблицыЗначений",Истина,СписокПолей));
	Для Индекс = 0 По СтрокиФактДокументаSMARTS.Количество - 1 Цикл
		СтрокаФактДокументаSMARTS = СтрокиФактДокументаSMARTS.Элемент(Индекс);
		
		// фильтр ТЧ если она была объединена из нескольких документов
		Если ЗначениеЗаполнено(ФильтрТЧПоИдДокумента) Тогда
			ИдДокументаВладелецСтроки = СтрокаФактДокументаSMARTS.ПолучитьПоле("ИдДокумента");
			// Если ИдДокумента пустой, но не неопределено, то возможно это старая конфа и можно поискать в BindedLine
			Если ИдДокументаВладелецСтроки = "" Тогда
				СвязаннаяСтрокаИзФакта = СтрокаФактДокументаSMARTS.ПолучитьПоле("СвязаннаяСтрока");
				Если Найти(ВРег(СвязаннаяСтрокаИзФакта), ВРег(СокрЛП("COMОбъект")))  Тогда
					ИдДокументаВладелецСтроки = СвязаннаяСтрокаИзФакта.ПолучитьПоле("ИдДокумента")
				КонецЕсли;
			КонецЕсли;
			Если ИдДокументаВладелецСтроки <> ФильтрТЧПоИдДокумента 
				И НЕ (ID_Документа = ФильтрТЧПоИдДокумента И ИдДокументаВладелецСтроки = "") // Это условие нужно для загрузки всех строк, которых не было по плану в первый документ
				Тогда 
				Продолжить;
			КонецЕсли;
		КонецЕсли;
		
		НоваяСтрока = Новый Структура();
		Для Каждого РеквизитТЧ Из МассивКолонок Цикл
			Попытка
				
				ЗначениеРеквизита = СтрокаФактДокументаSMARTS.ПолучитьПоле(РеквизитТЧ);
				
				Если Найти(ВРег(СокрЛП("BindedLine/СвязаннаяСтрока")), ВРег(СокрЛП(РеквизитТЧ))) Тогда
					
					СвязаннаяСтрока = Новый Структура;
					
					Если ЗначениеРеквизита <> Неопределено Тогда
						
						Для Каждого РеквизитСвязаннойСтроки Из МассивКолонок Цикл
							
							ЗначениеРеквизитаСвязаннойСтроки = ЗначениеРеквизита.ПолучитьПоле(РеквизитСвязаннойСтроки);					
							
							Если НЕ Найти(ВРег(СокрЛП(ЗначениеРеквизитаСвязаннойСтроки)), ВРег(СокрЛП("COMОбъект"))) Тогда
								
								СвязаннаяСтрока.Вставить(РеквизитСвязаннойСтроки, ЗначениеРеквизитаСвязаннойСтроки);
								
							КонецЕсли;																			
							
						КонецЦикла;
						
					КонецЕсли;
					
					НоваяСтрока.Вставить(РеквизитТЧ,СвязаннаяСтрока);
					
				Иначе	
					
					НоваяСтрока.Вставить(РеквизитТЧ,ЗначениеРеквизита);
					
				КонецЕсли;	
											
			Исключение
			
			КонецПопытки; 			
		КонецЦикла;
		ТабличнаяЧастьФакт.Добавить(НоваяСтрока);
	КонецЦикла;
	ДанныеДокументаMS.Вставить("СтрокиФакт", ТабличнаяЧастьФакт);
	
	// СовмещенныеСтроки
	ТабличнаяЧастьСовмещенные.Добавить(Новый Структура("ЭтоТаблицаЗначений,КолонкиТаблицыЗначений",Истина,СписокПолей));
	Для Индекс = 0 По СтрокиСовмДокументаSMARTS.Количество - 1 Цикл
		СтрокаСовмДокументаSMARTS = СтрокиСовмДокументаSMARTS.Элемент(Индекс);
		
		НоваяСтрока = Новый Структура();
		Для Каждого РеквизитТЧ Из МассивКолонок Цикл
			Попытка
				
				ЗначениеРеквизита = СтрокаСовмДокументаSMARTS.ПолучитьПоле(РеквизитТЧ);
				
				Если Найти(ВРег(СокрЛП("BindedLine/СвязаннаяСтрока")), ВРег(СокрЛП(РеквизитТЧ))) Тогда
					
					СвязаннаяСтрока = Новый Структура;
					
					Если ЗначениеРеквизита <> Неопределено Тогда
						
						Для Каждого РеквизитСвязаннойСтроки Из МассивКолонок Цикл
							
							ЗначениеРеквизитаСвязаннойСтроки = ЗначениеРеквизита.ПолучитьПоле(РеквизитСвязаннойСтроки);					
							
							Если НЕ Найти(ВРег(СокрЛП(ЗначениеРеквизитаСвязаннойСтроки)), ВРег(СокрЛП("COMОбъект"))) Тогда
								
								СвязаннаяСтрока.Вставить(РеквизитСвязаннойСтроки, ЗначениеРеквизитаСвязаннойСтроки);
								
							КонецЕсли;																			
							
						КонецЦикла;
						
					КонецЕсли;
					
					НоваяСтрока.Вставить(РеквизитТЧ,СвязаннаяСтрока);
					
				Иначе	
					
					НоваяСтрока.Вставить(РеквизитТЧ,ЗначениеРеквизита);
					
				КонецЕсли;	
											
			Исключение
				
			КонецПопытки; 			
		КонецЦикла;
		ТабличнаяЧастьСовмещенные.Добавить(НоваяСтрока);
	КонецЦикла;
	ДанныеДокументаMS.Вставить("СовмещенныеСтроки", ТабличнаяЧастьСовмещенные);	
	
	СписокИменаДополнительныхТабличныхЧастей = Новый СписокЗначений;
	
	// Получение данных из доп.таблиц документа типа "ОплатыВозвраты", "Деньги" и т.д.	
	Для каждого ДопТаблица Из СтруктураДокументаMS.ДополнительныеТаблицы Цикл		
		
		ИмяДопТаблицы			= ДопТаблица.Представление;
		СписокКолонокДопТаблицы = ДопТаблица.Значение;		
		ДопТабличнаяЧасть		= Новый Массив;
		СписокПолей 			= "";		
		
		СписокИменаДополнительныхТабличныхЧастей.Добавить(ИмяДопТаблицы);
		
		Для Каждого Колонка из СписокКолонокДопТаблицы Цикл
			СписокПолей = СписокПолей + Колонка.Значение + ",";
		КонецЦикла;	
		
		СтрокиДокументаMS = ДокументSMARTS.ПолучитьПоле(ИмяДопТаблицы).Rows;				
		
		Для Индекс = 0 по СтрокиДокументаMS.Количество - 1 Цикл
			
			ТекущаяСтрокаMS	= СтрокиДокументаMS.Элемент(Индекс);			
			НоваяСтрока 	= Новый Структура;						
			
			Для Каждого Колонка из СписокКолонокДопТаблицы Цикл
				
				Попытка					
					ЗначениеРеквизита = ТекущаяСтрокаMS.ПолучитьПоле(Колонка.Значение);
				Исключение
					Попытка
						ЗначениеРеквизита = ТекущаяСтрокаMS[Колонка.Значение];											
					Исключение
						ЗначениеРеквизита = Неопределено;						
					КонецПопытки; 					
				КонецПопытки;		
								
				НоваяСтрока.Вставить(Колонка.Значение, ЗначениеРеквизита);				
				
			КонецЦикла;
							
			ПоляТекущейСтрокиMS = ТекущаяСтрокаMS.Поля;
			
			Для ИндексПоля = 0 По ПоляТекущейСтрокиMS.Количество - 1 Цикл
				
				ИмяПоля = ПоляТекущейСтрокиMS.Элемент(ИндексПоля).ИмяПоля;				
				
				Если НЕ Найти(СписокПолей, ИмяПоля) Тогда				
					СписокПолей = СписокПолей + ИмяПоля + ",";				
				КонецЕсли; 
				
				Попытка					
					ЗначениеРеквизита = ТекущаяСтрокаMS.ПолучитьПоле(ИмяПоля);
				Исключение
					Попытка
						ЗначениеРеквизита = ТекущаяСтрокаMS[ИмяПоля];											
					Исключение
						ЗначениеРеквизита = Неопределено;						
					КонецПопытки; 					
				КонецПопытки;		
												
				НоваяСтрока.Вставить(ИмяПоля, ЗначениеРеквизита);				
				
			КонецЦикла;									
			
			ДопТабличнаяЧасть.Добавить(НоваяСтрока);			
			
		КонецЦикла;	
		
		СписокПолей = Лев(СписокПолей, СтрДлина(СписокПолей) - 1);
		
		ДопТабличнаяЧасть.Вставить(0, Новый Структура("ЭтоТаблицаЗначений, КолонкиТаблицыЗначений", Истина, СписокПолей));
		
		ДанныеДокументаMS.Вставить(ИмяДопТаблицы, ДопТабличнаяЧасть);	
		
	КонецЦикла;	
	
    // Получение данных доп.таблиц, которые не определены в метаданных документа, но существуют у самого экземпляра документа
    Для ИндексТаблицы = 0 По ДокументSMARTS.Таблицы.Количество - 1 Цикл
        
        ДопТаблицаMS = ДокументSMARTS.Таблицы.Элемент(ИндексТаблицы);
		
		Если ДопТаблицаMS.Строки.Количество = 0 Тогда
			Продолжить;
		КонецЕсли;
		
		Если СписокИменаДополнительныхТабличныхЧастей.НайтиПоЗначению(ДопТаблицаMS["name"]) <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		ДопТабличнаяЧасть 	= Новый Массив;
		СписокПолей 		= "";
        
        Для ИндексСтроки = 0 По ДопТаблицаMS.Строки.Количество - 1 Цикл
            
            ТекущаяСтрокаMS = ДопТаблицаMS.Строки.Элемент(ИндексСтроки);            
            НоваяСтрока 	= Новый Структура;
            
            Для ИндексПоля = 0 По ТекущаяСтрокаMS.Поля.Количество - 1 Цикл
                
                ИмяПоля = ТекущаяСтрокаMS.Поля.Элемент(ИндексПоля).ИмяПоля;
								
				Если НЕ Найти(СписокПолей, ИмяПоля) Тогда				
					СписокПолей = СписокПолей + ИмяПоля + ",";				
				КонецЕсли; 
				
                Попытка
                    ЗначениеРеквизита = ТекущаяСтрокаMS.ПолучитьПоле(ИмяПоля);
                Исключение
                    Попытка
                        ЗначениеРеквизита = ТекущаяСтрокаMS[ИмяПоля];
                    Исключение
                        ЗначениеРеквизита = Неопределено;
                    КонецПопытки;                 
                КонецПопытки;         	
                
                НоваяСтрока.Вставить(ИмяПоля, ЗначениеРеквизита);
                
            КонецЦикла;                                         
			
			ДопТабличнаяЧасть.Добавить(НоваяСтрока);						
			
        КонецЦикла; 
		
		СписокПолей = Лев(СписокПолей, СтрДлина(СписокПолей) - 1);
		
		ДопТабличнаяЧасть.Вставить(0, Новый Структура("ЭтоТаблицаЗначений, КолонкиТаблицыЗначений", Истина, СписокПолей));		
		
        ДанныеДокументаMS.Вставить(ДопТаблицаMS.Имя, ДопТабличнаяЧасть);   
        
    КонецЦикла;	
	
	Возврат ДанныеДокументаMS;
	
КонецФункции

&НаКлиенте
Функция КомЯдро_УдалитьДокументНаСервереSMARTS(ID_Документа, ТипБазы)
		
	Если НЕ КомЯдро_ПодключитьсяКСерверуSMARTS(Ложь,ТипБазы) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если ТипБазы = "Частная" Тогда
		СтруктураБазMS = COMЧастнойБазыMS;
	ИначеЕсли ТипБазы = "Временная" Тогда
		СтруктураБазMS = COMВременнойБазыMS;
	Иначе
		СтруктураБазMS = COMБазыMS;
	КонецЕсли;

	СтруктураБазMS.StorageConnector.УдалитьДокумент(ID_Документа);
	
	Возврат Истина;
	
КонецФункции

#КонецОбласти

#Область КомпонентаMobileSMARTS_ТаблицыSMARTS

&НаКлиенте
Функция КомЯдро_ВыгрузитьТаблицуНаСерверSMARTS(ТипБазы, ИмяТаблицы, ДанныеДляВыгрузки, ОчищатьСправочникПередВыгрузкой = Ложь)
	
	РезультатВыгрузки = Новый Структура;
	РезультатВыгрузки.Вставить("Статус"		, Истина);																			 
	РезультатВыгрузки.Вставить("Сообщение"	, "Таблица [" + ИмяТаблицы + "] успешно выгружена. Выгружено:" 
												+ Символы.ВК + Символы.Таб + "- " + Формат(ДанныеДляВыгрузки.МассивыСтрок.Количество(), "ЧН=0; ЧГ=3,0") + " строк");
												
	Если ИмяТаблицы = "Номенклатура" Тогда											
		
		КоличествоРазличныхТоваров = ?(ДанныеДляВыгрузки.Свойство("КоличествоТоваров"),ДанныеДляВыгрузки.КоличествоТоваров,0);
		РезультатВыгрузки.Сообщение = РезультатВыгрузки.Сообщение 
										+ Символы.ВК + Символы.Таб + "- " + Формат(КоличествоРазличныхТоваров, "ЧН=0; ЧГ=3,0") + " товаров";
	КонецЕсли;
	
	Если НЕ КомЯдро_ПодключитьсяКСерверуSMARTS(Ложь,ТипБазы) Тогда
		Возврат Новый Структура("Сообщение,Статус", "База Mobile SMARTS недоступна!", Ложь);
	КонецЕсли;		
	
	Если ТипБазы = "Частная" Тогда
		СтруктураПодключенияMS = COMЧастнойБазыMS;
	ИначеЕсли ТипБазы = "Временная" Тогда
		СтруктураПодключенияMS = COMВременнойБазыMS;
	Иначе
		СтруктураПодключенияMS = COMБазыMS;
	КонецЕсли;
	
	Если ИмяТаблицы = "Номенклатура" Тогда
		СтруктураПодключенияMS.TerminalConnector.ПерезаписыватьНоменклатуру(ОчищатьСправочникПередВыгрузкой);
		РезультатПопытки = СтруктураПодключенияMS.TerminalConnector.НачатьВыгрузкуТоваров(ДанныеДляВыгрузки.МассивИмен);
	ИначеЕсли ИмяТаблицы = "Ячейки" Тогда	
		РезультатПопытки = СтруктураПодключенияMS.TerminalConnector.НачатьВыгрузкуЯчеек("1", ДанныеДляВыгрузки.МассивИмен, ОчищатьСправочникПередВыгрузкой);
	Иначе
		РезультатПопытки = СтруктураПодключенияMS.TerminalConnector.НачатьВыгрузкуТаблицы(ИмяТаблицы, ДанныеДляВыгрузки.МассивИмен, ОчищатьСправочникПередВыгрузкой);
	КонецЕсли;
	
	Если НЕ РезультатПопытки Тогда
		ОписаниеОшибки = КомЯдро_ПолучитьОшибку(ТипБазы);
		РезультатВыгрузки = Новый Структура("Сообщение,Статус", "Таблица [" + ИмяТаблицы + "] не выгружается!" + Символы.ВК + ОписаниеОшибки, Ложь);
	КонецЕсли;
	
	Если РезультатВыгрузки.Статус = Истина Тогда
		Для Каждого МассивСтрокиВыгрузки из ДанныеДляВыгрузки.МассивыСтрок Цикл
			Если ИмяТаблицы = "Номенклатура" Тогда
				РезультатПопытки = СтруктураПодключенияMS.TerminalConnector.ДобавитьВВыгрузкуТоваров(МассивСтрокиВыгрузки);
			ИначеЕсли ИмяТаблицы = "Ячейки" Тогда	
				РезультатПопытки = СтруктураПодключенияMS.TerminalConnector.ДобавитьВВыгрузкуЯчеек(МассивСтрокиВыгрузки);				
			Иначе
				РезультатПопытки = СтруктураПодключенияMS.TerminalConnector.ДобавитьВВыгрузкуТаблицы(МассивСтрокиВыгрузки);
			КонецЕсли;
			Если НЕ РезультатПопытки Тогда
				ОписаниеОшибки = КомЯдро_ПолучитьОшибку(ТипБазы);
				РезультатВыгрузки =  Новый Структура("Сообщение,Статус", "Ошибка выгрузки таблицы [" + ИмяТаблицы + "]." + Символы.ВК + ОписаниеОшибки, Ложь);
				Если ИмяТаблицы = "Ячейки" Тогда
					СтруктураПодключенияMS.TerminalConnector.ПрерватьВыгрузкуЯчеек();	
				ИначеЕсли ИмяТаблицы <> "Номенклатура" Тогда	
					СтруктураПодключенияMS.TerminalConnector.ПрерватьВыгрузкуТаблицы();			
				КонецЕсли;	
				Прервать;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Если РезультатВыгрузки.Статус = Истина Тогда
		Если ИмяТаблицы = "Номенклатура" Тогда
			РезультатПопытки = СтруктураПодключенияMS.TerminalConnector.ЗавершитьВыгрузкуТоваров();	
		ИначеЕсли ИмяТаблицы = "Ячейки" Тогда	
			РезультатПопытки = СтруктураПодключенияMS.TerminalConnector.ЗавершитьВыгрузкуЯчеек();						
		Иначе
			РезультатПопытки = СтруктураПодключенияMS.TerminalConnector.ЗавершитьВыгрузкуТаблицы();	
		КонецЕсли;
		
		Если НЕ РезультатПопытки Тогда
			ОписаниеОшибки = КомЯдро_ПолучитьОшибку(ТипБазы);
			РезультатВыгрузки =  Новый Структура("Сообщение,Статус", "Не удалось закончить выгрузку таблицы [" + ИмяТаблицы + "]." + Символы.ВК + ОписаниеОшибки, Ложь);
		КонецЕсли;
	КонецЕсли;

	СтруктураПодключенияMS.TerminalConnector.ОсвободитьРесурсы();
	
	Возврат РезультатВыгрузки;
	
КонецФункции

// Очищает таблицу на сервере Mobile Smarts
//
// Параметры:
//	ИмяТаблицы - Строка - имя таблицы Mobile Smarts	
//	ТипБазы - Строка - "Частная", "Временная", "Основная"
//
// Возвращаемое значение:
//	Структура - содержит:
//		* Сообщение - Строка - информационное сообщение о результате очистки таблицы
//		* Статус - Булево - флаг успешности очистки таблицы
&НаКлиенте
Функция КомЯдро_ОчиститьТаблицуНаСервереSMARTS(ИмяТаблицы, ТипБазы) Экспорт
	
	РезультатВыгрузки = Новый Структура("Сообщение,Статус", "Таблица [" + ИмяТаблицы + "] успешно очищена", Истина);
		
	Если НЕ КомЯдро_ПодключитьсяКСерверуSMARTS(Ложь,ТипБазы) Тогда
		РезультатВыгрузки = Новый Структура("Сообщение,Статус", "Ошибка очистки таблицы [" + ИмяТаблицы + "]", Ложь);
		Возврат РезультатВыгрузки;
	КонецЕсли;
	
	Если ТипБазы = "Частная" Тогда
		СтруктураБазMS = COMЧастнойБазыMS;
	ИначеЕсли ТипБазы = "Временная" Тогда
		СтруктураБазMS = COMВременнойБазыMS;
	Иначе
		СтруктураБазMS = COMБазыMS;
	КонецЕсли;
	
	Если ИмяТаблицы = "Номенклатура" Тогда
		СтруктураБазMS.StorageConnector.ОчиститьСправочникТоваров();
	ИначеЕсли ИмяТаблицы = "Ячейки" Тогда
		Попытка
    		СтруктураБазMS.StorageConnector.GetTableAccessor(ИмяТаблицы).Clear();
		Исключение
			// При прямом подключении очищаем этой командой
			СтруктураБазMS.StorageConnector.GetCellsAccesor(1).Clear();
		КонецПопытки;
	Иначе
    	СтруктураБазMS.StorageConnector.GetTableAccessor(ИмяТаблицы).Clear();
	КонецЕсли;
	
	Возврат РезультатВыгрузки;
	
КонецФункции

#КонецОбласти

#КонецОбласти

#Область Транзит

// Вызывает глобальный метод на клиенте
//
// Параметры:
//	СтруктураВызова	- Структура - структура вызова глобального метода
//	ВозвращатьАдресХранилища - Строка - флаг необходимости поместить результат во временное хранилище
//  пАдресаПеременных - Неопределено, Структура - структура с адресами переменных
//  КоличествоЛидирующихЗапятых - Число - количество лидирующих запятых в списке параметров метода
//
// Возвращаемое значение:
//	Строка - если ВозвращатьАдресХранилища = Истина
//	Произвольный - результат выполнения глобального метода
&НаКлиенте
Функция Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова, ВозвращатьАдресХранилища = Ложь,пАдресаПеременных=Неопределено,КоличествоЛидирующихЗапятых=0) Экспорт
	#Если Не ТолстыйКлиентУправляемоеПриложение Тогда
		ПередаваемыеПараметры = Транзит_ПоместитьЗначениеВХранилищеНаКлиенте(СтруктураВызова);
	#Иначе
		// В толстом клиенте управляемого приложения теряется значение ДанныеФормыСтруктура при помещении во врем хранилище
		// Например, из-за этого не работала кнопка "Загрузить из Mobile SMARTS" в форме документа толстого клиента упр приложения
		// Не помещаем параметры во врем хранилище в толстом клиента упр приложения
		ПередаваемыеПараметры = СтруктураВызова;
	#КонецЕсли

	АдресХранилища = Транзит_ВызватьГлобальныйМетодНаСервере(ПередаваемыеПараметры,пАдресаПеременных,КоличествоЛидирующихЗапятых);
	Если ВозвращатьАдресХранилища Тогда
		Возврат АдресХранилища;
	Иначе
		Возврат Транзит_ПолучитьЗначениеИзХранилищаНаКлиенте(АдресХранилища);
	КонецЕсли;
КонецФункции

&НаСервере
Функция Транзит_ВызватьГлобальныйМетодНаСервере(АдресХранилища,АдресаПеременных=Неопределено,КоличествоЛидирующихЗапятых=0)
	
	КоличествоПустыхПараметров = КоличествоЛидирующихЗапятых;
	
	Результат = Неопределено;
	
	Если ЭтоАдресВременногоХранилища(АдресХранилища) Тогда
		СтруктураВызова = Транзит_ПолучитьЗначениеИзХранилищаНаСервере(АдресХранилища);
	Иначе
		СтруктураВызова = АдресХранилища;
	КонецЕсли;

	ТипМетода = СтруктураВызова.ТипМетода;
	ИмяМетода = СтруктураВызова.ИмяМетода;
	
	СтрокаПараметровМетода = "";
	Если СтруктураВызова.Свойство("ПараметрыМетода") Тогда
		ПараметрыМетода = СтруктураВызова.ПараметрыМетода;
		Для Каждого Параметр Из СтруктураВызова.ПараметрыМетода Цикл
			СтрокаПараметровМетода = СтрокаПараметровМетода + ", ПараметрыМетода." + Параметр.Ключ;
		КонецЦикла;
		СтрокаПараметровМетода = Сред(СтрокаПараметровМетода, 3);
	КонецЕсли;
	
	СтрокаВызова = "_ГлКонтекст.ГлЯдро_" + ИмяМетода + "(" + СтрокаПараметровМетода;
	Пока КоличествоЛидирующихЗапятых>0 Цикл
		СтрокаВызова = СтрокаВызова + ",";
		КоличествоЛидирующихЗапятых = КоличествоЛидирующихЗапятых-1;
	КонецЦикла;
	СтрокаВызова = СтрокаВызова +?(АдресаПеременных<>Неопределено,?(ЗначениеЗАполнено(СтрокаПараметровМетода),",","")+"АдресаПеременных","")+ ");";
	
	Если ТипМетода = "Функция" Тогда
		СтрокаВызова = "Результат = " + СтрокаВызова;
	КонецЕсли;
	
	#Если ТолстыйКлиентОбычноеПриложение Тогда
		_ГлКонтекст = ЭтаФорма.ВладелецФормы.Объект;						
	#Иначе
		_ГлКонтекст = РеквизитФормыВЗначение("Объект");
	#КонецЕсли

	#Область НесовместимыйКодFresh
	Выполнить(СтрокаВызова);
	#КонецОбласти //НесовместимыйКодFresh
	
	// При данном способе устанавливается безопасный режим. А в безопасном режиме запрещено выполнение HTTPСоединение, поэтому данный способ не подойдет для тестирования с включенным безопасным режимом
	//ПараметрыАлгоритма = Новый Структура;
	//СтрокаВызова = СтрЗаменить(СтрокаВызова, "Результат", "Параметры.Результат");
	//СтрокаВызова = СтрЗаменить(СтрокаВызова, "ПараметрыМетода", "Параметры.ПараметрыМетода");
	//СтрокаВызова = СтрЗаменить(СтрокаВызова, "_ГлКонтекст", "Параметры._ГлКонтекст");
	//СтрокаВызова = СтрЗаменить(СтрокаВызова, "АдресаПеременных", "Параметры.АдресаПеременных");
	//ПараметрыАлгоритма.Вставить("Результат", 		Результат);
	//ПараметрыАлгоритма.Вставить("ПараметрыМетода", 	ПараметрыМетода);
	//ПараметрыАлгоритма.Вставить("_ГлКонтекст", 		_ГлКонтекст);
	//ПараметрыАлгоритма.Вставить("АдресаПеременных", АдресаПеременных);
	//ЛокЯдро_ВыполнитьВБезопасномРежиме(СтрокаВызова, ПараметрыАлгоритма);
	//Результат = ПараметрыАлгоритма.Результат;

  	// Данный способ нужен для тестирования с включенным безопасным режимом. Оставлю его пока закомментированным
	#Область СовместимыйКодFresh
	//МассивПараметров = Новый Массив;
	//Если ЗначениеЗаполнено(СтрокаПараметровМетода) Тогда
	//	МассивПараметров = ЛокЯдро_ПреобразоватьСоответствиеИлиСтруктуруВМассив(СтруктураВызова.ПараметрыМетода, Ложь);
	//КонецЕсли;
	//Пока КоличествоПустыхПараметров > 0 Цикл
	//	МассивПараметров.Добавить(Неопределено);
	//	КоличествоПустыхПараметров = КоличествоПустыхПараметров - 1;
	//КонецЦикла;
	//Если АдресаПеременных <> Неопределено Тогда
	//	МассивПараметров.Добавить(АдресаПеременных);
	//КонецЕсли;	
	//Если ТипМетода = "Функция" Тогда
	//	Результат = ОбщегоНазначения.ВызватьФункциюОбъекта(_ГлКонтекст, "ГлЯдро_" + ИмяМетода, МассивПараметров);
	//Иначе
	//	ОбщегоНазначения.ВыполнитьМетодОбъекта(_ГлКонтекст, "ГлЯдро_" + ИмяМетода, МассивПараметров);
	//КонецЕсли;
	#КонецОбласти //СовместимыйКодFresh
	
	Возврат Транзит_ПоместитьЗначениеВХранилищеНаСервере(Результат);
	
КонецФункции

&НаКлиенте
Функция Транзит_ПоместитьЗначениеВХранилищеНаКлиенте(СохраняемоеЗначение)
	Возврат ПоместитьВоВременноеХранилище(СохраняемоеЗначение, Новый УникальныйИдентификатор()); 
КонецФункции

&НаКлиенте
Функция Транзит_ПолучитьЗначениеИзХранилищаНаКлиенте(АдресХранилища)
	Возврат ПолучитьИзВременногоХранилища(АдресХранилища); 
КонецФункции

&НаСервере
Функция Транзит_ПоместитьЗначениеВХранилищеНаСервере(СохраняемоеЗначение)
	Возврат ПоместитьВоВременноеХранилище(СохраняемоеЗначение,Новый УникальныйИдентификатор()); 
КонецФункции

&НаСервере
Функция Транзит_ПолучитьЗначениеИзХранилищаНаСервере(АдресХранилища)
	Возврат ПолучитьИзВременногоХранилища(АдресХранилища); 
КонецФункции

#КонецОбласти

&НаСервере 
Функция ЛокЯдро_ВыгрузитьКолонкуИзТЧДокумента(Документ1С,НастройкаВыгрузкиТЧ,НазваниеРеквизита,ИмяРеквизитаИсточника)
	ИмяТЧДокумента = НастройкаВыгрузкиТЧ.НастройкаТЧСтрокой;
	
	Если ИмяТЧДокумента = "(Запрос)"  Или ИмяТЧДокумента = "Запрос"Тогда
			
		МассивНоменклатуры = Новый Массив;
		
		Запрос = Новый Запрос(СтрЗаменить(НастройкаВыгрузкиТЧ.ТекстЗапросаВыгрузкиНаТСД, "¶", ""));		
		Запрос.УстановитьПараметр("Ссылка", Документ1С);
			
		ПараметрыЗапроса = Новый Структура;    
		Попытка					
			//Выполнить(СтрЗаменить(НастройкаВыгрузкиТЧ.ТекстКодаПолучениеПараметров, "ДокументДляВыгрузки", "Документ1С"));
			ТекстКодаПолучениеПараметров = СтрЗаменить(НастройкаВыгрузкиТЧ.ТекстКодаПолучениеПараметров, "ДокументДляВыгрузки", "Документ1С");
			СтрокаВызова = СтрЗаменить(ТекстКодаПолучениеПараметров, "ПараметрыЗапроса", "Параметры.ПараметрыЗапроса");
			ПараметрыАлгоритма = Новый Структура;
			ПараметрыАлгоритма.Вставить("ПараметрыЗапроса", ПараметрыЗапроса);
			ЛокЯдро_ВыполнитьВБезопасномРежиме(СтрокаВызова, ПараметрыАлгоритма);
			ПараметрыЗапроса = ПараметрыАлгоритма.ПараметрыЗапроса;
			
			Если ПараметрыЗапроса.Количество() Тогда
				Для Каждого ПараметрЗапроса Из ПараметрыЗапроса Цикл
					Запрос.УстановитьПараметр(ПараметрЗапроса.Ключ, ПараметрЗапроса.Значение);	
				КонецЦикла;
			КонецЕсли;
		Исключение
			Сообщить("Ошибка получения параметров запроса табличной части. Номенклатура документа не выгружена" + Символы.ПС + КраткоеПредставлениеОшибки(ИнформацияОбОшибке()));
		КонецПопытки;				
		
		ТаблицаДанныхТЧ = Запрос.Выполнить().Выгрузить();
		МассивНоменклатуры = ТаблицаДанныхТЧ.ВыгрузитьКолонку(ИмяРеквизитаИсточника);
	Иначе
		Если ТипЗнч(Документ1С) = Тип("Массив") Тогда
			ОбщийМассив = Новый Массив;
			Для каждого СтрокаМассива Из Документ1С Цикл
				
				Док = СтрокаМассива;
				ТЧДокумента =  Док[ИмяТЧДокумента];
				
				Для каждого СтрокаТЧ Из ТЧДокумента Цикл
					ОбщийМассив.Добавить(СтрокаТЧ[НазваниеРеквизита]);	
				КонецЦикла;
				
			КонецЦикла;
			
			МассивНоменклатуры =  ОбщийМассив;
				
		Иначе 
			МассивНоменклатуры = Документ1С[ИмяТЧДокумента].ВыгрузитьКолонку(НазваниеРеквизита);
		КонецЕсли;
	КонецЕсли;
	
	// Из массива надо убрать пустые ссылки, иначе "захватится" вся номенклатура
	Если МассивНоменклатуры.Количество()>0 Тогда												
		КолвоЭлементовКоллекции = МассивНоменклатуры.Количество(); 
		Для ОбратныйИндекс = 1 По КолвоЭлементовКоллекции Цикл 
			ЭлементМассива = МассивНоменклатуры[КолвоЭлементовКоллекции - ОбратныйИндекс]; 
			Если ЭлементМассива.Пустая() Тогда 
				МассивНоменклатуры.Удалить(КолвоЭлементовКоллекции - ОбратныйИндекс); 
			КонецЕсли; 
		КонецЦикла;
	КонецЕсли;
	
	Возврат МассивНоменклатуры;

КонецФункции

// Проверяет создание COM-объекта и возвращает результат проверки
//
// Параметры:
//	Компонента - Строка - расположение компоненты Mobile Smarts
//
// Возвращаемое значение:
//	- Булево - полученное значение переменной КОМСоздан
//  - Неопределено - если получить значение переменной КОМСоздан не удалось
&НаКлиенте
Функция ЛокЯдро_ПроверитьСозданиеКОМОбъекта(Компонента = Неопределено) Экспорт
	
	ТипИнтерфейса = КомЯдро_ПолучитьЗначениеПеременной("ТипИнтерфейса");
	Если ТипИнтерфейса = "REST_API" Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(Компонента) Тогда
		Компонента = ЛокЯдро_ПолучитьДанныеИзХранилища1С("Cleverence_РасположениеКомпоненты");
	КонецЕсли;
	
	Если Компонента = "НаКлиенте" Тогда
		Возврат КОМсоздан = Истина;			
	ИначеЕсли НЕ ЗначениеЗаполнено(Компонента) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода", "Функция");
	СтруктураВызова.Вставить("ИмяМетода", "ПроверитьСозданиеКОМОбъекта");
	
	Возврат  Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,,АдресаПеременных);
	
КонецФункции

// Преобразует переданную строку в транслит
//
// Параметры:
//	пИсходнаяСтрока - Строка - исходная строка	
//
// Возвращаемое значение:
//	Строка - результирующая строка
&НаКлиенте
Функция ЛокЯдро_СтрокуВТранслитENG(Знач ИсходныйТекст) Экспорт
	
	Если СоотвСимволов = Неопределено Тогда
		СоотвСимволов = ЛокЯдро_ПолучитьСоответствиеСимволовТранслита();
	КонецЕсли;
	
	ИсходныйТекст = СокрЛП(ИсходныйТекст);
	ГотовоеЗначение = "";
	ТекущийСимвол = "";
	ТекущийГотовыйСимвол = "";
	Для к = 1 по СтрДлина(ИсходныйТекст) Цикл
		ТекущийСимвол = Сред(ИсходныйТекст, к, 1);
		ТекущийГотовыйСимвол = СоотвСимволов.Получить(ТекущийСимвол);
		Если ТекущийГотовыйСимвол = Неопределено Тогда
			ГотовоеЗначение = ГотовоеЗначение + ТекущийСимвол;
		Иначе
			ГотовоеЗначение = ГотовоеЗначение + ТекущийГотовыйСимвол;
		КонецЕсли;
		
	КонецЦикла;
	Возврат ГотовоеЗначение;
КонецФункции

&НаКлиенте
Функция ЛокЯдро_ПолучитьСоответствиеСимволовТранслита()
	СоответствиеСимволов = Новый Соответствие;
	СоответствиеСимволов.Вставить("А", "A");
	СоответствиеСимволов.Вставить("Б", "B");
	СоответствиеСимволов.Вставить("В", "V");
	СоответствиеСимволов.Вставить("Г", "G");
	СоответствиеСимволов.Вставить("Д", "D");
	СоответствиеСимволов.Вставить("Е", "E");
	СоответствиеСимволов.Вставить("Ё", "E");
	СоответствиеСимволов.Вставить("Ж", "Zh");
	СоответствиеСимволов.Вставить("З", "Z");
	СоответствиеСимволов.Вставить("И", "I");
	СоответствиеСимволов.Вставить("Й", "J");
	СоответствиеСимволов.Вставить("К", "K");
	СоответствиеСимволов.Вставить("Л", "L");
	СоответствиеСимволов.Вставить("М", "M");
	СоответствиеСимволов.Вставить("Н", "N");
	СоответствиеСимволов.Вставить("О", "O");
	СоответствиеСимволов.Вставить("П", "P");
	СоответствиеСимволов.Вставить("Р", "R");
	СоответствиеСимволов.Вставить("С", "S");
	СоответствиеСимволов.Вставить("Т", "T");
	СоответствиеСимволов.Вставить("У", "U");
	СоответствиеСимволов.Вставить("Ф", "F");
	СоответствиеСимволов.Вставить("Х", "H");
	СоответствиеСимволов.Вставить("Ц", "C");
	СоответствиеСимволов.Вставить("Ч", "Ch");
	СоответствиеСимволов.Вставить("Ш", "Sh");
	СоответствиеСимволов.Вставить("Щ", "Shh");
	СоответствиеСимволов.Вставить("Ъ", "");
	СоответствиеСимволов.Вставить("Ы", "Y");
	СоответствиеСимволов.Вставить("Ь", "");
	СоответствиеСимволов.Вставить("Э", "E");
	СоответствиеСимволов.Вставить("Ю", "Yu");
	СоответствиеСимволов.Вставить("Я", "Ya");
	
	СоответствиеСимволов.Вставить("а", "a");
	СоответствиеСимволов.Вставить("б", "b");
	СоответствиеСимволов.Вставить("в", "v");
	СоответствиеСимволов.Вставить("г", "g");
	СоответствиеСимволов.Вставить("д", "d");
	СоответствиеСимволов.Вставить("е", "e");
	СоответствиеСимволов.Вставить("Ё", "e");
	СоответствиеСимволов.Вставить("ж", "zh");
	СоответствиеСимволов.Вставить("з", "z");
	СоответствиеСимволов.Вставить("и", "i");
	СоответствиеСимволов.Вставить("й", "j");
	СоответствиеСимволов.Вставить("к", "k");
	СоответствиеСимволов.Вставить("л", "l");
	СоответствиеСимволов.Вставить("м", "m");
	СоответствиеСимволов.Вставить("н", "n");
	СоответствиеСимволов.Вставить("о", "o");
	СоответствиеСимволов.Вставить("п", "p");
	СоответствиеСимволов.Вставить("р", "r");
	СоответствиеСимволов.Вставить("с", "s");
	СоответствиеСимволов.Вставить("т", "t");
	СоответствиеСимволов.Вставить("у", "u");
	СоответствиеСимволов.Вставить("ф", "f");
	СоответствиеСимволов.Вставить("х", "h");
	СоответствиеСимволов.Вставить("ц", "c");
	СоответствиеСимволов.Вставить("ч", "ch");
	СоответствиеСимволов.Вставить("ш", "sh");
	СоответствиеСимволов.Вставить("щ", "shh");
	СоответствиеСимволов.Вставить("ъ", "");
	СоответствиеСимволов.Вставить("ы", "y");
	СоответствиеСимволов.Вставить("ь", "");
	СоответствиеСимволов.Вставить("э", "e");
	СоответствиеСимволов.Вставить("ю", "yu");
	СоответствиеСимволов.Вставить("я", "ya");

	Возврат СоответствиеСимволов;
КонецФункции

&НаКлиенте
Функция ЛокЯдро_ПреобразоватьИзUnicode(СтрокаUnicode)
	
	ПозицияСимвола = Найти(СтрокаUnicode, "\u");
	
	Если НЕ ПозицияСимвола Тогда
		Возврат СтрокаUnicode;
	КонецЕсли;
	
	СоответствиеСимволовUnicode = ЛокЯдро_ПолучитьСоответствиеСимволовUnicode();
	
	Пока ПозицияСимвола > 0 Цикл
		
		СимволUnicode = Сред(СтрокаUnicode, ПозицияСимвола + 2, 4);
		ВыводимыйСимвол = СоответствиеСимволовUnicode.Получить(СимволUnicode);
		Если ВыводимыйСимвол = Неопределено Тогда
			ВыводимыйСимвол = "?Unicode?";
		КонецЕсли;
		СтрокаUnicode = СтрЗаменить(СтрокаUnicode, "\u" + СимволUnicode, ВыводимыйСимвол);
		
		ПозицияСимвола = Найти(СтрокаUnicode, "\u");
                    
	КонецЦикла;
    
	Возврат СтрокаUnicode;
	
КонецФункции

&НаКлиенте
Функция ЛокЯдро_ПолучитьСоответствиеСимволовUnicode()

	СоответствиеСимволов = Новый Соответствие;
	
	СоответствиеСимволов.Вставить("0410", "А"); 
	СоответствиеСимволов.Вставить("0430", "а");
	СоответствиеСимволов.Вставить("0411", "Б");
	СоответствиеСимволов.Вставить("0431", "б");
	СоответствиеСимволов.Вставить("0412", "В");
	СоответствиеСимволов.Вставить("0432", "в");
	СоответствиеСимволов.Вставить("0413", "Г");
	СоответствиеСимволов.Вставить("0433", "г");
	СоответствиеСимволов.Вставить("0414", "Д");
	СоответствиеСимволов.Вставить("0434", "д");
	СоответствиеСимволов.Вставить("0415", "Е");
	СоответствиеСимволов.Вставить("0435", "е");
	СоответствиеСимволов.Вставить("0401", "Ё");
	СоответствиеСимволов.Вставить("0451", "ё");
	СоответствиеСимволов.Вставить("0416", "Ж");
	СоответствиеСимволов.Вставить("0436", "ж");
	СоответствиеСимволов.Вставить("0417", "З");
	СоответствиеСимволов.Вставить("0437", "з");
	СоответствиеСимволов.Вставить("0418", "И");
	СоответствиеСимволов.Вставить("0438", "и");
	СоответствиеСимволов.Вставить("0419", "Й");
	СоответствиеСимволов.Вставить("0439", "й");
	СоответствиеСимволов.Вставить("041a", "К");
	СоответствиеСимволов.Вставить("043a", "к");
	СоответствиеСимволов.Вставить("041b", "Л");
	СоответствиеСимволов.Вставить("043b", "л");
	СоответствиеСимволов.Вставить("041c", "М");
	СоответствиеСимволов.Вставить("043c", "м");
	СоответствиеСимволов.Вставить("041d", "Н");
	СоответствиеСимволов.Вставить("043d", "н");
	СоответствиеСимволов.Вставить("041e", "О");
	СоответствиеСимволов.Вставить("043e", "о");
	СоответствиеСимволов.Вставить("041f", "П");
	СоответствиеСимволов.Вставить("043f", "п");
	СоответствиеСимволов.Вставить("0420", "Р");
	СоответствиеСимволов.Вставить("0440", "р");
	СоответствиеСимволов.Вставить("0421", "С");
	СоответствиеСимволов.Вставить("0441", "с");
	СоответствиеСимволов.Вставить("0422", "Т");
	СоответствиеСимволов.Вставить("0442", "т");
	СоответствиеСимволов.Вставить("0423", "У");
	СоответствиеСимволов.Вставить("0443", "у");
	СоответствиеСимволов.Вставить("0424", "Ф");
	СоответствиеСимволов.Вставить("0444", "ф");
	СоответствиеСимволов.Вставить("0425", "Х");
	СоответствиеСимволов.Вставить("0445", "х");
	СоответствиеСимволов.Вставить("0426", "Ц");
	СоответствиеСимволов.Вставить("0446", "ц");
	СоответствиеСимволов.Вставить("0427", "Ч");
	СоответствиеСимволов.Вставить("0447", "ч");
	СоответствиеСимволов.Вставить("0428", "Ш");
	СоответствиеСимволов.Вставить("0448", "ш");
	СоответствиеСимволов.Вставить("0429", "Щ");
	СоответствиеСимволов.Вставить("0449", "щ");
	СоответствиеСимволов.Вставить("042a", "Ъ");
	СоответствиеСимволов.Вставить("044a", "ъ");
	СоответствиеСимволов.Вставить("042b", "Ы");
	СоответствиеСимволов.Вставить("044b", "ы");
	СоответствиеСимволов.Вставить("042c", "Ь");
	СоответствиеСимволов.Вставить("044c", "ь");
	СоответствиеСимволов.Вставить("042d", "Э");
	СоответствиеСимволов.Вставить("044d", "э");
	СоответствиеСимволов.Вставить("042e", "Ю");
	СоответствиеСимволов.Вставить("044e", "ю");
	СоответствиеСимволов.Вставить("042f", "Я");
	СоответствиеСимволов.Вставить("044f", "я");	
	
	Возврат СоответствиеСимволов;
	
КонецФункции

&НаКлиенте
Функция ЛокЯдро_ОчиститьНедопустимыеСимволыXML(СтрокаXML)
	
	#Если НЕ ВебКлиент Тогда
		ПозицияСимвола = НайтиНедопустимыеСимволыXML(СтрокаXML);
		Пока ПозицияСимвола <> 0 Цикл
			НедопустимыйСимвол 	= Сред(СтрокаXML, ПозицияСимвола, 1);
			СтрокаXML 			= СтрЗаменить(СтрокаXML, НедопустимыйСимвол, "");
			ПозицияСимвола 		= НайтиНедопустимыеСимволыXML(СтрокаXML);
		КонецЦикла;
	#КонецЕсли		

	Возврат СтрокаXML;
	
КонецФункции

&НаКлиенте
Функция ЛокЯдро_РасшифроватьGZIP(ЗашифрованныеДвоичныеДанные)

	// Получение сжатого тела из GZIP
	Поток = ЗашифрованныеДвоичныеДанные.ОткрытьПотокДляЧтения();
	Поток.Перейти(10, ПозицияВПотоке.Начало);
	БуферТелаФайла = Новый БуферДвоичныхДанных(Поток.Размер() - 10);
	Поток.Прочитать(БуферТелаФайла, 0, Поток.Размер() - 18);
	
	// Получение CRC(Контрольного хэша файла)
	БуферCRC = Новый БуферДвоичныхДанных(4);
	Поток.Перейти(Поток.Размер() - 8, ПозицияВПотоке.Начало);
	Поток.Прочитать(БуферCRC, 0, 4);
	CRC = БуферCRC.ПрочитатьЦелое32(0);
	
	// Получение размера несжатого файла
	БуферРазмерНесжатого = Новый БуферДвоичныхДанных(4);
	Поток.Перейти(Поток.Размер() - 4, ПозицияВПотоке.Начало);
	Поток.Прочитать(БуферРазмерНесжатого, 0, 4);
	РазмерРаспакованногоФайла = БуферРазмерНесжатого.ПрочитатьЦелое32(0);
	
	Поток.Закрыть();
	
	ПотокВПамяти = Новый ПотокВПамяти(БуферТелаФайла);
	
	// Формирование валидной ZIP структуры
	
	#Если ВебКлиент Тогда
		ПолноеИмяСжатогоФайла = ЛокЯдро_ПолучитьИмяВременногоФайла("json");
	#Иначе
		ПолноеИмяСжатогоФайла = ПолучитьИмяВременногоФайла("json");
	#КонецЕсли
	ИмяСжатогоФайла 		= Сред(ПолноеИмяСжатогоФайла, ЛокЯдро_СтрНайти(ПолноеИмяСжатогоФайла, ПолучитьРазделительПути(), "СКонца") + 1); // "body.json";
	ДлинаИмениСжатогоФайла	= СтрДлина(ИмяСжатогоФайла);
	РазмерСжатогоФайла		= ПотокВПамяти.Размер();
	ВремяФайла				= 0;
	ДатаФайла				= 0;
	
	РазмерZIP 	  = 98 + ДлинаИмениСжатогоФайла * 2 + РазмерСжатогоФайла; // 98 Байт - заголовки, Длина файла * 2, Размер сжатого тела файла
	БинарныйБуфер = Новый БуферДвоичныхДанных(РазмерZIP);
	
	// [Local File Header]
	ДлинаФиксированнойЧастиLFH = 30;
	
	БинарныйБуфер.ЗаписатьЦелое32(0	, 67324752);					// Обязательная сигнатура 0x04034B50
	БинарныйБуфер.ЗаписатьЦелое16(4	, 20); 							// Минимальная версия для распаковки
	БинарныйБуфер.ЗаписатьЦелое16(6	, 2050);						// Битовый флаг
	БинарныйБуфер.ЗаписатьЦелое16(8	, 8); 							// Метод сжатия (0 - без сжатия, 8 - deflate)
	БинарныйБуфер.ЗаписатьЦелое16(10, ВремяФайла); 					// Время модификации файла
	БинарныйБуфер.ЗаписатьЦелое16(12, ДатаФайла); 					// Дата модификации файла
	БинарныйБуфер.ЗаписатьЦелое32(14, CRC);							// Контрольная сумма
	БинарныйБуфер.ЗаписатьЦелое32(18, РазмерСжатогоФайла);			// Сжатый размер
	БинарныйБуфер.ЗаписатьЦелое32(22, РазмерРаспакованногоФайла);	// Несжатый размер
	БинарныйБуфер.ЗаписатьЦелое16(26, ДлинаИмениСжатогоФайла);		// Длина название файла
	БинарныйБуфер.ЗаписатьЦелое16(28, 0);							// Длина поля с дополнительными данными
	
	// Название файла
	Для ПозицияСимвола = 0 По ДлинаИмениСжатогоФайла - 1 Цикл
		БинарныйБуфер.Установить(ДлинаФиксированнойЧастиLFH + ПозицияСимвола, КодСимвола(Сред(ИмяСжатогоФайла, ПозицияСимвола + 1, 1)));
	КонецЦикла;
	
	// Сжатые данные
	БуферСжатыхДанных = Новый БуферДвоичныхДанных(РазмерСжатогоФайла);
	
	ПотокВПамяти.Прочитать(БуферСжатыхДанных, 0, РазмерСжатогоФайла);
	ПотокВПамяти.Закрыть();
	
	БинарныйБуфер.Записать(ДлинаФиксированнойЧастиLFH + ДлинаИмениСжатогоФайла, БуферСжатыхДанных);
	
	ТекущееСмещение = ДлинаФиксированнойЧастиLFH + ДлинаИмениСжатогоФайла + РазмерСжатогоФайла;
	
	// [Central directory file header]
	ДлинаФиксированнойЧастиCDFH	= 46;
	ДлинаДополнительныхДанных	= 0;
	
	БинарныйБуфер.ЗаписатьЦелое32(ТекущееСмещение + 0	, 33639248);					//Обязательная сигнатура 0x02014B50
	БинарныйБуфер.ЗаписатьЦелое16(ТекущееСмещение + 4	, 814); 						//Версия для создания
	БинарныйБуфер.ЗаписатьЦелое16(ТекущееСмещение + 6	, 20); 							//Минимальная версия для распаковки
	БинарныйБуфер.ЗаписатьЦелое16(ТекущееСмещение + 8	, 2050);						//Битовый флаг
	БинарныйБуфер.ЗаписатьЦелое16(ТекущееСмещение + 10	, 8); 							//Метод сжатия (0 - без сжатия, 8 - deflate)
	БинарныйБуфер.ЗаписатьЦелое16(ТекущееСмещение + 12	, ВремяФайла); 					//Время модификации файла
	БинарныйБуфер.ЗаписатьЦелое16(ТекущееСмещение + 14	, ДатаФайла); 					//Дата модификации файла
	БинарныйБуфер.ЗаписатьЦелое32(ТекущееСмещение + 16	, CRC);							//Контрольная сумма
	БинарныйБуфер.ЗаписатьЦелое32(ТекущееСмещение + 20	, РазмерСжатогоФайла);			//Сжатый размер
	БинарныйБуфер.ЗаписатьЦелое32(ТекущееСмещение + 24	, РазмерРаспакованногоФайла);	//Несжатый размер
	БинарныйБуфер.ЗаписатьЦелое16(ТекущееСмещение + 28	, ДлинаИмениСжатогоФайла);		//Длина название файла
	БинарныйБуфер.ЗаписатьЦелое16(ТекущееСмещение + 30	, ДлинаДополнительныхДанных);	//Длина поля с дополнительными данными
	БинарныйБуфер.ЗаписатьЦелое16(ТекущееСмещение + 32	, 0);							//Длина комментариев к файлу
	БинарныйБуфер.ЗаписатьЦелое16(ТекущееСмещение + 34	, 0);							//Номер диска
	БинарныйБуфер.ЗаписатьЦелое16(ТекущееСмещение + 36	, 0);							//Внутренние аттрибуты файла
	БинарныйБуфер.ЗаписатьЦелое32(ТекущееСмещение + 38	, 2176057344);					//Внешние аттрибуты файла
	БинарныйБуфер.ЗаписатьЦелое32(ТекущееСмещение + 42	, 0);							//Смещение до структуры LocalFileHeader
	
	// Название файла
	Для ПозицияСимвола = 0 По ДлинаИмениСжатогоФайла - 1 Цикл
		БинарныйБуфер.Установить(ТекущееСмещение + ДлинаФиксированнойЧастиCDFH + ПозицияСимвола, КодСимвола(Сред(ИмяСжатогоФайла, ПозицияСимвола + 1, 1)));
	КонецЦикла;
	
	ТекущееСмещение = ТекущееСмещение + ДлинаФиксированнойЧастиCDFH + ДлинаИмениСжатогоФайла;
	
	ТекущееСмещение = ТекущееСмещение + ДлинаДополнительныхДанных;
	
	// [End of central directory record (EOCD)]
	РазмерCentralDirectory		= ДлинаФиксированнойЧастиCDFH + ДлинаИмениСжатогоФайла + ДлинаДополнительныхДанных;
	СмещениеCentralDirectory	= ДлинаФиксированнойЧастиLFH  + ДлинаИмениСжатогоФайла + РазмерСжатогоФайла;
	
	БинарныйБуфер.ЗаписатьЦелое32(ТекущееСмещение + 0	, 101010256);					//Обязательная сигнатура 0x06054B50
	БинарныйБуфер.ЗаписатьЦелое16(ТекущееСмещение + 4	, 0); 							//Номер диска
	БинарныйБуфер.ЗаписатьЦелое16(ТекущееСмещение + 6	, 0); 							//Номер диска, где находится начало Central Directory
	БинарныйБуфер.ЗаписатьЦелое16(ТекущееСмещение + 8	, 1); 							//Количество записей в Central Directory в текущем диске
	БинарныйБуфер.ЗаписатьЦелое16(ТекущееСмещение + 10	, 1); 							//Всего записей в Central Directory
	БинарныйБуфер.ЗаписатьЦелое32(ТекущееСмещение + 12	, РазмерCentralDirectory);		//Размер Central Directory
	БинарныйБуфер.ЗаписатьЦелое32(ТекущееСмещение + 16	, СмещениеCentralDirectory);	//Смещение Central Directory
	БинарныйБуфер.ЗаписатьЦелое16(ТекущееСмещение + 20	, 0);							//Длина комментария
	
	КаталогВременныхФайлов = КаталогВременныхФайлов(); // КаталогВременныхФайлов() + ПолучитьРазделительПути() + "GZIP";
	                   
	ПотокВПамяти = Новый ПотокВПамяти(БинарныйБуфер);
	Файл = Новый ЧтениеZipФайла(ПотокВПамяти);
	#Если ВебКлиент Тогда
		Файл.Извлечь(Файл.Элементы[0], КаталогВременныхФайлов);
	#Иначе
		Файл.Извлечь(Файл.Элементы[0], КаталогВременныхФайлов, РежимВосстановленияПутейФайловZIP.НеВосстанавливать);
	#КонецЕсли
	ПотокВПамяти.Закрыть();
	
	// Чтение текста
	ЧтениеТекста = Новый ЧтениеТекста(ПолноеИмяСжатогоФайла); // Новый ЧтениеТекста(КаталогВременныхФайлов + ПолучитьРазделительПути() + "body.json");
	Текст = ЧтениеТекста.Прочитать();
	ЧтениеТекста.Закрыть();
	
	УдалитьФайлы(ПолноеИмяСжатогоФайла);
	
	Возврат Текст;
	
КонецФункции	

&НаКлиенте
Функция ЛокЯдро_ЗашифроватьGZIP(ИсходнаяСтрока)

	#Если ВебКлиент Тогда
		ИмяТекстовогоФайла = ЛокЯдро_ПолучитьИмяВременногоФайла("json");
	#Иначе
		ИмяТекстовогоФайла = ПолучитьИмяВременногоФайла("json");
	#КонецЕсли
	ЗаписьТекста = Новый ЗаписьТекста(ИмяТекстовогоФайла,"UTF-8",,,Символы.ПС);
	ЗаписьТекста.Записать(ИсходнаяСтрока);
	ЗаписьТекста.Закрыть();
	
	#Если ВебКлиент Тогда
		ИмяЗипФайла = ЛокЯдро_ПолучитьИмяВременногоФайла("zip");
		Сжатие = Новый ЗаписьZipФайла(ИмяЗипФайла); // УровеньСжатияZIP - по умолчанию Оптимальный
	#Иначе
		ИмяЗипФайла = ПолучитьИмяВременногоФайла("zip");
		Сжатие = Новый ЗаписьZipФайла(ИмяЗипФайла,,,, УровеньСжатияZIP.Максимальный);
	#КонецЕсли
	Сжатие.Добавить(ИмяТекстовогоФайла);
	Сжатие.Записать();
	
	ЧтениеДанных = Новый ЧтениеДанных(ИмяЗипФайла, КодировкаТекста.UTF8);
	
	Сигнатура 					= ЧтениеДанных.ПрочитатьЦелое32();
	Версия 						= ЧтениеДанных.ПрочитатьЦелое16();
	БитФлаг 					= ЧтениеДанных.ПрочитатьЦелое16();
	МетодКомпрессии 			= ЧтениеДанных.ПрочитатьЦелое16();
	ВремяМодификации 			= ЧтениеДанных.ПрочитатьЦелое16();
	ДатаМодификации 			= ЧтениеДанных.ПрочитатьЦелое16();
	КонтрольнаяСумма 			= ЧтениеДанных.ПрочитатьЦелое32();
	РазмерСжатогоФайла			= ЧтениеДанных.ПрочитатьЦелое32();
	РаспакованныйРазмер 		= ЧтениеДанных.ПрочитатьЦелое32();
	ДлинаИмениФайла 			= ЧтениеДанных.ПрочитатьЦелое16();
	ДлинаДополнительныхПолей 	= ЧтениеДанных.ПрочитатьЦелое16();
	
	ЧтениеДанных.Пропустить(ДлинаИмениФайла + ДлинаДополнительныхПолей);
	РезультатЧтения = ЧтениеДанных.Прочитать(РазмерСжатогоФайла);
	
	СжатыйБуфер = РезультатЧтения.ПолучитьБуферДвоичныхДанных();
	
	СигнатураГзип 			= 35615; // 2 байта
	МетодСжатияДефлейт 		= 8;	 // 1 байт
	ФлагМетодаКомпрессии 	= 2; 	 // 1 байт
	
	БуферГзипНачало = Новый БуферДвоичныхДанных(10);
	БуферГзипНачало.ЗаписатьЦелое16(0, СигнатураГзип);
	БуферГзипНачало.Установить(2, МетодСжатияДефлейт);
	БуферГзипНачало.Установить(8, ФлагМетодаКомпрессии);
	
	БуферГзипКонец = Новый БуферДвоичныхДанных(8);
	БуферГзипКонец.ЗаписатьЦелое32(0, КонтрольнаяСумма);
	БуферГзипКонец.ЗаписатьЦелое32(4, РаспакованныйРазмер);
	
	БуферРезультат = БуферГзипНачало.Соединить(СжатыйБуфер).Соединить(БуферГзипКонец);
	Поток = Новый ПотокВПамяти(БуферРезультат);
	СжатыеДанные = Поток.ЗакрытьИПолучитьДвоичныеДанные();
	
	ЧтениеДанных.Закрыть();
	
	УдалитьФайлы(ИмяТекстовогоФайла);
	УдалитьФайлы(ИмяЗипФайла);
	
	Возврат СжатыеДанные;
	
КонецФункции

&НаСервереБезКонтекста
Функция ЛокЯдро_ПолучитьИмяВременногоФайла(Расширение)
	Возврат ПолучитьИмяВременногоФайла(Расширение);
КонецФункции

&НаКлиенте
Процедура ЛокЯдро_ПреобразоватьUni(МассивИлиСоответствие)
	// Если приходит массив, то находим в каждой структуре реквизит Uni
	Если ТипЗнч(МассивИлиСоответствие) = Тип("Массив") Тогда
		Для Каждого Структура Из МассивИлиСоответствие Цикл
			Если ТипЗнч(Структура) = Тип("Структура") 
				И Структура.Свойство("Uni") Тогда
				Структура.Uni = ЛокЯдро_ПреобразоватьПервыйСимволВНижнийРегистр(Структура.Uni);
			КонецЕсли;
		КонецЦикла;
	// Если приходит соответствие, то преобразовываем значение каждого элемента соответствия
	ИначеЕсли ТипЗнч(МассивИлиСоответствие) = Тип("Соответствие") Тогда
		Для Каждого Элемент Из МассивИлиСоответствие Цикл
			МассивИлиСоответствие.Вставить(Элемент.Ключ, ЛокЯдро_ПреобразоватьПервыйСимволВНижнийРегистр(Элемент.Значение));
		КонецЦикла;
	КонецЕсли;
КонецПроцедуры

&НаКлиенте
Функция ЛокЯдро_ПреобразоватьПервыйСимволВНижнийРегистр(Строка)
 	Возврат	НРег(Лев(Строка,1))+Сред(Строка,2,СтрДлина(Строка)-1);
КонецФункции

// Вызывает из модуля обработки функцию получения ссылки на элемент справочника по уникальному идентификатору
//
// Параметры:
//	ИмяСправочника - Строка, Массив - имя справочника в метаданных либо массив имен
//	ID - Строка - уникальный идентификатор ссылки в строковом представлении
//
// Возвращаемое значение:
//	СправочникСсылка - ссылка на найденный по ID элемент справочника
&НаКлиенте
Функция ЛокЯдро_ПолучитьЗначениеСправочникаПоID(ИмяСправочника, ID) Экспорт
	
	ЗначениеСправочникаИзКэша = ЛокЯдро_ПолучитьЗначениеСсылкиИзКэша(ИмяСправочника, ID);
	Если ЗначениеЗаполнено(ЗначениеСправочникаИзКэша) Тогда
		Возврат ЗначениеСправочникаИзКэша;
	КонецЕсли;
	
	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода", 		"Функция");
	СтруктураВызова.Вставить("ИмяМетода", 		"ПолучитьЗначениеСправочникаПоID");
	СтруктураВызова.Вставить("ПараметрыМетода", Новый Структура);
	
	СтруктураВызова.ПараметрыМетода.Вставить("ИмяСправочника"	, ИмяСправочника);
	СтруктураВызова.ПараметрыМетода.Вставить("ID"				, ID);
	
	ЗначениеПоID = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова);
	
	Если ЗначениеЗаполнено(ЗначениеПоID) Тогда
		ЛокЯдро_ДобавитьЗначениеСсылкиВКэш(ИмяСправочника, ID, ЗначениеПоID); 
	КонецЕсли;
	
	Возврат ЗначениеПоID;
	
КонецФункции

&НаКлиенте
Функция ЛокЯдро_ПолучитьЗначениеСсылкиИзКэша(ИмяОбъектаМетаданных, ID)

	Если КэшЗначенийПолученныхПоID = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ЗначениеИзКэша = Неопределено;
	
	СсылкиПроверяемогоТипа = КэшЗначенийПолученныхПоID.Получить(ИмяОбъектаМетаданных);
	Если СсылкиПроверяемогоТипа <> Неопределено Тогда
		ЗначениеИзКэша = СсылкиПроверяемогоТипа.Получить(ID);
	КонецЕсли;
	
	Возврат ЗначениеИзКэша;
	
КонецФункции

&НаКлиенте
Процедура ЛокЯдро_ДобавитьЗначениеСсылкиВКэш(ИмяОбъектаМетаданных, ID, ЗначениеСсылки)
	
	Если КэшЗначенийПолученныхПоID = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	СсылкиПроверяемогоТипа = КэшЗначенийПолученныхПоID.Получить(ИмяОбъектаМетаданных);
	Если СсылкиПроверяемогоТипа = Неопределено Тогда
		ЗначениеКэша = Новый Соответствие;
		ЗначениеКэша.Вставить(ID, ЗначениеСсылки);
		
		КэшЗначенийПолученныхПоID.Вставить(ИмяОбъектаМетаданных, ЗначениеКэша);
	Иначе
		СсылкиПроверяемогоТипа.Вставить(ID, ЗначениеСсылки);
	КонецЕсли;
	
КонецПроцедуры
          
&НаКлиенте
Функция ЛокЯдро_ПолучитьСписокСлужебныхДокументовMS() Экспорт

	ТипБазы 		= ?(ЕстьЧастнаяБаза, "Частная", "Основная");		
	ТипИнтерфейса 	= ЛокЯдро_ПолучитьТипИнтерфейса(ТипБазы);	

	#Если ВебКлиент Тогда    
		СтруктураВызова = Новый Структура;
		СтруктураВызова.Вставить("ТипМетода", "Функция");
		СтруктураВызова.Вставить("ИмяМетода", "ПолучитьСписокСлужебныхДокументовMS");	
		
		ПараметрыМетода = Новый Структура;
		ПараметрыМетода.Вставить("ТипБазы", 		ТипБазы);           
		ПараметрыМетода.Вставить("ТипИнтерфейса", 	ТипИнтерфейса);
		
		СтруктураВызова.Вставить("ПараметрыМетода", ПараметрыМетода);
		
		пСтруктураСлужебныхДокументов = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,,АдресаПеременных);
	#Иначе
		Если РасположениеКомпоненты = "НаСервере" Тогда
			СтруктураВызова = Новый Структура;
			СтруктураВызова.Вставить("ТипМетода", "Функция");
			СтруктураВызова.Вставить("ИмяМетода", "ПолучитьСписокСлужебныхДокументовMS");	
			
			ПараметрыМетода = Новый Структура;
			ПараметрыМетода.Вставить("ТипБазы", 		ТипБазы);           
			ПараметрыМетода.Вставить("ТипИнтерфейса", 	ТипИнтерфейса);
			
			СтруктураВызова.Вставить("ПараметрыМетода", ПараметрыМетода);
			
			пСтруктураСлужебныхДокументов = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,,АдресаПеременных);	
		Иначе	
			Если ТипИнтерфейса = "REST_API" Тогда
				пСтруктураСлужебныхДокументов = REST_API_ПолучитьСписокСлужебныхДокументовMS("Основная");
			Иначе
				пСтруктураСлужебныхДокументов = КомЯдро_ПолучитьСписокСлужебныхДокументовMS("Основная");
			КонецЕсли;
		КонецЕсли; 
	#КонецЕсли
		
	Возврат пСтруктураСлужебныхДокументов;
	
КонецФункции

&НаКлиенте
Процедура ЛокЯдро_ОбновитьМетаданныеПользователейMS() Экспорт

	ТипБазы 		= ?(ЕстьЧастнаяБаза, "Частная", "Основная");		
	ТипИнтерфейса 	= ЛокЯдро_ПолучитьТипИнтерфейса(ТипБазы);	

	#Если ВебКлиент Тогда		
		СтруктураВызова = Новый Структура;
		СтруктураВызова.Вставить("ТипМетода", "Функция");
		СтруктураВызова.Вставить("ИмяМетода", "ОбновитьМетаданныеПользователейMS");	
		
		ПараметрыМетода = Новый Структура;
		ПараметрыМетода.Вставить("ТипБазы", 		ТипБазы);           
		ПараметрыМетода.Вставить("ТипИнтерфейса", 	ТипИнтерфейса);
		
		СтруктураВызова.Вставить("ПараметрыМетода", ПараметрыМетода);
		
		Результат = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,,АдресаПеременных);	
		
		СтруктураМетаданных.Вставить("ПользователиMS", Результат);
	#Иначе
		ТипИнтерфейса = КомЯдро_ПолучитьЗначениеПеременной("ТипИнтерфейса");
		Если ТипИнтерфейса = "REST_API" Тогда
			REST_API_ОбновитьМетаданныеПользователейMS("Основная");
		Иначе
			КомЯдро_ОбновитьМетаданныеПользователейMS("Основная");
		КонецЕсли;
	#КонецЕсли
	
КонецПроцедуры

&НаКлиенте
Процедура ЛокЯдро_ОбновитьМетаданныеПользователейMSВХранилище1С(СписокПользователейMS, ПользователиMSАдрес)

	Если ТипЗнч(СтруктураМетаданных) <> Тип("Структура") Тогда
		Возврат;		
	КонецЕсли;
	
	ИдентификаторБазыMS = "";
	
	Если ПараметрыПодключенияMS = Неопределено Тогда
		ПараметрыПодключенияMS = ЛокЯдро_ПолучитьДанныеИзХранилища1С("Cleverence_ПараметрыПодключенияMS");	
	КонецЕсли;
	
	Если ТипЗнч(ПараметрыПодключенияMS) = Тип("Структура") Тогда
		ИдентификаторБазыMS = ?(ПараметрыПодключенияMS.Свойство("Ид"), ПараметрыПодключенияMS.Ид, "");
		ИдентификаторБазыMS = СтрЗаменить(ИдентификаторБазыMS, "-", "_");
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(ИдентификаторБазыMS) Тогда
		Возврат;	
	КонецЕсли;	
	
	ИмяПеременнойНастройки 	= "Cleverence_СтруктураМетаданныхMS_" + ИдентификаторБазыMS;
	
	СтруктураМетаданных.Вставить("ПользователиMS", СписокПользователейMS);
	
	ЛокЯдро_СохранитьДанныеВХранилище1С(ИмяПеременнойНастройки, СтруктураМетаданных);
		
	СтруктураМетаданных.Вставить("ПользователиMS", ПользователиMSАдрес);
	
	КомЯдро_СохранитьЗначениеПеременной("СтруктураМетаданных", СтруктураМетаданных);
	
КонецПроцедуры	

#Область REST_API

&НаКлиенте
Функция REST_API_ПолучитьОписаниеБазы(ТипБазы,АдресаПеременных)
	
	ИмяСобытия = "REST_API_ПолучитьОписаниеБазы";
	
	Если ТипБазы = "Частная" Тогда
		КлючПеременной = "REST_API_СтруктураПодключенияЧастнойБазыMS";
	ИначеЕсли ТипБазы = "Временная" Тогда
		КлючПеременной = "REST_API_СтруктураПодключенияВременнойБазыMS";
	Иначе
		КлючПеременной = "REST_API_СтруктураПодключенияБазыMS";
	КонецЕсли;
	
	СтруктураПодключения = КомЯдро_ПолучитьЗначениеПеременной(КлючПеременной); 
	
	Если СтруктураПодключения = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключения,Новый Структура("HTTPМетод,Метод,ТипЗапроса","GET","BaseInfo","ПолучениеМетаданных"),,АдресаПеременных);
	
	Если СтруктураОтвета.КодСостояния <> 200 Тогда
		ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Запрос: GET, BaseInfo. Получен некорректный ответ от сервера, Код состояния: " + Строка(СтруктураОтвета.КодСостояния)+ ". Содержание ошибки: " + Строка(СтруктураОтвета.ТекстОшибки));
		Возврат Неопределено;
	КонецЕсли;
	
	Если НЕ СтруктураОтвета.Свойство("ОтветСервера") Тогда
		ТекстОшибки = "Произошла ошибка при подключении к базе Mobile SMARTS. Подробности см. в журнале регистрации";
		ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Запрос: GET, BaseInfo. " + ТекстОшибки);
		Возврат Неопределено;
	КонецЕсли;
	
	СтрокаПодключения = СтруктураПодключения.СтрокаПодключенияСМАРТС;
	
	ОписаниеБазы = СтруктураОтвета.ОтветСервера;	
	СтруктураДанныеБазы = Новый Структура;
	
	СтруктураДанныеБазы.Вставить("Ид", ОписаниеБазы.Получить("id"));
	СтруктураДанныеБазы.Вставить("Имя", ОписаниеБазы.Получить("name"));
	СтруктураДанныеБазы.Вставить("Комментарий", ОписаниеБазы.Получить("comment"));
	СтруктураДанныеБазы.Вставить("СтрокаПодключения", СтрокаПодключения);
	СтруктураДанныеБазы.Вставить("РабочийКаталог", ОписаниеБазы.Получить("folder"));
	СтруктураДанныеБазы.Вставить("ИдПриложения", ОписаниеБазы.Получить("appId"));		
	СтруктураДанныеБазы.Вставить("ИмяПриложения", ОписаниеБазы.Получить("appName"));
	СтруктураДанныеБазы.Вставить("УровеньПриложения", 100);//ОписаниеБазы.Получить("appLevel")); Пока не реализованно
	СтруктураДанныеБазы.Вставить("ИдОсновногоПриложения", Неопределено);//ОписаниеБазы.Приложение.ParentId); Пока не реализованно
	СтруктураДанныеБазы.Вставить("ПапкаОбмена", "");//НастройкиБазыСМАРТС.ПолучитьТекущуюПапкуОбмена()); Пока не реализованно
	ИнформацияОПродукте = ЛокЯдро_ПолучитьИнформациюОПродукте(СтруктураДанныеБазы.ИдПриложения,СтруктураДанныеБазы.ИдОсновногоПриложения);
	СтруктураДанныеБазы.Вставить("УровеньПриложенияСтрокой",	?(ЗначениеЗаполнено(ИнформацияОПродукте.УровеньПриложения), ИнформацияОПродукте.УровеньПриложения, ЛокЯдро_ПолучитьУровеньПриложения(СтруктураДанныеБазы.УровеньПриложения)));
	СтруктураДанныеБазы.Вставить("ТипУстановленногоПродукта",	ИнформацияОПродукте.ТипУстановленногоПродукта);
	СтруктураДанныеБазы.Вставить("АвторизацияВключена", 		Ложь);
	СтруктураДанныеБазы.Вставить("АвторизацияЛогин", 			"");
	СтруктураДанныеБазы.Вставить("АвторизацияТокен", 			"");
	СтруктураДанныеБазы.Вставить("АвторизацияРефрешТокен",		"");
	СтруктураДанныеБазы.Вставить("СтрокаПодключенияСМАРТС",		СтрокаПодключения);
	СтруктураДанныеБазы.Вставить("IdBaseSMARTS", 				ОписаниеБазы.Получить("id"));
	СтруктураДанныеБазы.Вставить("QR", 							ОписаниеБазы.Получить("connectionQRCode"));
	СтруктураДанныеБазы.Вставить("ВерсияПриложения",			ОписаниеБазы.Получить("appDescription").Получить("appVersion"));
	СтруктураДанныеБазы.Вставить("ВерсияКонфигурацииSMARTS",	ОписаниеБазы.Получить("configurationVersion"));
	
	Если НЕ ЗначениеЗаполнено(СтруктураДанныеБазы.ИмяПриложения) Тогда
		СтруктураДанныеБазы.Вставить("ИмяПриложения", ОписаниеБазы.Получить("appDescription").Получить("appName"));	
	КонецЕсли;
	
	appInstanceSettings = ОписаниеБазы.Получить("appInstanceSettings");
	Если appInstanceSettings <> Неопределено Тогда
		// СтруктураДанныеБазы.АвторизацияВключена = appInstanceSettings.Получить("hasServerAuth"); // Устаревшее свойство
		mode = appInstanceSettings.Получить("mode");
		СтруктураДанныеБазы.Вставить("РаботаСУстройствомНапрямую", mode = "Device");
		СтруктураДанныеБазы.Вставить("РаботаСКаталогом", mode = "Folder");
		СтруктураДанныеБазы.Вставить("РаботаССервером", mode = "Server");
		СтруктураДанныеБазы.Вставить("РаботаСЛокальнымСервером", Неопределено);
		СтруктураДанныеБазы.Вставить("РаботаСУдаленнымСервером", Неопределено);
	КонецЕсли;
	
	Если СтруктураПодключения.Свойство("АвторизацияВключена")
		И СтруктураПодключения.АвторизацияВключена = Истина Тогда
		СтруктураДанныеБазы.АвторизацияВключена = Истина;
		Если СтруктураПодключения.Свойство("АвторизацияЛогин") Тогда
			СтруктураДанныеБазы.АвторизацияЛогин = СтруктураПодключения.АвторизацияЛогин;
		КонецЕсли;
		Если СтруктураПодключения.Свойство("АвторизацияТокен") Тогда
			СтруктураДанныеБазы.АвторизацияТокен = СтруктураПодключения.АвторизацияТокен;
		КонецЕсли;
		Если СтруктураПодключения.Свойство("АвторизацияРефрешТокен") Тогда
			СтруктураДанныеБазы.АвторизацияРефрешТокен = СтруктураПодключения.АвторизацияРефрешТокен;
		КонецЕсли;
	КонецЕсли;
	
	СтруктураНастроек = Новый Структура;
	СтруктураНастроек.Вставить("ИмяИнтеграционнойОбработкиКонфигурации1С", 	Неопределено);
	СтруктураНастроек.Вставить("ПутьИнтеграционнойОбработкиКонфигурации1С", Неопределено);
	СтруктураНастроек.Вставить("ТипОбработки", 								Неопределено);
	СтруктураНастроек.Вставить("ПутьОсновнойОбработки", 					Неопределено);
	СтруктураНастроек.Вставить("ТипОсновнойОбработки", 						Неопределено);
	
	REST_API_ЗаполнитьНастройкиSMARTS(СтруктураНастроек, Новый Массив, СтруктураПодключения);
	
	ИмяИнтеграционнойОбработки 	= СтруктураНастроек.ИмяИнтеграционнойОбработкиКонфигурации1С;
	ПутьИнтеграционнойОбработки = СтруктураНастроек.ПутьИнтеграционнойОбработкиКонфигурации1С;
	ТипОбработки 				= СтруктураНастроек.ТипОбработки;
	ПутьОсновнойОбработки 		= СтруктураНастроек.ПутьОсновнойОбработки;
	ТипОсновнойОбработки 		= СтруктураНастроек.ТипОсновнойОбработки;
		
	Если ТипОбработки = "СправочникСсылка" Тогда
		Попытка
			ПутьИО = ЛокЯдро_ЗначениеИзСтрокиXML(ПутьИнтеграционнойОбработки);
		Исключение
			ПутьИО = Неопределено;
		КонецПопытки;
	Иначе
		ПутьИО = ПутьИнтеграционнойОбработки;
	КонецЕсли;
	
	//Заплатка
	Если ТипЗнч(ПутьИО) = Тип("COMОбъект") Тогда
		ПутьИО = Неопределено;
	КонецЕсли;
	
	СтруктураДанныеБазы.Вставить("ТипОбработки",				ТипОбработки);
	СтруктураДанныеБазы.Вставить("ИмяИнтеграционнойОбработки", 	?(НЕ ЗначениеЗаполнено(ИмяИнтеграционнойОбработки), "", ИмяИнтеграционнойОбработки));
	СтруктураДанныеБазы.Вставить("ПутьИнтеграционнойОбработки", ?(НЕ ЗначениеЗаполнено(ИмяИнтеграционнойОбработки),"\Обработки 1С\Обработки интеграции\", ПутьИО));		
	
	Если ТипОсновнойОбработки = "СправочникСсылка" Тогда
		Попытка
			ПутьОО = ЛокЯдро_ЗначениеИзСтрокиXML(ПутьОсновнойОбработки);
		Исключение
			ПутьОО = Неопределено;
		КонецПопытки;
	Иначе
		ПутьОО = ПутьОсновнойОбработки;
	КонецЕсли;
	
	//Заплатка
	Если ТипЗнч(ПутьОО) = Тип("COMОбъект") Тогда
		ПутьОО = Неопределено;
	КонецЕсли;
	
	СтруктураДанныеБазы.Вставить("ТипОсновнойОбработки", 	ТипОсновнойОбработки);
	СтруктураДанныеБазы.Вставить("ПутьОсновнойОбработки", 	ПутьОО);		
	
	Возврат СтруктураДанныеБазы;
	
КонецФункции

&НаКлиенте
Функция REST_API_ПолучитьЗначениеНастройкиБазыSMARTS(СтруктураПодключения,КлючНастройки,АдресаПеременных)
	
	СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключения,Новый Структура("HTTPМетод,Метод,ТипЗапроса","GET",?(ЗначениеЗаполнено(КлючНастройки),"CustomSettings('"+КлючНастройки+"')","CustomSettings"),"ПолучениеСохранениеНастроек"),,АдресаПеременных);
	
	Если СтруктураОтвета.КодСостояния <> 200 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат СтруктураОтвета.ОтветСервера.Получить("value");	
	
КонецФункции

&НаКлиенте
Функция REST_API_ЗаполнитьНастройкиSMARTS(СтруктураНастроек, УзловыеНастройки, ID_Узла = "", ТипБазы = "Основная", СтруктураПодключения = Неопределено)
	
	ИмяСобытия = "REST_API_ЗаполнитьНастройкиSMARTS";
	
	Если СтруктураПодключения = Неопределено Тогда
		Если ТипБазы = "Частная" Тогда
			КлючПеременной = "REST_API_СтруктураПодключенияЧастнойБазыMS";
		ИначеЕсли ТипБазы = "Временная" Тогда
			КлючПеременной = "REST_API_СтруктураПодключенияВременнойБазыMS";
		Иначе
			КлючПеременной = "REST_API_СтруктураПодключенияБазыMS";
		КонецЕсли;
	
		СтруктураПодключения = КомЯдро_ПолучитьЗначениеПеременной(КлючПеременной); 
	КонецЕсли;
	
	Если СтруктураПодключения = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	//Пока не реализованно получение настроек по умолчанию
	Если Ложь И СтруктураНастроек.Количество() > 3 Тогда
		СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключения,Новый Структура("HTTPМетод,Метод,ТипЗапроса","GET","CustomSettings","ПолучениеСохранениеНастроек"),,АдресаПеременных);
		
		Если СтруктураОтвета.КодСостояния <> 200 Тогда
			ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Запрос: GET, CustomSettings. Получен некорректный ответ от сервера, Код состояния: " + Строка(СтруктураОтвета.КодСостояния)+ ". Содержание ошибки: " + Строка(СтруктураОтвета.ТекстОшибки));
			Возврат Неопределено;
		КонецЕсли;
		
		МассивНастроек = СтруктураОтвета.ОтветСервера.Получить("value");	
		Для каждого СоответствиеНастройка Из МассивНастроек Цикл
			ИтоговыйКлючНастройки = СоответствиеНастройка.Получить("name");
			Если УзловыеНастройки.Найти(ИтоговыйКлючНастройки) <> Неопределено Тогда
				ИтоговыйКлючНастройки = ИтоговыйКлючНастройки + ?(ID_Узла = "", "", "_"+ ID_Узла);
			КонецЕсли;
			
			Если СтруктураНастроек.Свойство(ИтоговыйКлючНастройки) Тогда
				ЗначениеНастройки = СоответствиеНастройка.Получить("value");
				// Для совместимости со старыми настройками
				Если ЗначениеНастройки = Неопределено 
					И Найти(ИтоговыйКлючНастройки,"ПроизвольныеКоды_")  > 0  Тогда
					ЗначениеНастройки = REST_API_ПолучитьЗначениеНастройкиБазыSMARTS(СтруктураПодключения,СтрЗаменить(ИтоговыйКлючНастройки,"ПроизвольныеКоды_","ПроизвольныйКод_"),АдресаПеременных);
				КонецЕсли;			
				// Для совместимости со старыми настройками
				Если ЗначениеНастройки = "Да" Тогда
					ЗначениеНастройки = Истина;
				ИначеЕсли ЗначениеНастройки = "Нет" Тогда
					ЗначениеНастройки = Ложь;	
				КонецЕсли;
				СтруктураНастроек.Вставить(ИтоговыйКлючНастройки,ЗначениеНастройки);	
			КонецЕсли;
		КонецЦикла;
	ИначеЕсли СтруктураНастроек.Количество() > 3 Тогда
		//Получение настроек по фильтру
		СтрокаФильтра = "?$filter=";
		ПервыйПараметр = Истина;
		Икс=0;
		МассивНастроек = Новый Массив;
		Для Каждого Настройка Из СтруктураНастроек Цикл
			ИтоговыйКлючНастройки = Настройка.Ключ;
			Если УзловыеНастройки.Найти(Настройка.Ключ) <> Неопределено Тогда
				ИтоговыйКлючНастройки = ИтоговыйКлючНастройки + ?(ID_Узла = "", "", "_"+ ID_Узла);
			КонецЕсли;
			СтрокаФильтра = СтрокаФильтра + ?(НЕ ПервыйПараметр ," or ", "") + "name eq '"+ ИтоговыйКлючНастройки + "'";
			Если ПервыйПараметр Тогда
				ПервыйПараметр = Ложь;
			КонецЕсли;
			Икс=Икс+1;
			Если Икс = 10 ИЛИ Икс = СтруктураНастроек.Количество() Тогда
				Если СтрокаФильтра = "?$filter=" Тогда
					ПервыйПараметр = Истина;
					Икс = 0;	
					Продолжить;
				КонецЕсли;
				СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключения,Новый Структура("HTTPМетод,Метод,ТипЗапроса","GET","CustomSettings"+СтрокаФильтра,"ПолучениеСохранениеНастроек"),,АдресаПеременных);
				СтрокаФильтра = "?$filter=";
				ПервыйПараметр = Истина;
				Икс=0;
				Если СтруктураОтвета.КодСостояния <> 200 Тогда
					Продолжить;
				КонецЕсли;
				МассивРезультат = СтруктураОтвета.ОтветСервера.Получить("value");
				Для каждого Настройка из МассивРезультат Цикл
					МассивНастроек.Добавить(Настройка);
				КонецЦикла;
			КонецЕсли;
		КонецЦикла;
		
		Если СтрокаФильтра <> "?$filter=" Тогда
			СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключения,Новый Структура("HTTPМетод,Метод,ТипЗапроса","GET","CustomSettings"+СтрокаФильтра, "ПолучениеСохранениеНастроек"),,АдресаПеременных);
			
			Если СтруктураОтвета.КодСостояния <> 200 Тогда
				ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Запрос: GET, CustomSettings" + СтрокаФильтра + ". Получен некорректный ответ от сервера, Код состояния: " + Строка(СтруктураОтвета.КодСостояния)+ ". Содержание ошибки: " + Строка(СтруктураОтвета.ТекстОшибки));
				//Возврат Неопределено;
			Иначе
				МассивРезультат = СтруктураОтвета.ОтветСервера.Получить("value");
				Для каждого Настройка из МассивРезультат Цикл
					МассивНастроек.Добавить(Настройка);
				КонецЦикла;	
			КонецЕсли;
		КонецЕсли;
		
		Для каждого СоответствиеНастройка Из МассивНастроек Цикл
			ИтоговыйКлючНастройки = СоответствиеНастройка.Получить("name");
			//Если УзловыеНастройки.Найти(ИтоговыйКлючНастройки) <> Неопределено Тогда
			//	ИтоговыйКлючНастройки = ИтоговыйКлючНастройки + ?(ID_Узла = "", "", "_"+ ID_Узла);
			//КонецЕсли;
			Если ID_Узла <> "" Тогда
				ИтоговыйКлючНастройки = СтрЗаменить(ИтоговыйКлючНастройки, "_"+ ID_Узла, "");
			КонецЕсли;
			
			Если СтруктураНастроек.Свойство(ИтоговыйКлючНастройки) Тогда
				ЗначениеНастройки = СоответствиеНастройка.Получить("value");
				// Для совместимости со старыми настройками
				Если ЗначениеНастройки = Неопределено 
					И Найти(ИтоговыйКлючНастройки,"ПроизвольныеКоды_")  > 0  Тогда
					ЗначениеНастройки = REST_API_ПолучитьЗначениеНастройкиБазыSMARTS(СтруктураПодключения,СтрЗаменить(ИтоговыйКлючНастройки,"ПроизвольныеКоды_","ПроизвольныйКод_"),АдресаПеременных);
				КонецЕсли;			
				// Для совместимости со старыми настройками
				Если ЗначениеНастройки = "Да" Тогда
					ЗначениеНастройки = Истина;
				ИначеЕсли ЗначениеНастройки = "Нет" Тогда
					ЗначениеНастройки = Ложь;	
				КонецЕсли;
				СтруктураНастроек.Вставить(ИтоговыйКлючНастройки, ЗначениеНастройки);
			КонецЕсли;
		КонецЦикла;
	Иначе
		Для Каждого Настройка Из СтруктураНастроек Цикл
			ИтоговыйКлючНастройки = Настройка.Ключ;
			Если УзловыеНастройки.Найти(Настройка.Ключ) <> Неопределено Тогда
				ИтоговыйКлючНастройки = ИтоговыйКлючНастройки + ?(ID_Узла = "", "", "_"+ ID_Узла);
			КонецЕсли;
			ЗначениеНастройки = REST_API_ПолучитьЗначениеНастройкиБазыSMARTS(СтруктураПодключения,ИтоговыйКлючНастройки,АдресаПеременных);
			// Для совместимости со старыми настройками
			Если ЗначениеНастройки = Неопределено 
				И Найти(ИтоговыйКлючНастройки,"ПроизвольныеКоды_")  > 0  Тогда
				ЗначениеНастройки = REST_API_ПолучитьЗначениеНастройкиБазыSMARTS(СтруктураПодключения,СтрЗаменить(ИтоговыйКлючНастройки,"ПроизвольныеКоды_","ПроизвольныйКод_"),АдресаПеременных);
			КонецЕсли;			
			// Для совместимости со старыми настройками
			Если ЗначениеНастройки = "Да" Тогда
				ЗначениеНастройки = Истина;
			ИначеЕсли ЗначениеНастройки = "Нет" Тогда
				ЗначениеНастройки = Ложь;	
			КонецЕсли;	
			СтруктураНастроек.Вставить(Настройка.Ключ, ?(ЗначениеНастройки = Неопределено, Ложь, ЗначениеНастройки));
		КонецЦикла;
	КонецЕсли;
	
	Возврат СтруктураНастроек;
	
КонецФункции

// Выполняет авторизацию в базе Mobile Smarts и возвращает токен авторизации при работе с типом интерфейса REST_API
//
// Параметры:
//	СтрокаПодключения - Строка - строка подключения к базе Mobile Smarts
//	Логин - Строка - логин авторизации
//	Пароль - Строка - пароль авторизации
//	ТипБазы - Строка - "Частная", "Временная", "Основная"
//
// Возвращаемое значение:
//	Строка - токен авторизации
&НаКлиенте
Функция REST_API_ПолучитьТокенSMARTS(СтрокаПодключения,Логин,Пароль,ТипБазы) Экспорт
	
	ИмяСобытия = "REST_API_ПолучитьТокенSMARTS";
	
	СтруктураURI = REST_API_ПолучитьСтруктуруURIИзСтроки(СтрокаПодключения);
	
	СтруктураПодключения = Новый Структура;
	СтруктураПодключения.Вставить("СтрокаПодключенияСМАРТС", СтрокаПодключения);
	
	Заголовки = Новый Соответствие();
	Заголовки.Вставить("Content-Type", "application/x-www-form-urlencoded");
	
	СтруктураЗапроса = Новый Структура;
	СтруктураЗапроса.Вставить("HTTPМетод", 		"POST");
	СтруктураЗапроса.Вставить("Метод", 	   		"connect/token");
	СтруктураЗапроса.Вставить("Заголовки", 		Заголовки);
	СтруктураЗапроса.Вставить("ВерсияAPI", 		"");
	СтруктураЗапроса.Вставить("СтрокаЗапроса",	"<Авторизация Mobile SMARTS>");
	
	ОтправляемыеДанные = "scope=all offline_access&username=" + Логин + "&password=" + Пароль + "&grant_type=password&client_id=ext_client&client_secret=ext_client_secret";
	
	СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключения,СтруктураЗапроса,ОтправляемыеДанные,АдресаПеременных);
	
	Если СтруктураОтвета <> Ложь И СтруктураОтвета.Свойство("ТекстОшибки") И ЗначениеЗаполнено(СтруктураОтвета.ТекстОшибки) Тогда
		ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации("REST_API_ВыполнитьМетод", "Ошибка", СтруктураОтвета.ТекстОшибки);
	КонецЕсли;	

	ТокенПолучен = Истина;
	Если СтруктураОтвета = Ложь
		ИЛИ СтруктураОтвета.КодСостояния <> 200 Тогда
		ТокенПолучен = Ложь;
	КонецЕсли;
	
	Если НЕ ТокенПолучен Тогда
		// Пробуем использовать старый алгоритм
		Заголовки = Новый Соответствие();
		Заголовки.Вставить("Content-Type", "application/json");
		
		СтруктураЗапроса = Новый Структура;
		СтруктураЗапроса.Вставить("HTTPМетод", 		"GET");
		СтруктураЗапроса.Вставить("Метод", 	   		"session?username=" + Логин + "&password=" + Пароль);
		СтруктураЗапроса.Вставить("Заголовки", 		Заголовки);
		СтруктураЗапроса.Вставить("СтрокаЗапроса",	"<Авторизация Mobile SMARTS>");
		
		СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключения, СтруктураЗапроса,, АдресаПеременных);
		
		Если СтруктураОтвета <> Ложь И СтруктураОтвета.Свойство("ТекстОшибки") И ЗначениеЗаполнено(СтруктураОтвета.ТекстОшибки) Тогда
			ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации("REST_API_ВыполнитьМетод", "Ошибка", СтруктураОтвета.ТекстОшибки);
		КонецЕсли;
			
		Если СтруктураОтвета = Ложь
			ИЛИ СтруктураОтвета.КодСостояния <> 200 Тогда
			Возврат Ложь;
		КонецЕсли;	
	КонецЕсли;
	
	Если ТипЗнч(СтруктураОтвета) <> Тип("Структура")
		ИЛИ НЕ СтруктураОтвета.Свойство("ОтветСервера") Тогда
		ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Произошла ошибка при получении токена авторизации. Подробности см. в журнале регистрации.");
		Возврат Ложь;
	КонецЕсли;
	
	REST_API_session = СтруктураОтвета.ОтветСервера;
	REST_API_session.Вставить("Логин",Логин);
	КомЯдро_СохранитьЗначениеПеременной("API_session_"+СтрЗаменить(СтрЗаменить(СтруктураURI.Хост,".","_"),"-","_")+"_"+Формат(СтруктураURI.Порт,"ЧГ=")+"_"+СтрЗаменить(СтруктураURI.ПутьНаСервере,"-",""),СтруктураОтвета.ОтветСервера);
	
	Access_token = СтруктураОтвета.ОтветСервера.Получить("Access_token");
	Если Access_token = Неопределено Тогда
		Access_token = СтруктураОтвета.ОтветСервера.Получить("access_token");
	КонецЕсли;
	Refresh_token = СтруктураОтвета.ОтветСервера.Получить("Refresh_token"); 
	Если Refresh_token = Неопределено Тогда
		Refresh_token = СтруктураОтвета.ОтветСервера.Получить("refresh_token"); 		
	КонецЕсли;
	
	СтруктураВозврата = Новый Структура("АвторизацияТокен, АвторизацияРефрешТокен", Access_token, Refresh_token);
	
	Возврат СтруктураВозврата;
	
КонецФункции

&НаКлиенте
Функция REST_API_ОбновитьТокенSMARTS(СтрокаПодключения, REST_API_Session = Неопределено, Refresh_token = "")
	
	ИмяСобытия = "REST_API_ОбновитьТокенSMARTS";
	
	Если REST_API_session = Неопределено
		И ПустаяСтрока(Refresh_token) Тогда
		Возврат Неопределено;	
	КонецЕсли;
	
	Логин = "";
	Если REST_API_Session <> Неопределено Тогда
		Refresh_token = REST_API_session.Получить("Refresh_token");
		Если Refresh_token = Неопределено Тогда
			Refresh_token = REST_API_session.Получить("refresh_token");	
		КонецЕсли;
		Логин = REST_API_session.Получить("Логин");
	КонецЕсли;		
		
	Если НЕ ЗначениеЗаполнено(Refresh_token) Тогда
		Возврат Неопределено;		
	КонецЕсли;
	
	СтруктураПодключения = Новый Структура;
	СтруктураПодключения.Вставить("СтрокаПодключенияСМАРТС", СтрокаПодключения);
	
	Заголовки = Новый Соответствие();
	Заголовки.Вставить("Content-Type", "application/x-www-form-urlencoded");
	
	СтруктураЗапроса = Новый Структура;
	СтруктураЗапроса.Вставить("HTTPМетод", 		"POST");
	СтруктураЗапроса.Вставить("Метод", 	   		"connect/token");
	СтруктураЗапроса.Вставить("Заголовки", 		Заголовки);
	СтруктураЗапроса.Вставить("ВерсияAPI", 		"");
	СтруктураЗапроса.Вставить("СтрокаЗапроса",	"<Авторизация Mobile SMARTS>");
	
	ОтправляемыеДанные = "scope=refresh_token offline_access&refresh_token=" + Refresh_token + "&grant_type=refresh_token&client_id=ext_client&client_secret=ext_client_secret";
	
	СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключения, СтруктураЗапроса, ОтправляемыеДанные, АдресаПеременных);          
	
	Если СтруктураОтвета = Ложь
		ИЛИ СтруктураОтвета.КодСостояния <> 200 Тогда
		Возврат Неопределено; // Не удалось обновить токен
	КонецЕсли;
	
	Если ТипЗнч(СтруктураОтвета) <> Тип("Структура")
		ИЛИ НЕ СтруктураОтвета.Свойство("ОтветСервера") Тогда
		ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Произошла ошибка при обновлении токена авторизации. Подробности см. в журнале регистрации.");
		Возврат Неопределено;
	КонецЕсли;
	
	СтруктураURI = REST_API_ПолучитьСтруктуруURIИзСтроки(СтрокаПодключения);
	
	// Обновляем REST_API_session
	REST_API_session = СтруктураОтвета.ОтветСервера;
	REST_API_session.Вставить("Логин", Логин);
	КомЯдро_СохранитьЗначениеПеременной("API_session_" + СтрЗаменить(СтрЗаменить(СтруктураURI.Хост, ".", "_"), "-", "_") + "_" + Формат(СтруктураURI.Порт, "ЧГ=") + "_" + СтрЗаменить(СтруктураURI.ПутьНаСервере, "-", ""), СтруктураОтвета.ОтветСервера);
	
	Access_token = СтруктураОтвета.ОтветСервера.Получить("Access_token");
	Если Access_token = Неопределено Тогда
		Access_token = СтруктураОтвета.ОтветСервера.Получить("access_token");
	КонецЕсли;
	Refresh_token = СтруктураОтвета.ОтветСервера.Получить("Refresh_token"); 
	Если Refresh_token = Неопределено Тогда
		Refresh_token = СтруктураОтвета.ОтветСервера.Получить("refresh_token"); 		
	КонецЕсли;
	
	// Пересохранение настроек подключения
	Если ТипЗнч(ПараметрыПодключенияMS) = Тип("Структура")
		И ПараметрыПодключенияMS.СтрокаПодключения = СтрокаПодключения Тогда
		ПараметрыПодключенияMS.Вставить("АвторизацияТокен", 	  Access_token);
		ПараметрыПодключенияMS.Вставить("АвторизацияРефрешТокен", Refresh_token);
		
		ЛокЯдро_СохранитьДанныеВХранилище1С("Cleverence_ПараметрыПодключенияMS", ПараметрыПодключенияMS);
		КомЯдро_СохранитьЗначениеПеременной("ПараметрыПодключенияMS", ПараметрыПодключенияMS);
	КонецЕсли;
	
	СтруктураВозврата = Новый Структура("АвторизацияТокен, АвторизацияРефрешТокен", Access_token, Refresh_token);
	
	Возврат СтруктураВозврата;
	
КонецФункции

// Выполняет подключение к базе Mobile Smarts при работе с типом интерфейса REST_API
//
// Параметры:
//	СтруктураПодключения - Структура - структура подключения к базе Mobile Smarts
//  Интерактивно - Булево - флаг работы в интерактивном режиме
//	НеПроверятьАвторизацию - Булево - признак необходимости проверки авторизации
//
// Возвращаемое значение:
//	- Структура - если требуется авторизация в интерактивном режиме - содержит:
//  	* Статус - Строка	
//      * СтрокаПодключения - Строка
//      * ИмяБазы - Строка
//      * Логин - Строка
//      * ТипБазы - Строка
//      * ДопПараметры - Структура - содержит:
//			** СтрокаПодключения - Строка
//          ** ТипБазы - Строка
//          ** СтруктураПодключения - Структура - структура подключения к базе Mobile Smarts
//          ** СохранятьАвторизацию - Булево
//          ** ИмяБазы - Строка
//          ** Логин - Строка
//	- Булево - флаг успешности подключения к базе Mobile Smarts
&НаКлиенте
Функция REST_API_ПодключитьсяКБазеSMARTS(СтруктураПодключения, Интерактивно, НеПроверятьАвторизацию = Ложь) Экспорт
	
	ИмяСобытия = "REST_API_ПодключитьсяКБазеSMARTS";
	
	СтрокаПодключения = "";
	Если ТипЗнч(СтруктураПодключения) = Тип("Структура") Тогда
		Если НЕ СтруктураПодключения.Свойство("СтрокаПодключенияСМАРТС")
			И НЕ СтруктураПодключения.Свойство("СтрокаПодключения") Тогда
			Возврат Ложь;
		Иначе
			СтрокаПодключения = ?(СтруктураПодключения.Свойство("СтрокаПодключенияСМАРТС"), СтруктураПодключения.СтрокаПодключенияСМАРТС, СтруктураПодключения.СтрокаПодключения);
		КонецЕсли;
	КонецЕсли;
	
	СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключения,Новый Структура("HTTPМетод,Метод,ТипЗапроса","GET","","ПроверкаСоединения"),,АдресаПеременных);
    
	ДопПараметры = Новый Структура("СтрокаПодключения,ТипБазы,СтруктураПодключения,СохранятьАвторизацию,ИмяБазы,Логин",СтрокаПодключения,СтруктураПодключения.ТипБазы,СтруктураПодключения,?(СтруктураПодключения.Свойство("СохранятьАвторизацию"),СтруктураПодключения.СохранятьАвторизацию,Ложь),"REST API",?(СтруктураПодключения.Свойство("АвторизацияЛогин"),СтруктураПодключения.АвторизацияЛогин,""));
	
	Если СтруктураПодключения.Свойство("РасположениеКомпоненты") Тогда
		ДопПараметры.Вставить("РасположениеКомпоненты",СтруктураПодключения.РасположениеКомпоненты);	
	КонецЕсли;
	
	ТребуетсяАвторизация = Ложь;
	
	Если СтруктураОтвета.КодСостояния = 401 Тогда
		ТребуетсяАвторизация = Истина;		
	КонецЕсли;
	
	ТекстОшибки = "";
	Если СтруктураОтвета.КодСостояния = 200 Тогда
		Если Не НеПроверятьАвторизацию Тогда
			// Проверяем, нужна ли авторизация
			СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключения, Новый Структура("HTTPМетод,Метод,ТипЗапроса","GET","Warehouses","ПолучениеМетаданных"),,АдресаПеременных);
			Если СтруктураОтвета.КодСостояния = 401 Тогда
				ТребуетсяАвторизация = Истина;
			ИначеЕсли СтруктураОтвета.КодСостояния = 403 Тогда
				ТребуетсяАвторизация = Истина;
				ТекстОшибки = "У данного пользователя Mobile SMARTS недостаточно прав для подключения к базе!
				|Пользователь должен находиться в группе ""Администраторы"" или ""Внешние подключения"".";
			Иначе			
				Возврат Истина;			
			КонецЕсли;
		Иначе
			Возврат Истина;
		КонецЕсли;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ТекстОшибки) Тогда
		ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", ТекстОшибки);	
	КонецЕсли;
		
	Если ТребуетсяАвторизация Тогда
		// Сохраняем в структуре подключения информацию о том, что в базе включена авторизация
		СтруктураПодключения.Вставить("АвторизацияВключена", Истина);
		
		Если СтруктураПодключения.ТипБазы = "Частная" Тогда
			КлючПеременной = "REST_API_СтруктураПодключенияЧастнойБазыMS";
		ИначеЕсли СтруктураПодключения.ТипБазы = "Временная" Тогда
			КлючПеременной = "REST_API_СтруктураПодключенияВременнойБазыMS";
		Иначе
			КлючПеременной = "REST_API_СтруктураПодключенияБазыMS";
		КонецЕсли;
		СтруктураПодключенияБазыMS = КомЯдро_ПолучитьЗначениеПеременной(КлючПеременной);
		СохранятьДанныеАвторизации = ТипЗнч(СтруктураПодключенияБазыMS) = Тип("Структура");
		
		// Если в строке подключения передан tempuid для упрощенной авторизации, пробуем получить токен по нему
		ПолученТокенПоTempUid = Ложь;
		ТекстОшибкиTempUid	  = "";
		TempUid = "";
		Если НЕ НеПроверятьАвторизацию
			И СтруктураПодключения.Свойство("TempUid", TempUid)
			И НЕ ПустаяСтрока(TempUid) Тогда
			СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключения, Новый Структура("HTTPМетод,Метод,ТипЗапроса","GET","Warehouses","ПолучениеМетаданных"),, АдресаПеременных);
			Если СтруктураОтвета.КодСостояния = 200 Тогда
				ПолученТокенПоTempUid = Истина;
				Если СохранятьДанныеАвторизации Тогда
					СтруктураПодключенияБазыMS.Вставить("АвторизацияТокен", 	  ?(СтруктураПодключения.Свойство("АвторизацияТокен"), 		 СтруктураПодключения.АвторизацияТокен, 	  ""));
					СтруктураПодключенияБазыMS.Вставить("АвторизацияРефрешТокен", ?(СтруктураПодключения.Свойство("АвторизацияРефрешТокен"), СтруктураПодключения.АвторизацияРефрешТокен, ""));
				КонецЕсли;
			Иначе
				ТекстОшибкиTempUid = "Ссылка для подключения устарела. Получите новую ссылку и попробуйте еще раз.";
			КонецЕсли;
		КонецЕсли;
		
		Если СохранятьДанныеАвторизации Тогда
			СтруктураПодключенияБазыMS.Вставить("АвторизацияВключена", Истина);
			КомЯдро_СохранитьЗначениеПеременной(КлючПеременной, СтруктураПодключенияБазыMS);
		КонецЕсли;
		
		Если НеПроверятьАвторизацию Тогда
			Возврат Истина;
		ИначеЕсли ПолученТокенПоTempUid Тогда	
            Возврат Истина;
		ИначеЕсли Интерактивно
			И НЕ ПустаяСтрока(ТекстОшибкиTempUid) Тогда
			Возврат ТекстОшибкиTempUid;
		ИначеЕсли Интерактивно Тогда
			// Определяем имя базы
			СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключения,Новый Структура("HTTPМетод,Метод,ТипЗапроса","GET","BaseInfo","ПроверкаСоединения"),,АдресаПеременных);
	        ИмяБазы = "<Не удалось определить...>";
			Если СтруктураОтвета.КодСостояния = 200 Тогда
				ИмяБазы = СтруктураОтвета.ОтветСервера.Получить("name");
				Если ИмяБазы = Неопределено Тогда
					ИмяБазы = "<Не удалось определить...>";
				КонецЕсли;
			ИначеЕсли СтруктураПодключенияБазыMS.Свойство("Имя")
				И ЗначениеЗаполнено(СтруктураПодключенияБазыMS.Имя) Тогда
				ИмяБазы = СтруктураПодключенияБазыMS.Имя;
			ИначеЕсли ЗначениеЗаполнено(СтрокаПодключения) Тогда
				ИмяБазы = СтрокаПодключения;
			КонецЕсли;
			
			СтруктураВозврата = Новый Структура;
			СтруктураВозврата.Вставить("Статус", 			"ОшибкаАвторизации");
			СтруктураВозврата.Вставить("СтрокаПодключения", СтрокаПодключения);
			СтруктураВозврата.Вставить("ИмяБазы", 			ИмяБазы);
			СтруктураВозврата.Вставить("Логин", 			?(СтруктураПодключения.Свойство("АвторизацияЛогин"), СтруктураПодключения.АвторизацияЛогин, ""));
			СтруктураВозврата.Вставить("ТипБазы", 			СтруктураПодключения.ТипБазы);
			СтруктураВозврата.Вставить("ДопПараметры", 		ДопПараметры);
			СтруктураВозврата.Вставить("ТекстОшибки", 		ТекстОшибки);
			
			Возврат СтруктураВозврата;
		Иначе
			Возврат Ложь;
		КонецЕсли;	
	КонецЕсли;
	
КонецФункции

&НаКлиенте
Функция REST_API_ПолучитьМетаданныеДокументовMS(ТипБазы, ИмяПеременнойНастройки)
	
	ИмяСобытия = "REST_API_ПолучитьМетаданныеДокументовMS";
	
	Если ТипБазы = "Частная" Тогда
		КлючПеременной = "REST_API_СтруктураПодключенияЧастнойБазыMS";
	ИначеЕсли ТипБазы = "Временная" Тогда
		КлючПеременной = "REST_API_СтруктураПодключенияВременнойБазыMS";
	Иначе
		КлючПеременной = "REST_API_СтруктураПодключенияБазыMS";
	КонецЕсли;
	
	СтруктураПодключения = КомЯдро_ПолучитьЗначениеПеременной(КлючПеременной);
	
	СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключения,Новый Структура("HTTPМетод,Метод,ТипЗапроса","GET","DocTypes?$expand=tables","ПолучениеМетаданных"),,АдресаПеременных);
	Если СтруктураОтвета.КодСостояния <> 200 Тогда
		ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Запрос: GET, DocTypes?$expand=tables, получен некорректный ответ от сервера, Код состояния: " + Строка(СтруктураОтвета.КодСостояния)+ ". Содержание ошибки: " + Строка(СтруктураОтвета.ТекстОшибки));
		DocumentTypes = Неопределено;	
	Иначе
		DocumentTypes = СтруктураОтвета.ОтветСервера.Получить("value");
	КонецЕсли;
	
	СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключения,Новый Структура("HTTPМетод,Метод,ТипЗапроса","GET","TablesInfo?$expand=fields","ПолучениеМетаданных"),,АдресаПеременных);	
	Если СтруктураОтвета.КодСостояния <> 200 Тогда
		ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Запрос: GET, TablesInfo?$expand=fields. Получен некорректный ответ от сервера, Код состояния: " + Строка(СтруктураОтвета.КодСостояния)+ ". Содержание ошибки: " + Строка(СтруктураОтвета.ТекстОшибки));
		Tables = Неопределено;	
	Иначе
		Tables = СтруктураОтвета.ОтветСервера.Получить("value");
	КонецЕсли;
	
	СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключения,Новый Структура("HTTPМетод,Метод,ТипЗапроса","GET","Users","ПолучениеМетаданных"),,АдресаПеременных);	
	Если СтруктураОтвета.КодСостояния <> 200 Тогда
		ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Запрос: GET, Users. Получен некорректный ответ от сервера, Код состояния: " + Строка(СтруктураОтвета.КодСостояния)+ ". Содержание ошибки: " + Строка(СтруктураОтвета.ТекстОшибки));
		Users = Неопределено;	
	Иначе
		Users = СтруктураОтвета.ОтветСервера.Получить("value");
	КонецЕсли;
	
	СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключения,Новый Структура("HTTPМетод,Метод,ТипЗапроса","GET","Devices","ПолучениеМетаданных"),,АдресаПеременных);	
	Если СтруктураОтвета.КодСостояния <> 200 Тогда
		ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Запрос: GET, Devices. Получен некорректный ответ от сервера, Код состояния: " + Строка(СтруктураОтвета.КодСостояния)+ ". Содержание ошибки: " + Строка(СтруктураОтвета.ТекстОшибки));
		Devices = Неопределено;
	Иначе
		Devices = СтруктураОтвета.ОтветСервера.Получить("value");
	КонецЕсли;
		
	МетаданныеДокументовMS = Новый Структура;
	
	СписокОбязательныхПолей = Новый Массив;
	СписокОбязательныхПолей.Добавить(Новый Структура("Значение,Ключ,Uni","Ид", "Идентификатор","id"));
	СписокОбязательныхПолей.Добавить(Новый Структура("Значение,Ключ,Uni","СозданНаТСД", "Создан на ТСД","createdOnPDA")); //ЛокЯдро_СтрокуВТранслитENG("СозданНаТСД")));
	СписокОбязательныхПолей.Добавить(Новый Структура("Значение,Ключ,Uni","Имя", "Имя","name"));
	СписокОбязательныхПолей.Добавить(Новый Структура("Значение,Ключ,Uni","Назначение", "Назначение", "appointment"));
	СписокОбязательныхПолей.Добавить(Новый Структура("Значение,Ключ,Uni","ДатаСоздания", "Дата создания", "createDate"));
	СписокОбязательныхПолей.Добавить(Новый Структура("Значение,Ключ,Uni","ИмяТипаДокумента", "Имя типа документа", "documentTypeName"));
	СписокОбязательныхПолей.Добавить(Новый Структура("Значение,Ключ,Uni","ИдСклада", "Идентификатор склада", "warehouseId"));
	СписокОбязательныхПолей.Добавить(Новый Структура("Значение,Ключ,Uni","Штрихкод", "Штрихкод", "barcode"));
	СписокОбязательныхПолей.Добавить(Новый Структура("Значение,Ключ,Uni","Приоритет", "Приоритет", "priority"));
	СписокОбязательныхПолей.Добавить(Новый Структура("Значение,Ключ,Uni","Описание", "Описание", "description"));
	СписокОбязательныхПолей.Добавить(Новый Структура("Значение,Ключ,Uni","ВыдаватьПоШтрихкоду", "Выдавать по штрихкоду", "DistributeByBarcode"));
	СписокОбязательныхПолей.Добавить(Новый Структура("Значение,Ключ,Uni","ИсполняемыйНаСервере", "Исполняемый на сервере", "serverHosted"));
	СписокОбязательныхПолей.Добавить(Новый Структура("Значение,Ключ,Uni","Завершен", "Завершен", "finished"));
	СписокОбязательныхПолей.Добавить(Новый Структура("Значение,Ключ,Uni","ВОбработке", "В обработке", "inProcess"));
	СписокОбязательныхПолей.Добавить(Новый Структура("Значение,Ключ,Uni","Изменен", "Изменен", "modified"));
	СписокОбязательныхПолей.Добавить(Новый Структура("Значение,Ключ,Uni","ИдПользователя", "Идентификатор пользователя", "userId"));
	СписокОбязательныхПолей.Добавить(Новый Структура("Значение,Ключ,Uni","DeviceId", "ИдУстройства", "deviceId"));
	СписокОбязательныхПолей.Добавить(Новый Структура("Значение,Ключ,Uni","UserName", "ИмяПользователя", "userName"));
	СписокОбязательныхПолей.Добавить(Новый Структура("Значение,Ключ,Uni","Underloaded", "Underloaded", "Underloaded"));
	СписокОбязательныхПолей.Добавить(Новый Структура("Значение,Ключ,Uni","Overloaded", "Overloaded", "Overloaded"));
	СписокОбязательныхПолей.Добавить(Новый Структура("Значение,Ключ,Uni","UnderloadedOrOverloaded","UnderloadedOrOverloaded","UnderloadedOrOverloaded"));
	
	СписокОбязательныхПолейТЧ = Новый Массив;
	СписокОбязательныхПолейТЧ.Добавить(Новый Структура("Значение,Ключ,Uni","ИдТовара", "ИдТовара", "productId"));
	СписокОбязательныхПолейТЧ.Добавить(Новый Структура("Значение,Ключ,Uni","ИдУпаковки", "ИдУпаковки", "packingId"));
	СписокОбязательныхПолейТЧ.Добавить(Новый Структура("Значение,Ключ,Uni","КоличествоПлан", "Количество (План)", "declaredQuantity"));
	СписокОбязательныхПолейТЧ.Добавить(Новый Структура("Значение,Ключ,Uni","КоличествоФакт", "Количество (Факт)", "currentQuantity"));
	СписокОбязательныхПолейТЧ.Добавить(Новый Структура("Значение,Ключ,Uni","ИдПервогоМеста", "Ид первого места", "firstStorageId"));
	СписокОбязательныхПолейТЧ.Добавить(Новый Структура("Значение,Ключ,Uni","ИдВторогоМеста", "Ид второго места", "secondStorageId"));
	СписокОбязательныхПолейТЧ.Добавить(Новый Структура("Значение,Ключ,Uni","ДатаРегистрации", "Дата регистрации", "registrationDate"));
	СписокОбязательныхПолейТЧ.Добавить(Новый Структура("Значение,Ключ,Uni","СрокГодности", "Срок годности", "expiredDate"));
	СписокОбязательныхПолейТЧ.Добавить(Новый Структура("Значение,Ключ,Uni","Переполнение", "Переполнение",ЛокЯдро_СтрокуВТранслитENG("Переполнение")));
	СписокОбязательныхПолейТЧ.Добавить(Новый Структура("Значение,Ключ,Uni","Недобор", "Недобор",ЛокЯдро_СтрокуВТранслитENG("Недобор")));
	СписокОбязательныхПолейТЧ.Добавить(Новый Структура("Значение,Ключ,Uni","ЕстьНедоборИлиПереполнение", "Есть недобор или переполнение",ЛокЯдро_СтрокуВТранслитENG("ЕстьНедоборИлиПереполнение")));
	СписокОбязательныхПолейТЧ.Добавить(Новый Структура("Значение,Ключ,Uni","Остаток", "Остаток",ЛокЯдро_СтрокуВТранслитENG("Остаток")));
	СписокОбязательныхПолейТЧ.Добавить(Новый Структура("Значение,Ключ,Uni","СвязаннаяСтрока", "Связанная строка", "bindedLineUid"));
	СписокОбязательныхПолейТЧ.Добавить(Новый Структура("Значение,Ключ,Uni","SSCC", "SSCC", "SSCC"));
	
	РеквизитыСерии = Новый Массив;
	РеквизитыСерии.Добавить(Новый Структура("Значение,Ключ,Uni","ИдСерии", "Идентификатор Серии","IdSerii"));
	РеквизитыСерии.Добавить(Новый Структура("Значение,Ключ,Uni","ИмяСерии", "Имя серии","ImyaSerii"));
	РеквизитыСерии.Добавить(Новый Структура("Значение,Ключ,Uni","ИдТовара", "ИдТовара", "productId"));
	РеквизитыСерии.Добавить(Новый Структура("Значение,Ключ,Uni","КоличествоФакт", "Количество (Факт)", "currentQuantity"));
	РеквизитыСерии.Добавить(Новый Структура("Значение,Ключ,Uni","Характеристика", "Характеристика","Harakteristika"));
	РеквизитыСерии.Добавить(Новый Структура("Значение,Ключ,Uni","АлкоКод", "АлкоКод","AlkoKod"));
	РеквизитыСерии.Добавить(Новый Структура("Значение,Ключ,Uni","ФормаА", "ФормаА",ЛокЯдро_СтрокуВТранслитENG("ФормаА")));
	РеквизитыСерии.Добавить(Новый Структура("Значение,Ключ,Uni","КлючСерии", "КлючСерии","KlyuchSerij"));
	РеквизитыСерии.Добавить(Новый Структура("Значение,Ключ,Uni","АлкоНаим", "АлкоНаим","AlkoNaim"));
	РеквизитыСерии.Добавить(Новый Структура("Значение,Ключ,Uni","ДатаРозлива", "ДатаРозлива",ЛокЯдро_СтрокуВТранслитENG("ДатаРозлива")));
	РеквизитыСерии.Добавить(Новый Структура("Значение,Ключ,Uni","НаименованиеДляПоиска", "НаименованиеДляПоиска","NaimenovanieDlyaPoiska"));
	РеквизитыСерии.Добавить(Новый Структура("Значение,Ключ,Uni","ДатаСерии", "ДатаСерии","DataSerii"));
	РеквизитыСерии.Добавить(Новый Структура("Значение,Ключ,Uni","ИндексСорт", "ИндексСорт","IndeksSort"));
	РеквизитыСерии.Добавить(Новый Структура("Значение,Ключ,Uni","Код", "Код","Kod"));
	РеквизитыСерии.Добавить(Новый Структура("Значение,Ключ,Uni","Штрихкод", "Штрихкод","Shtrihkod"));
	РеквизитыСерии.Добавить(Новый Структура("Значение,Ключ,Uni","Номер", "Номер","Nomer"));
	РеквизитыСерии.Добавить(Новый Структура("Значение,Ключ,Uni","Ид", "Ид","Id"));
	РеквизитыСерии.Добавить(Новый Структура("Значение,Ключ,Uni","Дополнительно", "Дополнительно","Dopolnitelno"));
	
	РеквизитыСерийныеНомера = Новый Массив;
	РеквизитыСерийныеНомера.Добавить(Новый Структура("Значение,Ключ,Uni","СН", "Серийный номер","sn"));
	РеквизитыСерийныеНомера.Добавить(Новый Структура("Значение,Ключ,Uni","ИдСерии", "Идентификатор Серии","IdSerii"));
	РеквизитыСерийныеНомера.Добавить(Новый Структура("Значение,Ключ,Uni","ИдТовара", "ИдТовара", "productId"));
	РеквизитыСерийныеНомера.Добавить(Новый Структура("Значение,Ключ,Uni","КоличествоФакт", "Количество (факт)", "currentQuantity"));
	РеквизитыСерийныеНомера.Добавить(Новый Структура("Значение,Ключ,Uni","Характеристика", "Характеристика","Harakteristika"));
	
	ЛокЯдро_ПреобразоватьUni(СписокОбязательныхПолей);
	ЛокЯдро_ПреобразоватьUni(СписокОбязательныхПолейТЧ);
	ЛокЯдро_ПреобразоватьUni(РеквизитыСерии);
	ЛокЯдро_ПреобразоватьUni(РеквизитыСерийныеНомера);
	
	Если DocumentTypes <> Неопределено Тогда
		Для Каждого ТипДокумента из DocumentTypes Цикл
			
			Если ТипДокумента.Получить("virtual") Тогда // Виртуальный
				Продолжить;
			КонецЕсли;
			
			СтруктураДокумента = Новый Структура();
			СтруктураДокумента.Вставить("uni",  ЛокЯдро_ПреобразоватьПервыйСимволВНижнийРегистр(ТипДокумента.Получить("uni")));
			СтруктураДокумента.Вставить("Имя", ТипДокумента.Получить("name"));
			СтруктураДокумента.Вставить("Синоним", ТипДокумента.Получить("alias"));
			// реквизиты документа
			СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключения,Новый Структура("HTTPМетод,Метод,ТипЗапроса","GET","DocTypes('" + СтруктураДокумента.uni + "')?$expand=fields","ПолучениеМетаданных"),,АдресаПеременных);
			Если СтруктураОтвета.КодСостояния <> 200 Тогда
				ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Запрос: GET, DocTypes('" + Строка(СтруктураДокумента.uni) + "')?$expand=fields. Получен некорректный ответ от сервера, Код состояния: " + Строка(СтруктураОтвета.КодСостояния)+ ". Содержание ошибки: " + Строка(СтруктураОтвета.ТекстОшибки));
				Fields = Неопределено;	
			Иначе
				Fields = СтруктураОтвета.ОтветСервера.Получить("fields");
			КонецЕсли;
			
			Если Fields <> Неопределено Тогда
				СписокРеквизитов = REST_API_ПолучитьСписокРеквизитовСущностиMS(Fields, СписокОбязательныхПолей);
				СтруктураДокумента.Вставить("Реквизиты", СписокРеквизитов);
			Иначе	
				СтруктураДокумента.Вставить("Реквизиты", Новый СписокЗначений());
			КонецЕсли;
			
			// реквизиты табличной части
			СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключения,Новый Структура("HTTPМетод,Метод,ТипЗапроса","GET","DocTypes('" + СтруктураДокумента.uni + "')?$expand=columns","ПолучениеМетаданных"),,АдресаПеременных);
			Если СтруктураОтвета.КодСостояния <> 200 Тогда
				ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Запрос: GET, DocTypes('" + Строка(СтруктураДокумента.uni) + "')?$expand=columns. Получен некорректный ответ от сервера, Код состояния: " + Строка(СтруктураОтвета.КодСостояния)+ ". Содержание ошибки: " + Строка(СтруктураОтвета.ТекстОшибки));
				Columns = Неопределено;	
			Иначе
				Columns = СтруктураОтвета.ОтветСервера.Получить("columns");
			КонецЕсли;
					
			Если Columns <> Неопределено Тогда
				СписокРеквизитов = REST_API_ПолучитьСписокРеквизитовСущностиMS(Columns, СписокОбязательныхПолейТЧ);
				СтруктураДокумента.Вставить("РеквизитыТЧ", СписокРеквизитов);
			Иначе
				СтруктураДокумента.Вставить("РеквизитыТЧ", Новый СписокЗначений());
			КонецЕсли;
			
			// серии и серийные номера
			СтруктураДокумента.Вставить("РеквизитыСерии", РеквизитыСерии);
			СтруктураДокумента.Вставить("РеквизитыСерийныеНомера", РеквизитыСерийныеНомера);
			
			// Дополнительные таблицы
			СписокДополнительныхТаблиц = Новый СписокЗначений();
			СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключения,Новый Структура("HTTPМетод,Метод,ТипЗапроса","GET","DocTypes('" + СтруктураДокумента.uni + "')?$expand=tables($expand=fields)","ПолучениеМетаданных"),,АдресаПеременных);
			Если СтруктураОтвета.КодСостояния <> 200 Тогда
				ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Запрос: GET, DocTypes('" + Строка(СтруктураДокумента.uni) + "')?$expand=tables($expand=fields). Получен некорректный ответ от сервера, Код состояния: " + Строка(СтруктураОтвета.КодСостояния)+ ". Содержание ошибки: " + Строка(СтруктураОтвета.ТекстОшибки));
				DocTables = Неопределено;	
			Иначе
				DocTables = СтруктураОтвета.ОтветСервера.Получить("tables");
			КонецЕсли;
					
			Если DocTables <> Неопределено Тогда
				Для каждого ДопТаблица из DocTables Цикл
					СписокПолейДопТаблицы = REST_API_ПолучитьСписокРеквизитовСущностиMS(ДопТаблица.Получить("fields"));	
					СписокДополнительныхТаблиц.Добавить(СписокПолейДопТаблицы, ДопТаблица.Получить("name"));
				КонецЦикла;
			КонецЕсли;
										
			СтруктураДокумента.Вставить("ДополнительныеТаблицы", СписокДополнительныхТаблиц);									
			
			ИмяТипаДокумента = ЛокЯдро_ПреобразованиеНаименованияДокументаБезПробелов(ТипДокумента.Получить("name"));
			МетаданныеДокументовMS.Вставить(ИмяТипаДокумента, СтруктураДокумента);
			
		КонецЦикла;		
	КонецЕсли;
	
	Таблицы = Новый СписокЗначений;	
	Если Tables <> Неопределено Тогда
		Для Каждого ДопТаблица ИЗ Tables Цикл			
			
			// Реквизиты таблицы
			Fields = ДопТаблица.Получить("fields");
			Если Fields = Неопределено Тогда
				СписокРеквизитов = Новый Массив;
			Иначе
				СписокРеквизитов = REST_API_ПолучитьСписокРеквизитовСущностиMS(Fields,, Истина);
			КонецЕсли;
			
			Таблицы.Добавить(СписокРеквизитов, ДопТаблица.Получить("name"));
			
		КонецЦикла;
	КонецЕсли;
	
	СписокПользователейMS = Новый СписокЗначений;
	
	СписокПользователейMS.Добавить("Выгружать всем;Выгружать всем"); 	
	СписокПользователейMS.Добавить("Спрашивать при выгрузке;Спрашивать при выгрузке");	
	Если Users <> Неопределено Тогда
		Для Каждого ТекущийПользователь ИЗ Users Цикл
			Попытка
				СписокПользователейMS.Добавить(ТекущийПользователь.Получить("id") + ";" + ТекущийПользователь.Получить("name"), ТекущийПользователь.Получить("groupId") + ";" + ТекущийПользователь.Получить("groupName"));
			Исключение
				ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
			КонецПопытки;
		КонецЦикла;	
	КонецЕсли;
	
	ПризнакЛегкогоОблака = ЛокЯдро_ПолучитьНастройкиНаСервереSMARTS(Новый Структура("InternetGateOption"));
	Если ТипЗнч(ПризнакЛегкогоОблака) = Тип("Структура") И ПризнакЛегкогоОблака.Свойство("InternetGateOption") Тогда
		InternetGateOption = ПризнакЛегкогоОблака.InternetGateOption;
	Иначе
		InternetGateOption = Ложь;
	КонецЕсли;
	
	Если InternetGateOption <> Ложь И ВРег(InternetGateOption) = "AVAILABLE" Тогда
		флЛегкоеОблако = Истина;
	Иначе
		флЛегкоеОблако = Ложь;
	КонецЕсли;
	
	СписокУстройствMS = Новый СписокЗначений;
	Если Не флЛегкоеОблако Тогда
		СписокУстройствMS.Добавить("Выгружать всем;Выгружать всем"); 	
		СписокУстройствMS.Добавить("Спрашивать при выгрузке;Спрашивать при выгрузке");	
	КонецЕсли;

	Если Devices <> Неопределено Тогда
		Для Каждого ТекущееУстройство ИЗ Devices Цикл
			Если флЛегкоеОблако Тогда
				Pincode    = СокрЛП(ТекущееУстройство.Получить("pincode"));
			КонецЕсли;
			DeviceId   = СокрЛП(ТекущееУстройство.Получить("deviceId"));
			DeviceName = СокрЛП(ТекущееУстройство.Получить("deviceName"));
			Если флЛегкоеОблако Тогда
				СписокУстройствMS.Добавить(Pincode + ";" + DeviceId + ";" + ?(НЕ ЗначениеЗаполнено(DeviceName), DeviceId, DeviceName + ", (" + DeviceId + ")") + ";");
			Иначе
				СписокУстройствMS.Добавить(DeviceId + ";" + ?(НЕ ЗначениеЗаполнено(DeviceName), DeviceId, DeviceName + ", (" + DeviceId + ")") + ";");
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	СоответствиеПолейНоменклатуры = Новый Соответствие;
	СоответствиеПолейНоменклатуры.Вставить("ИмяСерии","serial");
	СоответствиеПолейНоменклатуры.Вставить("Колво","qty");
	СоответствиеПолейНоменклатуры.Вставить("Цена","price");
	СоответствиеПолейНоменклатуры.Вставить("ИмяХарактеристики","descr");
	СоответствиеПолейНоменклатуры.Вставить("ПоСН","withsn");
	СоответствиеПолейНоменклатуры.Вставить("ПоСериям","withserial");
	СоответствиеПолейНоменклатуры.Вставить("Весовой","Vesovoj");
	СоответствиеПолейНоменклатуры.Вставить("КлючСерий","KlyuchSerij");
	СоответствиеПолейНоменклатуры.Вставить("ВидНоменклатуры","VidNomenklatury");
	СоответствиеПолейНоменклатуры.Вставить("ИдСерии","serialId");
	СоответствиеПолейНоменклатуры.Вставить("Алко","Alko");
	СоответствиеПолейНоменклатуры.Вставить("АлкоВидЛиц","AlkoVidLic");
	СоответствиеПолейНоменклатуры.Вставить("АлкоМарк","AlkoMark");
	СоответствиеПолейНоменклатуры.Вставить("АлкоКодВ","AlkoKodV");
	СоответствиеПолейНоменклатуры.Вставить("АлкоНаимВ","AlkoNaimV");
	СоответствиеПолейНоменклатуры.Вставить("АлкоОбъем","AlkoObem");
	СоответствиеПолейНоменклатуры.Вставить("АлкоКрепость","AlkoKrepost");
	СоответствиеПолейНоменклатуры.Вставить("АлкоПроизводитель","AlkoProizvoditel");
	СоответствиеПолейНоменклатуры.Вставить("АлкоПроизвИНН","AlkoProizvINN");
	СоответствиеПолейНоменклатуры.Вставить("АлкоПроизвКПП","AlkoProizvKPP");
	СоответствиеПолейНоменклатуры.Вставить("АлкоКод","AlkoKod");
	СоответствиеПолейНоменклатуры.Вставить("ЭтоГруппа","EtoGruppa");
	СоответствиеПолейНоменклатуры.Вставить("Продавец","sellerName");
	СоответствиеПолейНоменклатуры.Вставить("АдресПродавца","sellerAddress");
	СоответствиеПолейНоменклатуры.Вставить("АдресПроизв","producerAddress");
	СоответствиеПолейНоменклатуры.Вставить("СтранаПроизв","producerCountry");
	СоответствиеПолейНоменклатуры.Вставить("Поставщик","supplierName");
	СоответствиеПолейНоменклатуры.Вставить("АдресПоставщика","supplierAddress");
	СоответствиеПолейНоменклатуры.Вставить("ДопИнфо","AdditionInfo");
	СоответствиеПолейНоменклатуры.Вставить("КлючХарактеристик","KlyuchHarakteristik");
	СоответствиеПолейНоменклатуры.Вставить("ПоХарактеристикам","PoHarakteristikam");
	СоответствиеПолейНоменклатуры.Вставить("Серия","Seriya");
	СоответствиеПолейНоменклатуры.Вставить("Характеристика","Harakteristika");
	СоответствиеПолейНоменклатуры.Вставить("ИдХарактеристики","descrId");
	СоответствиеПолейНоменклатуры.Вставить("ИдЕдиницыИзмерения","unitId");
	СоответствиеПолейНоменклатуры.Вставить("КИЗ","KIZ");
	СоответствиеПолейНоменклатуры.Вставить("АлкоНаим","AlkoNaim");
	СоответствиеПолейНоменклатуры.Вставить("ШК","barcode");
	
	ЛокЯдро_ПреобразоватьUni(СоответствиеПолейНоменклатуры);
	
	МассивВыгружаемыхПолейНоменклатурыMS = ЛокЯдро_ПолучитьМассивВыгружаемыхПолейНоменклатурыMS();
	
	СтрРезультат = Новый Структура;
	СтрРезультат.Вставить("ДокументыMS",					МетаданныеДокументовMS);
	СтрРезультат.Вставить("Tables",							Таблицы);
	СтрРезультат.Вставить("ПользователиMS",					СписокПользователейMS);
	СтрРезультат.Вставить("УстройстваMS",					СписокУстройствMS);
	СтрРезультат.Вставить("UniПолейНоменклатуры",			СоответствиеПолейНоменклатуры);
	СтрРезультат.Вставить("ВыгружаемыеПоляНоменклатурыMS", 	МассивВыгружаемыхПолейНоменклатурыMS);
	
	ЛокЯдро_СохранитьДанныеВХранилище1С(ИмяПеременнойНастройки, СтрРезультат);
	
	ПользователиMSАдрес = ЛокЯдро_ДеревоПользователейВоВременноеХранилище(СписокПользователейMS);
	УстройстваMSАдрес 	= ЛокЯдро_ДеревоУстройствВоВременноеХранилище(СписокУстройствMS, флЛегкоеОблако);
	
	СтрРезультат.Вставить("ПользователиMS", ПользователиMSАдрес);
	СтрРезультат.Вставить("УстройстваMS",	УстройстваMSАдрес);
	
	Возврат СтрРезультат;
	
КонецФункции

&НаКлиенте
Функция REST_API_ПолучитьМетаданныеMSИзХранилища1С(ТипБазы, ИмяПеременнойНастройки)
	
	ИмяСобытия = "REST_API_ПолучитьМетаданныеMSИзХранилища1С";
	
	пСтруктураМетаданных = ЛокЯдро_ПолучитьДанныеИзХранилища1С(ИмяПеременнойНастройки);
	Если ТипЗнч(пСтруктураМетаданных) <> Тип("Структура") Тогда
		Возврат Неопределено;		
	КонецЕсли;
	
	ПризнакЛегкогоОблака = ЛокЯдро_ПолучитьНастройкиНаСервереSMARTS(Новый Структура("InternetGateOption"));
	Если ТипЗнч(ПризнакЛегкогоОблака) = Тип("Структура") И ПризнакЛегкогоОблака.Свойство("InternetGateOption") Тогда
		InternetGateOption = ПризнакЛегкогоОблака.InternetGateOption;
	Иначе
		InternetGateOption = Ложь;
	КонецЕсли;
	
	Если InternetGateOption <> Ложь И ВРег(InternetGateOption) = "AVAILABLE" Тогда
		флЛегкоеОблако = Истина;
	Иначе
		флЛегкоеОблако = Ложь;
	КонецЕсли;

	СписокПользователейMS = пСтруктураМетаданных.ПользователиMS;
	СписокУстройствMS 	  = пСтруктураМетаданных.УстройстваMS;
	
	ОбновитьСписокПользователей = ТипЗнч(СписокПользователейMS) <> Тип("СписокЗначений");
    ОбновитьСписокУстройств		= флЛегкоеОблако ИЛИ ТипЗнч(СписокУстройствMS) <> Тип("СписокЗначений");
	
	Если ОбновитьСписокПользователей ИЛИ ОбновитьСписокУстройств Тогда
		Если ТипБазы = "Частная" Тогда
			КлючПеременной = "REST_API_СтруктураПодключенияЧастнойБазыMS";
		ИначеЕсли ТипБазы = "Временная" Тогда
			КлючПеременной = "REST_API_СтруктураПодключенияВременнойБазыMS";
		Иначе
			КлючПеременной = "REST_API_СтруктураПодключенияБазыMS";
		КонецЕсли;
		
		СтруктураПодключения = КомЯдро_ПолучитьЗначениеПеременной(КлючПеременной);	
	КонецЕсли;
	
	// ***

	Если ОбновитьСписокПользователей Тогда
		СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключения,Новый Структура("HTTPМетод,Метод,ТипЗапроса","GET","Users","ПолучениеМетаданных"),,АдресаПеременных);	
		Если СтруктураОтвета.КодСостояния <> 200 Тогда
			ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Запрос: GET, Users. Получен некорректный ответ от сервера, Код состояния: " + Строка(СтруктураОтвета.КодСостояния)+ ". Содержание ошибки: " + Строка(СтруктураОтвета.ТекстОшибки));
			Users = Неопределено;	
		Иначе
			Users = СтруктураОтвета.ОтветСервера.Получить("value");
		КонецЕсли;
	
		СписокПользователейMS = Новый СписокЗначений;
		СписокПользователейMS.Добавить("Выгружать всем;Выгружать всем"); 	
		СписокПользователейMS.Добавить("Спрашивать при выгрузке;Спрашивать при выгрузке");	
		Если Users <> Неопределено Тогда
			Для Каждого ТекущийПользователь ИЗ Users Цикл
				Попытка
					СписокПользователейMS.Добавить(ТекущийПользователь.Получить("id") + ";" + ТекущийПользователь.Получить("name"), ТекущийПользователь.Получить("groupId") + ";" + ТекущийПользователь.Получить("groupName"));
				Исключение
					ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
				КонецПопытки;
			КонецЦикла;	
		КонецЕсли;
		
		пСтруктураМетаданных.Вставить("ПользователиMS", СписокПользователейMS);
	КонецЕсли;
	
	// ***
	
	Если ОбновитьСписокУстройств Тогда
		СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключения,Новый Структура("HTTPМетод,Метод,ТипЗапроса","GET","Devices","ПолучениеМетаданных"),,АдресаПеременных);	
		Если СтруктураОтвета.КодСостояния <> 200 Тогда
			ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Запрос: GET, Devices. Получен некорректный ответ от сервера, Код состояния: " + Строка(СтруктураОтвета.КодСостояния)+ ". Содержание ошибки: " + Строка(СтруктураОтвета.ТекстОшибки));
			Devices = Неопределено;
		Иначе
			Devices = СтруктураОтвета.ОтветСервера.Получить("value");
		КонецЕсли;
		
		СписокУстройствMS = Новый СписокЗначений;
		Если Не флЛегкоеОблако Тогда
			СписокУстройствMS.Добавить("Выгружать всем;Выгружать всем"); 	
			СписокУстройствMS.Добавить("Спрашивать при выгрузке;Спрашивать при выгрузке");	
		КонецЕсли;

		Если Devices <> Неопределено Тогда
			Для Каждого ТекущееУстройство ИЗ Devices Цикл
				Если флЛегкоеОблако Тогда
					Pincode = СокрЛП(ТекущееУстройство.Получить("pincode"));
				КонецЕсли;
				DeviceId   = СокрЛП(ТекущееУстройство.Получить("deviceId"));
				DeviceName = СокрЛП(ТекущееУстройство.Получить("deviceName"));
				Если флЛегкоеОблако Тогда
					СписокУстройствMS.Добавить(Pincode + ";" + DeviceId + ";" + ?(НЕ ЗначениеЗаполнено(DeviceName), DeviceId, DeviceName + ", (" + DeviceId + ")") + ";");
				Иначе
					СписокУстройствMS.Добавить(DeviceId + ";" + ?(НЕ ЗначениеЗаполнено(DeviceName), DeviceId, DeviceName + ", (" + DeviceId + ")") + ";");
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
			
		пСтруктураМетаданных.Вставить("УстройстваMS", СписокУстройствMS);
	КонецЕсли;	

	Если ОбновитьСписокПользователей ИЛИ ОбновитьСписокУстройств Тогда
		ЛокЯдро_СохранитьДанныеВХранилище1С(ИмяПеременнойНастройки, пСтруктураМетаданных);
	КонецЕсли;
	
	ПользователиMSАдрес = ЛокЯдро_ДеревоПользователейВоВременноеХранилище(СписокПользователейMS);
	УстройстваMSАдрес 	= ЛокЯдро_ДеревоУстройствВоВременноеХранилище(СписокУстройствMS, флЛегкоеОблако);
	
	пСтруктураМетаданных.Вставить("ПользователиMS", ПользователиMSАдрес);
	пСтруктураМетаданных.Вставить("УстройстваMS",	УстройстваMSАдрес);
	
	Возврат пСтруктураМетаданных;
	
КонецФункции
 
&НаКлиенте
Функция REST_API_ОбновитьМетаданныеТаблицMS(ТипБазы)
	
	ИмяСобытия = "REST_API_ОбновитьМетаданныеТаблицMS";
	
	Если ТипБазы = "Частная" Тогда
		КлючПеременной = "REST_API_СтруктураПодключенияЧастнойБазыMS";
	ИначеЕсли ТипБазы = "Временная" Тогда
		КлючПеременной = "REST_API_СтруктураПодключенияВременнойБазыMS";
	Иначе
		КлючПеременной = "REST_API_СтруктураПодключенияБазыMS";
	КонецЕсли;
	
	СтруктураПодключения = КомЯдро_ПолучитьЗначениеПеременной(КлючПеременной);
	
	СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключения,Новый Структура("HTTPМетод,Метод,ТипЗапроса","GET","TablesInfo?$expand=fields","ПолучениеМетаданных"),,АдресаПеременных);	
	Если СтруктураОтвета.КодСостояния <> 200 Тогда
		ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Запрос: GET, TablesInfo?$expand=fields. Получен некорректный ответ от сервера, Код состояния: " + Строка(СтруктураОтвета.КодСостояния)+ ". Содержание ошибки: " + Строка(СтруктураОтвета.ТекстОшибки));
		Tables = Неопределено;	
	Иначе
		Tables = СтруктураОтвета.ОтветСервера.Получить("value");
	КонецЕсли;
	
	Таблицы = Новый СписокЗначений;	
	Если Tables <> Неопределено Тогда
		Для Каждого ДопТаблица ИЗ Tables Цикл			
			
			// Реквизиты таблицы
			Fields = ДопТаблица.Получить("fields");
			Если Fields = Неопределено Тогда
				СписокРеквизитов = Новый Массив;
			Иначе
				СписокРеквизитов = REST_API_ПолучитьСписокРеквизитовСущностиMS(Fields,, Истина);
			КонецЕсли;
			
			Таблицы.Добавить(СписокРеквизитов, ДопТаблица.Получить("name"));
			
		КонецЦикла;
	КонецЕсли;
	
	Возврат Таблицы;
	
КонецФункции
 
&НаКлиенте
Функция REST_API_ПолучитьСписокСлужебныхДокументовMS(ТипБазы)
	
	ИмяСобытия = "REST_API_ПолучитьСписокСлужебныхДокументовMS";
	
	Если ТипБазы = "Частная" Тогда
		КлючПеременной = "REST_API_СтруктураПодключенияЧастнойБазыMS";
	ИначеЕсли ТипБазы = "Временная" Тогда
		КлючПеременной = "REST_API_СтруктураПодключенияВременнойБазыMS";
	Иначе
		КлючПеременной = "REST_API_СтруктураПодключенияБазыMS";
	КонецЕсли;
	
	СтруктураПодключения = КомЯдро_ПолучитьЗначениеПеременной(КлючПеременной);
	
	СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключения,Новый Структура("HTTPМетод,Метод,ТипЗапроса","GET","DocTypes?$expand=tables","ПолучениеМетаданных"),,АдресаПеременных);
	Если СтруктураОтвета.КодСостояния <> 200 Тогда
		ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Запрос: GET, DocTypes?$expand=tables, получен некорректный ответ от сервера, Код состояния: " + Строка(СтруктураОтвета.КодСостояния)+ ". Содержание ошибки: " + Строка(СтруктураОтвета.ТекстОшибки));
		DocumentTypes = Неопределено;	
	Иначе
		DocumentTypes = СтруктураОтвета.ОтветСервера.Получить("value");
	КонецЕсли;
	
	СлужебныеДокументыMS = Новый СписокЗначений;
	
	Если DocumentTypes <> Неопределено Тогда
		Для Каждого ТипДокумента из DocumentTypes Цикл			
			
			Если Не ТипДокумента.Получить("virtual") Тогда
				Продолжить;
			КонецЕсли;                                		
			
			СлужебныеДокументыMS.Добавить(ТипДокумента.Получить("name"), ТипДокумента.Получить("displayName"));
			
		КонецЦикла;		
	КонецЕсли;	
	
	Возврат СлужебныеДокументыMS;
	
КонецФункции       

&НаКлиенте
Процедура REST_API_ОбновитьМетаданныеПользователейMS(ТипБазы)
	
	ИмяСобытия = "REST_API_ОбновитьМетаданныеПользователейMS";
	
	Если ТипБазы = "Частная" Тогда
		КлючПеременной = "REST_API_СтруктураПодключенияЧастнойБазыMS";
	ИначеЕсли ТипБазы = "Временная" Тогда
		КлючПеременной = "REST_API_СтруктураПодключенияВременнойБазыMS";
	Иначе
		КлючПеременной = "REST_API_СтруктураПодключенияБазыMS";
	КонецЕсли;
	
	СтруктураПодключения = КомЯдро_ПолучитьЗначениеПеременной(КлючПеременной);
	
	СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключения,Новый Структура("HTTPМетод,Метод,ТипЗапроса","GET","Users","ПолучениеМетаданных"),,АдресаПеременных);	
	Если СтруктураОтвета.КодСостояния <> 200 Тогда
		ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Запрос: GET, Users. Получен некорректный ответ от сервера, Код состояния: " + Строка(СтруктураОтвета.КодСостояния)+ ". Содержание ошибки: " + Строка(СтруктураОтвета.ТекстОшибки));
		Users = Неопределено;	
	Иначе
		Users = СтруктураОтвета.ОтветСервера.Получить("value");
	КонецЕсли;
	
	СписокПользователейMS = Новый СписокЗначений;
	
	СписокПользователейMS.Добавить("Выгружать всем;Выгружать всем"); 	
	СписокПользователейMS.Добавить("Спрашивать при выгрузке;Спрашивать при выгрузке");	
	Если Users <> Неопределено Тогда
		Для Каждого ТекущийПользователь ИЗ Users Цикл
			Попытка
				СписокПользователейMS.Добавить(ТекущийПользователь.Получить("id") + ";" + ТекущийПользователь.Получить("name"), ТекущийПользователь.Получить("groupId") + ";" + ТекущийПользователь.Получить("groupName"));
			Исключение
				ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
			КонецПопытки;
		КонецЦикла;	
	КонецЕсли;
	
	ПользователиMSАдрес = ЛокЯдро_ДеревоПользователейВоВременноеХранилище(СписокПользователейMS);	
	
	// СтруктураМетаданных.Вставить("ПользователиMS", ?(ПользователиMSАдрес = Неопределено, "", ПользователиMSАдрес));

	ЛокЯдро_ОбновитьМетаданныеПользователейMSВХранилище1С(СписокПользователейMS, ПользователиMSАдрес);
	
КонецПроцедуры
 
&НаКлиенте
Функция REST_API_ПолучитьСписокРеквизитовСущностиMS(СущностьMS, ДополнительныйСписок = Неопределено, ИсключатьВычисляемые = Ложь)
	
	СписокРеквизитов = Новый Массив;
	
	Для Каждого ДанныеРеквизита ИЗ СущностьMS Цикл 
		Если НЕ ДанныеРеквизита.Получить("readOnly") = Истина Тогда
			Если ИсключатьВычисляемые
				И ЗначениеЗаполнено(ДанныеРеквизита.Получить("valueTemplate")) Тогда
				Продолжить;
			КонецЕсли;
			СписокРеквизитов.Добавить(Новый Структура("Значение,Ключ,Uni",ДанныеРеквизита.Получить("fieldName"), ДанныеРеквизита.Получить("fieldName"), ЛокЯдро_ПреобразоватьПервыйСимволВНижнийРегистр(ДанныеРеквизита.Получить("uni"))));
		КонецЕсли;
	КонецЦикла;
	
	Если ДополнительныйСписок <> Неопределено Тогда
		Для Каждого ДополнительныйЭлемент Из ДополнительныйСписок Цикл
			СписокРеквизитов.Добавить(ДополнительныйЭлемент);
		КонецЦикла;
	КонецЕсли;
	
	Возврат СписокРеквизитов;
	
КонецФункции

&НаКлиенте
Процедура REST_API_ЗаписатьНастройкиSMARTS(СтруктураНастроек, УзловыеНастройки, ID_Узла = "")
	
	ИмяСобытия = "REST_API_ЗаписатьНастройкиSMARTS (ЛокЯдро)";
	
	Если СтруктураНастроек.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	НеЛогировать = Ложь;
	Если СтруктураНастроек.Свойство("НеЛогировать", НеЛогировать) Тогда
		СтруктураНастроек.Удалить("НеЛогировать");	
	КонецЕсли;
	
	//Обновляем дату актуальности настроек, чтобы при последующем онлайн-вызове были получены сохраненные настройки.
	ИзменилисьКлючевыеНастройки = Ложь;
	МассивИсключений = Новый Массив;
	МассивИсключений.Добавить("НастройкиОтборовУзлов_Онлайн");
	МассивИсключений.Добавить("НастройкиБизнесПроцессов_Пользовательские");
	МассивИсключений.Добавить("НастройкиОбменаСправочников");
	МассивИсключений.Добавить("ИспользоватьШаблоныВесовогоТовара");
	МассивИсключений.Добавить("ПрефиксКодаВесовогоТовара");
	МассивИсключений.Добавить("ЧислоЗнаковПослеЗапятойВесТовара");
	МассивИсключений.Добавить("ДлинаКодаВесовогоТовара");
	МассивИсключений.Добавить("ПрефиксВключенВКодВесовогоТовара");
	МассивИсключений.Добавить("ВыгружатьНоменклатуруДокументаПередВыгрузкойДокумента");
	МассивИсключений.Добавить("ЗначенияПараметровУзлов");
	МассивИсключений.Добавить("ГлобальныеПараметры_Значения");
	МассивИсключений.Добавить("ГлобальныеПараметры");
	МассивИсключений.Добавить("ГлобальныеПараметры_Пользовательские");
	МассивИсключений.Добавить("НастройкиБизнесПроцессов_ПользовательскиеНастройки");
	МассивИсключений.Добавить("ФормаОбменаВыбранныеКолонки");
	МассивИсключений.Добавить("ФормаОбменаВыбранныеКолонкиSMARTS");
	
	ИзменилисьКэшируемыеНастройки = Ложь;
	МассивИсключенийКэшируемыеНастройки = Новый Массив; // Ключевые настройки для оффлайна в дополнение к МассивИсключений
	МассивИсключенийКэшируемыеНастройки.Добавить("НастройкиОтборовУзлов_Интерактивный");
	
	СтруктураПодключения = КомЯдро_ПолучитьЗначениеПеременной("REST_API_СтруктураПодключенияБазыMS");

	Для Каждого Настройка Из СтруктураНастроек Цикл
		ОтправляемыеДанные = Новый Соответствие;
		ИтоговыйКлючНастройки = Настройка.Ключ;
		
		// Если мы пытаемся отключить сжатие данных, саму настройку уже нужно сохранять без сжатия данных
		Если Настройка.Ключ = "ОтключитьСжатиеДанных"
			И Настройка.Значение = Истина Тогда
			ЛокЯдро_ЗаписатьВКэшНастройкуSMARTS("ОтключитьСжатиеДанных", Истина);
		КонецЕсли;
		
		Если НЕ ИзменилисьКлючевыеНастройки
			И МассивИсключений.Найти(Настройка.Ключ) <> Неопределено Тогда
			ИзменилисьКлючевыеНастройки = Истина;
			ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Изменение ключевых настроек, изменена настройка: " + ИтоговыйКлючНастройки);
		КонецЕсли;
		
		Если НЕ ИзменилисьКэшируемыеНастройки
			И (ИзменилисьКлючевыеНастройки ИЛИ МассивИсключенийКэшируемыеНастройки.Найти(Настройка.Ключ) <> Неопределено) Тогда
			ИзменилисьКэшируемыеНастройки = Истина;
			ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Изменение кэшируемых настроек, изменена настройка: " + ИтоговыйКлючНастройки);
		КонецЕсли;
		
		Если УзловыеНастройки.Найти(Настройка.Ключ) <> Неопределено Тогда
			ИтоговыйКлючНастройки = ИтоговыйКлючНастройки + ?(ID_Узла = "", "", "_"+ ID_Узла);
		КонецЕсли;
		
		ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Запись настройки в CustomSettings: "+ИтоговыйКлючНастройки);
		
		ОтправляемыеДанные.Вставить("name", ИтоговыйКлючНастройки);
		ОтправляемыеДанные.Вставить("value", Настройка.Значение);
		
		СтруктураЗапроса = Новый Структура("HTTPМетод, Метод, ТипЗапроса", "POST", "CustomSettings", "ПолучениеСохранениеНастроек");
		Если НеЛогировать = Истина Тогда
			СтруктураЗапроса.Вставить("НеЛогировать", Истина);	
		Иначе
			ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Запись настройки в CustomSettings: " + ИтоговыйКлючНастройки);
		КонецЕсли;	
		
		REST_API_ВыполнитьМетод(СтруктураПодключения, СтруктураЗапроса, ОтправляемыеДанные, АдресаПеременных);	
	КонецЦикла;
	
	Если ИзменилисьКлючевыеНастройки ИЛИ ИзменилисьКэшируемыеНастройки Тогда
		Если СтруктураПодключения.Свойство("IdBaseSMARTS") Тогда
			ПостфиксБазы = СтрЗаменить(СтруктураПодключения.IdBaseSMARTS, "-", "_");
		Иначе
			ПостфиксБазы = "";
		КонецЕсли;
		ДатаАктуальности = ЛокЯдро_ПолучитьТекущуюДатуНаСервере();
		
		Если ИзменилисьКлючевыеНастройки Тогда
			ЛокЯдро_СохранитьДанныеВХранилище1С("Cleverence_ДатаАктуальностиНастроек_" + ПостфиксБазы, ДатаАктуальности);
			ЛокЯдро_СохранитьДанныеВХранилище1С("Cleverence_REST_API_ДатаАктуальностиСоединения", Неопределено);
			ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Информация", "Сброшена дата актуальности настроек, постфикс базы: " + ?(ПостфиксБазы = "", "<нет>", ПостфиксБазы));
		КонецЕсли;
		
		Если ИзменилисьКэшируемыеНастройки Тогда
			ЛокЯдро_СохранитьНастройкуВБазеSMARTS("ДатаАктуальностиКэшируемыхНастроек", ДатаАктуальности);
			ЛокЯдро_СохранитьДанныеВХранилище1С("Cleverence_ДатаАктуальностиКэшируемыхНастроек_" + ПостфиксБазы, ДатаАктуальности);
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

&НаКлиенте
Процедура REST_API_УдалитьНастройкиSMARTS(СтруктураНастроек, УзловыеНастройки, ID_Узла = "")
		
	СтруктураПодключения = КомЯдро_ПолучитьЗначениеПеременной("REST_API_СтруктураПодключенияБазыMS");
		
	Для Каждого Настройка Из СтруктураНастроек Цикл
		ИтоговыйКлючНастройки = Настройка.Ключ;
		Если УзловыеНастройки.Найти(Настройка.Ключ) <> Неопределено Тогда
			ИтоговыйКлючНастройки = ИтоговыйКлючНастройки + ?(ID_Узла = "", "", "_"+ ID_Узла);
		КонецЕсли;
		REST_API_ВыполнитьМетод(СтруктураПодключения,Новый Структура("HTTPМетод,Метод,ТипЗапроса","DELETE","CustomSettings('"+ИтоговыйКлючНастройки+"')","ПолучениеСохранениеНастроек"),,АдресаПеременных);
	КонецЦикла;
	
КонецПроцедуры

&НаКлиенте
Функция REST_API_ВыгрузитьТаблицуНаСерверSMARTS(ИмяТаблицы, ДанныеДляВыгрузки, ТипБазы, ОчищатьСправочникПередВыгрузкой = Ложь)
	
	РезультатВыгрузки = Новый Структура;
	РезультатВыгрузки.Вставить("Статус"		, Истина);																			 
	РезультатВыгрузки.Вставить("Сообщение"	, "Таблица [" + ИмяТаблицы + "] успешно выгружена. Выгружено:" 
												+ Символы.ВК + Символы.Таб + "- " + Формат(?(ИмяТаблицы = "Номенклатура",ДанныеДляВыгрузки.МассивыСтрок.Количество(),ДанныеДляВыгрузки.Количество()), "ЧН=0; ЧГ=3,0") + " строк");
												
	Если ИмяТаблицы = "Номенклатура" Тогда											
		
		КоличествоРазличныхТоваров = ?(ДанныеДляВыгрузки.Свойство("КоличествоТоваров"),ДанныеДляВыгрузки.КоличествоТоваров,0);
		РезультатВыгрузки.Сообщение = РезультатВыгрузки.Сообщение 
										+ Символы.ВК + Символы.Таб + "- " + Формат(КоличествоРазличныхТоваров, "ЧН=0; ЧГ=3,0") + " товаров";
	КонецЕсли;											
	ИмяТаблицыENG = ЛокЯдро_СтрокуВТранслитENG(ИмяТаблицы);
	
	Если ТипБазы = "Частная" Тогда
		КлючПеременной = "REST_API_СтруктураПодключенияЧастнойБазыMS";
	ИначеЕсли ТипБазы = "Временная" Тогда
		КлючПеременной = "REST_API_СтруктураПодключенияВременнойБазыMS";
	Иначе
		КлючПеременной = "REST_API_СтруктураПодключенияБазыMS";
	КонецЕсли;
	
	СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной(КлючПеременной);
	
	РезультатПопытки = Истина;
	
	СтруктураПараметровМетода = Новый Структура;
	СтруктураПараметровМетода.Вставить("ИмяТаблицы", ИмяТаблицы);
	СтруктураПараметровМетода.Вставить("СтруктураПодключенияMS",СтруктураПодключенияMS);
	Если ИмяТаблицы = "Номенклатура" Тогда
		ПакетДляОтправки = Новый Структура();
		ПакетДляОтправки.Вставить("lschema",					ДанныеДляВыгрузки.МассивИмен);
		ПакетДляОтправки.Вставить("rewriteProductsBook",		ОчищатьСправочникПередВыгрузкой);
		ПакетДляОтправки.Вставить("useFullTextSearch",			Истина);
		СтруктураПараметровМетода.Вставить("ПакетДляОтправки", 	ПакетДляОтправки);
		
	ИначеЕсли ИмяТаблицы = "Ячейки" Тогда	
		СтруктураПараметровМетода.Вставить("ВызываемыйМетод",	?(ОчищатьСправочникПередВыгрузкой, "Overwrite", "Update"));
		
	Иначе
		СтруктураПараметровМетода.Вставить("ИмяТаблицыENG", 	ИмяТаблицыENG);
		СтруктураПараметровМетода.Вставить("ВызываемыйМетод",	?(ОчищатьСправочникПередВыгрузкой, "Overwrite", "Update"));
		
	КонецЕсли;
	
	// Первая попытка начать выгрузку
	РезультатОтвет = REST_API_ВыгрузкаТаблицыНаСерверSMARTS_Начало(СтруктураПараметровМетода);
	РезультатПопытки = РезультатПопытки И РезультатОтвет.КодСостояния = 204;	
	
	Если НЕ РезультатПопытки Тогда
		// Если при начале выгрузки возвращается ошибка, возможно на сервере не была завершена предыдущая выгрузка. Попытаемся сбросить и повторить начало выгрузки
		РезультатСброса = REST_API_ВыгрузкаТаблицыНаСерверSMARTS_СбросВыгрузки(СтруктураПараметровМетода);
		Если РезультатСброса.КодСостояния = 204 Тогда
			// Вторая попытка начать выгрузку
			РезультатОтвет = REST_API_ВыгрузкаТаблицыНаСерверSMARTS_Начало(СтруктураПараметровМетода);
			РезультатПопытки = РезультатОтвет.КодСостояния = 204;
		КонецЕсли;
		Если НЕ РезультатПопытки Тогда
			ОписаниеОшибки = РезультатОтвет.ТекстОшибки;
			РезультатВыгрузки = Новый Структура("Сообщение,Статус", "Таблица [" + ИмяТаблицы + "] не выгружается!" + Символы.ВК + ОписаниеОшибки, Ложь);
		КонецЕсли;
	КонецЕсли;
	
	Если РезультатВыгрузки.Статус = Истина Тогда
		КоличествоСтрок = ДанныеДляВыгрузки.Количество();
		МассивОтправляемыхЗначений = Новый Массив;
		Если ИмяТаблицы = "Номенклатура" Тогда
			МассивДанныхДляВыгрузки = ДанныеДляВыгрузки.МассивыСтрок;
		Иначе
			МассивДанныхДляВыгрузки = ДанныеДляВыгрузки;
		КонецЕсли;
		
		Икс = 0;МассивСтрокиВыгрузки = Новый Массив;
		Для Каждого СтрокаВыгрузки из МассивДанныхДляВыгрузки Цикл
			Икс = Икс +1;
			Если Икс%5000 = 0 Тогда
				МассивОтправляемыхЗначений.Добавить(МассивСтрокиВыгрузки);					
				МассивСтрокиВыгрузки = Новый Массив;
			КонецЕсли;
			МассивСтрокиВыгрузки.Добавить(СтрокаВыгрузки);
		КонецЦикла;
		МассивОтправляемыхЗначений.Добавить(МассивСтрокиВыгрузки);
		
		Для Каждого МассивСтрокиВыгрузки из МассивОтправляемыхЗначений Цикл
			
			Если ИмяТаблицы = "Номенклатура" Тогда
				
				СовмещенныйМассив = Новый Массив();
				Для каждого МассивСтроки Из МассивСтрокиВыгрузки Цикл 
					Для каждого Строка Из МассивСтроки Цикл
						#Если ВебКлиент тогда
						СовмещенныйМассив.Добавить(REST_API_ПолучитьСтрокуXML(Строка));
						#Иначе
						СовмещенныйМассив.Добавить(XMLСтрока(Строка));
						#КонецЕсли
					КонецЦикла;
				КонецЦикла;
				ОтправляемыеДанные = Новый Структура();
				ОтправляемыеДанные.Вставить("flds",СовмещенныйМассив);
				
			ИначеЕсли ИмяТаблицы = "Ячейки" Тогда
				ОтправляемыеДанные = Новый Соответствие;
				ОтправляемыеДанные.Вставить("value",МассивСтрокиВыгрузки);
				
			Иначе
				ОтправляемыеДанные = Новый Соответствие;
				ОтправляемыеДанные.Вставить("value",МассивСтрокиВыгрузки);
				
			КонецЕсли;
			
			СтруктураПараметровМетода.Вставить("ОтправляемыеДанные",ОтправляемыеДанные);
			
			РезультатОтвет = REST_API_ВыгрузкаТаблицыНаСерверSMARTS_ОтправкаЗначений(СтруктураПараметровМетода);
			РезультатПопытки = РезультатПопытки И НЕ ЗначениеЗаполнено(РезультатОтвет.ТекстОшибки);
	
			Если НЕ РезультатПопытки Тогда
				ОписаниеОшибки = РезультатОтвет.ТекстОшибки;
				РезультатВыгрузки =  Новый Структура("Сообщение,Статус", "Ошибка выгрузки таблицы [" + ИмяТаблицы + "]." + Символы.ВК + ОписаниеОшибки, Ложь);
				
				// Если при отправке данных произошла ошибка, попытаемся сбросить выгрузку, чтоб сервер дальше не ждал от нас новую порцию
				РезультатСброса = REST_API_ВыгрузкаТаблицыНаСерверSMARTS_СбросВыгрузки(СтруктураПараметровМетода);								
				Прервать;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Если РезультатВыгрузки.Статус = Истина Тогда
		
		РезультатОтвет = REST_API_ВыгрузкаТаблицыНаСерверSMARTS_Завершение(СтруктураПараметровМетода);
		РезультатПопытки = РезультатПопытки И НЕ ЗначениеЗаполнено(РезультатОтвет.ТекстОшибки);
		
		Если НЕ РезультатПопытки Тогда
			ОписаниеОшибки = РезультатОтвет.ТекстОшибки;
			РезультатВыгрузки =  Новый Структура("Сообщение,Статус", "Не удалось закончить выгрузку таблицы [" + ИмяТаблицы + "]." + Символы.ВК + ОписаниеОшибки, Ложь);
		КонецЕсли;
	КонецЕсли;
	
	Возврат РезультатВыгрузки;
	
КонецФункции

&НаКлиенте
Функция REST_API_ВыгрузкаТаблицыНаСерверSMARTS_Начало(СтруктураПараметровМетода)
	
	ИмяТаблицы 				= СтруктураПараметровМетода.ИмяТаблицы;
	СтруктураПодключенияMS 	= СтруктураПараметровМетода.СтруктураПодключенияMS;
	
	Если ИмяТаблицы = "Номенклатура" Тогда
		ПакетДляОтправки = СтруктураПараметровМетода.ПакетДляОтправки;				
		РезультатОтвет = REST_API_ВыполнитьМетод(СтруктураПодключенияMS,Новый Структура("HTTPМетод,Метод,ТипЗапроса","POST","Products/BeginUploadProducts","НачалоВыгрузкиТаблицы"),ПакетДляОтправки,АдресаПеременных);
	
	ИначеЕсли ИмяТаблицы = "Ячейки" Тогда	
		ВызываемыйМетод = СтруктураПараметровМетода.ВызываемыйМетод;
		РезультатОтвет = REST_API_ВыполнитьМетод(СтруктураПодключенияMS,Новый Структура("HTTPМетод,Метод,ТипЗапроса","POST","Cells/Begin"+ВызываемыйМетод,"НачалоВыгрузкиТаблицы"),Новый Структура("warehouseId","1"),АдресаПеременных);
		//РезультатОтвет = REST_API_ВыполнитьМетод(СтруктураПодключенияMS,Новый Структура("HTTPМетод,Метод,ТипЗапроса","POST","Cells/BeginUpdate","НачалоВыгрузкиТаблицы"),Новый Структура("warehouseId","1"),АдресаПеременных);				
		
	Иначе
		ИмяТаблицыENG 	= СтруктураПараметровМетода.ИмяТаблицыENG;
		ВызываемыйМетод = СтруктураПараметровМетода.ВызываемыйМетод;
		РезультатОтвет = REST_API_ВыполнитьМетод(СтруктураПодключенияMS,Новый Структура("HTTPМетод,Метод,ТипЗапроса","POST","Tables/"+ИмяТаблицыENG+"/Begin"+ВызываемыйМетод,"НачалоВыгрузкиТаблицы"),,АдресаПеременных);
		//РезультатОтвет = REST_API_ВыполнитьМетод(СтруктураПодключенияMS,Новый Структура("HTTPМетод,Метод,ТипЗапроса","POST","Tables/"+ИмяТаблицыENG+"/BeginOverwrite","НачалоВыгрузкиТаблицы"),,АдресаПеременных);
		
	КонецЕсли;
	
	Возврат РезультатОтвет;
КонецФункции

&НаКлиенте
Функция REST_API_ВыгрузкаТаблицыНаСерверSMARTS_ОтправкаЗначений(СтруктураПараметровМетода)
	
	ИмяТаблицы 				= СтруктураПараметровМетода.ИмяТаблицы;
	СтруктураПодключенияMS 	= СтруктураПараметровМетода.СтруктураПодключенияMS;
	ОтправляемыеДанные 		= СтруктураПараметровМетода.ОтправляемыеДанные;
	
	Если ИмяТаблицы = "Номенклатура" Тогда	
		РезультатОтвет = REST_API_ВыполнитьМетод(СтруктураПодключенияMS,Новый Структура("HTTPМетод,Метод,ТипЗапроса","POST","Products/AddProductsToUpload","ВыгрузкаТаблицы"),ОтправляемыеДанные,АдресаПеременных);
		
	ИначеЕсли ИмяТаблицы = "Ячейки" Тогда		
		РезультатОтвет = REST_API_ВыполнитьМетод(СтруктураПодключенияMS,Новый Структура("HTTPМетод,Метод,ТипЗапроса","POST","Cells","ВыгрузкаТаблицы"),ОтправляемыеДанные,АдресаПеременных);
		
	Иначе
		ИмяТаблицыENG = СтруктураПараметровМетода.ИмяТаблицыENG;
		РезультатОтвет = REST_API_ВыполнитьМетод(СтруктураПодключенияMS,Новый Структура("HTTPМетод,Метод,ТипЗапроса","POST","Tables/"+ИмяТаблицыENG,"ВыгрузкаТаблицы"),ОтправляемыеДанные,АдресаПеременных);
		
	КонецЕсли;
	
	Возврат РезультатОтвет;
	
КонецФункции

&НаКлиенте
Функция REST_API_ВыгрузкаТаблицыНаСерверSMARTS_Завершение(СтруктураПараметровМетода)
	
	ИмяТаблицы 				= СтруктураПараметровМетода.ИмяТаблицы;
	СтруктураПодключенияMS 	= СтруктураПараметровМетода.СтруктураПодключенияMS;
	
	Если ИмяТаблицы = "Номенклатура" Тогда
		РезультатОтвет = REST_API_ВыполнитьМетод(СтруктураПодключенияMS,Новый Структура("HTTPМетод,Метод,ТипЗапроса","POST","Products/EndUploadProducts","КонецВыгрузкиТаблицы"),,АдресаПеременных);		
		
	ИначеЕсли ИмяТаблицы = "Ячейки" Тогда	
		ВызываемыйМетод = СтруктураПараметровМетода.ВызываемыйМетод;
		РезультатОтвет = REST_API_ВыполнитьМетод(СтруктураПодключенияMS,Новый Структура("HTTPМетод,Метод,ТипЗапроса","POST","Cells/End"+ВызываемыйМетод,"КонецВыгрузкиТаблицы"),Новый Структура("warehouseId","1"),АдресаПеременных);		
		//РезультатОтвет = REST_API_ВыполнитьМетод(СтруктураПодключенияMS,Новый Структура("HTTPМетод,Метод,ТипЗапроса","POST","Cells/EndUpdate","КонецВыгрузкиТаблицы"),Новый Структура("warehouseId","1"),АдресаПеременных);		
		
	Иначе
		ИмяТаблицыENG 	= СтруктураПараметровМетода.ИмяТаблицыENG;
		ВызываемыйМетод = СтруктураПараметровМетода.ВызываемыйМетод;
		РезультатОтвет = REST_API_ВыполнитьМетод(СтруктураПодключенияMS,Новый Структура("HTTPМетод,Метод,ТипЗапроса","POST","Tables/"+ИмяТаблицыENG+"/End"+ВызываемыйМетод,"КонецВыгрузкиТаблицы"),,АдресаПеременных);
		//РезультатОтвет = REST_API_ВыполнитьМетод(СтруктураПодключенияMS,Новый Структура("HTTPМетод,Метод,ТипЗапроса","POST","Tables/"+ИмяТаблицыENG+"/EndOverwrite","КонецВыгрузкиТаблицы"),,АдресаПеременных);
		
	КонецЕсли;
	
	Возврат РезультатОтвет;
	
КонецФункции

&НаКлиенте
Функция REST_API_ВыгрузкаТаблицыНаСерверSMARTS_СбросВыгрузки(СтруктураПараметровМетода)
	
	ИмяТаблицы 				= СтруктураПараметровМетода.ИмяТаблицы;
	СтруктураПодключенияMS 	= СтруктураПараметровМетода.СтруктураПодключенияMS;
	
	Если ИмяТаблицы = "Номенклатура" Тогда	                                                          
		СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключенияMS,Новый Структура("HTTPМетод,Метод,ТипЗапроса","POST","Products/ResetUploadProducts","НачалоВыгрузкиТаблицы"),,АдресаПеременных);		
	ИначеЕсли ИмяТаблицы = "Ячейки" Тогда
		ВызываемыйМетод = СтруктураПараметровМетода.ВызываемыйМетод;
		СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключенияMS,Новый Структура("HTTPМетод,Метод,ТипЗапроса","POST","Cells/Reset"+ВызываемыйМетод,"НачалоВыгрузкиТаблицы"),Новый Структура("warehouseId","1"),АдресаПеременных);
		//СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключенияMS,Новый Структура("HTTPМетод,Метод,ТипЗапроса","POST","Cells/ResetUpdate","НачалоВыгрузкиТаблицы"),Новый Структура("warehouseId","1"),АдресаПеременных);			
	Иначе
		ИмяТаблицыENG 	= СтруктураПараметровМетода.ИмяТаблицыENG;
		ВызываемыйМетод = СтруктураПараметровМетода.ВызываемыйМетод;
		СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключенияMS,Новый Структура("HTTPМетод,Метод,ТипЗапроса","POST","Tables/"+ИмяТаблицыENG+"/Reset"+ВызываемыйМетод,"НачалоВыгрузкиТаблицы"),,АдресаПеременных);
		//СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключенияMS,Новый Структура("HTTPМетод,Метод,ТипЗапроса","POST","Tables/"+ИмяТаблицыENG+"/ResetOverwrite","НачалоВыгрузкиТаблицы"),,АдресаПеременных);		
	КонецЕсли;
	
	Возврат СтруктураОтвета;
	
КонецФункции

&НаСервере
Функция REST_API_ПолучитьСтрокуXML(Строка)
	Возврат XMLСтрока(Строка);	
КонецФункции

// Выполняет очистку таблицы на сервере Mobile Smarts при работе с типом интерфейса REST_API
//
// Параметры:
//	ИмяТаблицы - Строка - имя таблицы Mobile Smarts, которую необходимо очистить
//  ТипБазы - Строка - "Частная", "Временная", "Основная"
//
// Возвращаемое значение:
//	Структура - содержит:
//		* Сообщение - Строка - информационное сообщение о результате очистки таблицы
//		* Статус - Булево - флаг успешности очистки таблицы
&НаКлиенте
Функция REST_API_ОчиститьТаблицуНаСервереSMARTS(ИмяТаблицы, ТипБазы) Экспорт
	
	Если ТипБазы = "Частная" Тогда
		КлючПеременной = "REST_API_СтруктураПодключенияЧастнойБазыMS";
	ИначеЕсли ТипБазы = "Временная" Тогда
		КлючПеременной = "REST_API_СтруктураПодключенияВременнойБазыMS";
	Иначе
		КлючПеременной = "REST_API_СтруктураПодключенияБазыMS";
	КонецЕсли;
	
	СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной(КлючПеременной);
	ИмяТаблицыENG = ЛокЯдро_СтрокуВТранслитENG(ИмяТаблицы);
	РезультатПопытки = Истина;
	// Во всех случаях ТипЗапроса устанавливается = "НачалоВыгрузкиТаблицы", т.к. не выгружаем данные и завершение апдейта не должно долго выполняться
	Если ИмяТаблицы = "Номенклатура" Тогда
		РезультатОтвет = REST_API_ВыполнитьМетод(СтруктураПодключенияMS,Новый Структура("HTTPМетод,Метод,ТипЗапроса","POST","Products/BeginOverwrite","НачалоВыгрузкиТаблицы"),,АдресаПеременных);
		РезультатПопытки = РезультатПопытки И РезультатОтвет.КодСостояния = 204;
		РезультатОтвет = REST_API_ВыполнитьМетод(СтруктураПодключенияMS,Новый Структура("HTTPМетод,Метод,ТипЗапроса","POST","Products/EndOverwrite","НачалоВыгрузкиТаблицы"),,АдресаПеременных);
		РезультатПопытки = РезультатПопытки И РезультатОтвет.КодСостояния = 204;
	ИначеЕсли ИмяТаблицы = "Ячейки" Тогда
		МассивСтрокиВыгрузки = Новый Соответствие;
		МассивСтрокиВыгрузки.Вставить("warehouseId","1");
		РезультатОтвет = REST_API_ВыполнитьМетод(СтруктураПодключенияMS,Новый Структура("HTTPМетод,Метод,ТипЗапроса","POST","Cells/BeginOverwrite","НачалоВыгрузкиТаблицы"),МассивСтрокиВыгрузки,АдресаПеременных);
		РезультатПопытки = РезультатПопытки И НЕ ЗначениеЗаполнено(РезультатОтвет.ТекстОшибки);
		РезультатОтвет = REST_API_ВыполнитьМетод(СтруктураПодключенияMS,Новый Структура("HTTPМетод,Метод,ТипЗапроса","POST","Cells/EndOverwrite","НачалоВыгрузкиТаблицы"),МассивСтрокиВыгрузки,АдресаПеременных);
		РезультатПопытки = РезультатПопытки И НЕ ЗначениеЗаполнено(РезультатОтвет.ТекстОшибки);
	Иначе
		РезультатОтвет = REST_API_ВыполнитьМетод(СтруктураПодключенияMS,Новый Структура("HTTPМетод,Метод,ТипЗапроса","POST","Tables/"+ИмяТаблицыENG+"/BeginOverwrite","НачалоВыгрузкиТаблицы"),,АдресаПеременных);
		РезультатПопытки = РезультатПопытки И РезультатОтвет.КодСостояния = 204;
		РезультатОтвет = REST_API_ВыполнитьМетод(СтруктураПодключенияMS,Новый Структура("HTTPМетод,Метод,ТипЗапроса","POST","Tables/"+ИмяТаблицыENG+"/EndOverwrite","НачалоВыгрузкиТаблицы"),,АдресаПеременных);
		РезультатПопытки = РезультатПопытки И РезультатОтвет.КодСостояния = 204;
	КонецЕсли;
	
	Если РезультатПопытки = Истина Тогда
		РезультатВыгрузки = Новый Структура("Сообщение,Статус", "Таблица [" + ИмяТаблицы + "] успешно очищена", Истина);
	Иначе
		РезультатВыгрузки = Новый Структура("Сообщение,Статус", "Ошибка при очистке таблицы [" + ИмяТаблицы + "]", Ложь);
	КонецЕсли;
	
	Возврат РезультатВыгрузки;
	
КонецФункции

&НаКлиенте
Функция REST_API_ПолучитьСписокДокументовНаСервереSMARTS(ТаблицаДокументов, ТипБазы, РазмерВыборки = 0, ОтборПоПериоду = Неопределено, ОтборПоУзлу = Неопределено)
	
	ИмяСобытия = "REST_API_ПолучитьСписокДокументовНаСервереSMARTS";
	
	Если ТипБазы = "Частная" Тогда
		КлючПеременной = "REST_API_СтруктураПодключенияЧастнойБазыMS";
	ИначеЕсли ТипБазы = "Временная" Тогда
		КлючПеременной = "REST_API_СтруктураПодключенияВременнойБазыMS";
	Иначе
		КлючПеременной = "REST_API_СтруктураПодключенияБазыMS";
	КонецЕсли;
	
	СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной(КлючПеременной);
	
	СтрокаФильтра 	= "";
	ФильтрПоПериоду = "";
	ФильтрПоУзлу	= "";
	
	Если ОтборПоПериоду <> Неопределено Тогда
		ДатаНачала 		= ОтборПоПериоду.ДатаНачала;                                      	
		Если ЗначениеЗаполнено(ДатаНачала) Тогда                                          
			ГодНачалаПериода 	= Формат(Год(ДатаНачала), "ЧГ=");
			МесяцНачалаПериода 	= Месяц(ДатаНачала);
			ФильтрПоПериоду = ФильтрПоПериоду + "((year(createDate) eq " + ГодНачалаПериода + " and month(createDate) gt " + МесяцНачалаПериода + ") " +
				"or (year(createDate) eq " + ГодНачалаПериода + " and month(createDate) eq " + МесяцНачалаПериода + " and day(createDate) ge " + День(ДатаНачала) + ") " + 
					"or (year(createDate) gt " + ГодНачалаПериода + "))";
		КонецЕсли;            		
		ДатаОкончания 	= ОтборПоПериоду.ДатаОкончания;
		Если ЗначениеЗаполнено(ДатаОкончания) Тогда     
			ГодКонцаПериода 	= Формат(Год(ДатаОкончания), "ЧГ=");
			МесяцКонцаПериода 	= Месяц(ДатаОкончания);
			ФильтрПоПериоду = ФильтрПоПериоду + ?(ЗначениеЗаполнено(ДатаНачала), " and ", "") + "((year(createDate) eq " + ГодКонцаПериода + " and month(createDate) lt " + МесяцКонцаПериода + ") " +
				"or (year(createDate) eq " + ГодКонцаПериода + " and month(createDate) eq " + МесяцКонцаПериода + " and day(createDate) lt " + День(ДатаОкончания) + ") " + 
					"or (year(createDate) lt " + ГодКонцаПериода + "))";
		КонецЕсли;		                                                                                          
	КонецЕсли;                                                            
		
	Если ОтборПоУзлу <> Неопределено Тогда
		ФильтрПоУзлу = ?(НЕ ПустаяСтрока(ФильтрПоПериоду), " and ", "") + "(idUzla eq '" + ОтборПоУзлу.ID_Узла + "' or idUzla eq NULL)";
	КонецЕсли;
	
	Если НЕ ПустаяСтрока(ФильтрПоПериоду)
		ИЛИ НЕ ПустаяСтрока(ФильтрПоУзлу) Тогда
		СтрокаФильтра = "&$filter=" + ФильтрПоПериоду + ФильтрПоУзлу;
	КонецЕсли;
	
	ДопОтбор = ?(ЗначениеЗаполнено(РазмерВыборки), "&$top=" + РазмерВыборки, "");
	
	// заполняем таблицу
	СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключенияMS,Новый Структура("HTTPМетод,Метод,ТипЗапроса", "GET", "Docs?$expand=declaredItems($count=true;$top=0),currentItems($count=true;$top=0),extendedFields" + СтрокаФильтра + ДопОтбор, "ПолучениеСпискаДокументов"),,АдресаПеременных);
	Если СтруктураОтвета.КодСостояния <> 200 Тогда
		ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Запрос: GET, Docs?$expand=declaredItems($count=true;$top=0),currentItems($count=true;$top=0),extendedFields" + СтрокаФильтра + ДопОтбор + ". Получен некорректный ответ от сервера, Код состояния: " + Строка(СтруктураОтвета.КодСостояния)+ ". Содержание ошибки: " + Строка(СтруктураОтвета.ТекстОшибки));
		Возврат Неопределено;
	КонецЕсли;
	СписокДокументовSMARTS = СтруктураОтвета.ОтветСервера.Получить("value");	
	Для Каждого ДокументSMARTS Из СписокДокументовSMARTS Цикл
		
		КоличествоПлан = ДокументSMARTS.Получить("declaredItems@odata.count");		
		Если КоличествоПлан = Неопределено Тогда
			СтрокиПлан = ДокументSMARTS.Получить("declaredItems");
			КоличествоПлан = ?(СтрокиПлан=Неопределено,0,СтрокиПлан.Количество());
		КонецЕсли;
		
		КоличествоФакт = ДокументSMARTS.Получить("currentItems@odata.count");
		Если КоличествоФакт = Неопределено Тогда
			СтрокиФакт = ДокументSMARTS.Получить("currentItems");
			КоличествоФакт = ?(СтрокиФакт=Неопределено,0,СтрокиФакт.Количество());
		КонецЕсли;
		
		extendedFields = ДокументSMARTS.Получить("extendedFields");
		ИмяТипаДокумента = ЛокЯдро_ПреобразованиеНаименованияДокументаБезПробелов(ДокументSMARTS.Получить("documentTypeName"));
		
		// Новые типы документов, добавленные, например, вручную, и еще не инициализированные в текущих
		// настройках ядра, просто пропускаем
		Если Не СтруктураМетаданных.ДокументыMS.Свойство(ИмяТипаДокумента) Тогда
			Продолжить;
		КонецЕсли;
		
		ТекущаяСтрокаТаблицы = Новый Структура(
		"ДатаСоздания,
		|Имя,
		|Ид,
		|ИмяТипаДокумента,
		|СтрокиПланКоличество,
		|СтрокиФактКоличество,
		|ИмяПользователя,
		|ВОбработке,
		|Завершен,
		|НастройкаБизнесПроцесса,
		|СозданНаТСД,
		|ЕстьПереполнениеИлиНедобор,
		|ЕстьПереполнение,
		|ЕстьНедобор,
		|ДатаЗавершения,
		|КонтрольКоличества,
		|ИдИсходныхДокументов,
		|ИмяБП,
		|ИдУзла"
		,ДокументSMARTS.Получить("createDate")
		,ДокументSMARTS.Получить("name")
		,ДокументSMARTS.Получить("id")
		,ИмяТипаДокумента
		,КоличествоПлан
		,КоличествоФакт
		,ДокументSMARTS.Получить("userName")
		,ДокументSMARTS.Получить("inProcess")
		,ДокументSMARTS.Получить("finished")
		,ДокументSMARTS.Получить("nastrojkaBiznesProcessa")
		,ДокументSMARTS.Получить("createdOnPDA")
		,?(extendedFields<>Неопределено,extendedFields.Получить("underloadedOrOverloaded"),Ложь)
		,?(extendedFields<>Неопределено,extendedFields.Получить("overloaded"),Ложь)
		,?(extendedFields<>Неопределено,extendedFields.Получить("underloaded"),Ложь)
		,ДокументSMARTS.Получить("lastChangeDate")
		,ДокументSMARTS.Получить("kontrolKolva")
		,ДокументSMARTS.Получить("idIshodnyhDokumentov")
		,ДокументSMARTS.Получить("imyaBP")
		,ДокументSMARTS.Получить("idUzla"));

		// Дополняем существующую таблицу реквизитами шапки документа
		МассивРеквизитов = СтруктураМетаданных.ДокументыMS[ИмяТипаДокумента].Реквизиты;
		Для Каждого СтрокаРеквизит Из МассивРеквизитов Цикл
			Если ТекущаяСтрокаТаблицы.Свойство(СтрокаРеквизит.Значение) Тогда
				Продолжить;
			КонецЕсли;                                                                   			
			ТекущаяСтрокаТаблицы.Вставить(СтрокаРеквизит.Значение, ДокументSMARTS.Получить(СтрокаРеквизит.Uni));			
		КонецЦикла;		
		
		ТаблицаДокументов.Добавить(ТекущаяСтрокаТаблицы);
	КонецЦикла;
	
	Для Каждого СтрокаТаблицы Из ТаблицаДокументов Цикл
		Если СтрокаТаблицы.Свойство("ЭтоТаблицаЗначений") Тогда
			Продолжить;
		КонецЕсли;
		
		Попытка
			Если ТипЗнч(СтрокаТаблицы.ДатаСоздания) = Тип("Строка") Тогда
				#Если Не ВебКлиент тогда
				СтрокаТаблицы.ДатаСоздания = ПрочитатьДатуJSON(СтрокаТаблицы.ДатаСоздания, ФорматДатыJSON.ISO);
				СтрокаТаблицы.ДатаЗавершения = ПрочитатьДатуJSON(СтрокаТаблицы.ДатаЗавершения, ФорматДатыJSON.ISO);
				#КонецЕсли
			КонецЕсли;
		Исключение
			Прервать; // не будем продолжать, если дата не ISO
		КонецПопытки;  		
	КонецЦикла;	
	
	Возврат ТаблицаДокументов;
	
КонецФункции

&НаКлиенте
Функция REST_API_ПолучитьДанныеДокументаНаСервереSMARTS(ID_Документа, СтруктураДокументаMS, ТипБазы, ФильтрТЧПоИдДокумента = Неопределено, ЗапрашиватьCombinedItems = Истина)
		
	ИмяСобытия = "REST_API_ПолучитьДанныеДокументаНаСервереSMARTS";
	
	Если ТипБазы = "Частная" Тогда
		КлючПеременной = "REST_API_СтруктураПодключенияЧастнойБазыMS";
	ИначеЕсли ТипБазы = "Временная" Тогда
		КлючПеременной = "REST_API_СтруктураПодключенияВременнойБазыMS";
	Иначе
		КлючПеременной = "REST_API_СтруктураПодключенияБазыMS";
	КонецЕсли;
	
	СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной(КлючПеременной);

	Если ЗапрашиватьCombinedItems Тогда
		СтрокаExpand = "expand=declaredItems,currentItems,combinedItems,extendedFields,tables($expand=rows)";
	Иначе
		СтрокаExpand = "expand=declaredItems,currentItems,extendedFields,tables($expand=rows)";		
	КонецЕсли;
	
	UniДокумента = СтруктураДокументаMS.uni;
	СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключенияMS,Новый Структура("HTTPМетод,Метод,ВернутьСтруктуру,ТипЗапроса","GET","Docs/"+UniДокумента+"('"+ID_Документа+"')?$"+СтрокаExpand,Истина,"ПолучениеПолногоДокумента"),,АдресаПеременных);
	Если СтруктураОтвета.КодСостояния <> 200 Тогда
		ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Запрос: GET, Docs/" + UniДокумента + "('" + ID_Документа + "')?$" + СтрокаExpand + ". Получен некорректный ответ от сервера, Код состояния: " + Строка(СтруктураОтвета.КодСостояния)+ ". Содержание ошибки: " + Строка(СтруктураОтвета.ТекстОшибки));
		Возврат Неопределено;
	КонецЕсли;
	ДокументSMARTS = СтруктураОтвета.ОтветСервера;
	
	ДанныеДокументаMS = Новый Структура;
	
	КешТранслитерацииПолей = Новый Соответствие;
	
	// Шапка
	РеквизитыШапки = Новый Структура;
	Для Каждого РеквизитДокумента Из СтруктураДокументаMS.Реквизиты Цикл
		Попытка
			ИмяПоля = РеквизитДокумента.Uni;
			
			Если ЗначениеЗаполнено(ИмяПоля) И ДокументSMARTS.Свойство(ИмяПоля) Тогда
				ЗначениеРеквизита = ДокументSMARTS[ИмяПоля];
			Иначе	
				ИмяТранслит = КешТранслитерацииПолей.Получить(РеквизитДокумента.Значение);
				Если ИмяТранслит = Неопределено Тогда
					ИмяПоля = ЛокЯдро_СтрокуВТранслитENG(РеквизитДокумента.Значение);
					КешТранслитерацииПолей.Вставить(РеквизитДокумента.Значение, ИмяПоля);
				Иначе
					ИмяПоля = ИмяТранслит;
				КонецЕсли;
				Если ЗначениеЗаполнено(ИмяПоля) И ДокументSMARTS.Свойство(ИмяПоля) Тогда
					ЗначениеРеквизита = ДокументSMARTS[ИмяПоля];
				Иначе
					ЗначениеРеквизита = Неопределено;
				КонецЕсли;
			КонецЕсли;
			
			РеквизитыШапки.Вставить(РеквизитДокумента.Значение, ЗначениеРеквизита);
		Исключение
			Сообщить("Реквизит с именем [" + РеквизитДокумента.Значение + "] отсутствует в шапке документа");
		КонецПопытки; 		
	КонецЦикла;
	
	Попытка
		Если ДокументSMARTS.Свойство("states") 
			И ТипЗнч(ДокументSMARTS.states) = Тип("Массив")
			И ДокументSMARTS.states.Количество() > 0 Тогда
			СтатусДокументаMS = ДокументSMARTS["states"][0];
			РеквизитыШапки.Вставить("ВремяНачалаОбработки",	СтатусДокументаMS["inProcessDate"]);
			РеквизитыШапки.Вставить("ВремяИзменения",		СтатусДокументаMS["modifiedDate"]);	
			РеквизитыШапки.Вставить("ВремяЗавершения",		СтатусДокументаMS["finishedDate"]);
		КонецЕсли;
	Исключение	
	КонецПопытки;
	
	Если ДокументSMARTS.Свойство("extendedFields") И ТипЗнч(ДокументSMARTS.extendedFields) = Тип("Структура") Тогда
		ExtendedFields = ДокументSMARTS["extendedFields"];
		РеквизитыШапки.Вставить("Overloaded",			 	?(ExtendedFields.Свойство("overloaded"), ExtendedFields["overloaded"], Ложь));	
		РеквизитыШапки.Вставить("Underloaded",				?(ExtendedFields.Свойство("underloaded"), ExtendedFields["underloaded"], Ложь));
		РеквизитыШапки.Вставить("UnderloadedOrOverloaded",	?(ExtendedFields.Свойство("underloadedOrOverloaded"), ExtendedFields["underloadedOrOverloaded"], Ложь));
	Иначе
		РеквизитыШапки.Вставить("Overloaded",			 	Ложь);	
		РеквизитыШапки.Вставить("Underloaded",				Ложь);
		РеквизитыШапки.Вставить("UnderloadedOrOverloaded",	Ложь);
	КонецЕсли;
	
	ДанныеДокументаMS.Вставить("ШапкаДокумента", РеквизитыШапки);
	
	// Подготовка табличных частей
	ТабличнаяЧастьФакт = Новый Массив;МассивКолонокФакт = Новый Массив;
	ТабличнаяЧастьПлан = Новый Массив;МассивКолонокПлан = Новый Массив;
	ТабличнаяЧастьСовмещенные = Новый Массив;МассивКолонокСовмещенные = Новый Массив;
	
	СписокПолей = "";
	МассивКолонок = Новый Массив;
	Для Каждого РеквизитТЧ Из СтруктураДокументаMS.РеквизитыТЧ Цикл		
		МассивКолонокФакт.Добавить(РеквизитТЧ);
		МассивКолонокПлан.Добавить(РеквизитТЧ);
		МассивКолонокСовмещенные.Добавить(РеквизитТЧ);
		СписокПолей = СписокПолей + РеквизитТЧ.Значение + ",";
	КонецЦикла;	
	СписокПолей = Лев(СписокПолей,СтрДлина(СписокПолей)-1);
	
	Если ТипЗнч(СтруктураМетаданных) = Тип("Структура") И СтруктураМетаданных.Свойство("UniПолейНоменклатуры") Тогда
		UniПолейНоменклатуры = СтруктураМетаданных.UniПолейНоменклатуры;
	Иначе
		UniПолейНоменклатуры = Новый Соответствие();
	КонецЕсли;
	
	СоответствиеИменПолейDeclaredItems = Новый Соответствие;
	СоответствиеИменПолейCurrentItems  = Новый Соответствие;
	СоответствиеИменПолейCombinedItems = Новый Соответствие;
	
	// План
	Если ДокументSMARTS.Свойство("declaredItems") И ТипЗнч(ДокументSMARTS["declaredItems"]) = Тип("Массив") Тогда
		Для Каждого СтрокаТЧ из ДокументSMARTS["declaredItems"] Цикл
			// фильтр ТЧ если она была объединена из нескольких документов
			Если ЗначениеЗаполнено(ФильтрТЧПоИдДокумента) 
				И СтрокаТЧ.Свойство("idDokumenta") Тогда                           
				ИдДокументаВладелецСтроки = СтрокаТЧ["idDokumenta"];
				Если ИдДокументаВладелецСтроки <> ФильтрТЧПоИдДокумента Тогда
					Продолжить;
				КонецЕсли;
			КонецЕсли;
			
			НоваяСтрока = Новый Структура();
			Для Каждого РеквизитТЧ Из МассивКолонокПлан Цикл
				Попытка
					ИмяПоля = СоответствиеИменПолейDeclaredItems.Получить(РеквизитТЧ.Uni);
					Если ИмяПоля = Неопределено Тогда
						ИмяПоля = РеквизитТЧ.Uni;
						Если ЗначениеЗаполнено(ИмяПоля) И СтрокаТЧ.Свойство(ИмяПоля) Тогда
							ЗначениеРеквизита = СтрокаТЧ[ИмяПоля];
							СоответствиеИменПолейDeclaredItems.Вставить(РеквизитТЧ.Uni, ИмяПоля);	
						Иначе	
							ИмяТранслит = КешТранслитерацииПолей.Получить(РеквизитТЧ.Значение);
							Если ИмяТранслит = Неопределено Тогда
								ИмяПоля = ЛокЯдро_СтрокуВТранслитENG(РеквизитТЧ.Значение);
								КешТранслитерацииПолей.Вставить(РеквизитТЧ.Значение,ИмяПоля);
							Иначе
								ИмяПоля = ИмяТранслит;
							КонецЕсли;
							Если ЗначениеЗаполнено(ИмяПоля) И СтрокаТЧ.Свойство(ИмяПоля) Тогда
								ЗначениеРеквизита = СтрокаТЧ[ИмяПоля];
								СоответствиеИменПолейDeclaredItems.Вставить(РеквизитТЧ.Uni, ИмяПоля);	
							Иначе
								ИмяПоля = UniПолейНоменклатуры.Получить(РеквизитТЧ.Значение);
								Если ЗначениеЗаполнено(ИмяПоля) И СтрокаТЧ.Свойство(ИмяПоля) Тогда
									ЗначениеРеквизита = СтрокаТЧ[ИмяПоля];
									СоответствиеИменПолейDeclaredItems.Вставить(РеквизитТЧ.Uni, ИмяПоля);	
								Иначе
									ЗначениеРеквизита = Неопределено;
								КонецЕсли;
							КонецЕсли;
						КонецЕсли;
					ИначеЕсли СтрокаТЧ.Свойство(ИмяПоля) Тогда
						ЗначениеРеквизита = СтрокаТЧ[ИмяПоля];
					Иначе
						ЗначениеРеквизита = Неопределено;	
					КонецЕсли;
					НоваяСтрока.Вставить(РеквизитТЧ.Значение,ЗначениеРеквизита);
				Исключение
					Сообщить("Реквизит с именем [" + РеквизитДокумента.Имя + "] отсутствует в табличной части [СтрокиПлан]");
				КонецПопытки; 			
			КонецЦикла;
			ТабличнаяЧастьПлан.Добавить(НоваяСтрока);
		КонецЦикла;                                  		
	КонецЕсли;
	ТабличнаяЧастьПлан.Вставить(0, Новый Структура("ЭтоТаблицаЗначений, КолонкиТаблицыЗначений", Истина, СписокПолей));
	ДанныеДокументаMS.Вставить("СтрокиПлан", ТабличнаяЧастьПлан);
	
	// Факт
	Если ДокументSMARTS.Свойство("currentItems") И ТипЗнч(ДокументSMARTS["currentItems"]) = Тип("Массив") Тогда
		Для Каждого СтрокаТЧ из ДокументSMARTS["currentItems"] Цикл
			
			// фильтр ТЧ если она была объединена из нескольких документов
			Если ЗначениеЗаполнено(ФильтрТЧПоИдДокумента) Тогда
				Если СтрокаТЧ.Свойство("bindedLineUid")
					И ЗначениеЗаполнено(СтрокаТЧ.bindedLineUid) Тогда
					СвязаннаяСтрока = ЛокЯдро_НайтиПоЗначениюВМассивеСтруктур(ДокументSMARTS["declaredItems"],"uid",СтрокаТЧ.bindedLineUid);
					Если СвязаннаяСтрока <> Неопределено
						И СвязаннаяСтрока.Свойство("idDokumenta") Тогда 
						СтрокаТЧ.Вставить("idDokumenta",СвязаннаяСтрока.IdDokumenta);
					КонецЕсли;
				КонецЕсли;
				ИдДокументаВладелецСтроки = "";
				Если СтрокаТЧ.Свойство("idDokumenta") Тогда                           
					ИдДокументаВладелецСтроки = СтрокаТЧ["idDokumenta"];
				КонецЕсли;
				Если ИдДокументаВладелецСтроки <> ФильтрТЧПоИдДокумента
					И НЕ (ID_Документа = ФильтрТЧПоИдДокумента И ИдДокументаВладелецСтроки = "") // Это условие нужно для загрузки всех строк, которых не было по плану, в первый документ
					Тогда
					Продолжить;
				КонецЕсли;
			КонецЕсли;
			
			НоваяСтрока = Новый Структура();
			Для Каждого РеквизитТЧ Из МассивКолонокФакт Цикл
				Попытка
					ИмяПоля = СоответствиеИменПолейCurrentItems.Получить(РеквизитТЧ.Uni);
					Если ИмяПоля = Неопределено Тогда
						ИмяПоля = РеквизитТЧ.Uni;
						Если ЗначениеЗаполнено(ИмяПоля) И СтрокаТЧ.Свойство(ИмяПоля) Тогда
							ЗначениеРеквизита = СтрокаТЧ[ИмяПоля];
							Если ИмяПоля = "bindedLineUid" Тогда
								СвязаннаяСтрока = ЛокЯдро_НайтиПоЗначениюВМассивеСтруктур(ДокументSMARTS["declaredItems"],"uid",СтрокаТЧ[ИмяПоля]);
								Если СвязаннаяСтрока <> Неопределено Тогда
							 		// +++ Преобразуем имена полей связанной строки
									Если СвязаннаяСтрока.Количество() > 0 Тогда
										Для Каждого РеквизитТЧПлан Из МассивКолонокПлан Цикл
											Попытка
												ИмяПоляСС = СоответствиеИменПолейDeclaredItems.Получить(РеквизитТЧПлан.Uni);
												Если ИмяПоляСС = Неопределено Тогда
													ИмяПоляСС = РеквизитТЧПлан.Uni;
													Если ЗначениеЗаполнено(ИмяПоляСС) И СвязаннаяСтрока.Свойство(ИмяПоляСС) Тогда
														ЗначениеРеквизитаСвязаннойСтроки = СвязаннаяСтрока[ИмяПоляСС];
														СоответствиеИменПолейDeclaredItems.Вставить(РеквизитТЧПлан.Uni, ИмяПоляСС);	
													Иначе	
														ИмяТранслит = КешТранслитерацииПолей.Получить(РеквизитТЧПлан.Значение);
														Если ИмяТранслит = Неопределено Тогда
															ИмяПоляСС = ЛокЯдро_СтрокуВТранслитENG(РеквизитТЧПлан.Значение);
															КешТранслитерацииПолей.Вставить(РеквизитТЧПлан.Значение,ИмяПоляСС);
														Иначе
															ИмяПоляСС = ИмяТранслит;
														КонецЕсли;
														Если ЗначениеЗаполнено(ИмяПоляСС) И СвязаннаяСтрока.Свойство(ИмяПоляСС) Тогда
															ЗначениеРеквизитаСвязаннойСтроки = СвязаннаяСтрока[ИмяПоляСС];
															СоответствиеИменПолейDeclaredItems.Вставить(РеквизитТЧПлан.Uni, ИмяПоляСС);	
														Иначе
															ИмяПоляСС = UniПолейНоменклатуры.Получить(РеквизитТЧПлан.Значение);
															Если ЗначениеЗаполнено(ИмяПоляСС) И СвязаннаяСтрока.Свойство(ИмяПоляСС) Тогда
																ЗначениеРеквизитаСвязаннойСтроки = СвязаннаяСтрока[ИмяПоляСС];
																СоответствиеИменПолейDeclaredItems.Вставить(РеквизитТЧПлан.Uni, ИмяПоляСС);	
															Иначе
																ЗначениеРеквизитаСвязаннойСтроки = Неопределено;
															КонецЕсли;
														КонецЕсли;
													КонецЕсли;
												ИначеЕсли СвязаннаяСтрока.Свойство(ИмяПоляСС) Тогда
													ЗначениеРеквизитаСвязаннойСтроки = СвязаннаяСтрока[ИмяПоляСС];
												Иначе
													ЗначениеРеквизитаСвязаннойСтроки = Неопределено;	
												КонецЕсли;
												СвязаннаяСтрока.Вставить(РеквизитТЧПлан.Значение,ЗначениеРеквизитаСвязаннойСтроки);
											Исключение
												
											КонецПопытки;	
										КонецЦикла;											
									КонецЕсли;
									ЗначениеРеквизита = СвязаннаяСтрока;
									// ---
								КонецЕсли;
							Иначе
								СоответствиеИменПолейCurrentItems.Вставить(РеквизитТЧ.Uni, ИмяПоля);
							КонецЕсли;						
						Иначе	
							ИмяТранслит = КешТранслитерацииПолей.Получить(РеквизитТЧ.Значение);
							Если ИмяТранслит = Неопределено Тогда
								ИмяПоля = ЛокЯдро_СтрокуВТранслитENG(РеквизитТЧ.Значение);
								КешТранслитерацииПолей.Вставить(РеквизитТЧ.Значение,ИмяПоля);
							Иначе
								ИмяПоля = ИмяТранслит;
							КонецЕсли;
							Если ЗначениеЗаполнено(ИмяПоля) И СтрокаТЧ.Свойство(ИмяПоля) Тогда
								ЗначениеРеквизита = СтрокаТЧ[ИмяПоля];
								СоответствиеИменПолейCurrentItems.Вставить(РеквизитТЧ.Uni, ИмяПоля);
							Иначе
								ИмяПоля = UniПолейНоменклатуры.Получить(РеквизитТЧ.Значение);
								Если ЗначениеЗаполнено(ИмяПоля) И СтрокаТЧ.Свойство(ИмяПоля) Тогда
									ЗначениеРеквизита = СтрокаТЧ[ИмяПоля];
									СоответствиеИменПолейCurrentItems.Вставить(РеквизитТЧ.Uni, ИмяПоля);	
								Иначе
									ЗначениеРеквизита = Неопределено;
								КонецЕсли;
							КонецЕсли;
						КонецЕсли;
					ИначеЕсли СтрокаТЧ.Свойство(ИмяПоля) Тогда						
						ЗначениеРеквизита = СтрокаТЧ[ИмяПоля];
					Иначе
						ЗначениеРеквизита = Неопределено;	
					КонецЕсли;
					НоваяСтрока.Вставить(РеквизитТЧ.Значение,ЗначениеРеквизита);
				Исключение
				
				КонецПопытки; 			
			КонецЦикла;
			ТабличнаяЧастьФакт.Добавить(НоваяСтрока);
		КонецЦикла;
	КонецЕсли;
	ТабличнаяЧастьФакт.Вставить(0, Новый Структура("ЭтоТаблицаЗначений, КолонкиТаблицыЗначений", Истина, СписокПолей));
	ДанныеДокументаMS.Вставить("СтрокиФакт", ТабличнаяЧастьФакт);
	
	// СовмещенныеСтроки
	Если ДокументSMARTS.Свойство("combinedItems") И ТипЗнч(ДокументSMARTS["combinedItems"]) = Тип("Массив") Тогда
		Для Каждого СтрокаТЧ из ДокументSMARTS["combinedItems"] Цикл
			
			// фильтр ТЧ если она была объединена из нескольких документов
			Если ЗначениеЗаполнено(ФильтрТЧПоИдДокумента) 
				И СтрокаТЧ.Свойство("idDokumenta") Тогда                           
				ИдДокументаВладелецСтроки = СтрокаТЧ["idDokumenta"];
				Если ИдДокументаВладелецСтроки <> ФильтрТЧПоИдДокумента Тогда
					Продолжить;
				КонецЕсли;
			КонецЕсли;
			
			НоваяСтрока = Новый Структура();
			Для Каждого РеквизитТЧ Из МассивКолонокСовмещенные Цикл
				Попытка
					ИмяПоля = СоответствиеИменПолейCombinedItems.Получить(РеквизитТЧ.Uni);
					Если ИмяПоля = Неопределено Тогда
						ИмяПоля = РеквизитТЧ.Uni;
						Если ЗначениеЗаполнено(ИмяПоля) И СтрокаТЧ.Свойство(ИмяПоля) Тогда
							ЗначениеРеквизита = СтрокаТЧ[ИмяПоля];
							СоответствиеИменПолейCombinedItems.Вставить(РеквизитТЧ.Uni, ИмяПоля);	
						Иначе	
							ИмяТранслит = КешТранслитерацииПолей.Получить(РеквизитТЧ.Значение);
							Если ИмяТранслит = Неопределено Тогда
								ИмяПоля = ЛокЯдро_СтрокуВТранслитENG(РеквизитТЧ.Значение);
								КешТранслитерацииПолей.Вставить(РеквизитТЧ.Значение,ИмяПоля);
							Иначе
								ИмяПоля = ИмяТранслит;
							КонецЕсли;
							Если ЗначениеЗаполнено(ИмяПоля) И СтрокаТЧ.Свойство(ИмяПоля) Тогда
								ЗначениеРеквизита = СтрокаТЧ[ИмяПоля];
								СоответствиеИменПолейCombinedItems.Вставить(РеквизитТЧ.Uni, ИмяПоля);	
							Иначе
								ИмяПоля = UniПолейНоменклатуры.Получить(РеквизитТЧ.Значение);
								Если ЗначениеЗаполнено(ИмяПоля) И СтрокаТЧ.Свойство(ИмяПоля) Тогда
									ЗначениеРеквизита = СтрокаТЧ[ИмяПоля];
									СоответствиеИменПолейCombinedItems.Вставить(РеквизитТЧ.Uni, ИмяПоля);	
								Иначе
									ЗначениеРеквизита = Неопределено;
								КонецЕсли;
							КонецЕсли;
						КонецЕсли;
					ИначеЕсли СтрокаТЧ.Свойство(ИмяПоля) Тогда
						ЗначениеРеквизита = СтрокаТЧ[ИмяПоля];
					Иначе
						ЗначениеРеквизита = Неопределено;	
					КонецЕсли;
					НоваяСтрока.Вставить(РеквизитТЧ.Значение,ЗначениеРеквизита);	
				Исключение
					
				КонецПопытки; 			
			КонецЦикла;
			ТабличнаяЧастьСовмещенные.Добавить(НоваяСтрока);
		КонецЦикла;
	КонецЕсли;
	ТабличнаяЧастьСовмещенные.Вставить(0, Новый Структура("ЭтоТаблицаЗначений, КолонкиТаблицыЗначений", Истина, СписокПолей));
	ДанныеДокументаMS.Вставить("СовмещенныеСтроки", ТабличнаяЧастьСовмещенные);	
	
	СписокИменаДополнительныхТабличныхЧастей = Новый СписокЗначений;
	
	// Получение данных из доп.таблиц документа типа "ОплатыВозвраты", "Деньги" и т.д.
	Для каждого ДопТаблица Из СтруктураДокументаMS.ДополнительныеТаблицы Цикл		
		
		ИмяДопТаблицы			= ДопТаблица.Представление;
		СписокКолонокДопТаблицы = ДопТаблица.Значение;		
		ДопТабличнаяЧасть		= Новый Массив;
		СписокПолей 			= "";
		
		СписокИменаДополнительныхТабличныхЧастей.Добавить(ИмяДопТаблицы);
		
		Для Каждого Колонка из СписокКолонокДопТаблицы Цикл
			СписокПолей = СписокПолей + Колонка.Значение + ",";
		КонецЦикла; 
		
		Попытка
			СтрокиДокументаMS = ДокументSMARTS.ПолучитьПоле(ИмяДопТаблицы).Rows;
		Исключение
			СтрокиДокументаMS = Новый Массив;
		
			ДопТаблицы = ДокументSMARTS["tables"];
			Для каждого ДополнительнаяТаблица ИЗ ДопТаблицы Цикл
				Если ДополнительнаяТаблица["name"] = ИмяДопТаблицы Тогда
					СтрокиДокументаMS = ДополнительнаяТаблица["rows"];
					Прервать;
				КонецЕсли;
			КонецЦикла;
		КонецПопытки;
		
		Для Индекс = 0 по СтрокиДокументаMS.Количество() - 1 Цикл
			
			Попытка
				ТекущаяСтрокаMS	= СтрокиДокументаMS.Элемент(Индекс);
			Исключение
				ТекущаяСтрокаMS = СтрокиДокументаMS[Индекс];
			КонецПопытки;
			НоваяСтрока 	= Новый Структура;						
			
			Для Каждого Колонка из СписокКолонокДопТаблицы Цикл
				
				Попытка
					
					ИмяПоля = Колонка.Uni;
					
					Если ЗначениеЗаполнено(ИмяПоля) И ТекущаяСтрокаMS.Свойство(ИмяПоля) Тогда
						ЗначениеРеквизита = ТекущаяСтрокаMS[ИмяПоля];
					Иначе
						ИмяТранслит = КешТранслитерацииПолей.Получить(Колонка.Значение);
						Если ИмяТранслит = Неопределено Тогда
							ИмяПоля = ЛокЯдро_СтрокуВТранслитENG(Колонка.Значение);
							КешТранслитерацииПолей.Вставить(Колонка.Значение,ИмяПоля);
						Иначе
							ИмяПоля = ИмяТранслит;
						КонецЕсли;
						Если ЗначениеЗаполнено(ИмяПоля) И СтрокаТЧ.Свойство(ИмяПоля) Тогда
							ЗначениеРеквизита = СтрокаТЧ[ИмяПоля];
						Иначе
							ИмяПоля = UniПолейНоменклатуры.Получить(Колонка.Значение);
							ЗначениеРеквизита = ?(ЗначениеЗаполнено(ИмяПоля) И СтрокаТЧ.Свойство(ИмяПоля), СтрокаТЧ[ИмяПоля], Неопределено);
						КонецЕсли;
					КонецЕсли;
					
					НоваяСтрока.Вставить(Колонка.Значение, ЗначениеРеквизита);
					
				Исключение	
					
				КонецПопытки;
				
			КонецЦикла;
			
			ДопТабличнаяЧасть.Добавить(НоваяСтрока);
			
		КонецЦикла;	
		СписокПолей = Лев(СписокПолей, СтрДлина(СписокПолей) - 1);
		
		ДопТабличнаяЧасть.Вставить(0, Новый Структура("ЭтоТаблицаЗначений, КолонкиТаблицыЗначений", Истина, СписокПолей));
		
		ДанныеДокументаMS.Вставить(ИмяДопТаблицы, ДопТабличнаяЧасть);	
		
	КонецЦикла;		
	
	// Получение данных доп.таблиц, которые не определены в метаданных документа, но существуют у самого экземпляра документа
	Если ДокументSMARTS.Свойство("tables") И ТипЗнч(ДокументSMARTS["tables"]) = Тип("Массив") Тогда
		Для Каждого ДопТаблицаMS из ДокументSMARTS["tables"] Цикл
			
			Если СписокИменаДополнительныхТабличныхЧастей.НайтиПоЗначению(ДопТаблицаMS["name"]) <> Неопределено Тогда
				Продолжить;
			КонецЕсли;
			
			Если НЕ ДопТаблицаMS.Свойство("rows") Тогда
				Продолжить;
			КонецЕсли;
			
			СтрокиДопТаблицыMS = ДопТаблицаMS["rows"];
			
			Если СтрокиДопТаблицыMS.Количество() = 0 Тогда
				Продолжить;
			КонецЕсли;
			
			ДопТабличнаяЧасть 	= Новый Массив;		
			СписокПолей 		= "";								        
						
			РеквизитыДопТаблицыMS = Неопределено;
			
			//Если есть структура реквизита доп таблицы, то используем ее
			Если СтруктураДокументаMS.Свойство("Реквизиты" + ДопТаблицаMS.name, РеквизитыДопТаблицыMS) Тогда
				
				Для Каждого Колонка из РеквизитыДопТаблицыMS Цикл
					СписокПолей = СписокПолей + Колонка.Значение + ",";
				КонецЦикла; 
				
				Для Индекс = 0 по СтрокиДопТаблицыMS.Количество() - 1 Цикл
					
					Попытка
						ТекущаяСтрокаMS	= СтрокиДопТаблицыMS.Элемент(Индекс);
					Исключение
						ТекущаяСтрокаMS = СтрокиДопТаблицыMS[Индекс];
					КонецПопытки;
					
					НоваяСтрока = Новый Структура;						
					
					Для Каждого Колонка из РеквизитыДопТаблицыMS Цикл
						
						Попытка
							
							ИмяПоля = Колонка.Uni;
							
							Если ЗначениеЗаполнено(ИмяПоля) И ТекущаяСтрокаMS.Свойство(ИмяПоля) Тогда
								ЗначениеРеквизита = ТекущаяСтрокаMS[ИмяПоля];
							Иначе
								ИмяПоля = ЛокЯдро_СтрокуВТранслитENG(Колонка.Значение);
								Если ЗначениеЗаполнено(ИмяПоля) И СтрокаТЧ.Свойство(ИмяПоля) Тогда
									ЗначениеРеквизита = СтрокаТЧ[ИмяПоля];
								Иначе
									ИмяПоля = UniПолейНоменклатуры.Получить(Колонка.Значение);
									ЗначениеРеквизита = ?(ЗначениеЗаполнено(ИмяПоля) И СтрокаТЧ.Свойство(ИмяПоля), СтрокаТЧ[ИмяПоля], Неопределено);
								КонецЕсли;
							КонецЕсли;
							
							НоваяСтрока.Вставить(Колонка.Значение, ЗначениеРеквизита);
							
						Исключение	
							
						КонецПопытки;
						
					КонецЦикла;
					
					ДопТабличнаяЧасть.Добавить(НоваяСтрока);
					
				КонецЦикла;
				
			Иначе //Если нет структуры доп таблицы, то записываем данные как есть
				
				Для Каждого ТекущаяСтрокаMS Из СтрокиДопТаблицыMS Цикл
					
					НоваяСтрока = Новый Структура;
					
					Для Каждого КлючЗначение из ТекущаяСтрокаMS Цикл
						
						НоваяСтрока.Вставить(КлючЗначение.Ключ, КлючЗначение.Значение);
						
					КонецЦикла;
					
					ДопТабличнаяЧасть.Добавить(НоваяСтрока);
					
				КонецЦикла; 

			КонецЕсли;
						
			СписокПолей = Лев(СписокПолей, СтрДлина(СписокПолей) - 1);
			
			ДопТабличнаяЧасть.Вставить(0, Новый Структура("ЭтоТаблицаЗначений, КолонкиТаблицыЗначений", Истина, СписокПолей));		
			
			ДанныеДокументаMS.Вставить(ДопТаблицаMS["name"], ДопТабличнаяЧасть);
		КонецЦикла;		
	КонецЕсли;
	
	Возврат ДанныеДокументаMS;
	
КонецФункции

&НаКлиенте
Функция REST_API_СформироватьНовыйДокументSMARTS(ДанныеДокумента,НазначенныйПользователь = "", СпособНазначения = "")
		
	ИмяТипаДокумента = ЛокЯдро_ПреобразованиеНаименованияДокументаБезПробелов(ДанныеДокумента.ШапкаДокумента.ИмяТипаДокумента);	
	МетаданныеДокументаMS = СтруктураМетаданных.ДокументыMS[ИмяТипаДокумента];
	
	ДокументSMARTS = Новый Структура;
	
	Для Каждого РеквизитДокумента Из ДанныеДокумента.ШапкаДокумента Цикл
		РеквизитMS = Неопределено;
		Для Каждого СтрокаРеквизита Из МетаданныеДокументаMS.Реквизиты Цикл
			Если НРег(СтрокаРеквизита.Значение) = НРег(РеквизитДокумента.Ключ) Тогда
				РеквизитMS = СтрокаРеквизита;
				Прервать;
			КонецЕсли;
		КонецЦикла;
		Если РеквизитMS = Неопределено Тогда
			РеквизитMS = Новый Структура("Ключ,Значение,Uni",РеквизитДокумента.Ключ,РеквизитДокумента.Ключ,РеквизитДокумента.Ключ);
		КонецЕсли;
		ЗначениеРеквизита = РеквизитДокумента.Значение;
		Если ТипЗнч(ЗначениеРеквизита) = Тип("Дата") Тогда
			Если ЗначениеЗаполнено(ЗначениеРеквизита) Тогда
				ЗначениеРеквизита = REST_API_ФорматДаты(ЗначениеРеквизита);	
			Иначе
				ЗначениеРеквизита = Неопределено;
			КонецЕсли;
		КонецЕсли;
		ДокументSMARTS.Вставить(РеквизитMS.Uni,ЗначениеРеквизита);
	КонецЦикла;
	
	ДокументSMARTS.Вставить("documentTypeName",ИмяТипаДокумента);
	Если НазначенныйПользователь <> "" Тогда 
		Если СпособНазначения = "Устройству" Тогда
			ДокументSMARTS.Вставить("appointment", НазначенныйПользователь);
		Иначе
			ДокументSMARTS.Вставить("appointment", НазначенныйПользователь);
			ДокументSMARTS.Вставить("id",ДокументSMARTS.Id+"#"+СтрЗаменить(НазначенныйПользователь,"|",""));
		КонецЕсли;
	КонецЕсли;
	
	UniОсновняхТабличныхЧастей = Новый Соответствие;
	UniОсновняхТабличныхЧастей.Вставить("СтрокиПлан","declaredItems");
	UniОсновняхТабличныхЧастей.Вставить("СтрокиФакт","currentItems");
	UniОсновняхТабличныхЧастей.Вставить("СовмещенныеСтроки","combinedItems");
	UniОсновняхТабличныхЧастей.Вставить("СерииПлан","");
	UniОсновняхТабличныхЧастей.Вставить("СерииФакт","");
	UniОсновняхТабличныхЧастей.Вставить("СерийныеНомераПлан","");
	UniОсновняхТабличныхЧастей.Вставить("СерийныеНомераФакт","");
	МассивДопТаблиц = Новый Массив;
	МассивСтрокТЧ = Новый Массив;
	
	РеквизитыТЧ = МетаданныеДокументаMS.РеквизитыТЧ;
	
	Если ДанныеДокумента.Свойство("ТабличныеЧасти") И ДанныеДокумента.ТабличныеЧасти.Количество() > 0 Тогда
		Для Каждого ТабличнаяЧасть Из ДанныеДокумента.ТабличныеЧасти Цикл
			UniТЧ = UniОсновняхТабличныхЧастей.Получить(ТабличнаяЧасть.Ключ);
			Если UniТЧ <> Неопределено Тогда
				Если ТабличнаяЧасть.Ключ <> "СтрокиПлан" Тогда
					Продолжить;
				КонецЕсли;
				СписокРеквизитов = Новый Соответствие;
				Если ТабличнаяЧасть.Значение.Количество() > 0 Тогда
					Для каждого КлючЗначение из ТабличнаяЧасть.Значение[0] Цикл
						REST_API_ДополнитьСписокРеквизитов(СписокРеквизитов, КлючЗначение.Ключ, РеквизитыТЧ);
					КонецЦикла;
				КонецЕсли;
				
				Для каждого СтрокаТЧ Из ТабличнаяЧасть.Значение Цикл
					СтрокаДокументаSMARTS = Новый Структура;
					Для Каждого РеквизитСтроки Из СтрокаТЧ Цикл
						ЗначениеРеквизита = РеквизитСтроки.Значение;
						Если ТипЗнч(ЗначениеРеквизита) = Тип("Дата") Тогда
							Если ЗначениеЗаполнено(ЗначениеРеквизита) Тогда
								ЗначениеРеквизита = REST_API_ФорматДаты(ЗначениеРеквизита);	
							Иначе
								ЗначениеРеквизита = Неопределено;
							КонецЕсли;
						КонецЕсли;
						Если ЗначениеЗаполнено(ЗначениеРеквизита) Тогда
							КлючРеквизита = СписокРеквизитов.Получить(РеквизитСтроки.Ключ);
							Если КлючРеквизита = Неопределено Тогда
								// Список реквизитов определен по первой строке таблицы ТабличнаяЧасть.
								// В случае, когда выгрузка производится из нескольких документов в один, в последующих строках
								// может быть больше колонок, чем в первой (например, если в первом документе нет маркированной
								// продукции, а во втором - есть).
								// Нужно предусмотреть дополнение списка реквизитов при необходимости.
								REST_API_ДополнитьСписокРеквизитов(СписокРеквизитов, РеквизитСтроки.Ключ, РеквизитыТЧ);
								
								КлючРеквизита = СписокРеквизитов.Получить(РеквизитСтроки.Ключ);
							КонецЕсли;
							
							СтрокаДокументаSMARTS.Вставить(КлючРеквизита, ЗначениеРеквизита);
						КонецЕсли;
					КонецЦикла;
					
					МассивСтрокТЧ.Добавить(СтрокаДокументаSMARTS);					
				КонецЦикла;
				ДокументSMARTS.Вставить("declaredItems",МассивСтрокТЧ);
			Иначе
				ДопТаблицаSMARTS = Новый Соответствие;		
				ДопТаблицаSMARTS.Вставить("name",ТабличнаяЧасть.Ключ);
				СписокРеквизитов = Новый Соответствие;
				МассивСтрокТЧ = Новый Массив;
				Если ТабличнаяЧасть.Значение.Количество() > 0 Тогда
					Для каждого КлючЗначение из ТабличнаяЧасть.Значение[0] Цикл
						РеквизитMS = Неопределено;
						Для Каждого СтрокаРеквизита Из МетаданныеДокументаMS.РеквизитыТЧ Цикл
							Если НРег(СтрокаРеквизита.Значение) = НРег(КлючЗначение.Ключ) Тогда
								РеквизитMS = СтрокаРеквизита;
								Прервать;
							КонецЕсли;
						КонецЦикла;
						Если РеквизитMS = Неопределено Тогда
							РеквизитMS = Новый Структура("Ключ,Значение,Uni",КлючЗначение.Ключ,КлючЗначение.Ключ,КлючЗначение.Ключ);
						КонецЕсли;
						СписокРеквизитов.Вставить(РеквизитMS.Значение,РеквизитMS.Uni);
						// Для табличной части МаркиДокумента не нужно заменять IdTovara на ProductId
						// Если выяснится, что для всех табличных частей имена реквизитов заменять не нужно,
						// убрать это условие и отменить выше поиск в МетаданныеДокументаMS
						Если НРег(ТабличнаяЧасть.Ключ) = "маркидокумента" И НРег(КлючЗначение.Ключ) = "идтовара" Тогда
							СписокРеквизитов.Вставить(РеквизитMS.Значение,КлючЗначение.Ключ);
						КонецЕсли;
					КонецЦикла;
				КонецЕсли;
				
				Для каждого СтрокаТЧ Из ТабличнаяЧасть.Значение Цикл
					Row = Новый Соответствие;
					Для Каждого РеквизитСтроки Из СтрокаТЧ Цикл
						ЗначениеРеквизита = РеквизитСтроки.Значение;
						Если ТипЗнч(ЗначениеРеквизита) = Тип("Дата") Тогда
							Если ЗначениеЗаполнено(ЗначениеРеквизита) Тогда
								ЗначениеРеквизита = REST_API_ФорматДаты(ЗначениеРеквизита);	
							Иначе
								ЗначениеРеквизита = Неопределено;
							КонецЕсли;
						КонецЕсли;
						Row.Вставить(СписокРеквизитов.Получить(РеквизитСтроки.Ключ), ЗначениеРеквизита);
					КонецЦикла;
					МассивСтрокТЧ.Добавить(Row);
				КонецЦикла;
				
				ДопТаблицаSMARTS.Вставить("rows",МассивСтрокТЧ);
				МассивДопТаблиц.Добавить(ДопТаблицаSMARTS);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Если МассивДопТаблиц.Количество() > 0 Тогда
		ДокументSMARTS.Вставить("tables",МассивДопТаблиц);	
	КонецЕсли;
	
	Возврат ДокументSMARTS;
	
КонецФункции

&НаКлиенте
Функция REST_API_ЗаписатьДокументВБазуSMARTS(ДокументSMARTS, ТипБазы)
	
	ИмяТипаДокумента = ЛокЯдро_ПреобразованиеНаименованияДокументаБезПробелов(ДокументSMARTS.documentTypeName);	
	МассивСтрокТЧ = Новый Массив;
	Если ДокументSMARTS.Свойство("declaredItems") Тогда
		МассивСтрокТЧ = ДокументSMARTS.declaredItems;
		ДокументSMARTS.Удалить("declaredItems");
	КонецЕсли;
	МетаданныеДокументаMS = СтруктураМетаданных.ДокументыMS[ИмяТипаДокумента];
	
	Если ТипБазы = "Частная" Тогда
		КлючПеременной = "REST_API_СтруктураПодключенияЧастнойБазыMS";
	ИначеЕсли ТипБазы = "Временная" Тогда
		КлючПеременной = "REST_API_СтруктураПодключенияВременнойБазыMS";
	Иначе
		КлючПеременной = "REST_API_СтруктураПодключенияБазыMS";
	КонецЕсли;
	
	СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной(КлючПеременной);
	Результат = Истина;
	UniДокумента = МетаданныеДокументаMS.uni;
	idДокумента = ДокументSMARTS.Id;
	СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключенияMS,Новый Структура("HTTPМетод,Метод,ВернутьСтруктуру,ТипЗапроса","POST","Docs",Истина,"ВыгрузкаШапкиДокумента"),ДокументSMARTS,АдресаПеременных);
	
	Если СтруктураОтвета.КодСостояния < 200 или СтруктураОтвета.КодСостояния >= 300 Тогда
		Результат =  Ложь;
	КонецЕсли;
	
	Если МассивСтрокТЧ.Количество() > 0 Тогда
		Если Результат = Истина Тогда
			ПакетСтрок = Новый Массив;	
			Икс = 0; ЭтоПерваяСтрока=Истина;
			Для каждого СтрокаТЧ Из МассивСтрокТЧ Цикл
				Если Икс%1000 = 0 И Не ЭтоПерваяСтрока Тогда
					ПакетДляОтправки = Новый Соответствие;
					ПакетДляОтправки.Вставить("value",ПакетСтрок);
					СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключенияMS,Новый Структура("HTTPМетод,Метод,ВернутьСтруктуру,ТипЗапроса","POST","Docs('"+idДокумента+"')/declaredItems",Истина,"ВыгрузкаСтрокДокумента"),ПакетДляОтправки,АдресаПеременных);
					Если СтруктураОтвета.КодСостояния < 200 или СтруктураОтвета.КодСостояния >= 300 Тогда
						СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключенияMS,Новый Структура("HTTPМетод,Метод,ТипЗапроса","DELETE","Docs('"+idДокумента+"')","ВыгрузкаШапкиДокумента"),,АдресаПеременных);
						Результат = Ложь;
						Прервать;
					КонецЕсли;
					ПакетСтрок = Новый Массив;	
				КонецЕсли;
				НовоеСоответствие = Новый Соответствие;
				Для каждого КлючЗначение Из СтрокаТЧ Цикл
					НовоеСоответствие.Вставить(КлючЗначение.Ключ,КлючЗначение.Значение);	
				КонецЦикла;			
				
				ПакетСтрок.Добавить(НовоеСоответствие);
				ЭтоПерваяСтрока = Ложь;
				Икс = Икс+1;
			КонецЦикла;
			
			Если ПакетСтрок.Количество() > 0 Тогда
				ПакетДляОтправки = Новый Соответствие;
				ПакетДляОтправки.Вставить("value",ПакетСтрок);
				СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключенияMS,Новый Структура("HTTPМетод,Метод,ВернутьСтруктуру,ТипЗапроса","POST","Docs('"+idДокумента+"')/declaredItems",Истина,"ВыгрузкаСтрокДокумента"),ПакетДляОтправки,АдресаПеременных);
				Если СтруктураОтвета.КодСостояния < 200 или СтруктураОтвета.КодСостояния >= 300 Тогда
					СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключенияMS,Новый Структура("HTTPМетод,Метод,ТипЗапроса","DELETE","Docs('"+idДокумента+"')","ВыгрузкаШапкиДокумента"),,АдресаПеременных);
					Результат = Ложь;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		
	КонецЕсли;
	
	Если Результат = Истина Тогда
		СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключенияMS,Новый Структура("HTTPМетод,Метод,ТипЗапроса","POST","Docs('"+idДокумента+"')/EndUpdate","ВыгрузкаСтрокДокумента"),,АдресаПеременных);
		Если СтруктураОтвета.КодСостояния < 200 или СтруктураОтвета.КодСостояния >= 300 Тогда
			Результат =  Ложь;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

&НаКлиенте
Функция REST_API_УдалитьДокументНаСервереSMARTS(ID_Документа, ТипБазы)
	
	Если ТипБазы = "Частная" Тогда
		КлючПеременной = "REST_API_СтруктураПодключенияЧастнойБазыMS";
	ИначеЕсли ТипБазы = "Временная" Тогда
		КлючПеременной = "REST_API_СтруктураПодключенияВременнойБазыMS";
	Иначе
		КлючПеременной = "REST_API_СтруктураПодключенияБазыMS";
	КонецЕсли;
	
	СтруктураПодключенияMS = КомЯдро_ПолучитьЗначениеПеременной(КлючПеременной);
	
	РезультатОтвет = REST_API_ВыполнитьМетод(СтруктураПодключенияMS,Новый Структура("HTTPМетод,Метод,ТипЗапроса","DELETE","Docs('"+ID_Документа+"')","ВыгрузкаШапкиДокумента"),,АдресаПеременных);
	РезультатПопытки = РезультатОтвет.КодСостояния = 204;
	
	Возврат РезультатПопытки;
	
КонецФункции

&НаСервере
Функция REST_API_ФорматДаты(пДата)
	
	Смещение = СмещениеСтандартногоВремени();
	Если Смещение < 0 Тогда
		Смещение = Смещение *-1;
		Знак="-";
	Иначе		
		Знак="+";
	КонецЕсли;
	GTM = Прав("0"+Строка(Цел(Смещение/3600)),2)+":"+Прав("0"+Строка(Цел(Смещение%3600/60)),2);
	Возврат Формат(пДата,"ДФ=yyyy-MM-ddTHH:mm:ss")+".0000000"+Знак+GTM; // Формат(УниверсальноеВремя(пДата),"ДФ=yyyy-MM-ddThh:mm:ss")+".0000000"+Знак+GTM;
	
КонецФункции

// Функция обратного преобразования даты из форматированного представления определенного формата в тип Дата
//
// Параметры:
// 		ДатаСтрокой	 - Строка - Представление даты в формате "ДФ=yyyy-MM-ddTHH:mm:ss.0000000+HH:mm"
// 
// Возвращаемое значение:
// 		ДатаВФормате - Дата, Строка - Преобразованное значение даты, либо если что-то пошло не так, исходное значение
//
// Пример:
// 		ДатаСтрокой  = "2021-03-09T08:09:24.0000000+03:00";
//		ДатаВФормате = <09.03.2021  8:09:24>
//
&НаКлиенте
Функция REST_API_ПреобразоватьКДате(ДатаСтрокой)
	
	ИмяСобытия = "REST_API_ПреобразоватьКДате";
	
	// Возьмем данный разделить даты/времени за признак корректного формата
	Если ЛокЯдро_СтрНайти(ДатаСтрокой, "T") = 0 Тогда
		Возврат ДатаСтрокой;
	КонецЕсли;
	
	МассивРазделеннойДаты = ЛокЯдро_СтрРазделить(ДатаСтрокой, "T", Ложь);
	
	Если МассивРазделеннойДаты.Количество() <> 2 Тогда
		Возврат ДатаСтрокой;
	КонецЕсли;
	
	СтрДата		= REST_API_УбратьНечисловыеСимволы(МассивРазделеннойДаты[0]);
	СтрВремя 	= Лев(REST_API_УбратьНечисловыеСимволы(МассивРазделеннойДаты[1]), 6);
	
	Попытка
		ДатаВФормате = Дата(СтрДата + СтрВремя);						
	Исключение		
		ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия,
			"Ошибка",
			ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
			
		ДатаВФормате = ДатаСтрокой;
	КонецПопытки;
	
	Возврат ДатаВФормате;	
	
КонецФункции

// Функция очистки строковой переменной от нечисловых символов для дальнейшей обработки
//
// Параметры:
// 		Стр 	  - Строка - Строка, в которой необходимо оставить только числовые символы
// 
// Возвращаемое значение:
// 		Результат - Строка - Преобразованная строка
//
// Пример:
//		Стр 	  = "2021-03-09T08:09:24";
//      Результат = "20210309080924"
//
&НаКлиенте
Функция REST_API_УбратьНечисловыеСимволы(Стр)
	
	Результат = "";
	
	Если ТипЗнч(Стр) <> Тип("Строка") Тогда
		Возврат Результат;
	КонецЕсли;
	
	Если СтрДлина(Стр) = 0 Тогда
		Возврат Результат;
	КонецЕсли;
	
	СтрокаПроверки = СокрЛП(Стр);
	
	Для Инд = 1 По СтрДлина(СтрокаПроверки) Цикл
		
		Символ = Сред(СтрокаПроверки, Инд, 1);
		
		Если Найти("0123456789", Символ) = 0 Тогда
			Продолжить;
		КонецЕсли;
		
		Результат = Результат + Символ;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Процедура REST_API_ДополнитьСписокРеквизитов(СписокРеквизитов, Ключ, РеквизитыТЧ)

	РеквизитMS = Неопределено;
	Для Каждого СтрокаРеквизита Из РеквизитыТЧ Цикл
		Если НРег(СтрокаРеквизита.Значение) = НРег(Ключ) Тогда
			РеквизитMS = СтрокаРеквизита;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	Если РеквизитMS = Неопределено Тогда
		РеквизитMS = Новый Структура("Ключ, Значение, Uni", Ключ, Ключ, Ключ);
	КонецЕсли;
	
	СписокРеквизитов.Вставить(РеквизитMS.Значение, РеквизитMS.Uni);
	
КонецПроцедуры

#Область REST_API_Транспорт

&НаКлиенте
Функция REST_API_ВыполнитьМетод(СтруктураПодключения,СтруктураЗапроса,ОтправляемыеДанные,АдресаПеременных)
	
	Перем ОтветHTTP,ТекстОшибки;
	
	СтруктураОтвета = Новый Структура;	
	
	Если ТипЗнч(СтруктураПодключения) = Тип("Строка") Тогда
		СтрокаПодключения = СтруктураПодключения;
	Иначе
		Если НЕ ТипЗнч(СтруктураПодключения) = Тип("Структура")
			ИЛИ НЕ СтруктураПодключения.Свойство("СтрокаПодключенияСМАРТС")
			ИЛИ НЕ ЗначениеЗаполнено(СтруктураПодключения.СтрокаПодключенияСМАРТС) Тогда
			
			СтруктураОтвета.Вставить("ТекстОшибки","Не заполнено значение ""Строка подключения""");
			СтруктураОтвета.Вставить("КодСостояния",Неопределено);
			
			Возврат СтруктураОтвета;
		КонецЕсли;
		СтрокаПодключения = СтруктураПодключения.СтрокаПодключенияСМАРТС;
	КонецЕсли;
	
	СтруктураURI = REST_API_ПолучитьСтруктуруURIИзСтроки(СтрокаПодключения);
	
	Если НЕ СтруктураЗапроса.Свойство("Заголовки")
		ИЛИ НЕ СтруктураЗапроса.Заголовки <> Неопределено Тогда				
		СтруктураЗапроса.Вставить("Заголовки",Новый Соответствие());
		СтруктураЗапроса.Заголовки.Вставить("Content-Type", "application/json");
		СтруктураЗапроса.Заголовки.Вставить("Accept-Encoding", "gzip");
	КонецЕсли;
	
	НеЛогировать = ?(СтруктураЗапроса.Свойство("НеЛогировать"), Истина, Ложь);
	
	РезультатыАвторизации = REST_API_ЗаполнитьДанныеАвторизацииHTTPЗапроса(СтрокаПодключения, СтруктураПодключения, СтруктураURI, СтруктураЗапроса, АдресаПеременных);
	СтруктураОтвета = РезультатыАвторизации.СтруктураОтвета;
	Если СтруктураОтвета.КодСостояния = 401 Тогда
		Возврат СтруктураОтвета;
	КонецЕсли;
	
	КоличествоПопыток = 1;
	КоличествоПопытокОтключенияСжатия = 1;
	КоличествоПопытокОбновленияТокена = 1;
	Пока КоличествоПопыток > 0 Цикл

		НачалоСобытия = ТекущаяУниверсальнаяДатаВМиллисекундах();		
				
		СтруктураОтвета = REST_API_ВыполнитьHTTPЗапрос(СтруктураURI,СтруктураЗапроса,ОтправляемыеДанные);
		
		Если НЕ НеЛогировать Тогда
			// Запись в ЖР
			ТекстЗаписиЖР = "HTTPМетод: " + СтруктураЗапроса.HTTPМетод + ", Метод: " + СтруктураЗапроса.Метод + 
				?(СтруктураЗапроса.Свойство("ТипЗапроса"), ", Тип запроса: " + СтруктураЗапроса.ТипЗапроса, "");		
			СтрокаЗапроса = ?(СтруктураОтвета.Свойство("СтрокаЗапроса"), СтруктураОтвета.СтрокаЗапроса, "");
			КонецСобытия = ТекущаяУниверсальнаяДатаВМиллисекундах();
			// Вычисляем продолжительность здесь, а не в методе гл контекста, 
			// т.к. метод ТекущаяУниверсальнаяДатаВМиллисекундах может возвращать разные значения на клиенте и сервере
			ПродолжительностьСобытия = КонецСобытия - НачалоСобытия;
			ТекстЗаписиЖР = ТекстЗаписиЖР + Символы.ПС + "Строка запроса: " + СтрокаЗапроса + Символы.ПС + "Время выполнения: " + " ("+Формат(ПродолжительностьСобытия,"ЧГ=") + " мс.)";
			
			ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации("REST_API_ВыполнитьHTTPЗапрос", "Информация", ТекстЗаписиЖР);
		КонецЕсли;
		
		Если СтруктураОтвета.Свойство("ТекстОшибки")
			И ЗначениеЗаполнено(СтруктураОтвета.ТекстОшибки)
			И НЕ НеЛогировать Тогда
			ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации("REST_API_ВыполнитьHTTPЗапрос", "Ошибка", СтруктураОтвета.ТекстОшибки);
		КонецЕсли;
		// Если требуется отключить сжатие данных, пробуем отключить и делаем еще одну попытку
		Если СтруктураОтвета.Свойство("ОтключитьСжатиеДанных")
			И СтруктураОтвета.ОтключитьСжатиеДанных 
			И КоличествоПопытокОтключенияСжатия Тогда
			Попытка
				ЛокЯдро_ЗаписатьВКэшНастройкуSMARTS("ОтключитьСжатиеДанных", Истина);
				ЛокЯдро_СохранитьНастройкуВБазеSMARTS("ОтключитьСжатиеДанных", Истина);
			Исключение
				Если НЕ НеЛогировать Тогда
					ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации("ОтключитьСжатиеДанных", "Ошибка", ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
				КонецЕсли;
			КонецПопытки;
			КоличествоПопытокОтключенияСжатия = КоличествоПопытокОтключенияСжатия - 1;
		ИначеЕсли СтруктураОтвета.КодСостояния = 401
            И КоличествоПопытокОбновленияТокена Тогда
			Access_token  = "";
			Refresh_token = "";
			Если ТипЗнч(СтруктураПодключения) = Тип("Структура")
				И СтруктураПодключения.Свойство("АвторизацияРефрешТокен") Тогда
				Refresh_token = СтруктураПодключения.АвторизацияРефрешТокен;
			КонецЕсли;
			
			ДанныеТокена = REST_API_ОбновитьТокенSMARTS(СтрокаПодключения, РезультатыАвторизации.REST_API_Session, Refresh_token);
			Если ТипЗнч(ДанныеТокена) = Тип("Структура") Тогда
				Access_token  = ДанныеТокена.АвторизацияТокен;
				Refresh_token = ДанныеТокена.АвторизацияРефрешТокен;
			КонецЕсли;
			
			Если ЗначениеЗаполнено(Access_token) Тогда
            	СтруктураЗапроса.Заголовки.Вставить("Authorization", "Bearer " + Access_token);				
			КонецЕсли;
			КоличествоПопытокОбновленияТокена = КоличествоПопытокОбновленияТокена - 1;	
		Иначе
			КоличествоПопыток = ?(СтруктураОтвета.КодСостояния = Неопределено, КоличествоПопыток - 1, 0);
		КонецЕсли;
	КонецЦикла;
	
	Если СтруктураОтвета.КодСостояния = 401 Тогда
		//В плане сделать переавторизацию
		//Если REST_API_session <> Неопределено Тогда
		//	refresh_token = REST_API_session.Получить("refresh_token");
		//	Логин = REST_API_session.Получить("Логин");
		//	Пароль = REST_API_session.Получить("Пароль");
		//КонецЕсли;
	КонецЕсли;
	
	Возврат СтруктураОтвета;
	
КонецФункции

&НаКлиенте
Функция REST_API_ПолучитьСтруктуруРезультатовАвторизации()

	СтруктураОтвета = Новый Структура("КодСостояния, ТекстОшибки");
	
	РезультатыАвторизации = Новый Структура;
	РезультатыАвторизации.Вставить("REST_API_Session", Неопределено);
	РезультатыАвторизации.Вставить("СтруктураОтвета",  СтруктураОтвета);
	
	Возврат РезультатыАвторизации;	
	
КонецФункции

&НаКлиенте
Функция REST_API_ЗаполнитьДанныеАвторизацииHTTPЗапроса(СтрокаПодключения, СтруктураПодключения, СтруктураURI, СтруктураЗапроса, АдресаПеременных)
	
	РезультатыАвторизации = REST_API_ПолучитьСтруктуруРезультатовАвторизации();
	
	АвторизацияВключена = ТипЗнч(СтруктураПодключения) = Тип("Структура")
		И СтруктураПодключения.Свойство("АвторизацияВключена")
		И СтруктураПодключения.АвторизацияВключена;
	ТребуетсяПолучитьТокен = Ложь;
	АвторизацияЛогин 	   = "";
	АвторизацияПароль 	   = "";
	
	REST_API_session = КомЯдро_ПолучитьЗначениеПеременной("API_session_" + СтрЗаменить(СтрЗаменить(СтруктураURI.Хост, ".", "_"), "-", "_") + "_" + Формат(СтруктураURI.Порт, "ЧГ=") + "_" + СтрЗаменить(СтруктураURI.ПутьНаСервере, "-", ""));
	Если REST_API_session <> Неопределено Тогда
		Access_token = REST_API_session.Получить("Access_token");
		Если Access_token = Неопределено Тогда
			Access_token = REST_API_session.Получить("access_token");	
		КонецЕсли;
		СтруктураЗапроса.Заголовки.Вставить("Authorization", "Bearer " + Access_token);
		РезультатыАвторизации.Вставить("REST_API_session", REST_API_session);
	ИначеЕсли АвторизацияВключена
		И СтруктураПодключения.Свойство("АвторизацияТокен")
		И ЗначениеЗаполнено(СтруктураПодключения.АвторизацияТокен) Тогда
		СтруктураЗапроса.Заголовки.Вставить("Authorization", "Bearer " + СтруктураПодключения.АвторизацияТокен);	
	ИначеЕсли АвторизацияВключена
		И ЗначениеЗаполнено(СтруктураURI.TempUid) Тогда
		ТребуетсяПолучитьТокен = Истина;
		АвторизацияЛогин  = "__tempuid__";
		АвторизацияПароль = СтруктураURI.TempUid;	
	ИначеЕсли АвторизацияВключена Тогда
		ТребуетсяПолучитьТокен = Истина;
		АвторизацияЛогин  = ЛокЯдро_ПолучитьДанныеИзХранилища1С("СохраненнаяАвторизацияЛогин");
		АвторизацияПароль = ЛокЯдро_ПолучитьДанныеИзХранилища1С("СохраненнаяАвторизацияПароль");
		АвторизацияПароль = ЛокЯдро_РасшифроватьСтроку(АвторизацияПароль, ЛокЯдро_ПолучитьКлючШифрования(АвторизацияЛогин, СтрДлина(АвторизацияПароль)));
	КонецЕсли;
	
	Если ТребуетсяПолучитьТокен
		И ЗначениеЗаполнено(АвторизацияЛогин) Тогда
		ДанныеТокена = REST_API_ПолучитьТокенSMARTS(СтрокаПодключения, АвторизацияЛогин, АвторизацияПароль, "Основная");
		Если ДанныеТокена = Ложь ИЛИ ДанныеТокена = Неопределено Тогда
			РезультатыАвторизации.СтруктураОтвета.Вставить("КодСостояния", 401);
			РезультатыАвторизации.СтруктураОтвета.Вставить("ТекстОшибки",  "Не удалось авторизоваться");
		ИначеЕсли ТипЗнч(ДанныеТокена) = Тип("Структура") Тогда
			СтруктураЗапроса.Заголовки.Вставить("Authorization", "Bearer " + ДанныеТокена.АвторизацияТокен);
			Если ТипЗнч(СтруктураПодключения) = Тип("Структура") Тогда
				СтруктураПодключения.Вставить("АвторизацияТокен", 		ДанныеТокена.АвторизацияТокен);
				СтруктураПодключения.Вставить("АвторизацияРефрешТокен",	ДанныеТокена.АвторизацияРефрешТокен);
			КонецЕсли;
		Иначе
			СтруктураЗапроса.Заголовки.Вставить("Authorization", "Bearer " + ДанныеТокена);
			Если ТипЗнч(СтруктураПодключения) = Тип("Структура") Тогда
				СтруктураПодключения.Вставить("АвторизацияТокен", 		ДанныеТокена);
				СтруктураПодключения.Вставить("АвторизацияРефрешТокен",	Неопределено);
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	Возврат РезультатыАвторизации;
	
КонецФункции

&НаКлиенте
Функция REST_API_ПолучитьВерсиюAPI()
	Возврат "v1"
КонецФункции

// Разбирает строку URI на составные части и возвращает в виде структуры.
// На основе RFC 3986.
//
// Параметры:
//	СтрокаURI - Строка - ссылка на ресурс в формате:
//                       <схема>://<логин>:<пароль>@<хост>:<порт>/<путь>?<параметры>#<якорь>.
//
// Возвращаемое значение:
//	Структура - составные части URI согласно формату:
//		* Схема         - Строка
//		* Логин         - Строка
//		* Пароль        - Строка
//		* ИмяСервера    - Строка - часть <хост>:<порт> входного параметра
//		* Хост          - Строка
//		* Порт          - Строка
//		* ПутьНаСервере - Строка - часть <путь>?<параметры>#<якорь> входного параметра
&НаКлиенте
Функция REST_API_ПолучитьСтруктуруURIИзСтроки(Знач СтрокаURI) Экспорт
   
     СтрокаURI = СокрЛП(СтрокаURI);
   
    // Схема
    Схема = "";
    Позиция = ЛокЯдро_СтрНайти(СтрокаURI, "://");
    Если Позиция > 0 Тогда
        Схема = НРег(Лев(СтрокаURI, Позиция - 1));
        СтрокаURI = Сред(СтрокаURI, Позиция + 3);
    КонецЕсли;

	// Строка соединения и путь на сервере
    СтрокаСоединения = СтрокаURI;
    ПутьНаСервере = "";
    ПозицияСтрокиПоиска = ЛокЯдро_СтрНайти(СтрокаСоединения, "/");
	Если ПозицияСтрокиПоиска > 0 Тогда
		ПутьНаСервере = Сред(СтрокаСоединения, ПозицияСтрокиПоиска + 1);
		Если Прав(ПутьНаСервере, 1) = "/" Тогда
			ПутьНаСервере = Лев(ПутьНаСервере, СтрДлина(ПутьНаСервере) - 1);
		КонецЕсли;
		СтрокаСоединения = Лев(СтрокаСоединения, ПозицияСтрокиПоиска - 1);
		
		ПозицияСтрокиПоиска = ЛокЯдро_СтрНайти(ПутьНаСервере, "?");
		Если ПозицияСтрокиПоиска > 0 Тогда
			ПутьНаСервере = Лев(ПутьНаСервере, ПозицияСтрокиПоиска - 1);
		КонецЕсли;
	КонецЕсли;
       
    // Информация пользователя и имя сервера
    СтрокаАвторизации = "";
    ИмяСервера = СтрокаСоединения;
    Позиция = ЛокЯдро_СтрНайти(СтрокаСоединения, "@");
    Если Позиция > 0 Тогда
        СтрокаАвторизации = Лев(СтрокаСоединения, Позиция - 1);
        ИмяСервера = Сред(СтрокаСоединения, Позиция + 1);
    КонецЕсли;
   
    // Логин и пароль
    Логин = СтрокаАвторизации;
    Пароль = "";
    Позиция = ЛокЯдро_СтрНайти(СтрокаАвторизации, ":");
    Если Позиция > 0 Тогда
        Логин = Лев(СтрокаАвторизации, Позиция - 1);
        Пароль = Сред(СтрокаАвторизации, Позиция + 1);
    КонецЕсли;
   
    // Хост и порт
    Хост = ИмяСервера;
    Порт = "";
    Позиция = ЛокЯдро_СтрНайти(ИмяСервера, ":");
    Если Позиция > 0 Тогда
        Хост = Лев(ИмяСервера, Позиция - 1);
        Порт = Сред(ИмяСервера, Позиция + 1);
        Если Не ЛокЯдро_ТолькоЦифрыВСтроке(Порт) Тогда
            Порт = "";
        КонецЕсли;
    КонецЕсли;
	
	// Получение всех хостов
	МассивХостов = Новый Массив;
	СтрокаПоиска = "?altip=";
	ПозицияСтрокиПоиска = ЛокЯдро_СтрНайти(СтрокаURI, СтрокаПоиска);
	Если ПозицияСтрокиПоиска > 0 Тогда
		СтрокаАльтернативныхХостов = Сред(СтрокаURI, ПозицияСтрокиПоиска);
		ПозицияСтрокиПоиска = ЛокЯдро_СтрНайти(СтрокаАльтернативныхХостов, "&");
		Если ПозицияСтрокиПоиска > 0 Тогда
			СтрокаАльтернативныхХостов = Лев(СтрокаАльтернативныхХостов, ПозицияСтрокиПоиска - 1);
		КонецЕсли;
		
		СтрокаАльтернативныхХостов = СтрЗаменить(СтрокаАльтернативныхХостов, СтрокаПоиска, "");
		Если ЗначениеЗаполнено(СтрокаАльтернативныхХостов) Тогда
			МассивХостов = ЛокЯдро_РазложитьСтрокуВМассивПодстрок(СтрокаАльтернативныхХостов, ",");
		КонецЕсли;
	КонецЕсли;
	// Вставляем в массив первым элементом основной хост
	МассивХостов.Вставить(0, Хост);
	
	// Данные упрощенной авторизации
	TempUid = "";
	ПозицияСтрокиПоиска = ЛокЯдро_СтрНайти(СтрокаURI, "tempuid=");
	Если ПозицияСтрокиПоиска > 0 Тогда
		TempUid	= Сред(СтрокаURI, ПозицияСтрокиПоиска + 8);
	КонецЕсли;	
	
	Результат = Новый Структура;
    Результат.Вставить("Схема", 		Схема);
    Результат.Вставить("Логин", 		Логин);
    Результат.Вставить("Пароль", 		Пароль);
    Результат.Вставить("ИмяСервера", 	ИмяСервера);
    Результат.Вставить("Хост", 			Хост);
    Результат.Вставить("Порт", 			?(ПустаяСтрока(Порт), Неопределено, Число(Порт)));
    Результат.Вставить("ПутьНаСервере", ПутьНаСервере);
    Результат.Вставить("Протокол", 		?(ПустаяСтрока(Схема), "http", Схема));
    Результат.Вставить("МассивХостов", 	МассивХостов);
	Результат.Вставить("TempUid",		TempUid);
	
	Возврат Результат;

КонецФункции

&НаКлиенте
Функция REST_API_ВыполнитьHTTPЗапрос(СтруктураURI,СтруктураЗапроса,ОтправляемыеДанные = Неопределено) 
	
	Перем ОтветHTTP,ТекстОшибки;
	
	Таймаут = ЛокЯдро_ПолучитьТаймаутПоТипуМетода(СтруктураЗапроса);
	
	ВернутьСтруктуру = ?(СтруктураЗапроса.Свойство("ВернутьСтруктуру"),СтруктураЗапроса.ВернутьСтруктуру,Ложь);
	
	ВерсияAPI = ?(СтруктураЗапроса.Свойство("ВерсияAPI"), СтруктураЗапроса.ВерсияAPI, "/api/"+REST_API_ПолучитьВерсиюAPI());
	
	Соединение = Новый HTTPСоединение(
        СтруктураURI.Хост // сервер (хост)
        ,СтруктураURI.Порт // порт, по умолчанию
        ,//СтруктураURI.Логин, // пользователь для доступа к серверу (если он есть)
        ,//СтруктураURI.Пароль, // пароль для доступа к серверу (если он есть)
        , // здесь указывается прокси, если он есть
        ,Таймаут // таймаут в секундах, 0 или пусто - не устанавливать
        ,?(СтруктураURI.Протокол = "https",Новый ЗащищенноеСоединениеOpenSSL(),Неопределено)  // защищенное соединение, если используется https
    );
	
	СтрокаЗапроса = ?(ЗначениеЗаполнено(СтруктураURI.ПутьНаСервере),"/"+СтруктураURI.ПутьНаСервере,"")
					+ВерсияAPI
					+?(ЗначениеЗаполнено(СтруктураЗапроса.Метод),"/"+СтрЗаменить(СтруктураЗапроса.Метод,"#","%23"),"");	 // временное решение, замена # на %23
	
	Запрос = Новый HTTPЗапрос(СтрокаЗапроса,СтруктураЗапроса.Заголовки);
	
	Если СтруктураЗапроса.HTTPМетод = "POST"  
		ИЛИ СтруктураЗапроса.HTTPМетод = "PATCH" 
		ИЛИ СтруктураЗапроса.HTTPМетод = "PUT" Тогда
		Если ТипЗнч(ОтправляемыеДанные) = Тип("Строка") Тогда
			Запрос.УстановитьТелоИзСтроки(ОтправляемыеДанные);
		Иначе
			ОтключитьСжатиеДанных = ЛокЯдро_ПолучитьИзКэшаНастройкуSMARTS("ОтключитьСжатиеДанных");
			#Если ВебКлиент тогда
				REST_API_УстановитьТелоИзСтрокиJSON(Запрос, ОтправляемыеДанные, ОтключитьСжатиеДанных);
			#Иначе
				ЗаписьJSON = Новый ЗаписьJSON; 
				ПараметрыJSON = Новый ПараметрыЗаписиJSON(ПереносСтрокJSON.Авто,"",Истина,,Ложь,Ложь,Ложь,Истина,Ложь);
				ЗаписьJSON.УстановитьСтроку(ПараметрыJSON);
				ЗаписатьJSON(ЗаписьJSON, ОтправляемыеДанные); // ОтправляемыеДанные обязательны в этом случае
				СтрокаДляТела = ЗаписьJSON.Закрыть();
					
				Если ОтключитьСжатиеДанных = Истина Тогда
					Запрос.УстановитьТелоИзСтроки(СтрокаДляТела, КодировкаТекста.UTF8, ИспользованиеByteOrderMark.НеИспользовать);
				Иначе
					СжатыеДанные = Неопределено;
					КоличествоПопытокСжатия = 2;
					Пока КоличествоПопытокСжатия Цикл
						Попытка
							СжатыеДанные = ЛокЯдро_ЗашифроватьGZIP(СтрокаДляТела);
							КоличествоПопытокСжатия = 0;
						Исключение
							ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
							ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации("ЛокЯдро_ЗашифроватьGZIP", "Ошибка", ТекстОшибки);
							КоличествоПопытокСжатия = КоличествоПопытокСжатия - 1;
						КонецПопытки;
					КонецЦикла;
					Если СжатыеДанные <> Неопределено Тогда
						Запрос.Заголовки.Вставить("Content-Encoding", "gzip");
						Запрос.УстановитьТелоИзДвоичныхДанных(СжатыеДанные);
					Иначе
						Запрос.УстановитьТелоИзСтроки(СтрокаДляТела, КодировкаТекста.UTF8, ИспользованиеByteOrderMark.НеИспользовать);	
					КонецЕсли;
				КонецЕсли;
			#КонецЕсли
		КонецЕсли;
	КонецЕсли;
	
	СтруктураОтвета = Новый Структура;
	СтруктураОтвета.Вставить("КодСостояния", Неопределено);	
	Попытка
		ОтветHTTP = Соединение.ВызватьHTTPМетод(СтруктураЗапроса.HTTPМетод,Запрос);
		
		СтруктураОтвета.КодСостояния = ОтветHTTP.КодСостояния;
		
		Если ОтветHTTP.Заголовки.Получить("Content-Encoding") = "gzip" Тогда
			КоличествоПопытокРаспаковки = 2;
			Пока КоличествоПопытокРаспаковки Цикл
				Попытка	
					ОтветСервера = ЛокЯдро_РасшифроватьGZIP(ОтветHTTP.ПолучитьТелоКакДвоичныеДанные());
					КоличествоПопытокРаспаковки = 0;
				Исключение				
					ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
					ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации("ЛокЯдро_РасшифроватьGZIP", "Ошибка", ТекстОшибки);
					КоличествоПопытокРаспаковки = КоличествоПопытокРаспаковки - 1;
				КонецПопытки;
			КонецЦикла;
		Иначе
			ОтветСервера = ОтветHTTP.ПолучитьТелоКакСтроку("UTF-8");
		КонецЕсли;
		
		Если ОтветHTTP.КодСостояния = Неопределено ИЛИ ОтветHTTP.КодСостояния < 200 ИЛИ ОтветHTTP.КодСостояния >= 300 Тогда
			ТекстОшибки = " Ошибка " + ОтветHTTP.КодСостояния + Символы.ПС +
			ОтветСервера;
		КонецЕсли;
		
		ЧтениеJSON = Новый ЧтениеJSON;
		Если ЗначениеЗаполнено(ОтветСервера) Тогда
			Если ВернутьСтруктуру Тогда
				НачСреза = ЛокЯдро_СтрНайти(ОтветСервера,"""@odata.context""");
				Если НачСреза > 0 Тогда
					КонецСреза = ЛокЯдро_СтрНайти(ОтветСервера,""",",,НачСреза);
					ОтветСервера = Лев(ОтветСервера,НачСреза) + Прав(ОтветСервера,СтрДлина(ОтветСервера)-КонецСреза-2);
				КонецЕсли;
			КонецЕсли;
			ЧтениеJSON.УстановитьСтроку(ОтветСервера);
			#Если ВебКлиент тогда
			Соответствие = REST_API_ПрочитатьJSON(ЧтениеJSON,ВернутьСтруктуру);
			#Иначе
			Соответствие = ПрочитатьJSON(ЧтениеJSON,НЕ ВернутьСтруктуру);
			#КонецЕсли
			СтруктураОтвета.Вставить("ОтветСервера", Соответствие);
			СтруктураОтвета.Вставить("ОтветСервераНеРасшифрованный", ОтветСервера);
		КонецЕсли;
				
	Исключение
		Если НЕ ЗначениеЗаполнено(ТекстОшибки) Тогда
			ТекстОшибки = "Не удалось выполнить HTTP запрос по причине " + ИнформацияОбОшибке().Описание;			
		КонецЕсли;
	КонецПопытки;
	
	Если ЗначениеЗаполнено(ТекстОшибки) Тогда
		ВыполняемыйЗапрос = СтрокаЗапроса;
		Если СтруктураЗапроса.Свойство("СтрокаЗапроса") Тогда
			ВыполняемыйЗапрос = СтруктураЗапроса.СтрокаЗапроса;		
		КонецЕсли;
		ТекстОшибки = ЛокЯдро_ПреобразоватьИзUnicode(ТекстОшибки);
		ТекстОшибки = ТекстОшибки + ", Строка запроса: " + СтруктураURI.Протокол + "://" + СтруктураURI.ИмяСервера + ВыполняемыйЗапрос + ", Таймаут: " + Таймаут + "с.";
		
		// Возможно, необходимо отключить сжатие
		Если СтруктураОтвета.КодСостояния = 400
			И (ЛокЯдро_СтрНайти(ВРег(ТекстОшибки), ВРег("Не удается преобразовать байты"))			
				ИЛИ ЛокЯдро_СтрНайти(ВРег(ТекстОшибки), ВРег("Unable to translate bytes"))) Тогда
            СтруктураОтвета.Вставить("ОтключитьСжатиеДанных", Истина);
		ИначеЕсли СтруктураОтвета.КодСостояния = 500 Тогда
			#Если ВебКлиент Тогда
				ТекстОшибки = "Ошибка 500" + Символы.ПС + ", Строка запроса: " + СтруктураURI.Протокол + "://" + СтруктураURI.ИмяСервера + ВыполняемыйЗапрос + ", Таймаут: " + Таймаут + "с.";
			#Иначе
				Если НайтиНедопустимыеСимволыXML(ТекстОшибки) Тогда
					ТекстОшибки = ЛокЯдро_ОчиститьНедопустимыеСимволыXML(ТекстОшибки);					
				КонецЕсли;
			#КонецЕсли
			СтруктураОтвета.Вставить("ОтключитьСжатиеДанных", Истина);
		КонецЕсли;
	КонецЕсли;
	
	СтруктураОтвета.Вставить("ТекстОшибки",ТекстОшибки);
	СтруктураОтвета.Вставить("СтрокаЗапроса", СтрокаЗапроса);
	
	Возврат СтруктураОтвета;
	
КонецФункции

&НаСервере
Процедура REST_API_УстановитьТелоИзСтрокиJSON(Запрос, ОтправляемыеДанные, ОтключитьСжатиеДанных)
	ЗаписьJSON = Новый ЗаписьJSON; 
	ПараметрыJSON = Новый ПараметрыЗаписиJSON(ПереносСтрокJSON.Авто,"",Истина,,Ложь,Ложь,Ложь,Истина,Ложь);
	ЗаписьJSON.УстановитьСтроку(ПараметрыJSON);
	ЗаписатьJSON(ЗаписьJSON, ОтправляемыеДанные); // ОтправляемыеДанные обязательны в этом случае
	СтрокаДляТела = ЗаписьJSON.Закрыть();	
	
	Если ОтключитьСжатиеДанных = Истина Тогда
		Запрос.УстановитьТелоИзСтроки(СтрокаДляТела, КодировкаТекста.UTF8, ИспользованиеByteOrderMark.НеИспользовать);
	Иначе
		СжатыеДанные = Неопределено;
		КоличествоПопытокСжатия = 2;
		Пока КоличествоПопытокСжатия Цикл
			Попытка
				СтруктураВызова = Новый Структура;
				СтруктураВызова.Вставить("ТипМетода", "Функция");
				СтруктураВызова.Вставить("ИмяМетода", "ЗашифроватьGZIP");
				СтруктураВызова.Вставить("ПараметрыМетода", Новый Структура("ИсходнаяСтрока", СтрокаДляТела));
					 
				СжатыеДанные = Транзит_ВызватьГлобальныйМетодНаСервере(ПоместитьВоВременноеХранилище(СтруктураВызова, Новый УникальныйИдентификатор()));
				
				КоличествоПопытокСжатия = 0;
			Исключение
				КоличествоПопытокСжатия = КоличествоПопытокСжатия - 1;
			КонецПопытки;
		КонецЦикла;
		Если СжатыеДанные <> Неопределено Тогда
			Запрос.Заголовки.Вставить("Content-Encoding", "gzip");
			Запрос.УстановитьТелоИзДвоичныхДанных(СжатыеДанные);
		Иначе
			Запрос.УстановитьТелоИзСтроки(СтрокаДляТела, КодировкаТекста.UTF8, ИспользованиеByteOrderMark.НеИспользовать);	
		КонецЕсли;
	КонецЕсли;
КонецПроцедуры

&НаСервере
Функция REST_API_ПрочитатьJSON(ЧтениеJSON,ВернутьСтруктуру)
	Возврат ПрочитатьJSON(ЧтениеJSON,НЕ ВернутьСтруктуру);
КонецФункции
#КонецОбласти

// Проверяет совместимость платформы для работы обмена с MS через REST, путем выполнения REST-запроса при первом запуске
// Если запрос выполнился, платформа считается совместимой
//
// Параметры:
//	СтруктураПодключения - Структура - содержит:
//		* ТипБазы - Строка
//		* СтрокаПодключенияСМАРТС - Строка
//		* IdBaseSMARTS - Строка
//		* ТипИнтерфейса - Строка
//		* РежимВыбораБазы - Строка
//
// Возвращаемое значение:
//	Булево - признак актуальности платформы
&НаКлиенте
Функция REST_API_ПроверитьСовместимостьПлатформы(СтруктураПодключения) Экспорт

	Результат = Ложь;
	
	СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключения, Новый Структура("HTTPМетод,Метод","GET","DocTypes?$expand=tables"),, АдресаПеременных);
	Если СтруктураОтвета.КодСостояния = 200 Тогда
		DocumentTypes = СтруктураОтвета.ОтветСервера.Получить("value");
		Если ТипЗнч(DocumentTypes) = Тип("Массив") И DocumentTypes.Количество() > 0 Тогда
			ТипДокумента = Неопределено;
			Для каждого ТипДокумента ИЗ DocumentTypes Цикл
				Если ТипДокумента.Получить("virtual") ИЛИ ТипДокумента.Получить("removeAfterFinish") Тогда
					Продолжить;
				КонецЕсли;
				Прервать;
			КонецЦикла;
			Если ТипДокумента <> Неопределено Тогда
				СтруктураДокумента = Новый Структура();
				СтруктураДокумента.Вставить("uni", ТипДокумента.Получить("uni"));
				СтруктураДокумента.Вставить("Имя", ТипДокумента.Получить("name"));
				СтруктураДокумента.Вставить("Синоним", ТипДокумента.Получить("alias"));
									
				СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключения, Новый Структура("HTTPМетод,Метод","GET","DocTypes('" + СтруктураДокумента.uni + "')?$expand=fields"),, АдресаПеременных);
				Если СтруктураОтвета.КодСостояния = 200 Тогда
					Результат = Истина;	
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;							   
	КонецЕсли; 
	
	Возврат Результат;
	
КонецФункции

&НаКлиенте
Функция REST_API_ПолучитьПользователейSMARTS(ТипБазы)
	
	ИмяСобытия = "REST_API_ПолучитьПользователейSMARTS";
	
	Если ТипБазы = "Частная" Тогда
		КлючПеременной = "REST_API_СтруктураПодключенияЧастнойБазыMS";
	ИначеЕсли ТипБазы = "Временная" Тогда
		КлючПеременной = "REST_API_СтруктураПодключенияВременнойБазыMS";
	Иначе
		КлючПеременной = "REST_API_СтруктураПодключенияБазыMS";
	КонецЕсли;
	
	СтруктураПодключения = КомЯдро_ПолучитьЗначениеПеременной(КлючПеременной);
	
	СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключения,Новый Структура("HTTPМетод,Метод,ТипЗапроса","GET","Users","ПолучениеМетаданных"),,АдресаПеременных);	
	Если СтруктураОтвета.КодСостояния <> 200 Тогда
		ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Запрос: GET, Users. Получен некорректный ответ от сервера, Код состояния: " + Строка(СтруктураОтвета.КодСостояния)+ ". Содержание ошибки: " + Строка(СтруктураОтвета.ТекстОшибки));	
		Users = Неопределено;	
	Иначе
		Users = СтруктураОтвета.ОтветСервера.Получить("value");	
	КонецЕсли;
		
	МассивПользователейMS = Новый Массив;      
	
	Если Users <> Неопределено Тогда
		
		Для Каждого ТекущийПользователь ИЗ Users Цикл
			
			стрПользователиMS = Новый Структура("Ид,Имя,ИдГруппы,ИмяГруппы,Пароль,Описание,Штрихкод,ИдСкладов");
			стрПользователиMS.Ид 		= ТекущийПользователь.Получить("id");
			стрПользователиMS.Имя 		= ТекущийПользователь.Получить("name");
			стрПользователиMS.ИдГруппы 	= ТекущийПользователь.Получить("groupId");
			стрПользователиMS.ИмяГруппы = ТекущийПользователь.Получить("groupName");
			стрПользователиMS.Описание 	= ТекущийПользователь.Получить("description");			
			стрПользователиMS.Пароль 	= ТекущийПользователь.Получить("password");			
			стрПользователиMS.Штрихкод 	= ТекущийПользователь.Получить("barcode");    			
			
			СписокСкладов = Новый СписокЗначений;
			Warehouses = ТекущийПользователь.Получить("warehouseIds");                     
			Если Warehouses <> Неопределено Тогда 
				Для Каждого Warehouse Из Warehouses Цикл
					СписокСкладов.Добавить(Warehouse);
				КонецЦикла;
			КонецЕсли;
			
			стрПользователиMS.ИдСкладов = СписокСкладов;
			
			МассивПользователейMS.Добавить(стрПользователиMS);
			
		КонецЦикла;	 		
		
	КонецЕсли;
			
	Возврат ПоместитьВоВременноеХранилище(МассивПользователейMS, Новый УникальныйИдентификатор());
	
КонецФункции

&НаКлиенте
Функция REST_API_ПолучитьСкладыSMARTS(ТипБазы)
	
	ИмяСобытия = "REST_API_ПолучитьСкладыSMARTS";
	
	Если ТипБазы = "Частная" Тогда
		КлючПеременной = "REST_API_СтруктураПодключенияЧастнойБазыMS";
	ИначеЕсли ТипБазы = "Временная" Тогда
		КлючПеременной = "REST_API_СтруктураПодключенияВременнойБазыMS";
	Иначе
		КлючПеременной = "REST_API_СтруктураПодключенияБазыMS";
	КонецЕсли;
	
	СтруктураПодключения = КомЯдро_ПолучитьЗначениеПеременной(КлючПеременной);
	
	СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключения,Новый Структура("HTTPМетод,Метод,ТипЗапроса","GET","Warehouses","ПолучениеМетаданных"),,АдресаПеременных);	
	Если СтруктураОтвета.КодСостояния <> 200 Тогда
		ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Запрос: GET, Warehouses. Получен некорректный ответ от сервера, Код состояния: " + Строка(СтруктураОтвета.КодСостояния)+ ". Содержание ошибки: " + Строка(СтруктураОтвета.ТекстОшибки));	
		Warehouses = Неопределено;	
	Иначе
		Warehouses = СтруктураОтвета.ОтветСервера.Получить("value");	
	КонецЕсли;
		
	МассивСкладовMS = Новый Массив;
	
	Если Warehouses <> Неопределено Тогда
		
		Для Каждого ТекущийСклад ИЗ Warehouses Цикл
			
			стрСкладыMS = Новый Структура("Ид,Имя");
			стрСкладыMS.Ид  = ТекущийСклад.Получить("id");
			стрСкладыMS.Имя = ТекущийСклад.Получить("name");			
			
			МассивСкладовMS.Добавить(стрСкладыMS);
			
		КонецЦикла;	 		
		
	КонецЕсли;
			
	Возврат ПоместитьВоВременноеХранилище(МассивСкладовMS, Новый УникальныйИдентификатор());
	
КонецФункции

&НаКлиенте
Функция REST_API_ПолучитьГруппыПользователейSMARTS(ТипБазы)
	
	ИмяСобытия = "REST_API_ПолучитьГруппыПользователейSMARTS";
	
	Если ТипБазы = "Частная" Тогда
		КлючПеременной = "REST_API_СтруктураПодключенияЧастнойБазыMS";
	ИначеЕсли ТипБазы = "Временная" Тогда
		КлючПеременной = "REST_API_СтруктураПодключенияВременнойБазыMS";
	Иначе
		КлючПеременной = "REST_API_СтруктураПодключенияБазыMS";
	КонецЕсли;
	
	СтруктураПодключения = КомЯдро_ПолучитьЗначениеПеременной(КлючПеременной);                              
	
	СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключения,Новый Структура("HTTPМетод,Метод,ТипЗапроса","GET","UserGroups?$select=id,name,role,documentTypeNames","ПолучениеМетаданных"),,АдресаПеременных);	
	Если СтруктураОтвета.КодСостояния <> 200 Тогда
		ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Запрос: GET, Users. Получен некорректный ответ от сервера, Код состояния: " + Строка(СтруктураОтвета.КодСостояния)+ ". Содержание ошибки: " + Строка(СтруктураОтвета.ТекстОшибки));	
		UserGroups = Неопределено;	
	Иначе
		UserGroups = СтруктураОтвета.ОтветСервера.Получить("value");	
	КонецЕсли;
		
	МассивГруппПользователейMS = Новый Массив;      	
	                  
	Если UserGroups <> Неопределено Тогда
		
		Для Каждого ТекущаяГруппа ИЗ UserGroups Цикл
			
			стрГруппыПользователейMS = Новый Структура("Ид,Имя,Роль,ТипыДокументов");
			стрГруппыПользователейMS.Ид		= ТекущаяГруппа.Получить("id");
			стрГруппыПользователейMS.Имя 	= ТекущаяГруппа.Получить("name");			
			
			ТекРоль = ТекущаяГруппа.Получить("role");			
			Если ТипЗнч(ТекРоль) = Тип("Число") Тогда
				Если ТекРоль = 3 Тогда 
					РольСтрока = "User";				
				ИначеЕсли ТекРоль = 2 Тогда 
					РольСтрока = "Administrator";
				Иначе
					РольСтрока = "MobileDeviceUser";
				КонецЕсли;
			Иначе     
				РольСтрока = ТекРоль;
			КонецЕсли;
			стрГруппыПользователейMS.Роль 	= РольСтрока;
			
			documentTypeNames = ТекущаяГруппа.Получить("documentTypeNames");
			Если documentTypeNames <> Неопределено Тогда
				стрГруппыПользователейMS.ТипыДокументов = documentTypeNames;
			Иначе
				стрГруппыПользователейMS.ТипыДокументов = Новый Массив;				
			КонецЕсли;
			
			МассивГруппПользователейMS.Добавить(стрГруппыПользователейMS);
			
		КонецЦикла;	 		
		
	КонецЕсли;
			
	Возврат ПоместитьВоВременноеХранилище(МассивГруппПользователейMS, Новый УникальныйИдентификатор());
	
КонецФункции

&НаКлиенте
Функция REST_API_ЗагрузитьПользователейВSMARTS(ПараметрыПользователя, ТипБазы)
	
	ИмяСобытия = "REST_API_ЗагрузитьПользователейВSMARTS";
	
	ТипЗапроса = "POST";   
	Метод = "Users";
	Если ПараметрыПользователя.Получить("ТолькоРедактирование") <> Неопределено Тогда 
		Если ПараметрыПользователя["ТолькоРедактирование"] Тогда
			ТипЗапроса = "PATCH";
			Метод = "Users('" + ПараметрыПользователя["id"] + "')";
		КонецЕсли;
		ПараметрыПользователя.Удалить("ТолькоРедактирование");
	КонецЕсли;
	
	Возврат REST_API_ЗагрузкаПользователей_ВыполнитьЗапрос(ПараметрыПользователя, ТипБазы, ТипЗапроса, Метод, "ВыгрузкаШапкиДокумента", ИмяСобытия); 	
	
КонецФункции

&НаКлиенте
Функция REST_API_ЗагрузитьГруппыПользователейВSMARTS(ПараметрыГруппы, ТипБазы)
			
	ИмяСобытия = "REST_API_ЗагрузитьГруппыПользователейВSMARTS";
	
	Возврат REST_API_ЗагрузкаПользователей_ВыполнитьЗапрос(ПараметрыГруппы, ТипБазы, "POST", "UserGroups", "ВыгрузкаШапкиДокумента", ИмяСобытия); 	
	
КонецФункции

&НаКлиенте
Функция REST_API_УдалитьПользователейВSMARTS(ПараметрыПользователя, ТипБазы)
	
	ИмяСобытия = "REST_API_УдалитьПользователейВSMARTS";
	
	Возврат REST_API_ЗагрузкаПользователей_ВыполнитьЗапрос(ПараметрыПользователя, ТипБазы, "DELETE", "Users('" + ПараметрыПользователя.Ид + "')", "ВыгрузкаШапкиДокумента", ИмяСобытия); 	
	
КонецФункции

&НаКлиенте
Функция REST_API_УдалитьГруппыПользователейВSMARTS(ПараметрыГруппы, ТипБазы)
			
	ИмяСобытия = "REST_API_УдалитьГруппыПользователейВSMARTS";
	
	Возврат REST_API_ЗагрузкаПользователей_ВыполнитьЗапрос(ПараметрыГруппы, ТипБазы, "DELETE", "UserGroups('" + ПараметрыГруппы.Ид + "')", "ВыгрузкаШапкиДокумента", ИмяСобытия); 	
				
КонецФункции

&НаКлиенте
Функция REST_API_ЗагрузкаПользователей_ВыполнитьЗапрос(ПараметрыЭлемента, ТипБазы, HTTPМетод, Метод, ТипЗапроса, ИмяСобытия)
	
	// Получаем настройки подключения
	Если ТипБазы = "Частная" Тогда
		КлючПеременной = "REST_API_СтруктураПодключенияЧастнойБазыMS";
	ИначеЕсли ТипБазы = "Временная" Тогда
		КлючПеременной = "REST_API_СтруктураПодключенияВременнойБазыMS";
	Иначе
		КлючПеременной = "REST_API_СтруктураПодключенияБазыMS";
	КонецЕсли;
	
	СтруктураПодключения = КомЯдро_ПолучитьЗначениеПеременной(КлючПеременной);
	
	// Посылаем запрос на сервер
	СтруктураОтвета = REST_API_ВыполнитьМетод(
		СтруктураПодключения, 
		Новый Структура("HTTPМетод,Метод,ТипЗапроса", HTTPМетод, Метод, ТипЗапроса), 
		ПараметрыЭлемента, 
		АдресаПеременных);	
		
	Ответ = Новый Структура("Результат,ТекстОшибки", Истина, "");
		
	// Обрабатываем ответ сервера
	Если СтруктураОтвета.КодСостояния < 200 или СтруктураОтвета.КодСостояния >= 300 Тогда
		ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Запрос: " + HTTPМетод + ", " + Метод + ". Получен некорректный ответ от сервера, Код состояния: " + Строка(СтруктураОтвета.КодСостояния)+ ". Содержание ошибки: " + Строка(СтруктураОтвета.ТекстОшибки));	
		Ответ.Результат 	=  Ложь;         
		
		ТекстОшибки = "";		
		
		error = СтруктураОтвета.ОтветСервера.Получить("error");
		Если error <> Неопределено И ТипЗнч(error) = Тип("Соответствие") Тогда    
			innererror = error.Получить("innererror");
			Если innererror <> Неопределено И ТипЗнч(innererror) = Тип("Соответствие") Тогда    			
				ТекстОшибки = "{" + innererror.Получить("message") + "}";	
			Иначе                                                      
				ТекстОшибки = СтруктураОтвета.ОтветСервераНеРасшифрованный;
			КонецЕсли;
		Иначе
			ТекстОшибки = СтруктураОтвета.ОтветСервераНеРасшифрованный;
		КонецЕсли; 	                     	
		Ответ.ТекстОшибки 	= ТекстОшибки;
	КонецЕсли;   
	
	Возврат Ответ;
	
КонецФункции

&НаКлиенте
Процедура REST_API_ОбновитьШаблоныВесовогоТовараMS(ТаблицаШаблонов, ТипБазы)
	
	ИмяСобытия = "REST_API_ОбновитьШаблоныВесовогоТовараMS";
	
	Если ТипБазы = "Частная" Тогда
		КлючПеременной = "REST_API_СтруктураПодключенияЧастнойБазыMS";
	ИначеЕсли ТипБазы = "Временная" Тогда
		КлючПеременной = "REST_API_СтруктураПодключенияВременнойБазыMS";
	Иначе
		КлючПеременной = "REST_API_СтруктураПодключенияБазыMS";
	КонецЕсли;
	
	СтруктураПодключения = КомЯдро_ПолучитьЗначениеПеременной(КлючПеременной);                              
	
	КоллекцияШаблонов = Новый Массив;
	// Добавление новых шаблонов
	Для Каждого Шаблон из ТаблицаШаблонов Цикл
		ЦелаяЧасть = Шаблон.ЦелаяЧасть - СтрДлина(Шаблон.Префикс);
		Если Шаблон.ПрефиксВключенВКод Тогда			
			КоллекцияШаблонов.Добавить("{Barcode:@" + Шаблон.Префикс + "[0-9]{" + Шаблон.ДлинаКодаВесовогоТовара + "}}{Quantity:" + ЦелаяЧасть + "." + Шаблон.ДробнаяЧасть + "}{OneC:1}");
		Иначе
			КоллекцияШаблонов.Добавить(Шаблон.Префикс + "{Barcode:" + Шаблон.ДлинаКодаВесовогоТовара + "}{Quantity:" + ЦелаяЧасть + "." + Шаблон.ДробнаяЧасть + "}{OneC:1}");
		КонецЕсли;
	КонецЦикла;	
	
	ОтправляемыеДанные = Новый Соответствие;
	ОтправляемыеДанные.Вставить("commonTemplates", КоллекцияШаблонов);
	
	СтруктураЗапроса = Новый Структура("HTTPМетод,Метод,ТипЗапроса", "PATCH", "ProductSchema('1')", "ПолучениеМетаданных");	
	СтруктураОтвета = REST_API_ВыполнитьМетод(СтруктураПодключения, СтруктураЗапроса, ОтправляемыеДанные, АдресаПеременных);	
	
	Если СтруктураОтвета.КодСостояния <> 204 Тогда
		ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Запрос: PATCH, ProductSchema. Получен некорректный ответ от сервера, Код состояния: " + Строка(СтруктураОтвета.КодСостояния)+ ". Содержание ошибки: " + Строка(СтруктураОтвета.ТекстОшибки));	
	КонецЕсли;	
	
КонецПроцедуры

#КонецОбласти

// Возвращает информацию об основной обработке
//
// Возвращаемое значение:
//   Структура - см. ГлЯдро_ПолучитьИнформациюОсновнойОбработки
//
&НаКлиенте
Функция ЛокЯдро_ПолучитьИнформациюОсновнойОбработки() Экспорт
	
	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода", "Функция");
	СтруктураВызова.Вставить("ИмяМетода", "ПолучитьИнформациюОсновнойОбработки");

	ПередаваемыеПараметры = Транзит_ПоместитьЗначениеВХранилищеНаСервере(СтруктураВызова);
	
	АдресРезультата = Транзит_ВызватьГлобальныйМетодНаСервере(ПередаваемыеПараметры);
	
	Если ЭтоАдресВременногоХранилища(АдресРезультата) Тогда
		ДанныеОсновнойОбработки = ПолучитьИзВременногоХранилища(АдресРезультата);
	Иначе
		ДанныеОсновнойОбработки = Новый Структура;
	КонецЕсли;
	
	Возврат ДанныеОсновнойОбработки;
	
КонецФункции

&НаСервере
Процедура ЛокЯдро_СоздатьНовыйШтрихкод(СтрокаТЧ, СтруктураХраненияШК, ДобавленныеШК) Экспорт
	
	Штрихкод =  СтрокаТЧ[СтруктураХраненияШК.ШК_ИзмерениеШтрихкода];
	Запись = "";
	РегистрСведенийМенеджер = СтруктураХраненияШК.ШК_ОбъектМетаданных;
	РегистрСведенийМенеджер = СтрЗаменить(РегистрСведенийМенеджер,"РегистрСведений.","РегистрыСведений.");
	РегистрСведенийМенеджер = СтрЗаменить(РегистрСведенийМенеджер,"Справочник.","Справочники.");
	//Выполнить("Запись = "+РегистрСведенийМенеджер+"."
	//+?(Найти(РегистрСведенийМенеджер,"Справочник")>0,"СоздатьЭлемент();","СоздатьМенеджерЗаписи();"));
	СтрокаВызова = "Параметры.Запись = " + РегистрСведенийМенеджер + "."
		+?(Найти(РегистрСведенийМенеджер,"Справочник")>0,"СоздатьЭлемент();","СоздатьМенеджерЗаписи();");
	ПараметрыАлгоритма = Новый Структура;
	ПараметрыАлгоритма.Вставить("Запись", 					Запись);
	ПараметрыАлгоритма.Вставить("РегистрСведенийМенеджер", 	РегистрСведенийМенеджер);
	ЛокЯдро_ВыполнитьВБезопасномРежиме(СтрокаВызова, ПараметрыАлгоритма);
	Запись = ПараметрыАлгоритма.Запись;

	СтрокаШК = ЛокЯдро_ПолучитьЗаполнитьСтрокуШК(СтрокаТЧ);
	ЗаполнитьЗначенияСвойств(Запись, СтрокаШК);
	
	Попытка
		Запись.Записать();
		Сообщить("Добавлен штрихкод """+Штрихкод+""" для номенклатуры """+СокрЛП(Запись[СтруктураХраненияШК.ШК_ИзмерениеНоменклатуры])+"""",СтатусСообщения.Информация);
		ДобавленныеШК.Добавить(Штрихкод);
		ЗаписаныНовыеШтрихкоды = Истина;
	Исключение
		ТекстОшибки = КраткоеПредставлениеОшибки(ИнформацияОбОшибке());
		Сообщить(ТекстОшибки, СтатусСообщения.Важное);		
		//ПоказатьПредупреждение(, ТекстОшибки);	
	КонецПопытки;	

КонецПроцедуры

// Вызывает из модуля обработки функцию получения получения строки штрихкода
//
// Параметры:
//	СтруктураЗаполненияСтрокиШК - Структура - структура, содержащие параметры заполнения строки штрихкода
//
// Возвращаемое значение:
//	Структура - содержит данные строки штрихкода, полученные из интеграционной обработки
//
&НаСервере
Функция ЛокЯдро_ПолучитьЗаполнитьСтрокуШК(СтруктураЗаполненияСтрокиШК)
	
	ПараметрыМетода = Новый Структура;
	ПараметрыМетода.Вставить("СтруктураЗаполненияСтрокиШК", СтруктураЗаполненияСтрокиШК);
	
	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода", "Функция");
	СтруктураВызова.Вставить("ИмяМетода", "ПолучитьЗаполнитьСтрокуШК");
	СтруктураВызова.Вставить("ПараметрыМетода", ПараметрыМетода);

	ПередаваемыеПараметры = Транзит_ПоместитьЗначениеВХранилищеНаСервере(СтруктураВызова);
	
	АдресРезультата = Транзит_ВызватьГлобальныйМетодНаСервере(ПередаваемыеПараметры, АдресаПеременных);
	
	Если ЭтоАдресВременногоХранилища(АдресРезультата) Тогда
		СтрокаШК = ПолучитьИзВременногоХранилища(АдресРезультата);
	Иначе
		СтрокаШК = Новый Структура;
	КонецЕсли;
	
	Возврат СтрокаШК;
	
КонецФункции

// Получает массив имен макетов из интеграционной обработки
//
// Возвращаемое значение:
//   Массив   - массив имен макетов
//
&НаКлиенте
Функция ЛокЯдро_ПолучитьМассивИменМакетовИО() Экспорт
	
	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода", "Функция");
	СтруктураВызова.Вставить("ИмяМетода", "ПолучитьМассивИменМакетовИО");
	
	Возврат Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,, АдресаПеременных);
	
КонецФункции

// Получает массив структур имен макетов по умолчанию из интеграционной обработки
//
// Параметры:
//  МассивСтруктурИменСправочников 	- Массив - массив структур имен справочников, для которых будут получены макеты ИО
//
// Возвращаемое значение:
//	Массив, содержащий структуры
//   Структура   - содержит:
//		* ИмяСправочника - имя таблицы (справочника)
//		* ИмяМакета - имя макета ИО по умолчанию
//
&НаКлиенте
Функция ЛокЯдро_ПолучитьМассивСтруктурМакетовИОПоУмолчанию(МассивСтруктурИменСправочников) Экспорт
	
	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода", "Функция");
	СтруктураВызова.Вставить("ИмяМетода", "ПолучитьМассивСтруктурМакетовИОПоУмолчанию");
	СтруктураВызова.Вставить("ПараметрыМетода", Новый Структура("МассивСтруктурИменСправочников", МассивСтруктурИменСправочников));
	
	Возврат Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,, АдресаПеременных);
	
КонецФункции

// Вызывает из модуля обработки функцию получения схемы компоновки данных по тексту запроса
//
// Параметры:
//	ТекстЗапрос - Строка - текст запроса, по которому необходимо построить СКД
//	ТекстКодаПолучениеПараметров - Строка - строка кода, из которой будут получены параметры
//	ТаблицаСопоставленияПолей - Массив - массив строк с сопоставлением реквизит 1с - реквизит MS
//
// Возвращаемое значение:
//	- СхемаКомпоновкиДанных - схема компоновки данных для выгрузки таблицы на сервер Mobile Smarts
//  - Неопределено - если не удалось получить интеграционную обработку
&НаКлиенте
Функция ЛокЯдро_ПолучитьСхемуСКДПоТекстуЗапроса(ТекстЗапроса, ТекстКодаПолучениеПараметров, ТаблицаСопоставленияПолей) Экспорт
	
	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода", "Функция");
	СтруктураВызова.Вставить("ИмяМетода", "ПолучитьСхемуСКДПоТекстуЗапроса");
	ПараметрыМетода = Новый Структура;
	ПараметрыМетода.Вставить("ТекстЗапроса", 					ТекстЗапроса);
	ПараметрыМетода.Вставить("ТекстКодаПолучениеПараметров", 	ТекстКодаПолучениеПараметров);
	ПараметрыМетода.Вставить("ТаблицаСопоставленияПолей", 		ТаблицаСопоставленияПолей);	
	СтруктураВызова.Вставить("ПараметрыМетода", 				ПараметрыМетода);
	
	СхемаСКД = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова, Истина, АдресаПеременных);	
		
	Возврат СхемаСКД;
	
КонецФункции

// Получает пустую структуру параметров выгрузки справочника
//
// Возвращаемое значение:
//   Структура   - см. ГлЯдро_ПолучитьПустуюСтруктуруПараметровВыгрузкиСправочника()
//
&НаКлиенте
Функция ЛокЯдро_ПолучитьПустуюСтруктуруПараметровВыгрузкиСправочника() Экспорт

	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода", "Функция");
	СтруктураВызова.Вставить("ИмяМетода", "ПолучитьПустуюСтруктуруПараметровВыгрузкиСправочника");
	
	ПараметрыВыгрузки = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,, АдресаПеременных);
	
	Возврат ПараметрыВыгрузки;

КонецФункции

// Получает и заполняет структуру параметров выгрузки справочника
//
// Параметры:
//  ИмяТаблицы  - Строка - имя таблицы, для которой необходимо получить сохраненное имя макета ИО
//
// Возвращаемое значение:
//   Структура   - см. ГлЯдро_ПолучитьПустуюСтруктуруПараметровВыгрузкиСправочника()
//
&НаКлиенте
Функция ЛокЯдро_ПолучитьЗаполнитьСтруктуруПараметровВыгрузкиСправочника(ИмяТаблицы) Экспорт

	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода", "Функция");
	СтруктураВызова.Вставить("ИмяМетода", "ПолучитьЗаполнитьСтруктуруПараметровВыгрузкиСправочника");
	ПараметрыМетода = Новый Структура;
	ПараметрыМетода.Вставить("ИмяТаблицы", 					ИмяТаблицы);
	СтруктураВызова.Вставить("ПараметрыМетода", 			ПараметрыМетода);

	ПараметрыВыгрузки = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,, АдресаПеременных);
	
	Возврат ПараметрыВыгрузки;

КонецФункции

// Получает массив имен полей номенклатуры MS, которые используются при выгрузке номенклатуры из 1с
//
// Возвращаемое значение:
//   Массив   - см. ГлЯдро_ПолучитьМассивВыгружаемыхПолейНоменклатурыMS()
//
&НаКлиенте
Функция ЛокЯдро_ПолучитьМассивВыгружаемыхПолейНоменклатурыMS() Экспорт

	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода", "Функция");
	СтруктураВызова.Вставить("ИмяМетода", "ПолучитьМассивВыгружаемыхПолейНоменклатурыMS");

	МассивПолейНоменклатуры = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова,, АдресаПеременных);
	
	Возврат МассивПолейНоменклатуры;

КонецФункции

&НаКлиенте
Функция ЛокЯдро_ВыполнитьПроизвольныйКод(ТекстПроизвольногоКода, СтруктураПеременных, ID_ПроизвольногоКода = Неопределено, ИмяПроизвольногоКода)
	
	ИмяСобытия = "ЛокЯдро_ВыполнитьПроизвольныйКод";
	
	РезультатСтатус = Истина;
	ТекстОшибки = "";
	
	ВыполняемыйКод = "";
	Для Каждого ИмяПеременной Из СтруктураПеременных Цикл
		ВыполняемыйКод = ВыполняемыйКод + ИмяПеременной.Ключ + " = СтруктураПеременных." + ИмяПеременной.Ключ + ";" + Символы.ВК;
	КонецЦикла;
	ВыполняемыйКод = ВыполняемыйКод + Символы.ВК + ТекстПроизвольногоКода;
	
	Попытка
		Если ID_ПроизвольногоКода = "" Тогда
			//Сюда вставить текст произвольного кода для его отладки, что бы началась отладка, в условие нужно вставить его ID_ПроизвольногоКода
		Иначе
			//Выполнить(ВыполняемыйКод);
			СтрокаВызова = ВыполняемыйКод;
			СтрокаВызова = СтрЗаменить(СтрокаВызова, "Результат", "Параметры.Результат");
			СтрокаВызова = СтрЗаменить(СтрокаВызова, "СтруктураПеременных", "Параметры.СтруктураПеременных");
			ПараметрыАлгоритма = Новый Структура;
			ПараметрыАлгоритма.Вставить("ТекстОшибки", 			ТекстОшибки);
			ПараметрыАлгоритма.Вставить("СтруктураПеременных", 	СтруктураПеременных);
			ЛокЯдро_ВыполнитьВБезопасномРежиме(СтрокаВызова, ПараметрыАлгоритма);
			ТекстОшибки = ПараметрыАлгоритма.ТекстОшибки;
		КонецЕсли;
	Исключение
		ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", "Ошибка выполнения произвольного кода " + ИмяПроизвольногоКода + ": " 
			+ Символы.ПС + ТекстОшибки);		
		РезультатСтатус = Ложь;
	КонецПопытки;	
	
	РезультатВыполненияКода = Новый Структура("Статус, Данные", РезультатСтатус, ТекстОшибки);		
	
	Возврат РезультатВыполненияКода;
	
КонецФункции

// Представление имени типа документа Mobile SMARTS с пробелами в виде, доступном для использования в 1С
// Пример: "Документ с некорректным именем" преобразуется в "ДокументСНекорректнымИменем"
//
&НаКлиенте
Функция ЛокЯдро_ПреобразованиеНаименованияДокументаБезПробелов(ИмяДокумента)
	
	МассивЭлементовИмени = ЛокЯдро_РазложитьСтрокуВМассивПодстрок(ИмяДокумента, " ");
	Если МассивЭлементовИмени.Количество() = 1 Тогда
		Возврат ИмяДокумента;
	КонецЕсли;
	
	НовоеНаименование = "";
	
	Для Каждого Слово Из МассивЭлементовИмени Цикл
		ПерваяБуква = Лев(Слово, 1);
		ОстальнаяЧастьСлова = Прав(Слово, СтрДлина(Слово) - 1);
		НовоеНаименование = НовоеНаименование + ВРег(ПерваяБуква) + ОстальнаяЧастьСлова;
	КонецЦикла;
	
	Возврат НовоеНаименование;
	
КонецФункции

// Преобразовывает переданную коллекцию в массив.
//
// Параметры:
//	ИсходныеДанные - Структура, Соответствие - Исходная коллекция
//	ПреобразовыватьКлюч - Булево - определяет что именно надо преобразовывать, ключ или значение.
//
// Возвращаемое значение:
//	Массив - ключи или значения переданной коллекции.
//
&НаКлиентеНаСервереБезКонтекста
Функция ЛокЯдро_ПреобразоватьСоответствиеИлиСтруктуруВМассив(ИсходныеДанные, ПреобразовыватьКлюч = Истина) Экспорт
	
	Результат = Новый Массив;
	
	Для Каждого КлючИЗначение Из ИсходныеДанные Цикл
		Результат.Добавить(?(ПреобразовыватьКлюч, КлючИЗначение.Ключ, КлючИЗначение.Значение));
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Выполняет произвольный алгоритм на встроенном языке 1С:Предприятия
// Параметры:
//  Алгоритм  - Строка - алгоритм на встроенном языке "1С:Предприятия".
//  Параметры - Произвольный -  контекст, который требуется для выполнения алгоритма.
//    В тексте алгоритма обращение к контексту должно происходить по имени "Параметры".
//    Например, выражение "Параметры.Значение1 = Параметры.Значение2" обращается к значениям
//    "Значение1" и "Значение2", переданным в Параметры, как свойства.
//	АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
//
// Пример 1
//  Параметры = Новый Структура;
//  Параметры.Вставить("Значение1", 1);
//  Параметры.Вставить("Значение2", 10);
//  Результат = ГлЯдро_ВыполнитьАлгоритм("Параметры.Значение1 = Параметры.Значение2", Параметры);
//
//  // Пример 2
//  Результат = ГлЯдро_ВыполнитьАлгоритм("СтандартныеПодсистемыСервер.ВерсияБиблиотеки()");
//
&НаСервере
Процедура ЛокЯдро_ВыполнитьВБезопасномРежиме(Знач Алгоритм, Знач Параметры = Неопределено) Экспорт
	
	#Область НесовместимыйКодFresh
	Выполнить Алгоритм;
	#КонецОбласти //НесовместимыйКодFresh
	#Область СовместимыйКодFresh
	//ОбщегоНазначения.ВыполнитьВБезопасномРежиме(Алгоритм, Параметры);
	#КонецОбласти //СовместимыйКодFresh
	
КонецПроцедуры

// Вычисляет переданное выражение, предварительно устанавливая безопасный режим выполнения кода
// и безопасный режим разделения данных для всех разделителей, присутствующих в составе конфигурации.
//
// Параметры:
//  Выражение - Строка - выражение на встроенном языке 1С:Предприятия.
//  Параметры - Произвольный - контекст, который требуется для вычисления выражения.
//    В тексте выражения обращение к контексту должно происходить по имени "Параметры".
//    Например, выражение "Параметры.Значение1 = Параметры.Значение2" обращается к значениям
//    "Значение1" и "Значение2" переданные в Параметры, как свойства.
//	АдресаПеременных - Структура - см. КомЯдро_СоздатьСтруктуруАдресаПеременных
//
// Возвращаемое значение:
//   Произвольный - результат вычисления выражения.
//
// Пример:
//
//  // Пример 1
//  Параметры = Новый Структура;
//  Параметры.Вставить("Значение1", 1);
//  Параметры.Вставить("Значение2", 10);
//  Результат = ОбщегоНазначения.ВычислитьВБезопасномРежиме("Параметры.Значение1 = Параметры.Значение2", Параметры);
//
//  // Пример 2
//  Результат = ОбщегоНазначения.ВычислитьВБезопасномРежиме("СтандартныеПодсистемыСервер.ВерсияБиблиотеки()");
//
&НаСервере
Функция ЛокЯдро_ВычислитьВБезопасномРежиме(Знач Выражение, Знач Параметры = Неопределено) Экспорт

	#Область НесовместимыйКодFresh
	Возврат Вычислить(Выражение);
	#КонецОбласти //НесовместимыйКодFresh
	#Область СовместимыйКодFresh
	//Возврат ОбщегоНазначения.ВычислитьВБезопасномРежиме(Выражение, Параметры);
	#КонецОбласти //СовместимыйКодFresh
	
КонецФункции

&НаКлиенте
Функция ЛокЯдро_ВыполнитьПроизвольныйКодНаСервере(СтруктураПараметров)
	
	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода", 		"Функция");
	СтруктураВызова.Вставить("ИмяМетода", 		"ВыполнитьПроизвольныйКод");
	СтруктураВызова.Вставить("ПараметрыМетода", СтруктураПараметров);
	
	РезультатВыполненияКода = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова, Ложь, АдресаПеременных);	
	
	Возврат РезультатВыполненияКода;	
	
КонецФункции

&НаКлиенте
Функция ЛокЯдро_ПолучитьУИДТекущегоПользователя() Экспорт

	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода", 		"Функция");
	СтруктураВызова.Вставить("ИмяМетода", 		"ПолучитьУИДТекущегоПользователя");	
	СтруктураВызова.Вставить("ПараметрыМетода", Новый Структура());
	
	Возврат Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова, Ложь, АдресаПеременных);

КонецФункции  

&НаКлиенте
Функция ЛокЯдро_ПолучитьКлючПоТекущемуПользователю() Экспорт
	
	Возврат СтрЗаменить(Строка(ЛокЯдро_ПолучитьУИДТекущегоПользователя()), "-", "_");
	
КонецФункции

&НаКлиенте
Функция ЛокЯдро_ПолучитьСтруктуруПользовательскихНастроек() Экспорт
	
	СтруктураНастроек = КомЯдро_ПолучитьЗначениеПеременной("НастройкиПодсказокПользователю");	
	Если ЗначениеЗаполнено(СтруктураНастроек) Тогда
		Возврат СтруктураНастроек;
	Иначе
		Возврат Новый Структура();
	КонецЕсли;                                                                                	
	
КонецФункции

&НаКлиенте
Функция ЛокЯдро_ЗначениеПользовательскойНастройки(ИмяНастройки) Экспорт
	
	ЗначениеНастройки = Истина;
	
	СтруктураНастроек = ЛокЯдро_ПолучитьСтруктуруПользовательскихНастроек();
	Если СтруктураНастроек.Свойство(ИмяНастройки) Тогда
		ЗначениеНастройки = СтруктураНастроек[ИмяНастройки];
	КонецЕсли;                                                                                	
	
	Возврат ЗначениеНастройки;
	
КонецФункции

&НаКлиенте
Процедура ЛокЯдро_ЗаписатьПользовательскуюНастройку(ИмяНастройки, Значение, ID_Узла = "") Экспорт
	
	СтруктураНастроек = ЛокЯдро_ПолучитьСтруктуруПользовательскихНастроек();	
	СтруктураНастроек.Вставить(ИмяНастройки, Значение);
	
	ЛокЯдро_СохранитьДанныеВХранилище1С("Cleverence_НастройкиПодсказокПользователю", СтруктураНастроек);
	КомЯдро_СохранитьЗначениеПеременной("НастройкиПодсказокПользователю", СтруктураНастроек);	
		
КонецПроцедуры

// Дополняет структуру значениями из другой структуры.
//
// Параметры:
//   Приемник - Структура - коллекция, в которую будут добавляться новые значения.
//   Источник - Структура - коллекция, из которой будут считываться пары Ключ и Значение для заполнения.
//   Заменять - Булево
//            - Неопределено - что делать в местах пересечения ключей источника и приемника:
//                             Истина - заменять значения приемника (самый быстрый способ),
//                             Ложь   - не заменять значения приемника (пропускать),
//                             Неопределено - значение по умолчанию. Бросать исключение.
//
&НаКлиенте
Процедура ЛокЯдро_ДополнитьСтруктуру(Приемник, Источник, Заменять = Неопределено) Экспорт
	
	Для Каждого Элемент Из Источник Цикл
		Если Заменять <> Истина И Приемник.Свойство(Элемент.Ключ) Тогда
			Если Заменять = Ложь Тогда
				Продолжить;
			Иначе
				ВызватьИсключение "Пересечение ключей источника и приемника: """ + Элемент.Ключ + """.";
			КонецЕсли
		КонецЕсли;
		Приемник.Вставить(Элемент.Ключ, Элемент.Значение);
	КонецЦикла;
	
КонецПроцедуры

// Возвращает ссылку на общий модуль или модуль менеджера по имени.
//
// См. ОбщегоНазначения.ОбщийМодуль
//
// Параметры:
//  Имя - Строка - имя общего модуля.
//
// Возвращаемое значение:
//  ОбщийМодуль, МодульМенеджераОбъекта - общий модуль.
//
// Пример:
//	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.ОбновлениеКонфигурации") Тогда
//		МодульОбновлениеКонфигурации = ОбщегоНазначения.ОбщийМодуль("ОбновлениеКонфигурации");
//		МодульОбновлениеКонфигурации.<Имя метода>();
//	КонецЕсли;
//
//	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.ПолнотекстовыйПоиск") Тогда
//		МодульПолнотекстовыйПоискСервер = ОбщегоНазначения.ОбщийМодуль("ПолнотекстовыйПоискСервер");
//		МодульПолнотекстовыйПоискСервер.<Имя метода>();
//	КонецЕсли;
//
&НаКлиенте
Функция ЛокЯдро_ОбщийМодуль(Имя) Экспорт
	
	#Область НесовместимыйКодFresh
	Возврат Вычислить(Имя);
	#КонецОбласти //НесовместимыйКодFresh
	#Область СовместимыйКодFresh
	//Возврат ОбщегоНазначенияКлиент.ОбщийМодуль(Имя);
	#КонецОбласти //СовместимыйКодFresh
	
КонецФункции

// Выполняет поиск в массиве структур по заданным ключу и значению ключа
//
// Параметры:
//	МассивСтруктур - Массив из Структура - массив структур, в котором выполняетчся поиск
//	КлючПоиска - Строка - ключ структуры, по которому выполняется поиск
//	ЗначениеПоиска - Произвольный - значение ключа структуры, по которому выполняется поиск
//	ВернутьИндекс - Булево - флаг необходимости вернуть индекс элемента массива, а не сам элемент
//
// Возвращаемое значение:
//	- Число - индекс найденного элемента массива, если ВернутьИндекс = Истина
//	- Структура - значение найденного элемента массива, если ВернутьИндекс = Ложь
//	- Неопределено - если элемент массива найти не удалось
&НаКлиенте
Функция ЛокЯдро_НайтиСтруктуруВМассивеПоЭлементу(МассивСтруктур, КлючПоиска, ЗначениеПоиска,ВернутьИндекс=Ложь) Экспорт
	
	Если ТипЗнч(МассивСтруктур) <> Тип("Массив") 
		ИЛИ КлючПоиска = "" 
		ИЛИ ЗначениеПоиска = Неопределено Тогда
		// переданные параметры некорректны 
		Возврат Неопределено;
	КонецЕсли;
	
	НайденноеЗначениеЭлемента = Неопределено;
	Индекс = -1;
	Для каждого ЭлементМассива Из МассивСтруктур Цикл
		Индекс = Индекс + 1;
		Если ТипЗнч(ЭлементМассива) <> Тип("Структура") Тогда
			Продолжить;
		КонецЕсли;  
		
		Если ЭлементМассива.Свойство(КлючПоиска, НайденноеЗначениеЭлемента) Тогда
			Если НайденноеЗначениеЭлемента = ЗначениеПоиска Тогда
				Возврат ?(ВернутьИндекс,Индекс,ЭлементМассива);
			КонецЕсли; 
		КонецЕсли; 
	
	КонецЦикла; 
	
	Возврат Неопределено;

КонецФункции // НайтиСтруктуруВМассивеПоЭлементу()

&НаКлиенте 
Процедура ЛокЯдро_ПередПодключениемРасширенияРаботыСФайлами(ДополнительныеПараметры) Экспорт
	
	НачатьПодключениеРасширенияРаботыСФайлами(
		Новый ОписаниеОповещения(
			"ЛокЯдро_ПослеПодключенияРасширенияРаботыСФайлами",
			ЭтаФорма,
			ДополнительныеПараметры));
		
КонецПроцедуры

&НаКлиенте
Процедура ЛокЯдро_ПослеПодключенияРасширенияРаботыСФайлами(Подключено, ДополнительныеПараметры) Экспорт
	
	Если Подключено Тогда
        // Расширение работы с файлами подключено
		ВыполнитьОбработкуОповещения(ДополнительныеПараметры.ВыборЗавершение, ДополнительныеПараметры);
	ИначеЕсли ДополнительныеПараметры.УстановитьЕслиНеПодключено Тогда
		ДополнительныеПараметры.УстановитьЕслиНеПодключено = Ложь;
		
		НачатьУстановкуРасширенияРаботыСФайлами(
            Новый ОписаниеОповещения(
                "ЛокЯдро_ПередПодключениемРасширенияРаботыСФайлами",
                ЭтаФорма,
                ДополнительныеПараметры));
    Иначе
        // Не удалось установить или подключить расширение работы с файлами
		Сообщить("Не удалось установить (подключить) расширение работы с файлами");
	КонецЕсли;
	
КонецПроцедуры

&НаКлиенте
Функция ПолучитьФорматированнуюСтрокуПоНомеруОшибки(НомерОшибки) Экспорт
	
	Возврат Новый ФорматированнаяСтрока(
		НомерОшибки,
		,
		,
		, 
		ПолучитьСсылкуПоНомеруОшибки(НомерОшибки)); 
			
КонецФункции

&НаКлиенте
Функция ПолучитьСсылкуПоНомеруОшибки(НомерОшибки) Экспорт

	Возврат "https://www.cleverence.ru/search/?searchid=2471938&text=%23" 
		+ Прав(НомерОшибки, СтрДлина(НомерОшибки) - 1) + "&web=0#lr=20523&constraintid=0";
		
	КонецФункции

&НаСервере
Функция ЛокЯдро_ЗаполнитьСписокПолейЗапроса(КлючНастройки, ТипДокумента1С, ТекстЗапроса, ТекстКодаПолучениеПараметров) Экспорт
	
	СписокПолей = Новый СписокЗначений;
	
	Запрос = Новый Запрос(ТекстЗапроса);
	Если Найти(ВРег(КлючНастройки), ВРег("Документ")) Тогда
		Запрос.УстановитьПараметр("Ссылка", Документы[ТипДокумента1С].ПустаяСсылка());
	КонецЕсли;
	
	ПараметрыЗапроса = Новый Структура;
	Попытка
		СтрокаВызова = ТекстКодаПолучениеПараметров;
		СтрокаВызова = СтрЗаменить(СтрокаВызова, "ДокументДляВыгрузки", "Документы[""" + ТипДокумента1С + """].ПустаяСсылка()");
		ПараметрыАлгоритма = Новый Структура;
		ПараметрыАлгоритма.Вставить("ПараметрыЗапроса", ПараметрыЗапроса);
		ПараметрыЗапроса = ЛокЯдро_ВыполнитьКодПолученияПараметровЗапроса(СтрокаВызова, ПараметрыАлгоритма);
		
		Если ПараметрыЗапроса.Количество() Тогда
			Для Каждого ПараметрЗапроса Из ПараметрыЗапроса Цикл
				Запрос.УстановитьПараметр(ПараметрЗапроса.Ключ, ПараметрЗапроса.Значение);	
			КонецЦикла;
		КонецЕсли;
	Исключение
		Сообщить("Ошибка получения параметров запроса табличной части." + Символы.ПС + КраткоеПредставлениеОшибки(ИнформацияОбОшибке()));
		Возврат СписокПолей;
	КонецПопытки;	
	
	Попытка
		Результат = Запрос.Выполнить().Выгрузить();
		Для Каждого Колонка из Результат.Колонки Цикл
			СписокПолей.Добавить(Колонка.Имя, Колонка.Имя);
		КонецЦикла;
	Исключение
		Сообщить("Не удалось получить список полей по причине ошибки выполнения запроса.
		|"+КраткоеПредставлениеОшибки(ИнформацияОбОшибке()));		
	КонецПопытки;
	
	Возврат СписокПолей;

КонецФункции

&НаСервере
Функция ЛокЯдро_ВыполнитьКодПолученияПараметровЗапроса(СтрокаВызова, Знач ПараметрыАлгоритма) Экспорт

	ПараметрыМетода = Новый Структура;
	ПараметрыМетода.Вставить("СтрокаВызова", 		СтрокаВызова);
	ПараметрыМетода.Вставить("ПараметрыАлгоритма",  ПараметрыАлгоритма);
	ПараметрыМетода.Вставить("АдресаПеременных",	АдресаПеременных);
	
	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода", 		"Функция");
	СтруктураВызова.Вставить("ИмяМетода", 		"ВыполнитьКодПолученияПараметровЗапроса");
	СтруктураВызова.Вставить("ПараметрыМетода", ПараметрыМетода);

	ПередаваемыеПараметры = Транзит_ПоместитьЗначениеВХранилищеНаСервере(СтруктураВызова);
	
	АдресРезультата = Транзит_ВызватьГлобальныйМетодНаСервере(ПередаваемыеПараметры);
	
	Если ЭтоАдресВременногоХранилища(АдресРезультата) Тогда
		ПараметрыЗапроса = ПолучитьИзВременногоХранилища(АдресРезультата);
	Иначе
		ПараметрыЗапроса = Новый Структура;
	КонецЕсли;
	
	Возврат ПараметрыЗапроса;
	
КонецФункции

&НаКлиенте
Процедура ЛокЯдро_ПоказатьПолучениеФайлов(ДополнительныеПараметры, ДопПараметр) Экспорт
	
	Контекст = ДополнительныеПараметры.Контекст;

	ОписаниеОповещения = Новый ОписаниеОповещения(ДополнительныеПараметры.ОбработчикЗавершения, ЭтаФорма, ДополнительныеПараметры);
	НачатьПолучениеФайлов(ОписаниеОповещения, Контекст.ПолучаемыеФайлы,
		Контекст.Диалог, Контекст.Интерактивно);
	
КонецПроцедуры

&НаКлиенте
Процедура ЛокЯдро_ПоказатьПомещениеФайлов(ДополнительныеПараметры, ДопПараметр) Экспорт
	
	Контекст = ДополнительныеПараметры.Контекст;

	ОписаниеОповещения = Новый ОписаниеОповещения(ДополнительныеПараметры.ОбработчикЗавершения, ЭтаФорма, ДополнительныеПараметры);
	НачатьПомещениеФайлов(ОписаниеОповещения, Контекст.ЗагружаемыеФайлы, Контекст.Интерактивно,,
		Контекст.ДействиеПередНачаломПомещенияФайлов);
	
КонецПроцедуры
	
#КонецОбласти

#КонецОбласти

#Область ЛокальныйКонтекст_СправочникиИТаблицы_ПечатьЭтикеток

&НаКлиенте
Функция ЛокЯдро_ПолучитьСписокПолейШаблона(СтруктураПараметров) Экспорт
	
	ПараметрыМетода = Новый Структура;
	ПараметрыМетода.Вставить("СтруктураПараметров", СтруктураПараметров);
	
	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода", 		"Функция");
	СтруктураВызова.Вставить("ИмяМетода", 		"ПолучитьСписокПолейШаблона");
	СтруктураВызова.Вставить("ПараметрыМетода", ПараметрыМетода);
	
	СписокПолейШаблона = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова, Ложь, АдресаПеременных);	
	
	//Может вернуться неопределено в случае, если нет интеграционной обработки
	//Попробуем получить ИО снова
	Если СписокПолейШаблона = Неопределено Тогда
		Если РасположениеКомпоненты = Неопределено Тогда
			РасположениеКомпоненты = ЛокЯдро_ПолучитьДанныеИзХранилища1С("Cleverence_РасположениеКомпоненты");
		КонецЕсли;
		ЛокЯдро_ПодключитьИнтеграционнуюОбработку(РасположениеКомпоненты);
		СписокПолейШаблона = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова, Ложь, АдресаПеременных);
	КонецЕсли;
	
	Возврат СписокПолейШаблона;
	
КонецФункции

&НаКлиенте
Процедура ЛокЯдро_НапечататьЭтикетки(СтруктураПараметров) Экспорт

	ИмяТаблицы 		= СтруктураПараметров.ИмяТаблицы;
	ID_Узла			= СтруктураПараметров.ID_Узла;
	ТаблицаВыборки 	= СтруктураПараметров.ТаблицаВыборки;
	
	// Получение настроек
	
	НастройкиПечатиЭтикеток = ЛокЯдро_ПолучитьИзКэшаНастройкуSMARTS("НастройкиПечатиЭтикеток", Истина);
	Если НастройкиПечатиЭтикеток = Неопределено Тогда
		СтруктураНастроек = ЛокЯдро_ПолучитьЗначениеТабличнойНастройкиНаСервереSMARTS("НастройкиПечатиЭтикеток", Новый Структура("ИмяТаблицы", ИмяТаблицы));
	Иначе
		СтруктураНастроек = ЛокЯдро_НайтиВМассивеСтруктурПоОтбору(НастройкиПечатиЭтикеток, Новый Структура("ИмяТаблицы", ИмяТаблицы));
	КонецЕсли;
	
	Если СтруктураНастроек = Неопределено Тогда
		ПоказатьПредупреждение(, "Не найдены настройки печати этикеток для таблицы [" + ИмяТаблицы + "]!", , "Внимание");
		Возврат;
	Иначе
		ШаблонЭтикетки 	= ?(СтруктураНастроек[0].Свойство("ШаблонЭтикетки"), 				СтруктураНастроек[0].ШаблонЭтикетки, 				Неопределено);
		ВстроенныйМакет = ?(СтруктураНастроек[0].Свойство("ВстроенныйМакет"), 				СтруктураНастроек[0].ВстроенныйМакет, 				Ложь);
		НастройкиПечати = ?(СтруктураНастроек[0].Свойство("НастройкаПечатиМассивСтруктур"), СтруктураНастроек[0].НастройкаПечатиМассивСтруктур, Неопределено);
		
		Если НЕ ЗначениеЗаполнено(ШаблонЭтикетки) Тогда
			ПоказатьПредупреждение(, "В настройках печати для таблицы [" + ИмяТаблицы + "] не выбран шаблон этикетки!", , "Внимание");
			Возврат;
		КонецЕсли;
		
		Если НастройкиПечати = Неопределено ИЛИ ТипЗнч(НастройкиПечати) <> Тип("Массив") Тогда
			ПоказатьПредупреждение(, "Не найдены настройки печати этикеток для таблицы [" + ИмяТаблицы + "]!", , "Внимание");
			Возврат;
		КонецЕсли;		
	КонецЕсли;
	
	// Формирование данных для печати
	
	ЕстьГлобальныеПараметры = ЛокЯдро_НайтиПоЗначениюВМассивеСтруктур(НастройкиПечати, "ТипИсточника", "ГлобальныйПараметр") <> Неопределено;
	Если ЕстьГлобальныеПараметры Тогда	
		ГлобальныеПараметры = ЛокЯдро_ПолучитьЗначенияГлобальныхПараметров(ID_Узла);
	КонецЕсли;
		
	ЕстьПроизвольныеКоды = ЛокЯдро_НайтиПоЗначениюВМассивеСтруктур(НастройкиПечати, "ТипИсточника", "ПроизвольныйКод") <> Неопределено;
	Если ЕстьПроизвольныеКоды Тогда	
		ПроизвольныеКоды = ЛокЯдро_ПолучитьИзКэшаЗначениеТабличнойНастройкиSMARTS("ПроизвольныеКоды", Новый Структура("Направление,ТипОбъекта", "Настройка", "ПечатьЭтикеток"));
	КонецЕсли;
		
	МассивДанных = Новый Массив;
	
	Для каждого СтрокаТаблицы ИЗ ТаблицаВыборки Цикл
		Если СтрокаТаблицы.Свойство("ЭтоТаблицаЗначений") Тогда
			Продолжить;
		КонецЕсли;
		
		СтруктураДанных = Новый Структура;		
		
		Для каждого ТекСтрока ИЗ НастройкиПечати Цикл
			Если ТекСтрока.Свойство("ЭтоТаблицаЗначений") Тогда
				Продолжить;
			КонецЕсли;
			
			Если НЕ ТекСтрока.Выгружать
				ИЛИ НЕ ЗначениеЗаполнено(ТекСтрока.ИмяПриемника) Тогда
				Продолжить;				
			КонецЕсли;
			
			ЗначениеПоля = Неопределено;			
			
			Если ТекСтрока.ТипИсточника = "ГлобальныйПараметр" Тогда
				НайденныйГП = ЛокЯдро_НайтиПоЗначениюВМассивеСтруктур(ГлобальныеПараметры, "ID_Параметра", ТекСтрока.ИмяИсточника);
				Если НайденныйГП <> Неопределено Тогда
					ЗначениеПоля = НайденныйГП.Значение;	
				КонецЕсли;
			ИначеЕсли ТекСтрока.ТипИсточника = "ПроизвольныйКод" Тогда				
				НайденныйПК = ЛокЯдро_НайтиПоЗначениюВМассивеСтруктур(ПроизвольныеКоды, "ID_ПроизвольногоКода", ТекСтрока.ИмяИсточника);
				Если НайденныйПК <> Неопределено Тогда
					СтруктураПеременных = Новый Структура;
					СтруктураПеременных.Вставить("СтрокаДанныхДляВыгрузки", СтрокаТаблицы);  
					
					СтруктураПараметров = Новый Структура;
					СтруктураПараметров.Вставить("ТекстПроизвольногоКода", 	НайденныйПК.ТекстПроизвольногоКода);
					СтруктураПараметров.Вставить("СтруктураПеременных", 	СтруктураПеременных);
					СтруктураПараметров.Вставить("ID_ПроизвольногоКода", 	НайденныйПК.ID_ПроизвольногоКода);
					СтруктураПараметров.Вставить("ИмяПроизвольногоКода", 	НайденныйПК.Наименование);
					
					РезультатВыполненияКода = ЛокЯдро_ВыполнитьПроизвольныйКодНаСервере(СтруктураПараметров);
					Если РезультатВыполненияКода.Статус Тогда
						ЗначениеПоля = РезультатВыполненияКода.Данные;	
					Иначе
						СообщениеОбОшибках = "Не удалось выполнить произвольный код [" + НайденныйПК.Наименование + "]";
						Сообщить(СообщениеОбОшибках);
					КонецЕсли;
				КонецЕсли;			
			ИначеЕсли ТекСтрока.ТипИсточника = "Реквизит1С"	Тогда
				ЗначениеИсточника = Неопределено;
				Если ЗначениеЗаполнено(ТекСтрока.ИмяИсточника) И СтрокаТаблицы.Свойство(ТекСтрока.ИмяИсточника, ЗначениеИсточника) Тогда
					ЗначениеПоля = ЗначениеИсточника;
				КонецЕсли;
			Иначе	
				ЗначениеПоля = ТекСтрока.ЗначениеИсточника;				
			КонецЕсли;
			
			КлючСтруктуры = ТекСтрока.ИмяПриемника;
			Пока Найти(КлючСтруктуры, ".") Цикл
				КлючСтруктуры = СтрЗаменить(КлючСтруктуры, ".", "_СимволТочки_");				
			КонецЦикла;
			
			СтруктураДанных.Вставить(КлючСтруктуры, ЗначениеПоля); 					
			
		КонецЦикла;
			
		Если СтруктураДанных.Количество() Тогда
			МассивДанных.Добавить(СтруктураДанных);
		КонецЕсли;

	КонецЦикла;
	
	// Вывод на печать
	
	Если ВстроенныйМакет Тогда
		ШаблонЭтикетки = ЛокЯдро_ПолучитьМакетОбработки("Этикетка" + СокрЛП(ШаблонЭтикетки));		
	КонецЕсли;	
	СтруктураШаблона = ЛокЯдро_ПодготовитьСтруктуруМакетаШаблона(ШаблонЭтикетки, ИмяТаблицы);
	
	ТабличныйДокумент = ЛокЯдро_СформироватьПечатнуюФормуЭтикетки(Новый Структура("СтруктураШаблона, ДанныеДляПечати", СтруктураШаблона, МассивДанных));
		
	ДокументНапечатан = Ложь;
	
	// Проверка существования модуля УправлениеПечатьюКлиент
	МодульПечатиСуществует = ЛокЯдро_ВычислитьВБезопасномРежиме("Метаданные.ОбщиеМодули.Найти(""УправлениеПечатьюКлиент"") <> Неопределено");
	Если НЕ МодульПечатиСуществует Тогда
		УправлениеПечатьюКлиент = Неопределено;
	КонецЕсли;
	
	Если МодульПечатиСуществует Тогда
		Попытка
			КоллекцияПечатныхФорм = УправлениеПечатьюКлиент.НоваяКоллекцияПечатныхФорм("ПроизвольнаяЭтикетка");
			КоллекцияПечатныхФорм[0].ТабличныйДокумент = ТабличныйДокумент;
				
			УправлениеПечатьюКлиент.ПечатьДокументов(КоллекцияПечатныхФорм);
			ДокументНапечатан = Истина;
		Исключение
			ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
			ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации("ЛокЯдро_НапечататьЭтикетки", "Предупреждение", "Не удалось добавить документ в коллекцию: " + ТекстОшибки);
		КонецПопытки;
	КонецЕсли;
	
	Если НЕ ДокументНапечатан Тогда
		ТабличныйДокумент.ОтображатьСетку = Ложь;
		ТабличныйДокумент.Показать("Печать этикеток для таблицы " + СокрЛП(ИмяТаблицы));		
	КонецЕсли;
		
КонецПроцедуры

&НаКлиенте
Функция ЛокЯдро_ПодготовитьСтруктуруМакетаШаблона(ШаблонЭтикетки, ИмяТаблицы)
	
	СтруктураПараметров = Новый Структура;
	СтруктураПараметров.Вставить("ШаблонЭтикетки",  ШаблонЭтикетки);
	СтруктураПараметров.Вставить("ИмяТаблицы",		ИмяТаблицы);
	
	ПараметрыМетода = Новый Структура;
	ПараметрыМетода.Вставить("СтруктураПараметров", СтруктураПараметров);
	
	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода", 		"Функция");
	СтруктураВызова.Вставить("ИмяМетода", 		"ПодготовитьСтруктуруМакетаШаблона");
	СтруктураВызова.Вставить("ПараметрыМетода", ПараметрыМетода);
	
	СтруктураШаблона = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова, Ложь, АдресаПеременных);	
	
	Возврат СтруктураШаблона;
	
КонецФункции

&НаКлиенте
Функция ЛокЯдро_СформироватьПечатнуюФормуЭтикетки(СтруктураПараметров) Экспорт

	ПараметрыМетода = Новый Структура;
	ПараметрыМетода.Вставить("СтруктураПараметров", СтруктураПараметров);
	
	СтруктураВызова = Новый Структура;
	СтруктураВызова.Вставить("ТипМетода", 		"Функция");
	СтруктураВызова.Вставить("ИмяМетода", 		"СформироватьПечатнуюФормуЭтикетки");
	СтруктураВызова.Вставить("ПараметрыМетода", ПараметрыМетода);
	
	ТабличныйДокумент = Транзит_ВызватьГлобальныйМетодНаКлиенте(СтруктураВызова, Ложь, АдресаПеременных);	
	
	Возврат ТабличныйДокумент;		
	
КонецФункции

&НаКлиенте
Функция ЛокЯдро_ПозицииПараметровШаблона(ТекстЯчейки) Экспорт
	
	Массив = Новый Массив;
	
	Начало = -1;
	Конец  = -1;
	СчетчикСкобокОткрывающих = 0;
	СчетчикСкобокЗакрывающих = 0;
	
	Для Индекс = 1 По СтрДлина(ТекстЯчейки) Цикл
		Символ = Сред(ТекстЯчейки, Индекс, 1);
		Если Символ = "[" Тогда
			СчетчикСкобокОткрывающих = СчетчикСкобокОткрывающих + 1;
			Если СчетчикСкобокОткрывающих = 1 Тогда
				Начало = Индекс;
			КонецЕсли;
		ИначеЕсли Символ = "]" Тогда
			СчетчикСкобокЗакрывающих = СчетчикСкобокЗакрывающих + 1;
			Если СчетчикСкобокЗакрывающих = СчетчикСкобокОткрывающих Тогда
				Конец = Индекс;
				
				Массив.Добавить(Новый Структура("Начало, Конец", Начало, Конец));
				
				Начало = -1;
				Конец  = -1;
				СчетчикСкобокОткрывающих = 0;
				СчетчикСкобокЗакрывающих = 0;
				
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Массив;
	
КонецФункции

#КонецОбласти

#Область ЛокальныйКонтекст_ФоновыеЗадания

&НаКлиенте
Процедура ЛокЯдро_НачатьВыполнениеФоновогоЗадания(ПараметрыФЗ, ОписаниеОповещенияЗавершенияФЗ = Неопределено, ОписаниеОповещенияОшибкиФЗ = Неопределено)

	ИмяСобытия = "ЛокЯдро_НачатьВыполнениеФоновогоЗадания";
	
	#Если НЕ ТолстыйКлиентОбычноеПриложение Тогда
		
		Попытка
			
			Если ПараметрыФЗ.Свойство("ПараметрыМетода") И
				ТипЗнч(ПараметрыФЗ.ПараметрыМетода) = Тип("Структура") И
				ПараметрыФЗ.ПараметрыМетода.Свойство("АдресаПеременных") Тогда
				
				// ФЗ выполняется в другом сеансе, поэтому данные добавленные в кэш в ФЗ не будут сохранены
				// Чтобы данные сохранились, добавим в АдресаПеременных пустые значения всех настроек, которые могут быть добавлены в кэш
				// В методе сохранения настроек в кэш будем анализировать, если это фоновое задание, то будем сохранять данные иначе. См. КомЯдро_СохранитьЗначениеПеременной()	
				КоличествоПеременныхСохраняемыхВКэш = 30;
				МассивАдресовПустыхЗначений = Новый Массив();
				Для Счетчик = 1 По КоличествоПеременныхСохраняемыхВКэш Цикл
					ЗначениеМассива = ПоместитьВоВременноеХранилище("", АдресаПеременных.ИдентификаторФормы);
					МассивАдресовПустыхЗначений.Добавить(ЗначениеМассива);
				КонецЦикла;
				ПараметрыФЗ.ПараметрыМетода.Вставить("МассивАдресовПустыхЗначений", МассивАдресовПустыхЗначений);
				
			КонецЕсли;
			
			ДополнительныеПараметры = Новый Структура;
			ДополнительныеПараметры.Вставить("ПараметрыФЗ", 					ПараметрыФЗ);
			ДополнительныеПараметры.Вставить("ОписаниеОповещенияЗавершенияФЗ", 	ОписаниеОповещенияЗавершенияФЗ);
			ДополнительныеПараметры.Вставить("ОписаниеОповещенияОшибкиФЗ", 		ОписаниеОповещенияОшибкиФЗ);
			#Если ВебКлиент Тогда
				ДополнительныеПараметры.Вставить("УстановитьЕслиНеПодключено", Истина);
				ДополнительныеПараметры.Вставить("ВыборЗавершение", Новый ОписаниеОповещения("ЛокЯдро_ПоместитьФайлВнешнейОбработки", ЭтаФорма));
				
				ЛокЯдро_ПередПодключениемРасширенияРаботыСФайлами(ДополнительныеПараметры);
			#Иначе
				ЛокЯдро_ПоместитьФайлВнешнейОбработки(ДополнительныеПараметры);
			#КонецЕсли
			
		Исключение
			
			ИнфоОбОшибке 	= ИнформацияОбОшибке();
			ТекстОшибки 	= ПодробноеПредставлениеОшибки(ИнфоОбОшибке);
			
			Если ТипЗнч(ОписаниеОповещенияОшибкиФЗ) = Тип("ОписаниеОповещения") Тогда
				ВыполнитьОбработкуОповещения(ОписаниеОповещенияОшибкиФЗ, ТекстОшибки);
			Иначе
				ТекстСообщения = "Ошибка выполнения фонового задания:" + Символы.ПС + ТекстОшибки;
				Сообщить(ТекстСообщения);
				ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", ТекстСообщения);
			КонецЕсли;
			
		КонецПопытки;
		
	#КонецЕсли

КонецПроцедуры

&НаКлиенте
Процедура ЛокЯдро_НачатьВыполнениеФоновогоЗаданияПродолжение(ДополнительныеПараметры)
	
	#Если НЕ ТолстыйКлиентОбычноеПриложение Тогда
		
		ПараметрыФЗ 					= ДополнительныеПараметры.ПараметрыФЗ;
		ОписаниеОповещенияЗавершенияФЗ 	= ДополнительныеПараметры.ОписаниеОповещенияЗавершенияФЗ;
		ОписаниеОповещенияОшибкиФЗ 		= ДополнительныеПараметры.ОписаниеОповещенияОшибкиФЗ;
				
		// Заготовка для вывода собственного прогресс бара
		//ОповещениеОПрогрессеВыполнения = Новый ОписаниеОповещения("<ОповещениеОПрогрессеВыполнения>", ЭтотОбъект);
		
		ДлительнаяОперация = ЛокЯдро_НачатьВыполнениеФоновогоЗаданияНаСервере(ПараметрыФЗ);
		
		ПараметрыОжидания = ЛокЯдро_ОбщийМодуль("ДлительныеОперацииКлиент").ПараметрыОжидания(Неопределено);
		ПараметрыОжидания.ТекстСообщения = ПараметрыФЗ.ТекстСообщения;
		Если ПараметрыФЗ.Свойство("ВыводитьОкноОжидания") Тогда
			ПараметрыОжидания.ВыводитьОкноОжидания = ПараметрыФЗ.ВыводитьОкноОжидания;
		КонецЕсли;
		
		ДопПараметры = Новый Структура;
		ДопПараметры.Вставить("ОписаниеОповещенияЗавершенияФЗ", ОписаниеОповещенияЗавершенияФЗ);
		ДопПараметры.Вставить("ОписаниеОповещенияОшибкиФЗ", 	ОписаниеОповещенияОшибкиФЗ);
		
		ОповещениеОЗавершении = Новый ОписаниеОповещения("ЛокЯдро_ВыполнитьПроцедуруФоновоВыполнено", ЭтаФорма, ДопПараметры);
		ЛокЯдро_ОбщийМодуль("ДлительныеОперацииКлиент").ОжидатьЗавершение(ДлительнаяОперация, ОповещениеОЗавершении, ПараметрыОжидания);
				
	#КонецЕсли
	
КонецПроцедуры

&НаСервере
Функция ЛокЯдро_НачатьВыполнениеФоновогоЗаданияНаСервере(ПараметрыФЗ)

	#Если НЕ ТолстыйКлиентОбычноеПриложение Тогда
				
		ЭтоВнешняяОбработка = ЛокЯдро_ЭтоВнешняяОбработка();
		ИмяОбработки = ?(ЭтоВнешняяОбработка, ХранениеФайлаОбработки, ИмяОбъекта);
		
		ПараметрыМетода = ПараметрыФЗ.ПараметрыМетода;
		Если ТипЗнч(ПараметрыМетода) = Тип("Структура") И
			ПараметрыМетода.Свойство("АдресаПеременных") Тогда
			// Скопируем в новую структуру, чтобы не возращать на клиент значения, которые там не доступны
			СтруктураВызова = Новый Структура;
			СтруктураВызова.Вставить("ТипМетода", "Функция");
			СтруктураВызова.Вставить("ИмяМетода", "СкопироватьСтруктуру");
			СтруктураВызова.Вставить("ПараметрыМетода", Новый Структура("СтруктураИсточник", ПараметрыМетода));
			
			КопияПараметрыМетода = ПолучитьИзВременногоХранилища(Транзит_ВызватьГлобальныйМетодНаСервере(ПоместитьВоВременноеХранилище(СтруктураВызова)));
			
			пАдресаПеременных = КопияПараметрыМетода.АдресаПеременных;

			// ФЗ запускается в другом сеансе, поэтому значения переменных из АдресаПеременных не будут там доступны
			// Создадим новую структуру, в которой будут не адреса во врем хранилище, а сами значения
			ЗначенияПеременных = Новый Структура;
			Для Каждого ЭлементАдресовПеременных Из пАдресаПеременных Цикл
				
				КлючЭлемента = ЭлементАдресовПеременных.Ключ;
				
				// TODO. Реализовать универсально. Параметры ФЗ не поддерживают сериализацию
				Если КлючЭлемента = "ИнтеграционнаяОбработка" Тогда
					
					Значение = ПолучитьИзВременногоХранилища(ЭлементАдресовПеременных.Значение);
					КопияЗначение = Неопределено;
					
					Если ТипЗнч(Значение) = Тип("Структура") И
						Значение.Свойство("ИнтеграционнаяОбработка") Тогда
						
						// Скопируем структуру, т.к. будет удалять из нее элементы
						СтруктураВызова.Вставить("ПараметрыМетода", Новый Структура("СтруктураИсточник", Значение));
						
						КопияЗначение = ПолучитьИзВременногоХранилища(Транзит_ВызватьГлобальныйМетодНаСервере(ПоместитьВоВременноеХранилище(СтруктураВызова)));

						// Удалим ключ ИнтеграционнаяОбработка, т.к. в нем может содержаться значение типа ВнешняяОбработкаОбъект,
						// которое не сериализуется, и поэтому не может быть передано в качестве параметра в фон задание
						// В фон задании ИО будет подключаться из значения ИнтеграционнаяОбработкаДвоичныеДанные
						КопияЗначение.Удалить("ИнтеграционнаяОбработка");
					КонецЕсли;
					
					АдресЗначенияПеременной = ?(ЗначениеЗаполнено(КопияЗначение), КопияЗначение, Значение);
										
				ИначеЕсли КлючЭлемента = "COMЧастнойБазыMS" Или
					КлючЭлемента = "COMВременнойБазыMS" Или
					КлючЭлемента = "COMБазыMS" Тогда
					// Удаляем данные ключи, т.к. в них могут содержаться несериализуемые значения
					АдресЗначенияПеременной = Неопределено;
				ИначеЕсли КлючЭлемента = "КОМсоздан" Тогда
					АдресЗначенияПеременной = Ложь;	
				Иначе
					АдресЗначенияПеременной = ЭлементАдресовПеременных.Значение;
				КонецЕсли;		

				ЗначенияПеременных.Вставить(КлючЭлемента, 
					?(ЭтоАдресВременногоХранилища(АдресЗначенияПеременной), ПолучитьИзВременногоХранилища(АдресЗначенияПеременной), АдресЗначенияПеременной));
			КонецЦикла;
			
			КопияПараметрыМетода.Вставить("ЗначенияПеременных", ЗначенияПеременных);
			
			ПараметрыМетода = КопияПараметрыМетода;
		КонецЕсли;
		
		ПараметрыЗадания = Новый Структура;
		ПараметрыЗадания.Вставить("ИмяОбработки",					ИмяОбработки);
		ПараметрыЗадания.Вставить("ДополнительнаяОбработкаСсылка", 	ОбъектСсылка);
		ПараметрыЗадания.Вставить("ИмяМетода",						ПараметрыФЗ.ИмяМетода);
		ПараметрыЗадания.Вставить("ПараметрыВыполнения",			ПараметрыМетода);
		ПараметрыЗадания.Вставить("ЭтоВнешняяОбработка",			ЭтоВнешняяОбработка);
		
		ПараметрыВыполнения = ЛокЯдро_ВычислитьВБезопасномРежиме("ДлительныеОперации").ПараметрыВыполненияВФоне(УникальныйИдентификатор);
		ПараметрыВыполнения.НаименованиеФоновогоЗадания = ПараметрыФЗ.НаименованиеФЗ;
		
		ВыполняемыйМетод = "ДлительныеОперации.ВыполнитьПроцедуруМодуляОбъектаОбработки"; // Выполняем процедуру из модуля объекта
		Возврат ЛокЯдро_ВычислитьВБезопасномРежиме("ДлительныеОперации").ВыполнитьВФоне(ВыполняемыйМетод, ПараметрыЗадания, ПараметрыВыполнения);
		
	#КонецЕсли

КонецФункции

&НаКлиенте
Процедура ЛокЯдро_ВыполнитьПроцедуруФоновоВыполнено(Результат, ДополнительныеПараметры) Экспорт
	
	ИмяСобытия = "ЛокЯдро_ВыполнитьПроцедуруФоновоВыполнено";
	
	ТекстОшибки = "";
	
    Если Результат = Неопределено Тогда
        ТекстОшибки = "Не удалось получить результат выполнения фонового задания";
    ИначеЕсли Результат.Статус = "Ошибка" Тогда
        ТекстОшибки = Результат.ПодробноеПредставлениеОшибки;
    ИначеЕсли Результат.Статус = "Выполнено" Тогда
        // Обрабатываем результат
		Попытка
			Если ДополнительныеПараметры.ОписаниеОповещенияЗавершенияФЗ <> Неопределено Тогда
				ВыполнитьОбработкуОповещения(ДополнительныеПараметры.ОписаниеОповещенияЗавершенияФЗ, Результат.АдресРезультата);
			КонецЕсли;
		Исключение
			ИнфоОбОшибке = ИнформацияОбОшибке();
			ТекстОшибки = ПодробноеПредставлениеОшибки(ИнфоОбОшибке);	
		КонецПопытки;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ТекстОшибки) Тогда
		// Удалим из кэша признак, что выполнялось фоновое задание
		Если АдресаПеременных.Свойство("ЭтоФоновоеЗадание") Тогда
			АдресаПеременных.Удалить("ЭтоФоновоеЗадание");
		КонецЕсли;
		Если ДополнительныеПараметры.Свойство("ОписаниеОповещенияОшибкиФЗ") И
			ТипЗнч(ДополнительныеПараметры.ОписаниеОповещенияОшибкиФЗ) = Тип("ОписаниеОповещения") Тогда
			// Если есть описание оповещения обработки ошибки фз, то выполняем его
			ВыполнитьОбработкуОповещения(ДополнительныеПараметры.ОписаниеОповещенияОшибкиФЗ, ТекстОшибки);
		Иначе
			// Сообщение пользователю и запись в ЖР
			ТекстСообщения = "Ошибка выполнения фонового задания:" + Символы.ПС + ТекстОшибки;
			Сообщить(ТекстСообщения);
			ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", ТекстСообщения);
		КонецЕсли;
	КонецЕсли;		

КонецПроцедуры

&НаКлиенте
Процедура ЛокЯдро_ОбработатьОшибкиПолученияДанныхДляИнициализацииВФоне(Результат, ДополнительныеПараметры) Экспорт
	
	ИмяСобытия = "ЛокЯдро_ОбработатьОшибкиПолученияДанныхДляИнициализацииВФоне";
		
	ТекстОшибки = Результат;
	ТекстСообщения = "Фоновые задания отключены. Попробуйте повторить операцию." + Символы.ПС + "Ошибка инициализации в фоне по причине:" + Символы.ПС + ТекстОшибки;
	
	ДоступноВыполнениеВФоне = Ложь;
	КомЯдро_СохранитьЗначениеПеременной("ДоступноВыполнениеВФоне", ДоступноВыполнениеВФоне);
	
	Сообщить(ТекстСообщения);
	Попытка
		ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", ТекстСообщения);
	Исключение
	КонецПопытки;
	
	СтруктураСменыСтатуса = Новый Структура("Статус, Параметр, Операция", 
		"ОшибкиФоновойИнициализации", 
		"", 
		ИмяСобытия);
	Оповестить("СменаСтатуса", СтруктураСменыСтатуса);

КонецПроцедуры

&НаКлиенте
Процедура ЛокЯдро_ОбработатьОшибкиВыгрузкиТаблицыВФоне(Результат, ДополнительныеПараметры) Экспорт
	
	ИмяСобытия = "ЛокЯдро_ОбработатьОшибкиВыгрузкиТаблицыВФоне";
	
	ТекстОшибки = Результат;
	ИмяТаблицы 	= ДополнительныеПараметры.ИмяТаблицы;
	
	ЭлементСписка = СписокТаблицВыгружаемыхВФоне.НайтиПоЗначению(ИмяТаблицы);
	Если ЭлементСписка <> Неопределено Тогда
		СписокТаблицВыгружаемыхВФоне.Удалить(ЭлементСписка);
	КонецЕсли;
	
	ТекстСообщения = "Ошибка выгрузки таблицы [" + ИмяТаблицы + "] в фоне по причине:" + Символы.ПС + ТекстОшибки;

	Сообщить(ТекстСообщения);
	ЛокЯдро_ЗаписатьСобытиеВЖурналРегистрации(ИмяСобытия, "Ошибка", ТекстСообщения);
	
КонецПроцедуры

&НаКлиенте
Функция ЛокЯдро_ПроверитьЗапускВыгрузкиТаблицыВФоне(ИмяТаблицы = Неопределено)
	
	ЗапущенаВыгрузкаТаблицыВФоне = Ложь;
	
	Если ИмяТаблицы = Неопределено Тогда
		// Проверяем, что запущена выгрузка любой таблицы
		ЗапущенаВыгрузкаТаблицыВФоне = СписокТаблицВыгружаемыхВФоне.Количество() > 0;
	Иначе
		ЗапущенаВыгрузкаТаблицыВФоне = СписокТаблицВыгружаемыхВФоне.НайтиПоЗначению(ИмяТаблицы) <> Неопределено;
	КонецЕсли;
	
	Возврат ЗапущенаВыгрузкаТаблицыВФоне;

КонецФункции

#КонецОбласти
